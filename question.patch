diff -crB questionorg/addquestion.php questionupd/addquestion.php
*** questionorg/addquestion.php	2012-04-13 12:31:14.528178306 +0500
--- questionupd/addquestion.php	2012-04-13 09:42:52.000000000 +0500
***************
*** 47,68 ****
  
  // Validate params.
  if (!$category = $DB->get_record('question_categories', array('id' => $categoryid))) {
!     print_error('categorydoesnotexist', 'question', $returnurl);
  }
  
  if ($cmid) {
!     list($module, $cm) = get_module_from_cmid($cmid);
!     require_login($cm->course, false, $cm);
!     $thiscontext = get_context_instance(CONTEXT_MODULE, $cmid);
!     $hiddenparams['cmid'] = $cmid;
  } else if ($courseid) {
!     require_login($courseid, false);
!     $thiscontext = get_context_instance(CONTEXT_COURSE, $courseid);
!     $module = null;
!     $cm = null;
!     $hiddenparams['courseid'] = $courseid;
  } else {
!     print_error('missingcourseorcmid', 'question');
  }
  
  // Check permissions.
--- 47,68 ----
  
  // Validate params.
  if (!$category = $DB->get_record('question_categories', array('id' => $categoryid))) {
! 	print_error('categorydoesnotexist', 'question', $returnurl);
  }
  
  if ($cmid) {
! 	list($module, $cm) = get_module_from_cmid($cmid);
! 	require_login($cm->course, false, $cm);
! 	$thiscontext = get_context_instance(CONTEXT_MODULE, $cmid);
! 	$hiddenparams['cmid'] = $cmid;
  } else if ($courseid) {
! 	require_login($courseid, false);
! 	$thiscontext = get_context_instance(CONTEXT_COURSE, $courseid);
! 	$module = null;
! 	$cm = null;
! 	$hiddenparams['courseid'] = $courseid;
  } else {
! 	print_error('missingcourseorcmid', 'question');
  }
  
  // Check permissions.
***************
*** 71,80 ****
  
  // Ensure other optional params get passed on to question.php.
  if (!empty($returnurl)) {
!     $hiddenparams['returnurl'] = $returnurl;
  }
  if (!empty($appendqnumstring)) {
!     $hiddenparams['appendqnumstring'] = $appendqnumstring;
  }
  
  $PAGE->set_url('/question/addquestion.php', $hiddenparams);
--- 71,80 ----
  
  // Ensure other optional params get passed on to question.php.
  if (!empty($returnurl)) {
! 	$hiddenparams['returnurl'] = $returnurl;
  }
  if (!empty($appendqnumstring)) {
! 	$hiddenparams['appendqnumstring'] = $appendqnumstring;
  }
  
  $PAGE->set_url('/question/addquestion.php', $hiddenparams);
***************
*** 82,99 ****
  $chooseqtype = get_string('chooseqtypetoadd', 'question');
  $PAGE->set_heading($COURSE->fullname);
  if ($cm !== null) {
!     // Nasty hack, but we don't want this link if returnurl returns to view.php
!     if (stripos($returnurl, "/mod/{$cm->modname}/view.php")!== 0) {
!         $PAGE->navbar->add(get_string('editinga', 'moodle', get_string('modulename', $cm->modname)),$returnurl);
!     }
!     $PAGE->navbar->add($chooseqtype);
!     $PAGE->set_title($chooseqtype);    
!     echo $OUTPUT->header();
  } else {
!     $PAGE->navbar->add(get_string('questionbank', 'question'),$returnurl);
!     $PAGE->navbar->add($chooseqtype);
!     $PAGE->set_title($chooseqtype);    
!     echo $OUTPUT->header();
  }
  
  // Display a form to choose the question type.
--- 82,99 ----
  $chooseqtype = get_string('chooseqtypetoadd', 'question');
  $PAGE->set_heading($COURSE->fullname);
  if ($cm !== null) {
! 	// Nasty hack, but we don't want this link if returnurl returns to view.php
! 	if (stripos($returnurl, "/mod/{$cm->modname}/view.php")!== 0) {
! 		$PAGE->navbar->add(get_string('editinga', 'moodle', get_string('modulename', $cm->modname)),$returnurl);
! 	}
! 	$PAGE->navbar->add($chooseqtype);
! 	$PAGE->set_title($chooseqtype);
! 	echo $OUTPUT->header();
  } else {
! 	$PAGE->navbar->add(get_string('questionbank', 'question'),$returnurl);
! 	$PAGE->navbar->add($chooseqtype);
! 	$PAGE->set_title($chooseqtype);
! 	echo $OUTPUT->header();
  }
  
  // Display a form to choose the question type.
diff -crB questionorg/category_class.php questionupd/category_class.php
*** questionorg/category_class.php	2012-04-13 12:31:14.548178306 +0500
--- questionupd/category_class.php	2012-04-13 09:42:52.000000000 +0500
***************
*** 15,86 ****
  require_once('move_form.php');
  
  class question_category_list extends moodle_list {
!     public $table = "question_categories";
!     public $listitemclassname = 'question_category_list_item';
!     /**
!      * @var reference to list displayed below this one.
!      */
!     public $nextlist = null;
!     /**
!      * @var reference to list displayed above this one.
!      */
!     public $lastlist = null;
! 
!     public $context = null;
!     public $sortby = 'parent, sortorder, name';
! 
!     public function __construct($type='ul', $attributes='', $editable = false, $pageurl=null, $page = 0, $pageparamname = 'page', $itemsperpage = 20, $context = null){
!         parent::__construct('ul', '', $editable, $pageurl, $page, 'cpage', $itemsperpage);
!         $this->context = $context;
!     }
! 
!     public function get_records() {
!         $this->records = get_categories_for_contexts($this->context->id, $this->sortby);
!     }
  }
  
  class question_category_list_item extends list_item {
!     public function set_icon_html($first, $last, &$lastitem){
!         global $CFG;
!         $category = $this->item;
!         $url = new moodle_url('/question/category.php', ($this->parentlist->pageurl->params() + array('edit'=>$category->id)));
!         $this->icons['edit']= $this->image_icon(get_string('editthiscategory', 'question'), $url, 'edit');
!         parent::set_icon_html($first, $last, $lastitem);
!         $toplevel = ($this->parentlist->parentitem === null);//this is a top level item
!         if (($this->parentlist->nextlist !== null) && $last && $toplevel && (count($this->parentlist->items)>1)){
!             $url = new moodle_url($this->parentlist->pageurl, array('movedowncontext'=>$this->id, 'tocontext'=>$this->parentlist->nextlist->context->id, 'sesskey'=>sesskey()));
!             $this->icons['down'] = $this->image_icon(
!                 get_string('shareincontext', 'question', print_context_name($this->parentlist->nextlist->context)), $url, 'down');
!         }
!         if (($this->parentlist->lastlist !== null) && $first && $toplevel && (count($this->parentlist->items)>1)){
!             $url = new moodle_url($this->parentlist->pageurl, array('moveupcontext'=>$this->id, 'tocontext'=>$this->parentlist->lastlist->context->id, 'sesskey'=>sesskey()));
!             $this->icons['up'] = $this->image_icon(
!                 get_string('shareincontext', 'question', print_context_name($this->parentlist->lastlist->context)), $url, 'up');
!         }
!     }
! 
!     public function item_html($extraargs = array()){
!         global $CFG, $OUTPUT;
!         $str = $extraargs['str'];
!         $category = $this->item;
! 
!         $editqestions = get_string('editquestions', 'quiz');
! 
!         /// Each section adds html to be displayed as part of this list item
!         $questionbankurl = new moodle_url("/question/edit.php", ($this->parentlist->pageurl->params() + array('category'=>"$category->id,$category->contextid")));
!         $catediturl = $this->parentlist->pageurl->out(true, array('edit' => $this->id));
!         $item = "<b><a title=\"{$str->edit}\" href=\"$catediturl\">".$category->name ."</a></b> <a title=\"$editqestions\" href=\"$questionbankurl\">".'('.$category->questioncount.')</a>';
! 
!         $item .= '&nbsp;'. $category->info;
! 
!         // don't allow delete if this is the last category in this context.
!         if (count($this->parentlist->records) != 1) {
!             $item .=  '<a title="' . $str->delete . '" href="'.$this->parentlist->pageurl->out(true, array('delete'=>$this->id, 'sesskey'=>sesskey())).'">
                      <img src="' . $OUTPUT->pix_url('t/delete') . '" class="iconsmall" alt="' .$str->delete. '" /></a>';
!         }
  
!         return $item;
!     }
  }
  
  
--- 15,86 ----
  require_once('move_form.php');
  
  class question_category_list extends moodle_list {
! 	public $table = "question_categories";
! 	public $listitemclassname = 'question_category_list_item';
! 	/**
! 	 * @var reference to list displayed below this one.
! 	 */
! 	public $nextlist = null;
! 	/**
! 	 * @var reference to list displayed above this one.
! 	 */
! 	public $lastlist = null;
! 
! 	public $context = null;
! 	public $sortby = 'parent, sortorder, name';
! 
! 	public function __construct($type='ul', $attributes='', $editable = false, $pageurl=null, $page = 0, $pageparamname = 'page', $itemsperpage = 20, $context = null){
! 		parent::__construct('ul', '', $editable, $pageurl, $page, 'cpage', $itemsperpage);
! 		$this->context = $context;
! 	}
! 
! 	public function get_records() {
! 		$this->records = get_categories_for_contexts($this->context->id, $this->sortby);
! 	}
  }
  
  class question_category_list_item extends list_item {
! 	public function set_icon_html($first, $last, &$lastitem){
! 		global $CFG;
! 		$category = $this->item;
! 		$url = new moodle_url('/question/category.php', ($this->parentlist->pageurl->params() + array('edit'=>$category->id)));
! 		$this->icons['edit']= $this->image_icon(get_string('editthiscategory', 'question'), $url, 'edit');
! 		parent::set_icon_html($first, $last, $lastitem);
! 		$toplevel = ($this->parentlist->parentitem === null);//this is a top level item
! 		if (($this->parentlist->nextlist !== null) && $last && $toplevel && (count($this->parentlist->items)>1)){
! 			$url = new moodle_url($this->parentlist->pageurl, array('movedowncontext'=>$this->id, 'tocontext'=>$this->parentlist->nextlist->context->id, 'sesskey'=>sesskey()));
! 			$this->icons['down'] = $this->image_icon(
! 			get_string('shareincontext', 'question', print_context_name($this->parentlist->nextlist->context)), $url, 'down');
! 		}
! 		if (($this->parentlist->lastlist !== null) && $first && $toplevel && (count($this->parentlist->items)>1)){
! 			$url = new moodle_url($this->parentlist->pageurl, array('moveupcontext'=>$this->id, 'tocontext'=>$this->parentlist->lastlist->context->id, 'sesskey'=>sesskey()));
! 			$this->icons['up'] = $this->image_icon(
! 			get_string('shareincontext', 'question', print_context_name($this->parentlist->lastlist->context)), $url, 'up');
! 		}
! 	}
! 
! 	public function item_html($extraargs = array()){
! 		global $CFG, $OUTPUT;
! 		$str = $extraargs['str'];
! 		$category = $this->item;
! 
! 		$editqestions = get_string('editquestions', 'quiz');
! 
! 		/// Each section adds html to be displayed as part of this list item
! 		$questionbankurl = new moodle_url("/question/edit.php", ($this->parentlist->pageurl->params() + array('category'=>"$category->id,$category->contextid")));
! 		$catediturl = $this->parentlist->pageurl->out(true, array('edit' => $this->id));
! 		$item = "<b><a title=\"{$str->edit}\" href=\"$catediturl\">".$category->name ."</a></b> <a title=\"$editqestions\" href=\"$questionbankurl\">".'('.$category->questioncount.')</a>';
! 
! 		$item .= '&nbsp;'. $category->info;
! 
! 		// don't allow delete if this is the last category in this context.
! 		if (count($this->parentlist->records) != 1) {
! 			$item .=  '<a title="' . $str->delete . '" href="'.$this->parentlist->pageurl->out(true, array('delete'=>$this->id, 'sesskey'=>sesskey())).'">
                      <img src="' . $OUTPUT->pix_url('t/delete') . '" class="iconsmall" alt="' .$str->delete. '" /></a>';
! 		}
  
! 		return $item;
! 	}
  }
  
  
***************
*** 91,430 ****
   */
  class question_category_object {
  
!     var $str;
!     /**
!      * Nested lists to display categories.
!      *
!      * @var array
!      */
!     var $editlists = array();
!     var $newtable;
!     var $tab;
!     var $tabsize = 3;
! //------------------------------------------------------
!     /**
!      * @var moodle_url Object representing url for this page
!      */
!     var $pageurl;
!     /**
!      * @var question_category_edit_form Object representing form for adding / editing categories.
!      */
!     var $catform;
! 
!     /**
!      * Constructor
!      *
!      * Gets necessary strings and sets relevant path information
!      */
!     public function question_category_object($page, $pageurl, $contexts, $currentcat, $defaultcategory, $todelete, $addcontexts) {
!         global $CFG, $COURSE, $OUTPUT;
! 
!         $this->tab = str_repeat('&nbsp;', $this->tabsize);
! 
!         $this->str->course         = get_string('course');
!         $this->str->category       = get_string('category', 'quiz');
!         $this->str->categoryinfo   = get_string('categoryinfo', 'quiz');
!         $this->str->questions      = get_string('questions', 'quiz');
!         $this->str->add            = get_string('add');
!         $this->str->delete         = get_string('delete');
!         $this->str->moveup         = get_string('moveup');
!         $this->str->movedown       = get_string('movedown');
!         $this->str->edit           = get_string('editthiscategory', 'question');
!         $this->str->hide           = get_string('hide');
!         $this->str->publish        = get_string('publish', 'quiz');
!         $this->str->order          = get_string('order');
!         $this->str->parent         = get_string('parent', 'quiz');
!         $this->str->add            = get_string('add');
!         $this->str->action         = get_string('action');
!         $this->str->top            = get_string('top', 'quiz');
!         $this->str->addcategory    = get_string('addcategory', 'quiz');
!         $this->str->editcategory   = get_string('editcategory', 'quiz');
!         $this->str->cancel         = get_string('cancel');
!         $this->str->editcategories = get_string('editcategories', 'quiz');
!         $this->str->page           = get_string('page');
! 
!         $this->pageurl = $pageurl;
! 
!         $this->initialize($page, $contexts, $currentcat, $defaultcategory, $todelete, $addcontexts);
! 
!     }
! 
! 
! 
!     /**
!      * Initializes this classes general category-related variables
!      */
!     public function initialize($page, $contexts, $currentcat, $defaultcategory, $todelete, $addcontexts) {
!         $lastlist = null;
!         foreach ($contexts as $context){
!             $this->editlists[$context->id] = new question_category_list('ul', '', true, $this->pageurl, $page, 'cpage', QUESTION_PAGE_LENGTH, $context);
!             $this->editlists[$context->id]->lastlist =& $lastlist;
!             if ($lastlist!== null){
!                 $lastlist->nextlist =& $this->editlists[$context->id];
!             }
!             $lastlist =& $this->editlists[$context->id];
!         }
! 
!         $count = 1;
!         $paged = false;
!         foreach ($this->editlists as $key => $list){
!             list($paged, $count) = $this->editlists[$key]->list_from_records($paged, $count);
!         }
!         $this->catform = new question_category_edit_form($this->pageurl, compact('contexts', 'currentcat'));
!         if (!$currentcat){
!             $this->catform->set_data(array('parent'=>$defaultcategory));
!         }
!     }
!     /**
!      * Displays the user interface
!      *
!      */
!     public function display_user_interface() {
! 
!         /// Interface for editing existing categories
!         $this->output_edit_lists();
! 
! 
!         echo '<br />';
!         /// Interface for adding a new category:
!         $this->output_new_table();
!         echo '<br />';
! 
!     }
! 
!     /**
!      * Outputs a table to allow entry of a new category
!      */
!     public function output_new_table() {
!         $this->catform->display();
!     }
! 
!     /**
!      * Outputs a list to allow editing/rearranging of existing categories
!      *
!      * $this->initialize() must have already been called
!      *
!      */
!     public function output_edit_lists() {
!         global $OUTPUT;
! 
!         echo $OUTPUT->heading_with_help(get_string('editcategories', 'question'), 'editcategories', 'question');
! 
!         foreach ($this->editlists as $context => $list){
!             $listhtml = $list->to_html(0, array('str'=>$this->str));
!             if ($listhtml){
!                 echo $OUTPUT->box_start('boxwidthwide boxaligncenter generalbox questioncategories contextlevel' . $list->context->contextlevel);
!                 echo $OUTPUT->heading(get_string('questioncatsfor', 'question', print_context_name(get_context_instance_by_id($context))), 3);
!                 echo $listhtml;
!                 echo $OUTPUT->box_end();
!             }
!         }
!         echo $list->display_page_numbers();
!      }
! 
! 
! 
!     /**
!      * gets all the courseids for the given categories
!      *
!      * @param array categories contains category objects in  a tree representation
!      * @return array courseids flat array in form categoryid=>courseid
!      */
!     public function get_course_ids($categories) {
!         $courseids = array();
!         foreach ($categories as $key=>$cat) {
!             $courseids[$key] = $cat->course;
!             if (!empty($cat->children)) {
!                 $courseids = array_merge($courseids, $this->get_course_ids($cat->children));
!             }
!         }
!         return $courseids;
!     }
! 
! 
! 
!     public function edit_single_category($categoryid) {
!     /// Interface for adding a new category
!         global $COURSE, $DB;
!         /// Interface for editing existing categories
!         if ($category = $DB->get_record("question_categories", array("id" => $categoryid))) {
! 
!             $category->parent = "$category->parent,$category->contextid";
!             $category->submitbutton = get_string('savechanges');
!             $category->categoryheader = $this->str->edit;
!             $this->catform->set_data($category);
!             $this->catform->display();
!         } else {
!             print_error('invalidcategory', '', '', $categoryid);
!         }
!     }
! 
! 
!     /**
!      * Sets the viable parents
!      *
!      *  Viable parents are any except for the category itself, or any of it's descendants
!      *  The parentstrings parameter is passed by reference and changed by this function.
!      *
!      * @param    array parentstrings a list of parentstrings
!      * @param   object category
!      */
!     public function set_viable_parents(&$parentstrings, $category) {
! 
!         unset($parentstrings[$category->id]);
!         if (isset($category->children)) {
!             foreach ($category->children as $child) {
!                 $this->set_viable_parents($parentstrings, $child);
!             }
!         }
!     }
! 
!     /**
!      * Gets question categories
!      *
!      * @param    int parent - if given, restrict records to those with this parent id.
!      * @param    string sort - [[sortfield [,sortfield]] {ASC|DESC}]
!      * @return   array categories
!      */
!     public function get_question_categories($parent=null, $sort="sortorder ASC") {
!         global $COURSE, $DB;
!         if (is_null($parent)) {
!             $categories = $DB->get_records('question_categories', array('course' => $COURSE->id), $sort);
!         } else {
!             $select = "parent = ? AND course = ?";
!             $categories = $DB->get_records_select('question_categories', $select, array($parent, $COURSE->id), $sort);
!         }
!         return $categories;
!     }
! 
!     /**
!      * Deletes an existing question category
!      *
!      * @param int deletecat id of category to delete
!      */
!     public function delete_category($categoryid) {
!         global $CFG, $DB;
!         question_can_delete_cat($categoryid);
!         if (!$category = $DB->get_record("question_categories", array("id" => $categoryid))) {  // security
!             print_error('unknowcategory');
!         }
!         /// Send the children categories to live with their grandparent
!         $DB->set_field("question_categories", "parent", $category->parent, array("parent" => $category->id));
! 
!         /// Finally delete the category itself
!         $DB->delete_records("question_categories", array("id" => $category->id));
!     }
! 
!     public function move_questions_and_delete_category($oldcat, $newcat){
!         question_can_delete_cat($oldcat);
!         $this->move_questions($oldcat, $newcat);
!         $this->delete_category($oldcat);
!     }
! 
!     public function display_move_form($questionsincategory, $category){
!         global $OUTPUT;
!         $vars = new stdClass;
!         $vars->name = $category->name;
!         $vars->count = $questionsincategory;
!         echo $OUTPUT->box(get_string('categorymove', 'quiz', $vars), 'generalbox boxaligncenter');
!         $this->moveform->display();
!     }
! 
!     public function move_questions($oldcat, $newcat){
!         global $DB;
!         $questionids = $DB->get_records_select_menu('question',
                  'category = ? AND (parent = 0 OR parent = id)', array($oldcat), '', 'id,1');
!         question_move_questions_to_category($questionids, $newcat);
!     }
  
!     /**
!      * Creates a new category with given params
!      */
!     public function add_category($newparent, $newcategory, $newinfo, $return = false) {
!         global $DB;
!         if (empty($newcategory)) {
!             print_error('categorynamecantbeblank', 'quiz');
!         }
!         list($parentid, $contextid) = explode(',', $newparent);
!         //moodle_form makes sure select element output is legal no need for further cleaning
!         require_capability('moodle/question:managecategory', get_context_instance_by_id($contextid));
! 
!         if ($parentid) {
!             if(!($DB->get_field('question_categories', 'contextid', array('id' => $parentid)) == $contextid)) {
!                 print_error('cannotinsertquestioncatecontext', 'question', '', array('cat'=>$newcategory, 'ctx'=>$contextid));
!             }
!         }
! 
!         $cat = new stdClass();
!         $cat->parent = $parentid;
!         $cat->contextid = $contextid;
!         $cat->name = $newcategory;
!         $cat->info = $newinfo;
!         $cat->sortorder = 999;
!         $cat->stamp = make_unique_id_code();
!         $categoryid = $DB->insert_record("question_categories", $cat);
!         if ($return) {
!             return $categoryid;
!         } else {
!             redirect($this->pageurl);//always redirect after successful action
!         }
!     }
! 
!     /**
!      * Updates an existing category with given params
!      */
!     public function update_category($updateid, $newparent, $newname, $newinfo) {
!         global $CFG, $QTYPES, $DB;
!         if (empty($newname)) {
!             print_error('categorynamecantbeblank', 'quiz');
!         }
! 
!         // Get the record we are updating.
!         $oldcat = $DB->get_record('question_categories', array('id' => $updateid));
!         $lastcategoryinthiscontext = question_is_only_toplevel_category_in_context($updateid);
! 
!         if (!empty($newparent) && !$lastcategoryinthiscontext) {
!             list($parentid, $tocontextid) = explode(',', $newparent);
!         } else {
!             $parentid = $oldcat->parent;
!             $tocontextid = $oldcat->contextid;
!         }
! 
!         // Check permissions.
!         $fromcontext = get_context_instance_by_id($oldcat->contextid);
!         require_capability('moodle/question:managecategory', $fromcontext);
! 
!         // If moving to another context, check permissions some more.
!         if ($oldcat->contextid != $tocontextid) {
!             $tocontext = get_context_instance_by_id($tocontextid);
!             require_capability('moodle/question:managecategory', $tocontext);
!         }
! 
!         // Update the category record.
!         $cat = NULL;
!         $cat->id = $updateid;
!         $cat->name = $newname;
!         $cat->info = $newinfo;
!         $cat->parent = $parentid;
!         $cat->contextid = $tocontextid;
!         $DB->update_record('question_categories', $cat);
! 
!         // If the category name has changed, rename any random questions in that category.
!         if ($oldcat->name != $cat->name) {
!             $where = "qtype = 'random' AND category = ? AND " . $DB->sql_compare_text('questiontext') . " = ?";
! 
!             $randomqname = $QTYPES[RANDOM]->question_name($cat, false);
!             $DB->set_field_select('question', 'name', $randomqname, $where, array($cat->id, '0'));
! 
!             $randomqname = $QTYPES[RANDOM]->question_name($cat, true);
!             $DB->set_field_select('question', 'name', $randomqname, $where, array($cat->id, '1'));
!         }
! 
!         if ($oldcat->contextid != $tocontextid) {
!             // Moving to a new context. Must move files belonging to questions.
!             question_move_category_to_context($cat->id, $oldcat->contextid, $tocontextid);
!         }
  
!         redirect($this->pageurl);
!     }
  }
--- 91,430 ----
   */
  class question_category_object {
  
! 	var $str;
! 	/**
! 	 * Nested lists to display categories.
! 	 *
! 	 * @var array
! 	 */
! 	var $editlists = array();
! 	var $newtable;
! 	var $tab;
! 	var $tabsize = 3;
! 	//------------------------------------------------------
! 	/**
! 	* @var moodle_url Object representing url for this page
! 	*/
! 	var $pageurl;
! 	/**
! 	 * @var question_category_edit_form Object representing form for adding / editing categories.
! 	 */
! 	var $catform;
! 
! 	/**
! 	 * Constructor
! 	 *
! 	 * Gets necessary strings and sets relevant path information
! 	 */
! 	public function question_category_object($page, $pageurl, $contexts, $currentcat, $defaultcategory, $todelete, $addcontexts) {
! 		global $CFG, $COURSE, $OUTPUT;
! 
! 		$this->tab = str_repeat('&nbsp;', $this->tabsize);
! 
! 		$this->str->course         = get_string('course');
! 		$this->str->category       = get_string('category', 'quiz');
! 		$this->str->categoryinfo   = get_string('categoryinfo', 'quiz');
! 		$this->str->questions      = get_string('questions', 'quiz');
! 		$this->str->add            = get_string('add');
! 		$this->str->delete         = get_string('delete');
! 		$this->str->moveup         = get_string('moveup');
! 		$this->str->movedown       = get_string('movedown');
! 		$this->str->edit           = get_string('editthiscategory', 'question');
! 		$this->str->hide           = get_string('hide');
! 		$this->str->publish        = get_string('publish', 'quiz');
! 		$this->str->order          = get_string('order');
! 		$this->str->parent         = get_string('parent', 'quiz');
! 		$this->str->add            = get_string('add');
! 		$this->str->action         = get_string('action');
! 		$this->str->top            = get_string('top', 'quiz');
! 		$this->str->addcategory    = get_string('addcategory', 'quiz');
! 		$this->str->editcategory   = get_string('editcategory', 'quiz');
! 		$this->str->cancel         = get_string('cancel');
! 		$this->str->editcategories = get_string('editcategories', 'quiz');
! 		$this->str->page           = get_string('page');
! 
! 		$this->pageurl = $pageurl;
! 
! 		$this->initialize($page, $contexts, $currentcat, $defaultcategory, $todelete, $addcontexts);
! 
! 	}
! 
! 
! 
! 	/**
! 	 * Initializes this classes general category-related variables
! 	 */
! 	public function initialize($page, $contexts, $currentcat, $defaultcategory, $todelete, $addcontexts) {
! 		$lastlist = null;
! 		foreach ($contexts as $context){
! 			$this->editlists[$context->id] = new question_category_list('ul', '', true, $this->pageurl, $page, 'cpage', QUESTION_PAGE_LENGTH, $context);
! 			$this->editlists[$context->id]->lastlist =& $lastlist;
! 			if ($lastlist!== null){
! 				$lastlist->nextlist =& $this->editlists[$context->id];
! 			}
! 			$lastlist =& $this->editlists[$context->id];
! 		}
! 
! 		$count = 1;
! 		$paged = false;
! 		foreach ($this->editlists as $key => $list){
! 			list($paged, $count) = $this->editlists[$key]->list_from_records($paged, $count);
! 		}
! 		$this->catform = new question_category_edit_form($this->pageurl, compact('contexts', 'currentcat'));
! 		if (!$currentcat){
! 			$this->catform->set_data(array('parent'=>$defaultcategory));
! 		}
! 	}
! 	/**
! 	 * Displays the user interface
! 	 *
! 	 */
! 	public function display_user_interface() {
! 
! 		/// Interface for editing existing categories
! 		$this->output_edit_lists();
! 
! 
! 		echo '<br />';
! 		/// Interface for adding a new category:
! 		$this->output_new_table();
! 		echo '<br />';
! 
! 	}
! 
! 	/**
! 	 * Outputs a table to allow entry of a new category
! 	 */
! 	public function output_new_table() {
! 		$this->catform->display();
! 	}
! 
! 	/**
! 	 * Outputs a list to allow editing/rearranging of existing categories
! 	 *
! 	 * $this->initialize() must have already been called
! 	 *
! 	 */
! 	public function output_edit_lists() {
! 		global $OUTPUT;
! 
! 		echo $OUTPUT->heading_with_help(get_string('editcategories', 'question'), 'editcategories', 'question');
! 
! 		foreach ($this->editlists as $context => $list){
! 			$listhtml = $list->to_html(0, array('str'=>$this->str));
! 			if ($listhtml){
! 				echo $OUTPUT->box_start('boxwidthwide boxaligncenter generalbox questioncategories contextlevel' . $list->context->contextlevel);
! 				echo $OUTPUT->heading(get_string('questioncatsfor', 'question', print_context_name(get_context_instance_by_id($context))), 3);
! 				echo $listhtml;
! 				echo $OUTPUT->box_end();
! 			}
! 		}
! 		echo $list->display_page_numbers();
! 	}
! 
! 
! 
! 	/**
! 	 * gets all the courseids for the given categories
! 	 *
! 	 * @param array categories contains category objects in  a tree representation
! 	 * @return array courseids flat array in form categoryid=>courseid
! 	 */
! 	public function get_course_ids($categories) {
! 		$courseids = array();
! 		foreach ($categories as $key=>$cat) {
! 			$courseids[$key] = $cat->course;
! 			if (!empty($cat->children)) {
! 				$courseids = array_merge($courseids, $this->get_course_ids($cat->children));
! 			}
! 		}
! 		return $courseids;
! 	}
! 
! 
! 
! 	public function edit_single_category($categoryid) {
! 		/// Interface for adding a new category
! 		global $COURSE, $DB;
! 		/// Interface for editing existing categories
! 		if ($category = $DB->get_record("question_categories", array("id" => $categoryid))) {
! 
! 			$category->parent = "$category->parent,$category->contextid";
! 			$category->submitbutton = get_string('savechanges');
! 			$category->categoryheader = $this->str->edit;
! 			$this->catform->set_data($category);
! 			$this->catform->display();
! 		} else {
! 			print_error('invalidcategory', '', '', $categoryid);
! 		}
! 	}
! 
! 
! 	/**
! 	 * Sets the viable parents
! 	 *
! 	 *  Viable parents are any except for the category itself, or any of it's descendants
! 	 *  The parentstrings parameter is passed by reference and changed by this function.
! 	 *
! 	 * @param    array parentstrings a list of parentstrings
! 	 * @param   object category
! 	 */
! 	public function set_viable_parents(&$parentstrings, $category) {
! 
! 		unset($parentstrings[$category->id]);
! 		if (isset($category->children)) {
! 			foreach ($category->children as $child) {
! 				$this->set_viable_parents($parentstrings, $child);
! 			}
! 		}
! 	}
! 
! 	/**
! 	 * Gets question categories
! 	 *
! 	 * @param    int parent - if given, restrict records to those with this parent id.
! 	 * @param    string sort - [[sortfield [,sortfield]] {ASC|DESC}]
! 	 * @return   array categories
! 	 */
! 	public function get_question_categories($parent=null, $sort="sortorder ASC") {
! 		global $COURSE, $DB;
! 		if (is_null($parent)) {
! 			$categories = $DB->get_records('question_categories', array('course' => $COURSE->id), $sort);
! 		} else {
! 			$select = "parent = ? AND course = ?";
! 			$categories = $DB->get_records_select('question_categories', $select, array($parent, $COURSE->id), $sort);
! 		}
! 		return $categories;
! 	}
! 
! 	/**
! 	 * Deletes an existing question category
! 	 *
! 	 * @param int deletecat id of category to delete
! 	 */
! 	public function delete_category($categoryid) {
! 		global $CFG, $DB;
! 		question_can_delete_cat($categoryid);
! 		if (!$category = $DB->get_record("question_categories", array("id" => $categoryid))) {  // security
! 			print_error('unknowcategory');
! 		}
! 		/// Send the children categories to live with their grandparent
! 		$DB->set_field("question_categories", "parent", $category->parent, array("parent" => $category->id));
! 
! 		/// Finally delete the category itself
! 		$DB->delete_records("question_categories", array("id" => $category->id));
! 	}
! 
! 	public function move_questions_and_delete_category($oldcat, $newcat){
! 		question_can_delete_cat($oldcat);
! 		$this->move_questions($oldcat, $newcat);
! 		$this->delete_category($oldcat);
! 	}
! 
! 	public function display_move_form($questionsincategory, $category){
! 		global $OUTPUT;
! 		$vars = new stdClass;
! 		$vars->name = $category->name;
! 		$vars->count = $questionsincategory;
! 		echo $OUTPUT->box(get_string('categorymove', 'quiz', $vars), 'generalbox boxaligncenter');
! 		$this->moveform->display();
! 	}
! 
! 	public function move_questions($oldcat, $newcat){
! 		global $DB;
! 		$questionids = $DB->get_records_select_menu('question',
                  'category = ? AND (parent = 0 OR parent = id)', array($oldcat), '', 'id,1');
! 		question_move_questions_to_category($questionids, $newcat);
! 	}
  
! 	/**
! 	 * Creates a new category with given params
! 	 */
! 	public function add_category($newparent, $newcategory, $newinfo, $return = false) {
! 		global $DB;
! 		if (empty($newcategory)) {
! 			print_error('categorynamecantbeblank', 'quiz');
! 		}
! 		list($parentid, $contextid) = explode(',', $newparent);
! 		//moodle_form makes sure select element output is legal no need for further cleaning
! 		require_capability('moodle/question:managecategory', get_context_instance_by_id($contextid));
! 
! 		if ($parentid) {
! 			if(!($DB->get_field('question_categories', 'contextid', array('id' => $parentid)) == $contextid)) {
! 				print_error('cannotinsertquestioncatecontext', 'question', '', array('cat'=>$newcategory, 'ctx'=>$contextid));
! 			}
! 		}
! 
! 		$cat = new stdClass();
! 		$cat->parent = $parentid;
! 		$cat->contextid = $contextid;
! 		$cat->name = $newcategory;
! 		$cat->info = $newinfo;
! 		$cat->sortorder = 999;
! 		$cat->stamp = make_unique_id_code();
! 		$categoryid = $DB->insert_record("question_categories", $cat);
! 		if ($return) {
! 			return $categoryid;
! 		} else {
! 			redirect($this->pageurl);//always redirect after successful action
! 		}
! 	}
! 
! 	/**
! 	 * Updates an existing category with given params
! 	 */
! 	public function update_category($updateid, $newparent, $newname, $newinfo) {
! 		global $CFG, $QTYPES, $DB;
! 		if (empty($newname)) {
! 			print_error('categorynamecantbeblank', 'quiz');
! 		}
! 
! 		// Get the record we are updating.
! 		$oldcat = $DB->get_record('question_categories', array('id' => $updateid));
! 		$lastcategoryinthiscontext = question_is_only_toplevel_category_in_context($updateid);
! 
! 		if (!empty($newparent) && !$lastcategoryinthiscontext) {
! 			list($parentid, $tocontextid) = explode(',', $newparent);
! 		} else {
! 			$parentid = $oldcat->parent;
! 			$tocontextid = $oldcat->contextid;
! 		}
! 
! 		// Check permissions.
! 		$fromcontext = get_context_instance_by_id($oldcat->contextid);
! 		require_capability('moodle/question:managecategory', $fromcontext);
! 
! 		// If moving to another context, check permissions some more.
! 		if ($oldcat->contextid != $tocontextid) {
! 			$tocontext = get_context_instance_by_id($tocontextid);
! 			require_capability('moodle/question:managecategory', $tocontext);
! 		}
! 
! 		// Update the category record.
! 		$cat = NULL;
! 		$cat->id = $updateid;
! 		$cat->name = $newname;
! 		$cat->info = $newinfo;
! 		$cat->parent = $parentid;
! 		$cat->contextid = $tocontextid;
! 		$DB->update_record('question_categories', $cat);
! 
! 		// If the category name has changed, rename any random questions in that category.
! 		if ($oldcat->name != $cat->name) {
! 			$where = "qtype = 'random' AND category = ? AND " . $DB->sql_compare_text('questiontext') . " = ?";
! 
! 			$randomqname = $QTYPES[RANDOM]->question_name($cat, false);
! 			$DB->set_field_select('question', 'name', $randomqname, $where, array($cat->id, '0'));
! 
! 			$randomqname = $QTYPES[RANDOM]->question_name($cat, true);
! 			$DB->set_field_select('question', 'name', $randomqname, $where, array($cat->id, '1'));
! 		}
! 
! 		if ($oldcat->contextid != $tocontextid) {
! 			// Moving to a new context. Must move files belonging to questions.
! 			question_move_category_to_context($cat->id, $oldcat->contextid, $tocontextid);
! 		}
  
! 		redirect($this->pageurl);
! 	}
  }
diff -crB questionorg/category_form.php questionupd/category_form.php
*** questionorg/category_form.php	2012-04-13 12:31:14.443178304 +0500
--- questionupd/category_form.php	2012-04-13 09:42:52.000000000 +0500
***************
*** 1,43 ****
  <?php
  
  if (!defined('MOODLE_INTERNAL')) {
!     die('Direct access to this script is forbidden.');    ///  It must be included from a Moodle page
  }
  
  require_once($CFG->libdir.'/formslib.php');
  
  class question_category_edit_form extends moodleform {
  
!     function definition() {
!         global $CFG, $DB;
!         $mform    =& $this->_form;
! 
!         $contexts   = $this->_customdata['contexts'];
!         $currentcat   = $this->_customdata['currentcat'];
! //--------------------------------------------------------------------------------
!         $mform->addElement('header', 'categoryheader', get_string('addcategory', 'quiz'));
! 
!         $questioncategoryel = $mform->addElement('questioncategory', 'parent', get_string('parentcategory', 'question'),
!                     array('contexts'=>$contexts, 'top'=>true, 'currentcat'=>$currentcat, 'nochildrenof'=>$currentcat));
!         $mform->setType('parent', PARAM_SEQUENCE);
!         if (question_is_only_toplevel_category_in_context($currentcat)) {
!             $mform->hardFreeze('parent');
!         }
!         $mform->addHelpButton('parent', 'parentcategory', 'question');
! 
!         $mform->addElement('text','name', get_string('name'),'maxlength="254" size="50"');
!         $mform->setDefault('name', '');
!         $mform->addRule('name', get_string('categorynamecantbeblank', 'quiz'), 'required', null, 'client');
!         $mform->setType('name', PARAM_MULTILANG);
! 
!         $mform->addElement('textarea', 'info', get_string('categoryinfo', 'quiz'), array('rows'=> '10', 'cols'=>'45'));
!         $mform->setDefault('info', '');
!         $mform->setType('info', PARAM_MULTILANG);
! //--------------------------------------------------------------------------------
!         $this->add_action_buttons(false, get_string('addcategory', 'quiz'));
! //--------------------------------------------------------------------------------
!         $mform->addElement('hidden', 'id', 0);
!         $mform->setType('id', PARAM_INT);
!     }
  }
  
--- 1,43 ----
  <?php
  
  if (!defined('MOODLE_INTERNAL')) {
! 	die('Direct access to this script is forbidden.');    ///  It must be included from a Moodle page
  }
  
  require_once($CFG->libdir.'/formslib.php');
  
  class question_category_edit_form extends moodleform {
  
! 	function definition() {
! 		global $CFG, $DB;
! 		$mform    =& $this->_form;
! 
! 		$contexts   = $this->_customdata['contexts'];
! 		$currentcat   = $this->_customdata['currentcat'];
! 		//--------------------------------------------------------------------------------
! 		$mform->addElement('header', 'categoryheader', get_string('addcategory', 'quiz'));
! 
! 		$questioncategoryel = $mform->addElement('questioncategory', 'parent', get_string('parentcategory', 'question'),
! 		array('contexts'=>$contexts, 'top'=>true, 'currentcat'=>$currentcat, 'nochildrenof'=>$currentcat));
! 		$mform->setType('parent', PARAM_SEQUENCE);
! 		if (question_is_only_toplevel_category_in_context($currentcat)) {
! 			$mform->hardFreeze('parent');
! 		}
! 		$mform->addHelpButton('parent', 'parentcategory', 'question');
! 
! 		$mform->addElement('text','name', get_string('name'),'maxlength="254" size="50"');
! 		$mform->setDefault('name', '');
! 		$mform->addRule('name', get_string('categorynamecantbeblank', 'quiz'), 'required', null, 'client');
! 		$mform->setType('name', PARAM_MULTILANG);
! 
! 		$mform->addElement('textarea', 'info', get_string('categoryinfo', 'quiz'), array('rows'=> '10', 'cols'=>'45'));
! 		$mform->setDefault('info', '');
! 		$mform->setType('info', PARAM_MULTILANG);
! 		//--------------------------------------------------------------------------------
! 		$this->add_action_buttons(false, get_string('addcategory', 'quiz'));
! 		//--------------------------------------------------------------------------------
! 		$mform->addElement('hidden', 'id', 0);
! 		$mform->setType('id', PARAM_INT);
! 	}
  }
  
diff -crB questionorg/category.php questionupd/category.php
*** questionorg/category.php	2012-04-13 12:31:14.595178307 +0500
--- questionupd/category.php	2012-04-13 09:42:52.000000000 +0500
***************
*** 8,107 ****
   * @package questionbank
   */
  
!     require_once("../config.php");
!     require_once($CFG->dirroot."/question/editlib.php");
!     require_once($CFG->dirroot."/question/category_class.php");
! 
!     list($thispageurl, $contexts, $cmid, $cm, $module, $pagevars) =
!             question_edit_setup('categories', '/question/category.php');
! 
!     // get values from form for actions on this page
!     $param = new stdClass();
!     $param->moveup = optional_param('moveup', 0, PARAM_INT);
!     $param->movedown = optional_param('movedown', 0, PARAM_INT);
!     $param->moveupcontext = optional_param('moveupcontext', 0, PARAM_INT);
!     $param->movedowncontext = optional_param('movedowncontext', 0, PARAM_INT);
!     $param->tocontext = optional_param('tocontext', 0, PARAM_INT);
!     $param->left = optional_param('left', 0, PARAM_INT);
!     $param->right = optional_param('right', 0, PARAM_INT);
!     $param->delete = optional_param('delete', 0, PARAM_INT);
!     $param->confirm = optional_param('confirm', 0, PARAM_INT);
!     $param->cancel = optional_param('cancel', '', PARAM_ALPHA);
!     $param->move = optional_param('move', 0, PARAM_INT);
!     $param->moveto = optional_param('moveto', 0, PARAM_INT);
!     $param->edit = optional_param('edit', 0, PARAM_INT);
! 
!     $url = new moodle_url($thispageurl);
!     foreach ((array)$param as $key=>$value) {
!         if (($key !== 'cancel' && $value !== 0) || ($key === 'cancel' && $value !== '')) {
!             $url->param($key, $value);
!         }
!     }
!     $PAGE->set_url($url);
!     $PAGE->set_pagelayout('standard');
! 
!     $qcobject = new question_category_object($pagevars['cpage'], $thispageurl, $contexts->having_one_edit_tab_cap('categories'), $param->edit, $pagevars['cat'], $param->delete,
!                                 $contexts->having_cap('moodle/question:add'));
! 
!     $streditingcategories = get_string('editcategories', 'quiz');
!     if ($param->left || $param->right || $param->moveup || $param->movedown|| $param->moveupcontext || $param->movedowncontext){
!         require_sesskey();
!         foreach ($qcobject->editlists as $list){
!             //processing of these actions is handled in the method where appropriate and page redirects.
!             $list->process_actions($param->left, $param->right, $param->moveup, $param->movedown,
!                                     $param->moveupcontext, $param->movedowncontext, $param->tocontext);
!         }
!     }
!     if ($param->delete && ($questionstomove = $DB->count_records("question", array("category" => $param->delete)))){
!         if (!$category = $DB->get_record("question_categories", array("id" => $param->delete))) {  // security
!             print_error('nocate', 'question', $thispageurl->out(), $param->delete);
!         }
!         $categorycontext = get_context_instance_by_id($category->contextid);
!         $qcobject->moveform = new question_move_form($thispageurl,
!                     array('contexts'=>array($categorycontext), 'currentcat'=>$param->delete));
!         if ($qcobject->moveform->is_cancelled()){
!             redirect($thispageurl);
!         }  elseif ($formdata = $qcobject->moveform->get_data()) {
!             /// 'confirm' is the category to move existing questions to
!             list($tocategoryid, $tocontextid) = explode(',', $formdata->category);
!             $qcobject->move_questions_and_delete_category($formdata->delete, $tocategoryid);
!             $thispageurl->remove_params('cat', 'category');
!             redirect($thispageurl);
!         }
!     } else {
!         $questionstomove = 0;
!     }
!     if ($qcobject->catform->is_cancelled()) {
!         redirect($thispageurl);
!     } else if ($catformdata = $qcobject->catform->get_data()) {
!         if (!$catformdata->id) {//new category
!             $qcobject->add_category($catformdata->parent, $catformdata->name, $catformdata->info);
!         } else {
!             $qcobject->update_category($catformdata->id, $catformdata->parent, $catformdata->name, $catformdata->info);
!         }
!         redirect($thispageurl);
!     } else if ((!empty($param->delete) and (!$questionstomove) and confirm_sesskey())) {
!         $qcobject->delete_category($param->delete);//delete the category now no questions to move
!         $thispageurl->remove_params('cat', 'category');
!         redirect($thispageurl);
!     }
! 
!     if ($param->edit){
!         $PAGE->navbar->add(get_string('editingcategory', 'question'));
!     }
! 
!     $PAGE->set_title($streditingcategories);
!     $PAGE->set_heading($COURSE->fullname);
!     echo $OUTPUT->header();
! 
!     // display UI
!     if (!empty($param->edit)) {
!         $qcobject->edit_single_category($param->edit);
!     } else if ($questionstomove){
!         $qcobject->display_move_form($questionstomove, $category);
!     } else {
!         // display the user interface
!         $qcobject->display_user_interface();
!     }
!     echo $OUTPUT->footer();
  
--- 8,107 ----
   * @package questionbank
   */
  
! require_once("../config.php");
! require_once($CFG->dirroot."/question/editlib.php");
! require_once($CFG->dirroot."/question/category_class.php");
! 
! list($thispageurl, $contexts, $cmid, $cm, $module, $pagevars) =
! question_edit_setup('categories', '/question/category.php');
! 
! // get values from form for actions on this page
! $param = new stdClass();
! $param->moveup = optional_param('moveup', 0, PARAM_INT);
! $param->movedown = optional_param('movedown', 0, PARAM_INT);
! $param->moveupcontext = optional_param('moveupcontext', 0, PARAM_INT);
! $param->movedowncontext = optional_param('movedowncontext', 0, PARAM_INT);
! $param->tocontext = optional_param('tocontext', 0, PARAM_INT);
! $param->left = optional_param('left', 0, PARAM_INT);
! $param->right = optional_param('right', 0, PARAM_INT);
! $param->delete = optional_param('delete', 0, PARAM_INT);
! $param->confirm = optional_param('confirm', 0, PARAM_INT);
! $param->cancel = optional_param('cancel', '', PARAM_ALPHA);
! $param->move = optional_param('move', 0, PARAM_INT);
! $param->moveto = optional_param('moveto', 0, PARAM_INT);
! $param->edit = optional_param('edit', 0, PARAM_INT);
! 
! $url = new moodle_url($thispageurl);
! foreach ((array)$param as $key=>$value) {
! 	if (($key !== 'cancel' && $value !== 0) || ($key === 'cancel' && $value !== '')) {
! 		$url->param($key, $value);
! 	}
! }
! $PAGE->set_url($url);
! $PAGE->set_pagelayout('standard');
! 
! $qcobject = new question_category_object($pagevars['cpage'], $thispageurl, $contexts->having_one_edit_tab_cap('categories'), $param->edit, $pagevars['cat'], $param->delete,
! $contexts->having_cap('moodle/question:add'));
! 
! $streditingcategories = get_string('editcategories', 'quiz');
! if ($param->left || $param->right || $param->moveup || $param->movedown|| $param->moveupcontext || $param->movedowncontext){
! 	require_sesskey();
! 	foreach ($qcobject->editlists as $list){
! 		//processing of these actions is handled in the method where appropriate and page redirects.
! 		$list->process_actions($param->left, $param->right, $param->moveup, $param->movedown,
! 		$param->moveupcontext, $param->movedowncontext, $param->tocontext);
! 	}
! }
! if ($param->delete && ($questionstomove = $DB->count_records("question", array("category" => $param->delete)))){
! 	if (!$category = $DB->get_record("question_categories", array("id" => $param->delete))) {  // security
! 		print_error('nocate', 'question', $thispageurl->out(), $param->delete);
! 	}
! 	$categorycontext = get_context_instance_by_id($category->contextid);
! 	$qcobject->moveform = new question_move_form($thispageurl,
! 	array('contexts'=>array($categorycontext), 'currentcat'=>$param->delete));
! 	if ($qcobject->moveform->is_cancelled()){
! 		redirect($thispageurl);
! 	}  elseif ($formdata = $qcobject->moveform->get_data()) {
! 		/// 'confirm' is the category to move existing questions to
! 		list($tocategoryid, $tocontextid) = explode(',', $formdata->category);
! 		$qcobject->move_questions_and_delete_category($formdata->delete, $tocategoryid);
! 		$thispageurl->remove_params('cat', 'category');
! 		redirect($thispageurl);
! 	}
! } else {
! 	$questionstomove = 0;
! }
! if ($qcobject->catform->is_cancelled()) {
! 	redirect($thispageurl);
! } else if ($catformdata = $qcobject->catform->get_data()) {
! 	if (!$catformdata->id) {//new category
! 		$qcobject->add_category($catformdata->parent, $catformdata->name, $catformdata->info);
! 	} else {
! 		$qcobject->update_category($catformdata->id, $catformdata->parent, $catformdata->name, $catformdata->info);
! 	}
! 	redirect($thispageurl);
! } else if ((!empty($param->delete) and (!$questionstomove) and confirm_sesskey())) {
! 	$qcobject->delete_category($param->delete);//delete the category now no questions to move
! 	$thispageurl->remove_params('cat', 'category');
! 	redirect($thispageurl);
! }
! 
! if ($param->edit){
! 	$PAGE->navbar->add(get_string('editingcategory', 'question'));
! }
! 
! $PAGE->set_title($streditingcategories);
! $PAGE->set_heading($COURSE->fullname);
! echo $OUTPUT->header();
! 
! // display UI
! if (!empty($param->edit)) {
! 	$qcobject->edit_single_category($param->edit);
! } else if ($questionstomove){
! 	$qcobject->display_move_form($questionstomove, $category);
! } else {
! 	// display the user interface
! 	$qcobject->display_user_interface();
! }
! echo $OUTPUT->footer();
  
diff -crB questionorg/editlib.php questionupd/editlib.php
*** questionorg/editlib.php	2012-04-13 12:31:14.542178304 +0500
--- questionupd/editlib.php	2012-04-13 09:42:52.000000000 +0500
***************
*** 35,100 ****
  define('DEFAULT_QUESTIONS_PER_PAGE', 20);
  
  function get_module_from_cmid($cmid) {
!     global $CFG, $DB;
!     if (!$cmrec = $DB->get_record_sql("SELECT cm.*, md.name as modname
                                 FROM {course_modules} cm,
                                      {modules} md
                                 WHERE cm.id = ? AND
                                       md.id = cm.module", array($cmid))){
!         print_error('invalidcoursemodule');
!     } elseif (!$modrec =$DB->get_record($cmrec->modname, array('id' => $cmrec->instance))) {
!         print_error('invalidcoursemodule');
!     }
!     $modrec->instance = $modrec->id;
!     $modrec->cmid = $cmrec->id;
!     $cmrec->name = $modrec->name;
  
!     return array($modrec, $cmrec);
  }
  /**
! * Function to read all questions for category into big array
! *
! * @param int $category category number
! * @param bool $noparent if true only questions with NO parent will be selected
! * @param bool $recurse include subdirectories
! * @param bool $export set true if this is called by questionbank export
! * @author added by Howard Miller June 2004
! */
  function get_questions_category( $category, $noparent=false, $recurse=true, $export=true ) {
  
!     global $QTYPES, $DB;
  
!     // questions will be added to an array
!     $qresults = array();
  
!     // build sql bit for $noparent
!     $npsql = '';
!     if ($noparent) {
!       $npsql = " and parent='0' ";
!     }
! 
!     // get (list) of categories
!     if ($recurse) {
!         $categorylist = question_categorylist($category->id);
!     }
!     else {
!         $categorylist = $category->id;
!     }
! 
!     // get the list of questions for the category
!     list ($usql, $params) = $DB->get_in_or_equal(explode(',', $categorylist));
!     if ($questions = $DB->get_records_select("question","category $usql $npsql", $params, "qtype, name ASC")) {
! 
!         // iterate through questions, getting stuff we need
!         foreach($questions as $question) {
!             $questiontype = $QTYPES[$question->qtype];
!             $question->export_process = $export;
!             $questiontype->get_question_options($question);
!             $qresults[] = $question;
!         }
!     }
  
!     return $qresults;
  }
  
  /**
--- 35,100 ----
  define('DEFAULT_QUESTIONS_PER_PAGE', 20);
  
  function get_module_from_cmid($cmid) {
! 	global $CFG, $DB;
! 	if (!$cmrec = $DB->get_record_sql("SELECT cm.*, md.name as modname
                                 FROM {course_modules} cm,
                                      {modules} md
                                 WHERE cm.id = ? AND
                                       md.id = cm.module", array($cmid))){
! 	print_error('invalidcoursemodule');
!                                      } elseif (!$modrec =$DB->get_record($cmrec->modname, array('id' => $cmrec->instance))) {
!                                      	print_error('invalidcoursemodule');
!                                      }
!                                      $modrec->instance = $modrec->id;
!                                      $modrec->cmid = $cmrec->id;
!                                      $cmrec->name = $modrec->name;
  
!                                      return array($modrec, $cmrec);
  }
  /**
!  * Function to read all questions for category into big array
!  *
!  * @param int $category category number
!  * @param bool $noparent if true only questions with NO parent will be selected
!  * @param bool $recurse include subdirectories
!  * @param bool $export set true if this is called by questionbank export
!  * @author added by Howard Miller June 2004
!  */
  function get_questions_category( $category, $noparent=false, $recurse=true, $export=true ) {
  
! 	global $QTYPES, $DB;
  
! 	// questions will be added to an array
! 	$qresults = array();
  
! 	// build sql bit for $noparent
! 	$npsql = '';
! 	if ($noparent) {
! 		$npsql = " and parent='0' ";
! 	}
! 
! 	// get (list) of categories
! 	if ($recurse) {
! 		$categorylist = question_categorylist($category->id);
! 	}
! 	else {
! 		$categorylist = $category->id;
! 	}
! 
! 	// get the list of questions for the category
! 	list ($usql, $params) = $DB->get_in_or_equal(explode(',', $categorylist));
! 	if ($questions = $DB->get_records_select("question","category $usql $npsql", $params, "qtype, name ASC")) {
! 
! 		// iterate through questions, getting stuff we need
! 		foreach($questions as $question) {
! 			$questiontype = $QTYPES[$question->qtype];
! 			$question->export_process = $export;
! 			$questiontype->get_question_options($question);
! 			$qresults[] = $question;
! 		}
! 	}
  
! 	return $qresults;
  }
  
  /**
***************
*** 102,109 ****
   * @return boolean whether this is the only top-level category in a context.
   */
  function question_is_only_toplevel_category_in_context($categoryid) {
!     global $DB;
!     return 1 == $DB->count_records_sql("
              SELECT count(*)
                FROM {question_categories} c1,
                     {question_categories} c2
--- 102,109 ----
   * @return boolean whether this is the only top-level category in a context.
   */
  function question_is_only_toplevel_category_in_context($categoryid) {
! 	global $DB;
! 	return 1 == $DB->count_records_sql("
              SELECT count(*)
                FROM {question_categories} c1,
                     {question_categories} c2
***************
*** 118,565 ****
   * @param integer $todelete a category id.
   */
  function question_can_delete_cat($todelete) {
!     global $DB;
!     if (question_is_only_toplevel_category_in_context($todelete)) {
!         print_error('cannotdeletecate', 'question');
!     } else {
!         $contextid = $DB->get_field('question_categories', 'contextid', array('id' => $todelete));
!         require_capability('moodle/question:managecategory', get_context_instance_by_id($contextid));
!     }
  }
  
  abstract class question_bank_column_base {
!     /**
!      * @var question_bank_view
!      */
!     protected $qbank;
! 
!     /**
!      * Constructor.
!      * @param $qbank the question_bank_view we are helping to render.
!      */
!     public function __construct(question_bank_view $qbank) {
!         $this->qbank = $qbank;
!         $this->init();
!     }
! 
!     /**
!      * A chance for subclasses to initialise themselves, for example to load lang strings,
!      * without having to override the constructor.
!      */
!     protected function init() {
!     }
! 
!     public function is_extra_row() {
!         return false;
!     }
! 
!     /**
!      * Output the column header cell.
!      * @param integer $currentsort 0 for none. 1 for normal sort, -1 for reverse sort.
!      */
!     public function display_header() {
!         echo '<th class="header ' . $this->get_classes() . '" scope="col">';
!         $sortable = $this->is_sortable();
!         $name = $this->get_name();
!         $title = $this->get_title();
!         $tip = $this->get_title_tip();
!         if (is_array($sortable)) {
!             if ($title) {
!                 echo '<div class="title">' . $title . '</div>';
!             }
!             $links = array();
!             foreach ($sortable as $subsort => $details) {
!                 $links[] = $this->make_sort_link($name . '_' . $subsort,
!                         $details['title'], '', !empty($details['reverse']));
!             }
!             echo '<div class="sorters">' . implode(' / ', $links) . '</div>';
!         } else if ($sortable) {
!             echo $this->make_sort_link($name, $title, $tip);
!         } else {
!             if ($tip) {
!                 echo '<span title="' . $tip . '">';
!             }
!             echo $title;
!             if ($tip) {
!                 echo '</span>';
!             }
!         }
!         echo "</th>\n";
!     }
! 
!     /**
!      * Title for this column. Not used if is_sortable returns an array.
!      * @param object $question the row from the $question table, augmented with extra information.
!      * @param string $rowclasses CSS class names that should be applied to this row of output.
!      */
!     abstract protected function get_title();
! 
!     /**
!      * @return string a fuller version of the name. Use this when get_title() returns
!      * something very short, and you want a longer version as a tool tip.
!      */
!     protected function get_title_tip() {
!         return '';
!     }
! 
!     /**
!      * Get a link that changes the sort order, and indicates the current sort state.
!      * @param $name internal name used for this type of sorting.
!      * @param $currentsort the current sort order -1, 0, 1 for descending, none, ascending.
!      * @param $title the link text.
!      * @param $defaultreverse whether the default sort order for this column is descending, rather than ascending.
!      * @return string HTML fragment.
!      */
!     protected function make_sort_link($sort, $title, $tip, $defaultreverse = false) {
!         $currentsort = $this->qbank->get_primary_sort_order($sort);
!         $newsortreverse = $defaultreverse;
!         if ($currentsort) {
!             $newsortreverse = $currentsort > 0;
!         }
!         if (!$tip) {
!             $tip = $title;
!         }
!         if ($newsortreverse) {
!             $tip = get_string('sortbyxreverse', '', $tip);
!         } else {
!             $tip = get_string('sortbyx', '', $tip);
!         }
!         $link = '<a href="' . $this->qbank->new_sort_url($sort, $newsortreverse) . '" title="' . $tip . '">';
!         $link .= $title;
!         if ($currentsort) {
!             $link .= $this->get_sort_icon($currentsort < 0);
!         }
!         $link .= '</a>';
!         return $link;
!     }
! 
!     /**
!      * Get an icon representing the corrent sort state.
!      * @param $reverse sort is descending, not ascending.
!      * @return string HTML image tag.
!      */
!     protected function get_sort_icon($reverse) {
!         global $OUTPUT;
!         if ($reverse) {
!             return ' <img src="' . $OUTPUT->pix_url('t/up') . '" alt="' . get_string('desc') . '" />';
!         } else {
!             return ' <img src="' . $OUTPUT->pix_url('t/down') . '" alt="' . get_string('asc') . '" />';
!         }
!     }
! 
!     /**
!      * Output this column.
!      * @param object $question the row from the $question table, augmented with extra information.
!      * @param string $rowclasses CSS class names that should be applied to this row of output.
!      */
!     public function display($question, $rowclasses) {
!         $this->display_start($question, $rowclasses);
!         $this->display_content($question, $rowclasses);
!         $this->display_end($question, $rowclasses);
!     }
! 
!     protected function display_start($question, $rowclasses) {
!         echo '<td class="' . $this->get_classes() . '">';
!     }
! 
!     /**
!      * @return string the CSS classes to apply to every cell in this column.
!      */
!     protected function get_classes() {
!         $classes = $this->get_extra_classes();
!         $classes[] = $this->get_name();
!         return implode(' ', $classes);
!     }
! 
!     /**
!      * @param object $question the row from the $question table, augmented with extra information.
!      * @return string internal name for this column. Used as a CSS class name,
!      *     and to store information about the current sort. Must match PARAM_ALPHA.
!      */
!     abstract public function get_name();
! 
!     /**
!      * @return array any extra class names you would like applied to every cell in this column.
!      */
!     public function get_extra_classes() {
!         return array();
!     }
! 
!     /**
!      * Output the contents of this column.
!      * @param object $question the row from the $question table, augmented with extra information.
!      * @param string $rowclasses CSS class names that should be applied to this row of output.
!      */
!     abstract protected function display_content($question, $rowclasses);
! 
!     protected function display_end($question, $rowclasses) {
!         echo "</td>\n";
!     }
! 
!     /**
!      * Return an array 'table_alias' => 'JOIN clause' to bring in any data that
!      * this column required.
!      *
!      * The return values for all the columns will be checked. It is OK if two
!      * columns join in the same table with the same alias and identical JOIN clauses.
!      * If to columns try to use the same alias with different joins, you get an error.
!      * The only table included by default is the question table, which is aliased to 'q'.
!      *
!      * It is importnat that your join simply adds additional data (or NULLs) to the
!      * existing rows of the query. It must not cause additional rows.
!      *
!      * @return array 'table_alias' => 'JOIN clause'
!      */
!     public function get_extra_joins() {
!         return array();
!     }
! 
!     /**
!      * @return array fields required. use table alias 'q' for the question table, or one of the
!      * ones from get_extra_joins. Every field requested must specify a table prefix.
!      */
!     public function get_required_fields() {
!         return array();
!     }
! 
!     /**
!      * Can this column be sorted on? You can return either:
!      *  + false for no (the default),
!      *  + a field name, if sorting this column corresponds to sorting on that datbase field.
!      *  + an array of subnames to sort on as follows
!      *  return array(
!      *      'firstname' => array('field' => 'uc.firstname', 'title' => get_string('firstname')),
!      *      'lastname' => array('field' => 'uc.lastname', 'field' => get_string('lastname')),
!      *  );
!      * As well as field, and field, you can also add 'revers' => 1 if you want the default sort
!      * order to be DESC.
!      * @return mixed as above.
!      */
!     public function is_sortable() {
!         return false;
!     }
! 
!     /**
!      * Helper method for building sort clauses.
!      * @param boolean $reverse whether the normal direction should be reversed.
!      * @param string $normaldir 'ASC' or 'DESC'
!      * @return string 'ASC' or 'DESC'
!      */
!     protected function sortorder($reverse) {
!         if ($reverse) {
!             return ' DESC';
!         } else {
!             return ' ASC';
!         }
!     }
! 
!     /**
!      * @param $reverse Whether to sort in the reverse of the default sort order.
!      * @param $subsort if is_sortable returns an array of subnames, then this will be
!      *      one of those. Otherwise will be empty.
!      * @return string some SQL to go in the order by clause.
!      */
!     public function sort_expression($reverse, $subsort) {
!         $sortable = $this->is_sortable();
!         if (is_array($sortable)) {
!             if (array_key_exists($subsort, $sortable)) {
!                 return $sortable[$subsort]['field'] . $this->sortorder($reverse, !empty($sortable[$subsort]['reverse']));
!             } else {
!                 throw new coding_exception('Unexpected $subsort type: ' . $subsort);
!             }
!         } else if ($sortable) {
!             return $sortable . $this->sortorder($reverse);
!         } else {
!             throw new coding_exception('sort_expression called on a non-sortable column.');
!         }
!     }
  }
  
  /**
   * A column with a checkbox for each question with name q{questionid}.
   */
  class question_bank_checkbox_column extends question_bank_column_base {
!     protected $strselect;
!     protected $firstrow = true;
  
!     public function init() {
!         $this->strselect = get_string('select', 'quiz');
!     }
! 
!     public function get_name() {
!         return 'checkbox';
!     }
! 
!     protected function get_title() {
!         return '<input type="checkbox" disabled="disabled" id="qbheadercheckbox" />';
!     }
! 
!     protected function get_title_tip() {
!         return get_string('selectquestionsforbulk', 'question');
!     }
! 
!     protected function display_content($question, $rowclasses) {
!         global $PAGE;
!         echo '<input title="' . $this->strselect . '" type="checkbox" name="q' .
!                 $question->id . '" id="checkq' . $question->id . '" value="1"/>';
!         if ($this->firstrow) {
!             $PAGE->requires->js_function_call('question_bank.init_checkbox_column', array(get_string('selectall'),
!                     get_string('deselectall'), 'checkq' . $question->id));
!             $this->firstrow = false;
!         }
!     }
! 
!     public function get_required_fields() {
!         return array('q.id');
!     }
  }
  
  /**
   * A column type for the name of the question type.
   */
  class question_bank_question_type_column extends question_bank_column_base {
!     public function get_name() {
!         return 'qtype';
!     }
! 
!     protected function get_title() {
!         return get_string('qtypeveryshort', 'question');
!     }
! 
!     protected function get_title_tip() {
!         return get_string('questiontype', 'question');
!     }
! 
!     protected function display_content($question, $rowclasses) {
!         echo print_question_icon($question);
!     }
! 
!     public function get_required_fields() {
!         return array('q.qtype');
!     }
! 
!     public function is_sortable() {
!         return 'q.qtype';
!     }
  }
  
  /**
   * A column type for the name of the question name.
   */
  class question_bank_question_name_column extends question_bank_column_base {
!     protected $checkboxespresent = null;
  
!     public function get_name() {
!         return 'questionname';
!     }
! 
!     protected function get_title() {
!         return get_string('question');
!     }
! 
!     protected function label_for($question) {
!         if (is_null($this->checkboxespresent)) {
!             $this->checkboxespresent = $this->qbank->has_column('checkbox');
!         }
!         if ($this->checkboxespresent) {
!             return 'checkq' . $question->id;
!         } else {
!             return '';
!         }
!     }
! 
!     protected function display_content($question, $rowclasses) {
!         $labelfor = $this->label_for($question);
!         if ($labelfor) {
!             echo '<label for="' . $labelfor . '">';
!         }
!         echo format_string($question->name);
!         if ($labelfor) {
!             echo '</label>';
!         }
!     }
! 
!     public function get_required_fields() {
!         return array('q.id', 'q.name');
!     }
! 
!     public function is_sortable() {
!         return 'q.name';
!     }
  }
  
  /**
   * A column type for the name of the question creator.
   */
  class question_bank_creator_name_column extends question_bank_column_base {
!     public function get_name() {
!         return 'creatorname';
!     }
! 
!     protected function get_title() {
!         return get_string('createdby', 'question');
!     }
! 
!     protected function display_content($question, $rowclasses) {
!         if (!empty($question->creatorfirstname) && !empty($question->creatorlastname)) {
!             $u = new stdClass;
!             $u->firstname = $question->creatorfirstname;
!             $u->lastname = $question->creatorlastname;
!             echo fullname($u);
!         }
!     }
! 
!     public function get_extra_joins() {
!         return array('uc' => 'LEFT JOIN {user} uc ON uc.id = q.createdby');
!     }
! 
!     public function get_required_fields() {
!         return array('uc.firstname AS creatorfirstname', 'uc.lastname AS creatorlastname');
!     }
  
!     public function is_sortable() {
!         return array(
              'firstname' => array('field' => 'uc.firstname', 'title' => get_string('firstname')),
              'lastname' => array('field' => 'uc.lastname', 'title' => get_string('lastname')),
!         );
!     }
  }
  
  /**
   * A column type for the name of the question last modifier.
   */
  class question_bank_modifier_name_column extends question_bank_column_base {
!     public function get_name() {
!         return 'modifiername';
!     }
! 
!     protected function get_title() {
!         return get_string('lastmodifiedby', 'question');
!     }
! 
!     protected function display_content($question, $rowclasses) {
!         if (!empty($question->modifierfirstname) && !empty($question->modifierlastname)) {
!             $u = new stdClass;
!             $u->firstname = $question->modifierfirstname;
!             $u->lastname = $question->modifierlastname;
!             echo fullname($u);
!         }
!     }
! 
!     public function get_extra_joins() {
!         return array('um' => 'LEFT JOIN {user} um ON um.id = q.modifiedby');
!     }
! 
!     public function get_required_fields() {
!         return array('um.firstname AS modifierfirstname', 'um.lastname AS modifierlastname');
!     }
  
!     public function is_sortable() {
!         return array(
              'firstname' => array('field' => 'um.firstname', 'title' => get_string('firstname')),
              'lastname' => array('field' => 'um.lastname', 'title' => get_string('lastname')),
!         );
!     }
  }
  
  /**
--- 118,565 ----
   * @param integer $todelete a category id.
   */
  function question_can_delete_cat($todelete) {
! 	global $DB;
! 	if (question_is_only_toplevel_category_in_context($todelete)) {
! 		print_error('cannotdeletecate', 'question');
! 	} else {
! 		$contextid = $DB->get_field('question_categories', 'contextid', array('id' => $todelete));
! 		require_capability('moodle/question:managecategory', get_context_instance_by_id($contextid));
! 	}
  }
  
  abstract class question_bank_column_base {
! 	/**
! 	 * @var question_bank_view
! 	 */
! 	protected $qbank;
! 
! 	/**
! 	 * Constructor.
! 	 * @param $qbank the question_bank_view we are helping to render.
! 	 */
! 	public function __construct(question_bank_view $qbank) {
! 		$this->qbank = $qbank;
! 		$this->init();
! 	}
! 
! 	/**
! 	 * A chance for subclasses to initialise themselves, for example to load lang strings,
! 	 * without having to override the constructor.
! 	 */
! 	protected function init() {
! 	}
! 
! 	public function is_extra_row() {
! 		return false;
! 	}
! 
! 	/**
! 	 * Output the column header cell.
! 	 * @param integer $currentsort 0 for none. 1 for normal sort, -1 for reverse sort.
! 	 */
! 	public function display_header() {
! 		echo '<th class="header ' . $this->get_classes() . '" scope="col">';
! 		$sortable = $this->is_sortable();
! 		$name = $this->get_name();
! 		$title = $this->get_title();
! 		$tip = $this->get_title_tip();
! 		if (is_array($sortable)) {
! 			if ($title) {
! 				echo '<div class="title">' . $title . '</div>';
! 			}
! 			$links = array();
! 			foreach ($sortable as $subsort => $details) {
! 				$links[] = $this->make_sort_link($name . '_' . $subsort,
! 				$details['title'], '', !empty($details['reverse']));
! 			}
! 			echo '<div class="sorters">' . implode(' / ', $links) . '</div>';
! 		} else if ($sortable) {
! 			echo $this->make_sort_link($name, $title, $tip);
! 		} else {
! 			if ($tip) {
! 				echo '<span title="' . $tip . '">';
! 			}
! 			echo $title;
! 			if ($tip) {
! 				echo '</span>';
! 			}
! 		}
! 		echo "</th>\n";
! 	}
! 
! 	/**
! 	 * Title for this column. Not used if is_sortable returns an array.
! 	 * @param object $question the row from the $question table, augmented with extra information.
! 	 * @param string $rowclasses CSS class names that should be applied to this row of output.
! 	 */
! 	abstract protected function get_title();
! 
! 	/**
! 	 * @return string a fuller version of the name. Use this when get_title() returns
! 	 * something very short, and you want a longer version as a tool tip.
! 	 */
! 	protected function get_title_tip() {
! 		return '';
! 	}
! 
! 	/**
! 	 * Get a link that changes the sort order, and indicates the current sort state.
! 	 * @param $name internal name used for this type of sorting.
! 	 * @param $currentsort the current sort order -1, 0, 1 for descending, none, ascending.
! 	 * @param $title the link text.
! 	 * @param $defaultreverse whether the default sort order for this column is descending, rather than ascending.
! 	 * @return string HTML fragment.
! 	 */
! 	protected function make_sort_link($sort, $title, $tip, $defaultreverse = false) {
! 		$currentsort = $this->qbank->get_primary_sort_order($sort);
! 		$newsortreverse = $defaultreverse;
! 		if ($currentsort) {
! 			$newsortreverse = $currentsort > 0;
! 		}
! 		if (!$tip) {
! 			$tip = $title;
! 		}
! 		if ($newsortreverse) {
! 			$tip = get_string('sortbyxreverse', '', $tip);
! 		} else {
! 			$tip = get_string('sortbyx', '', $tip);
! 		}
! 		$link = '<a href="' . $this->qbank->new_sort_url($sort, $newsortreverse) . '" title="' . $tip . '">';
! 		$link .= $title;
! 		if ($currentsort) {
! 			$link .= $this->get_sort_icon($currentsort < 0);
! 		}
! 		$link .= '</a>';
! 		return $link;
! 	}
! 
! 	/**
! 	 * Get an icon representing the corrent sort state.
! 	 * @param $reverse sort is descending, not ascending.
! 	 * @return string HTML image tag.
! 	 */
! 	protected function get_sort_icon($reverse) {
! 		global $OUTPUT;
! 		if ($reverse) {
! 			return ' <img src="' . $OUTPUT->pix_url('t/up') . '" alt="' . get_string('desc') . '" />';
! 		} else {
! 			return ' <img src="' . $OUTPUT->pix_url('t/down') . '" alt="' . get_string('asc') . '" />';
! 		}
! 	}
! 
! 	/**
! 	 * Output this column.
! 	 * @param object $question the row from the $question table, augmented with extra information.
! 	 * @param string $rowclasses CSS class names that should be applied to this row of output.
! 	 */
! 	public function display($question, $rowclasses) {
! 		$this->display_start($question, $rowclasses);
! 		$this->display_content($question, $rowclasses);
! 		$this->display_end($question, $rowclasses);
! 	}
! 
! 	protected function display_start($question, $rowclasses) {
! 		echo '<td class="' . $this->get_classes() . '">';
! 	}
! 
! 	/**
! 	 * @return string the CSS classes to apply to every cell in this column.
! 	 */
! 	protected function get_classes() {
! 		$classes = $this->get_extra_classes();
! 		$classes[] = $this->get_name();
! 		return implode(' ', $classes);
! 	}
! 
! 	/**
! 	 * @param object $question the row from the $question table, augmented with extra information.
! 	 * @return string internal name for this column. Used as a CSS class name,
! 	 *     and to store information about the current sort. Must match PARAM_ALPHA.
! 	 */
! 	abstract public function get_name();
! 
! 	/**
! 	 * @return array any extra class names you would like applied to every cell in this column.
! 	 */
! 	public function get_extra_classes() {
! 		return array();
! 	}
! 
! 	/**
! 	 * Output the contents of this column.
! 	 * @param object $question the row from the $question table, augmented with extra information.
! 	 * @param string $rowclasses CSS class names that should be applied to this row of output.
! 	 */
! 	abstract protected function display_content($question, $rowclasses);
! 
! 	protected function display_end($question, $rowclasses) {
! 		echo "</td>\n";
! 	}
! 
! 	/**
! 	 * Return an array 'table_alias' => 'JOIN clause' to bring in any data that
! 	 * this column required.
! 	 *
! 	 * The return values for all the columns will be checked. It is OK if two
! 	 * columns join in the same table with the same alias and identical JOIN clauses.
! 	 * If to columns try to use the same alias with different joins, you get an error.
! 	 * The only table included by default is the question table, which is aliased to 'q'.
! 	 *
! 	 * It is importnat that your join simply adds additional data (or NULLs) to the
! 	 * existing rows of the query. It must not cause additional rows.
! 	 *
! 	 * @return array 'table_alias' => 'JOIN clause'
! 	 */
! 	public function get_extra_joins() {
! 		return array();
! 	}
! 
! 	/**
! 	 * @return array fields required. use table alias 'q' for the question table, or one of the
! 	 * ones from get_extra_joins. Every field requested must specify a table prefix.
! 	 */
! 	public function get_required_fields() {
! 		return array();
! 	}
! 
! 	/**
! 	 * Can this column be sorted on? You can return either:
! 	 *  + false for no (the default),
! 	 *  + a field name, if sorting this column corresponds to sorting on that datbase field.
! 	 *  + an array of subnames to sort on as follows
! 	 *  return array(
! 	 *      'firstname' => array('field' => 'uc.firstname', 'title' => get_string('firstname')),
! 	 *      'lastname' => array('field' => 'uc.lastname', 'field' => get_string('lastname')),
! 	 *  );
! 	 * As well as field, and field, you can also add 'revers' => 1 if you want the default sort
! 	 * order to be DESC.
! 	 * @return mixed as above.
! 	 */
! 	public function is_sortable() {
! 		return false;
! 	}
! 
! 	/**
! 	 * Helper method for building sort clauses.
! 	 * @param boolean $reverse whether the normal direction should be reversed.
! 	 * @param string $normaldir 'ASC' or 'DESC'
! 	 * @return string 'ASC' or 'DESC'
! 	 */
! 	protected function sortorder($reverse) {
! 		if ($reverse) {
! 			return ' DESC';
! 		} else {
! 			return ' ASC';
! 		}
! 	}
! 
! 	/**
! 	 * @param $reverse Whether to sort in the reverse of the default sort order.
! 	 * @param $subsort if is_sortable returns an array of subnames, then this will be
! 	 *      one of those. Otherwise will be empty.
! 	 * @return string some SQL to go in the order by clause.
! 	 */
! 	public function sort_expression($reverse, $subsort) {
! 		$sortable = $this->is_sortable();
! 		if (is_array($sortable)) {
! 			if (array_key_exists($subsort, $sortable)) {
! 				return $sortable[$subsort]['field'] . $this->sortorder($reverse, !empty($sortable[$subsort]['reverse']));
! 			} else {
! 				throw new coding_exception('Unexpected $subsort type: ' . $subsort);
! 			}
! 		} else if ($sortable) {
! 			return $sortable . $this->sortorder($reverse);
! 		} else {
! 			throw new coding_exception('sort_expression called on a non-sortable column.');
! 		}
! 	}
  }
  
  /**
   * A column with a checkbox for each question with name q{questionid}.
   */
  class question_bank_checkbox_column extends question_bank_column_base {
! 	protected $strselect;
! 	protected $firstrow = true;
  
! 	public function init() {
! 		$this->strselect = get_string('select', 'quiz');
! 	}
! 
! 	public function get_name() {
! 		return 'checkbox';
! 	}
! 
! 	protected function get_title() {
! 		return '<input type="checkbox" disabled="disabled" id="qbheadercheckbox" />';
! 	}
! 
! 	protected function get_title_tip() {
! 		return get_string('selectquestionsforbulk', 'question');
! 	}
! 
! 	protected function display_content($question, $rowclasses) {
! 		global $PAGE;
! 		echo '<input title="' . $this->strselect . '" type="checkbox" name="q' .
! 		$question->id . '" id="checkq' . $question->id . '" value="1"/>';
! 		if ($this->firstrow) {
! 			$PAGE->requires->js_function_call('question_bank.init_checkbox_column', array(get_string('selectall'),
! 			get_string('deselectall'), 'checkq' . $question->id));
! 			$this->firstrow = false;
! 		}
! 	}
! 
! 	public function get_required_fields() {
! 		return array('q.id');
! 	}
  }
  
  /**
   * A column type for the name of the question type.
   */
  class question_bank_question_type_column extends question_bank_column_base {
! 	public function get_name() {
! 		return 'qtype';
! 	}
! 
! 	protected function get_title() {
! 		return get_string('qtypeveryshort', 'question');
! 	}
! 
! 	protected function get_title_tip() {
! 		return get_string('questiontype', 'question');
! 	}
! 
! 	protected function display_content($question, $rowclasses) {
! 		echo print_question_icon($question);
! 	}
! 
! 	public function get_required_fields() {
! 		return array('q.qtype');
! 	}
! 
! 	public function is_sortable() {
! 		return 'q.qtype';
! 	}
  }
  
  /**
   * A column type for the name of the question name.
   */
  class question_bank_question_name_column extends question_bank_column_base {
! 	protected $checkboxespresent = null;
  
! 	public function get_name() {
! 		return 'questionname';
! 	}
! 
! 	protected function get_title() {
! 		return get_string('question');
! 	}
! 
! 	protected function label_for($question) {
! 		if (is_null($this->checkboxespresent)) {
! 			$this->checkboxespresent = $this->qbank->has_column('checkbox');
! 		}
! 		if ($this->checkboxespresent) {
! 			return 'checkq' . $question->id;
! 		} else {
! 			return '';
! 		}
! 	}
! 
! 	protected function display_content($question, $rowclasses) {
! 		$labelfor = $this->label_for($question);
! 		if ($labelfor) {
! 			echo '<label for="' . $labelfor . '">';
! 		}
! 		echo format_string($question->name);
! 		if ($labelfor) {
! 			echo '</label>';
! 		}
! 	}
! 
! 	public function get_required_fields() {
! 		return array('q.id', 'q.name');
! 	}
! 
! 	public function is_sortable() {
! 		return 'q.name';
! 	}
  }
  
  /**
   * A column type for the name of the question creator.
   */
  class question_bank_creator_name_column extends question_bank_column_base {
! 	public function get_name() {
! 		return 'creatorname';
! 	}
! 
! 	protected function get_title() {
! 		return get_string('createdby', 'question');
! 	}
! 
! 	protected function display_content($question, $rowclasses) {
! 		if (!empty($question->creatorfirstname) && !empty($question->creatorlastname)) {
! 			$u = new stdClass;
! 			$u->firstname = $question->creatorfirstname;
! 			$u->lastname = $question->creatorlastname;
! 			echo fullname($u);
! 		}
! 	}
! 
! 	public function get_extra_joins() {
! 		return array('uc' => 'LEFT JOIN {user} uc ON uc.id = q.createdby');
! 	}
! 
! 	public function get_required_fields() {
! 		return array('uc.firstname AS creatorfirstname', 'uc.lastname AS creatorlastname');
! 	}
  
! 	public function is_sortable() {
! 		return array(
              'firstname' => array('field' => 'uc.firstname', 'title' => get_string('firstname')),
              'lastname' => array('field' => 'uc.lastname', 'title' => get_string('lastname')),
! 		);
! 	}
  }
  
  /**
   * A column type for the name of the question last modifier.
   */
  class question_bank_modifier_name_column extends question_bank_column_base {
! 	public function get_name() {
! 		return 'modifiername';
! 	}
! 
! 	protected function get_title() {
! 		return get_string('lastmodifiedby', 'question');
! 	}
! 
! 	protected function display_content($question, $rowclasses) {
! 		if (!empty($question->modifierfirstname) && !empty($question->modifierlastname)) {
! 			$u = new stdClass;
! 			$u->firstname = $question->modifierfirstname;
! 			$u->lastname = $question->modifierlastname;
! 			echo fullname($u);
! 		}
! 	}
! 
! 	public function get_extra_joins() {
! 		return array('um' => 'LEFT JOIN {user} um ON um.id = q.modifiedby');
! 	}
! 
! 	public function get_required_fields() {
! 		return array('um.firstname AS modifierfirstname', 'um.lastname AS modifierlastname');
! 	}
  
! 	public function is_sortable() {
! 		return array(
              'firstname' => array('field' => 'um.firstname', 'title' => get_string('firstname')),
              'lastname' => array('field' => 'um.lastname', 'title' => get_string('lastname')),
! 		);
! 	}
  }
  
  /**
***************
*** 567,753 ****
   */
  abstract class question_bank_action_column_base extends question_bank_column_base {
  
!     protected function get_title() {
!         return '&#160;';
!     }
! 
!     public function get_extra_classes() {
!         return array('iconcol');
!     }
! 
!     protected function print_icon($icon, $title, $url) {
!         global $OUTPUT;
!         echo '<a title="' . $title . '" href="' . $url . '">
                  <img src="' . $OUTPUT->pix_url($icon) . '" class="iconsmall" alt="' . $title . '" /></a>';
!     }
  
!     public function get_required_fields() {
!         return array('q.id');
!     }
  }
  
  class question_bank_edit_action_column extends question_bank_action_column_base {
!     protected $stredit;
!     protected $strview;
  
!     public function init() {
!         parent::init();
!         $this->stredit = get_string('edit');
!         $this->strview = get_string('view');
!     }
! 
!     public function get_name() {
!         return 'editaction';
!     }
! 
!     protected function display_content($question, $rowclasses) {
!         if (question_has_capability_on($question, 'edit') ||
!                 question_has_capability_on($question, 'move')) {
!             $this->print_icon('t/edit', $this->stredit, $this->qbank->edit_question_url($question->id));
!         } else {
!             $this->print_icon('i/info', $this->strview, $this->qbank->edit_question_url($question->id));
!         }
!     }
  }
  
  class question_bank_preview_action_column extends question_bank_action_column_base {
!     protected $strpreview;
  
!     public function init() {
!         parent::init();
!         $this->strpreview = get_string('preview');
!     }
! 
!     public function get_name() {
!         return 'previewaction';
!     }
! 
!     protected function display_content($question, $rowclasses) {
!         global $OUTPUT;
!         if (question_has_capability_on($question, 'use')) {
!             // Build the icon.
!             $image = $OUTPUT->pix_icon('t/preview', $this->strpreview);
! 
!             $link = new moodle_url($this->qbank->preview_question_url($question->id));
!             parse_str(QUESTION_PREVIEW_POPUP_OPTIONS, $options);
!             $action = new popup_action('click', $link, 'questionpreview', $options);
! 
!             echo $OUTPUT->action_link($link, $image, $action, array('title' => $this->strpreview));
!         }
!     }
! 
!     public function get_required_fields() {
!         return array('q.id');
!     }
  }
  
  class question_bank_move_action_column extends question_bank_action_column_base {
!     protected $strmove;
  
!     public function init() {
!         parent::init();
!         $this->strmove = get_string('move');
!     }
! 
!     public function get_name() {
!         return 'moveaction';
!     }
! 
!     protected function display_content($question, $rowclasses) {
!         if (question_has_capability_on($question, 'move')) {
!             $this->print_icon('t/move', $this->strmove, $this->qbank->move_question_url($question->id));
!         }
!     }
  }
  
  /**
   * action to delete (or hide) a question, or restore a previously hidden question.
   */
  class question_bank_delete_action_column extends question_bank_action_column_base {
!     protected $strdelete;
!     protected $strrestore;
  
!     public function init() {
!         parent::init();
!         $this->strdelete = get_string('delete');
!         $this->strrestore = get_string('restore');
!     }
! 
!     public function get_name() {
!         return 'deleteaction';
!     }
! 
!     protected function display_content($question, $rowclasses) {
!         if (question_has_capability_on($question, 'edit')) {
!             if ($question->hidden) {
!                 $url = new moodle_url($this->qbank->base_url(), array('unhide' => $question->id, 'sesskey'=>sesskey()));
!                 $this->print_icon('t/restore', $this->strrestore, $url);
!             } else {
!                 $url = new moodle_url($this->qbank->base_url(), array('deleteselected' => $question->id, 'q' . $question->id => 1, 'sesskey'=>sesskey()));
!                 $this->print_icon('t/delete', $this->strdelete, $url);
!             }
!         }
!     }
! 
!     public function get_required_fields() {
!         return array('q.id', 'q.hidden');
!     }
  }
  
  /**
   * Base class for 'columns' that are actually displayed as a row following the main question row.
   */
  abstract class question_bank_row_base extends question_bank_column_base {
!     public function is_extra_row() {
!         return true;
!     }
! 
!     protected function display_start($question, $rowclasses) {
!         if ($rowclasses) {
!             echo '<tr class="' . $rowclasses . '">' . "\n";
!         } else {
!             echo "<tr>\n";
!         }
!         echo '<td colspan="' . $this->qbank->get_column_count() . '" class="' . $this->get_name() . '">';
!     }
! 
!     protected function display_end($question, $rowclasses) {
!         echo "</td></tr>\n";
!     }
  }
  
  /**
   * A column type for the name of the question name.
   */
  class question_bank_question_text_row extends question_bank_row_base {
!     protected $formatoptions;
  
!     protected function init() {
!         $this->formatoptions = new stdClass;
!         $this->formatoptions->noclean = true;
!         $this->formatoptions->para = false;
!     }
! 
!     public function get_name() {
!         return 'questiontext';
!     }
! 
!     protected function get_title() {
!         return get_string('questiontext', 'question');
!     }
! 
!     protected function display_content($question, $rowclasses) {
!         $text = format_text($question->questiontext, $question->questiontextformat,
!                 $this->formatoptions, $this->qbank->get_courseid());
!         if ($text == '') {
!             $text = '&#160;';
!         }
!         echo $text;
!     }
! 
!     public function get_required_fields() {
!         return array('q.questiontext', 'q.questiontextformat');
!     }
  }
  
  /**
--- 567,753 ----
   */
  abstract class question_bank_action_column_base extends question_bank_column_base {
  
! 	protected function get_title() {
! 		return '&#160;';
! 	}
! 
! 	public function get_extra_classes() {
! 		return array('iconcol');
! 	}
! 
! 	protected function print_icon($icon, $title, $url) {
! 		global $OUTPUT;
! 		echo '<a title="' . $title . '" href="' . $url . '">
                  <img src="' . $OUTPUT->pix_url($icon) . '" class="iconsmall" alt="' . $title . '" /></a>';
! 	}
  
! 	public function get_required_fields() {
! 		return array('q.id');
! 	}
  }
  
  class question_bank_edit_action_column extends question_bank_action_column_base {
! 	protected $stredit;
! 	protected $strview;
  
! 	public function init() {
! 		parent::init();
! 		$this->stredit = get_string('edit');
! 		$this->strview = get_string('view');
! 	}
! 
! 	public function get_name() {
! 		return 'editaction';
! 	}
! 
! 	protected function display_content($question, $rowclasses) {
! 		if (question_has_capability_on($question, 'edit') ||
! 		question_has_capability_on($question, 'move')) {
! 			$this->print_icon('t/edit', $this->stredit, $this->qbank->edit_question_url($question->id));
! 		} else {
! 			$this->print_icon('i/info', $this->strview, $this->qbank->edit_question_url($question->id));
! 		}
! 	}
  }
  
  class question_bank_preview_action_column extends question_bank_action_column_base {
! 	protected $strpreview;
  
! 	public function init() {
! 		parent::init();
! 		$this->strpreview = get_string('preview');
! 	}
! 
! 	public function get_name() {
! 		return 'previewaction';
! 	}
! 
! 	protected function display_content($question, $rowclasses) {
! 		global $OUTPUT;
! 		if (question_has_capability_on($question, 'use')) {
! 			// Build the icon.
! 			$image = $OUTPUT->pix_icon('t/preview', $this->strpreview);
! 
! 			$link = new moodle_url($this->qbank->preview_question_url($question->id));
! 			parse_str(QUESTION_PREVIEW_POPUP_OPTIONS, $options);
! 			$action = new popup_action('click', $link, 'questionpreview', $options);
! 
! 			echo $OUTPUT->action_link($link, $image, $action, array('title' => $this->strpreview));
! 		}
! 	}
! 
! 	public function get_required_fields() {
! 		return array('q.id');
! 	}
  }
  
  class question_bank_move_action_column extends question_bank_action_column_base {
! 	protected $strmove;
  
! 	public function init() {
! 		parent::init();
! 		$this->strmove = get_string('move');
! 	}
! 
! 	public function get_name() {
! 		return 'moveaction';
! 	}
! 
! 	protected function display_content($question, $rowclasses) {
! 		if (question_has_capability_on($question, 'move')) {
! 			$this->print_icon('t/move', $this->strmove, $this->qbank->move_question_url($question->id));
! 		}
! 	}
  }
  
  /**
   * action to delete (or hide) a question, or restore a previously hidden question.
   */
  class question_bank_delete_action_column extends question_bank_action_column_base {
! 	protected $strdelete;
! 	protected $strrestore;
  
! 	public function init() {
! 		parent::init();
! 		$this->strdelete = get_string('delete');
! 		$this->strrestore = get_string('restore');
! 	}
! 
! 	public function get_name() {
! 		return 'deleteaction';
! 	}
! 
! 	protected function display_content($question, $rowclasses) {
! 		if (question_has_capability_on($question, 'edit')) {
! 			if ($question->hidden) {
! 				$url = new moodle_url($this->qbank->base_url(), array('unhide' => $question->id, 'sesskey'=>sesskey()));
! 				$this->print_icon('t/restore', $this->strrestore, $url);
! 			} else {
! 				$url = new moodle_url($this->qbank->base_url(), array('deleteselected' => $question->id, 'q' . $question->id => 1, 'sesskey'=>sesskey()));
! 				$this->print_icon('t/delete', $this->strdelete, $url);
! 			}
! 		}
! 	}
! 
! 	public function get_required_fields() {
! 		return array('q.id', 'q.hidden');
! 	}
  }
  
  /**
   * Base class for 'columns' that are actually displayed as a row following the main question row.
   */
  abstract class question_bank_row_base extends question_bank_column_base {
! 	public function is_extra_row() {
! 		return true;
! 	}
! 
! 	protected function display_start($question, $rowclasses) {
! 		if ($rowclasses) {
! 			echo '<tr class="' . $rowclasses . '">' . "\n";
! 		} else {
! 			echo "<tr>\n";
! 		}
! 		echo '<td colspan="' . $this->qbank->get_column_count() . '" class="' . $this->get_name() . '">';
! 	}
! 
! 	protected function display_end($question, $rowclasses) {
! 		echo "</td></tr>\n";
! 	}
  }
  
  /**
   * A column type for the name of the question name.
   */
  class question_bank_question_text_row extends question_bank_row_base {
! 	protected $formatoptions;
  
! 	protected function init() {
! 		$this->formatoptions = new stdClass;
! 		$this->formatoptions->noclean = true;
! 		$this->formatoptions->para = false;
! 	}
! 
! 	public function get_name() {
! 		return 'questiontext';
! 	}
! 
! 	protected function get_title() {
! 		return get_string('questiontext', 'question');
! 	}
! 
! 	protected function display_content($question, $rowclasses) {
! 		$text = format_text($question->questiontext, $question->questiontextformat,
! 		$this->formatoptions, $this->qbank->get_courseid());
! 		if ($text == '') {
! 			$text = '&#160;';
! 		}
! 		echo $text;
! 	}
! 
! 	public function get_required_fields() {
! 		return array('q.questiontext', 'q.questiontextformat');
! 	}
  }
  
  /**
***************
*** 768,1493 ****
   *  + outputting table headers.
   */
  class question_bank_view {
!     const MAX_SORTS = 3;
  
!     protected $baseurl;
!     protected $editquestionurl;
!     protected $quizorcourseid;
!     protected $contexts;
!     protected $cm;
!     protected $course;
!     protected $knowncolumntypes;
!     protected $visiblecolumns;
!     protected $extrarows;
!     protected $requiredcolumns;
!     protected $sort;
!     protected $lastchangedid;
!     protected $countsql;
!     protected $loadsql;
!     protected $sqlparams;
! 
!     public function __construct($contexts, $pageurl, $course, $cm = null) {
!         global $CFG, $PAGE;
! 
!         $this->contexts = $contexts;
!         $this->baseurl = $pageurl;
!         $this->course = $course;
!         $this->cm = $cm;
! 
!         if (!empty($cm) && $cm->modname == 'quiz') {
!             $this->quizorcourseid = '&amp;quizid=' . $cm->instance;
!         } else {
!             $this->quizorcourseid = '&amp;courseid=' .$this->course->id;
!         }
! 
!         // Create the url of the new question page to forward to.
!         $returnurl = str_replace($CFG->wwwroot, '', $pageurl->out(false));
!         $this->editquestionurl = new moodle_url('/question/question.php',
!                 array('returnurl' => $returnurl));
!         if ($cm !== null){
!             $this->editquestionurl->param('cmid', $cm->id);
!         } else {
!             $this->editquestionurl->param('courseid', $this->course->id);
!         }
! 
!         $this->lastchangedid = optional_param('lastchanged',0,PARAM_INT);
! 
!         $this->init_column_types();
!         $this->init_columns($this->wanted_columns());
!         $this->init_sort();
  
!         $PAGE->requires->yui2_lib('container');
!     }
  
!     protected function wanted_columns() {
!         $columns = array('checkbox', 'qtype', 'questionname', 'editaction',
                  'previewaction', 'moveaction', 'deleteaction', 'creatorname',
                  'modifiername');
!         if (optional_param('qbshowtext', false, PARAM_BOOL)) {
!             $columns[] = 'questiontext';
!         }
!         return $columns;
!     }
! 
!     protected function known_field_types() {
!         return array(
!             new question_bank_checkbox_column($this),
!             new question_bank_question_type_column($this),
!             new question_bank_question_name_column($this),
!             new question_bank_creator_name_column($this),
!             new question_bank_modifier_name_column($this),
!             new question_bank_edit_action_column($this),
!             new question_bank_preview_action_column($this),
!             new question_bank_move_action_column($this),
!             new question_bank_delete_action_column($this),
!             new question_bank_question_text_row($this),
!         );
!     }
! 
!     protected function init_column_types() {
!         $this->knowncolumntypes = array();
!         foreach ($this->known_field_types() as $col) {
!             $this->knowncolumntypes[$col->get_name()] = $col;
!         }
!     }
! 
!     protected function init_columns($wanted) {
!         $this->visiblecolumns = array();
!         $this->extrarows = array();
!         foreach ($wanted as $colname) {
!             if (!isset($this->knowncolumntypes[$colname])) {
!                 throw new coding_exception('Unknown column type ' . $colname . ' requested in init columns.');
!             }
!             $column = $this->knowncolumntypes[$colname];
!             if ($column->is_extra_row()) {
!                 $this->extrarows[$colname] = $column;
!             } else {
!                 $this->visiblecolumns[$colname] = $column;
!             }
!         }
!         $this->requiredcolumns = array_merge($this->visiblecolumns, $this->extrarows);
!     }
! 
!     /**
!      * @param string $colname a column internal name.
!      * @return boolean is this column included in the output?
!      */
!     public function has_column($colname) {
!         return isset($this->visiblecolumns[$colname]);
!     }
! 
!     /**
!      * @return integer The number of columns in the table.
!      */
!     public function get_column_count() {
!         return count($this->visiblecolumns);
!     }
! 
!     public function get_courseid() {
!         return $this->course->id;
!     }
! 
!     protected function init_sort() {
!         $this->init_sort_from_params();
!         if (empty($this->sort)) {
!             $this->sort = $this->default_sort();
!         }
!     }
! 
!     /**
!      * Deal with a sort name of the forum columnname, or colname_subsort by
!      * breaking it up, validating the bits that are presend, and returning them.
!      * If there is no subsort, then $subsort is returned as ''.
!      * @return array array($colname, $subsort).
!      */
!     protected function parse_subsort($sort) {
!     /// Do the parsing.
!         if (strpos($sort, '_') !== false) {
!             list($colname, $subsort) = explode('_', $sort, 2);
!         } else {
!             $colname = $sort;
!             $subsort = '';
!         }
!     /// Validate the column name.
!         if (!isset($this->knowncolumntypes[$colname]) || !$this->knowncolumntypes[$colname]->is_sortable()) {
!             for ($i = 1; $i <= question_bank_view::MAX_SORTS; $i++) {
!                 $this->baseurl->remove_params('qbs' . $i);
!             }
!             throw new moodle_exception('unknownsortcolumn', '', $link = $this->baseurl->out(), $colname);
!         }
!     /// Validate the subsort, if present.
!         if ($subsort) {
!             $subsorts = $this->knowncolumntypes[$colname]->is_sortable();
!             if (!is_array($subsorts) || !isset($subsorts[$subsort])) {
!                 throw new moodle_exception('unknownsortcolumn', '', $link = $this->baseurl->out(), $sort);
!             }
!         }
!         return array($colname, $subsort);
!     }
! 
!     protected function init_sort_from_params() {
!         $this->sort = array();
!         for ($i = 1; $i <= question_bank_view::MAX_SORTS; $i++) {
!             if (!$sort = optional_param('qbs' . $i, '', PARAM_ALPHAEXT)) {
!                 break;
!             }
!             // Work out the appropriate order.
!             $order = 1;
!             if ($sort[0] == '-') {
!                 $order = -1;
!                 $sort = substr($sort, 1);
!                 if (!$sort) {
!                     break;
!                 }
!             }
!             // Deal with subsorts.
!             list($colname, $subsort) = $this->parse_subsort($sort);
!             $this->requiredcolumns[$colname] = $this->knowncolumntypes[$colname];
!             $this->sort[$sort] = $order;
!         }
!     }
! 
!     protected function sort_to_params($sorts) {
!         $params = array();
!         $i = 0;
!         foreach ($sorts as $sort => $order) {
!             $i += 1;
!             if ($order < 0) {
!                 $sort = '-' . $sort;
!             }
!             $params['qbs' . $i] = $sort;
!         }
!         return $params;
!     }
! 
!     protected function default_sort() {
!         return array('qtype' => 1, 'questionname' => 1);
!     }
! 
!     /**
!      * @param $sort a column or column_subsort name.
!      * @return integer the current sort order for this column -1, 0, 1
!      */
!     public function get_primary_sort_order($sort) {
!         $order = reset($this->sort);
!         $primarysort = key($this->sort);
!         if ($sort == $primarysort) {
!             return $order;
!         } else {
!             return 0;
!         }
!     }
! 
!     /**
!      * Get a URL to redisplay the page with a new sort for the question bank.
!      * @param string $sort the column, or column_subsort to sort on.
!      * @param boolean $newsortreverse whether to sort in reverse order.
!      * @return string The new URL.
!      */
!     public function new_sort_url($sort, $newsortreverse) {
!         if ($newsortreverse) {
!             $order = -1;
!         } else {
!             $order = 1;
!         }
!         // Tricky code to add the new sort at the start, removing it from where it was before, if it was present.
!         $newsort = array_reverse($this->sort);
!         if (isset($newsort[$sort])) {
!             unset($newsort[$sort]);
!         }
!         $newsort[$sort] = $order;
!         $newsort = array_reverse($newsort);
!         if (count($newsort) > question_bank_view::MAX_SORTS) {
!             $newsort = array_slice($newsort, 0, question_bank_view::MAX_SORTS, true);
!         }
!         return $this->baseurl->out(true, $this->sort_to_params($newsort));
!     }
! 
!     protected function build_query_sql($category, $recurse, $showhidden) {
!         global $DB;
! 
!     /// Get the required tables.
!         $joins = array();
!         foreach ($this->requiredcolumns as $column) {
!             $extrajoins = $column->get_extra_joins();
!             foreach ($extrajoins as $prefix => $join) {
!                 if (isset($joins[$prefix]) && $joins[$prefix] != $join) {
!                     throw new coding_exception('Join ' . $join . ' conflicts with previous join ' . $joins[$prefix]);
!                 }
!                 $joins[$prefix] = $join;
!             }
!         }
! 
!     /// Get the required fields.
!         $fields = array('q.hidden', 'q.category');
!         foreach ($this->visiblecolumns as $column) {
!             $fields = array_merge($fields, $column->get_required_fields());
!         }
!         foreach ($this->extrarows as $row) {
!             $fields = array_merge($fields, $row->get_required_fields());
!         }
!         $fields = array_unique($fields);
! 
!     /// Build the order by clause.
!         $sorts = array();
!         foreach ($this->sort as $sort => $order) {
!             list($colname, $subsort) = $this->parse_subsort($sort);
!             $sorts[] = $this->knowncolumntypes[$colname]->sort_expression($order < 0, $subsort);
!         }
! 
!     /// Build the where clause.
!         $tests = array('parent = 0');
! 
!         if (!$showhidden) {
!             $tests[] = 'hidden = 0';
!         }
! 
!         if ($recurse) {
!             $categoryids = explode(',', question_categorylist($category->id));
!         } else {
!             $categoryids = array($category->id);
!         }
!         list($catidtest, $params) = $DB->get_in_or_equal($categoryids, SQL_PARAMS_NAMED, 'cat');
!         $tests[] = 'q.category ' . $catidtest;
!         $this->sqlparams = $params;
! 
!     /// Build the SQL.
!         $sql = ' FROM {question} q ' . implode(' ', $joins);
!         $sql .= ' WHERE ' . implode(' AND ', $tests);
!         $this->countsql = 'SELECT count(1)' . $sql;
!         $this->loadsql = 'SELECT ' . implode(', ', $fields) . $sql . ' ORDER BY ' . implode(', ', $sorts);
!         $this->sqlparams = $params;
!     }
! 
!     protected function get_question_count() {
!         global $DB;
!         return $DB->count_records_sql($this->countsql, $this->sqlparams);
!     }
! 
!     protected function load_page_questions($page, $perpage) {
!         global $DB;
!         $questions = $DB->get_recordset_sql($this->loadsql, $this->sqlparams, $page*$perpage, $perpage);
!         if (!$questions->valid()) {
!         /// No questions on this page. Reset to page 0.
!             $questions = $DB->get_recordset_sql($this->loadsql, $this->sqlparams, 0, $perpage);
!         }
!         return $questions;
!     }
! 
!     public function base_url() {
!         return $this->baseurl;
!     }
! 
!     public function edit_question_url($questionid) {
!         return $this->editquestionurl->out(true, array('id' => $questionid));
!     }
! 
!     public function move_question_url($questionid) {
!         return $this->editquestionurl->out(true, array('id' => $questionid, 'movecontext' => 1));
!     }
! 
!     public function preview_question_url($questionid) {
!         global $CFG;
!         return $CFG->wwwroot . '/question/preview.php?id=' . $questionid . '&amp;courseid=' . $this->course->id;
!     }
! 
!     /**
!      * Shows the question bank editing interface.
!      *
!      * The function also processes a number of actions:
!      *
!      * Actions affecting the question pool:
!      * move           Moves a question to a different category
!      * deleteselected Deletes the selected questions from the category
!      * Other actions:
!      * category      Chooses the category
!      * displayoptions Sets display options
!      */
!     public function display($tabname, $page, $perpage, $sortorder,
!             $sortorderdecoded, $cat, $recurse, $showhidden, $showquestiontext){
!         global $PAGE, $OUTPUT;
! 
!         if ($this->process_actions_needing_ui()) {
!             return;
!         }
! 
!         $PAGE->requires->js('/question/qbank.js');
! 
!         // Category selection form
!         echo $OUTPUT->heading(get_string('questionbank', 'question'), 2);
! 
!         $this->display_category_form($this->contexts->having_one_edit_tab_cap($tabname),
!                 $this->baseurl, $cat);
!         $this->display_options($recurse, $showhidden, $showquestiontext);
! 
!         if (!$category = $this->get_current_category($cat)) {
!             return;
!         }
!         $this->print_category_info($category);
! 
!         // continues with list of questions
!         $this->display_question_list($this->contexts->having_one_edit_tab_cap($tabname), $this->baseurl, $cat, $this->cm,
!                 $recurse, $page, $perpage, $showhidden, $sortorder, $sortorderdecoded, $showquestiontext,
!                 $this->contexts->having_cap('moodle/question:add'));
!     }
! 
!     protected function print_choose_category_message($categoryandcontext) {
!         echo "<p style=\"text-align:center;\"><b>";
!         print_string("selectcategoryabove", "quiz");
!         echo "</b></p>";
!     }
! 
!     protected function get_current_category($categoryandcontext) {
!         global $DB, $OUTPUT;
!         list($categoryid, $contextid) = explode(',', $categoryandcontext);
!         if (!$categoryid) {
!             $this->print_choose_category_message($categoryandcontext);
!             return false;
!         }
! 
!         if (!$category = $DB->get_record('question_categories',
!                 array('id' => $categoryid, 'contextid' => $contextid))) {
!             echo $OUTPUT->box_start('generalbox questionbank');
!             echo $OUTPUT->notification('Category not found!');
!             echo $OUTPUT->box_end();
!             return false;
!         }
! 
!         return $category;
!     }
! 
!     protected function print_category_info($category) {
!         $formatoptions = new stdClass;
!         $formatoptions->noclean = true;
!         $formatoptions->overflowdiv = true;
!         echo '<div class="boxaligncenter">';
!         echo format_text($category->info, FORMAT_MOODLE, $formatoptions, $this->course->id);
!         echo "</div>\n";
!     }
! 
!     /**
!      * prints a form to choose categories
!      */
!     protected function display_category_form($contexts, $pageurl, $current) {
!         global $CFG, $OUTPUT;
! 
!     /// Get all the existing categories now
!         echo '<div class="choosecategory">';
!         $catmenu = question_category_options($contexts, false, 0, true);
! 
!         $select = new single_select($this->baseurl, 'category', $catmenu, $current, null, 'catmenu');
!         $select->set_label(get_string('selectacategory', 'question'));
!         echo $OUTPUT->render($select);
!         echo "</div>\n";
!     }
! 
!     protected function display_options($recurse = 1, $showhidden = false, $showquestiontext = false) {
!         echo '<form method="get" action="edit.php" id="displayoptions">';
!         echo "<fieldset class='invisiblefieldset'>";
!         echo html_writer::input_hidden_params($this->baseurl, array('recurse', 'showhidden', 'showquestiontext'));
!         $this->display_category_form_checkbox('recurse', get_string('recurse', 'quiz'));
!         $this->display_category_form_checkbox('showhidden', get_string('showhidden', 'quiz'));
!         $this->display_category_form_checkbox('qbshowtext', get_string('showquestiontext', 'quiz'));
!         echo '<noscript><div class="centerpara"><input type="submit" value="'. get_string('go') .'" />';
!         echo '</div></noscript></fieldset></form>';
!     }
! 
!     /**
!      * Print a single option checkbox. Used by the preceeding.
!      */
!     protected function display_category_form_checkbox($name, $label) {
!         echo '<div><input type="hidden" id="' . $name . '_off" name="' . $name . '" value="0" />';
!         echo '<input type="checkbox" id="' . $name . '_on" name="' . $name . '" value="1"';
!         if (optional_param($name, false, PARAM_BOOL)) {
!             echo ' checked="checked"';
!         }
!         echo ' onchange="getElementById(\'displayoptions\').submit(); return true;" />';
!         echo '<label for="' . $name . '_on">' . $label . '</label>';
!         echo "</div>\n";
!     }
! 
!     protected function create_new_question_form($category, $canadd) {
!         global $CFG;
!         echo '<div class="createnewquestion">';
!         if ($canadd) {
!             create_new_question_button($category->id, $this->editquestionurl->params(),
!                     get_string('createnewquestion', 'question'));
!         } else {
!             print_string('nopermissionadd', 'question');
!         }
!         echo '</div>';
!     }
! 
!     /**
!     * Prints the table of questions in a category with interactions
!     *
!     * @param object $course   The course object
!     * @param int $categoryid  The id of the question category to be displayed
!     * @param int $cm      The course module record if we are in the context of a particular module, 0 otherwise
!     * @param int $recurse     This is 1 if subcategories should be included, 0 otherwise
!     * @param int $page        The number of the page to be displayed
!     * @param int $perpage     Number of questions to show per page
!     * @param boolean $showhidden   True if also hidden questions should be displayed
!     * @param boolean $showquestiontext whether the text of each question should be shown in the list
!     */
!     protected function display_question_list($contexts, $pageurl, $categoryandcontext,
!             $cm = null, $recurse=1, $page=0, $perpage=100, $showhidden=false,
!             $sortorder='typename', $sortorderdecoded='qtype, name ASC',
!             $showquestiontext = false, $addcontexts = array()) {
!         global $CFG, $DB, $OUTPUT;
! 
!         $category = $this->get_current_category($categoryandcontext);
! 
!         $cmoptions = new stdClass;
!         $cmoptions->hasattempts = !empty($this->quizhasattempts);
! 
!         $strselectall = get_string("selectall", "quiz");
!         $strselectnone = get_string("selectnone", "quiz");
!         $strdelete = get_string("delete");
! 
!         list($categoryid, $contextid) = explode(',', $categoryandcontext);
!         $catcontext = get_context_instance_by_id($contextid);
! 
!         $canadd = has_capability('moodle/question:add', $catcontext);
!         $caneditall =has_capability('moodle/question:editall', $catcontext);
!         $canuseall =has_capability('moodle/question:useall', $catcontext);
!         $canmoveall =has_capability('moodle/question:moveall', $catcontext);
! 
!         $this->create_new_question_form($category, $canadd);
! 
!         $this->build_query_sql($category, $recurse, $showhidden);
!         $totalnumber = $this->get_question_count();
!         if ($totalnumber == 0) {
!             return;
!         }
! 
!         $questions = $this->load_page_questions($page, $perpage);
! 
!         echo '<div class="categorypagingbarcontainer">';
!         $pageing_url = new moodle_url('edit.php');
!         $r = $pageing_url->params($pageurl->params());
!         $pagingbar = new paging_bar($totalnumber, $page, $perpage, $pageing_url);
!         $pagingbar->pagevar = 'qpage';
!         echo $OUTPUT->render($pagingbar);
!         echo '</div>';
! 
!         echo '<form method="post" action="edit.php">';
!         echo '<fieldset class="invisiblefieldset" style="display: block;">';
!         echo '<input type="hidden" name="sesskey" value="'.sesskey().'" />';
!         echo html_writer::input_hidden_params($pageurl);
! 
!         echo '<div class="categoryquestionscontainer">';
!         $this->start_table();
!         $rowcount = 0;
!         foreach ($questions as $question) {
!             $this->print_table_row($question, $rowcount);
!             $rowcount += 1;
!         }
!         $this->end_table();
!         echo "</div>\n";
! 
!         echo '<div class="categorypagingbarcontainer pagingbottom">';
!         echo $OUTPUT->render($pagingbar);
!         if ($totalnumber > DEFAULT_QUESTIONS_PER_PAGE) {
!             if ($perpage == DEFAULT_QUESTIONS_PER_PAGE) {
!                 $url = new moodle_url('edit.php', ($pageurl->params()+array('qperpage'=>1000)));
!                 $showall = '<a href="'.$url.'">'.get_string('showall', 'moodle', $totalnumber).'</a>';
!             } else {
!                 $url = new moodle_url('edit.php', ($pageurl->params()+array('qperpage'=>DEFAULT_QUESTIONS_PER_PAGE)));
!                 $showall = '<a href="'.$url.'">'.get_string('showperpage', 'moodle', DEFAULT_QUESTIONS_PER_PAGE).'</a>';
!             }
!             echo "<div class='paging'>$showall</div>";
!         }
!         echo '</div>';
! 
!         echo '<div class="modulespecificbuttonscontainer">';
!         if ($caneditall || $canmoveall || $canuseall){
!             echo '<strong>&nbsp;'.get_string('withselected', 'quiz').':</strong><br />';
! 
!             if (function_exists('module_specific_buttons')) {
!                 echo module_specific_buttons($this->cm->id,$cmoptions);
!             }
! 
!             // print delete and move selected question
!             if ($caneditall) {
!                 echo '<input type="submit" name="deleteselected" value="' . $strdelete . "\" />\n";
!             }
! 
!             if ($canmoveall && count($addcontexts)) {
!                 echo '<input type="submit" name="move" value="'.get_string('moveto', 'quiz')."\" />\n";
!                 question_category_select_menu($addcontexts, false, 0, "$category->id,$category->contextid");
!             }
! 
!             if (function_exists('module_specific_controls') && $canuseall) {
!                 $modulespecific = module_specific_controls($totalnumber, $recurse, $category, $this->cm->id,$cmoptions);
!                 if(!empty($modulespecific)){
!                     echo "<hr />$modulespecific";
!                 }
!             }
!         }
!         echo "</div>\n";
! 
!         echo '</fieldset>';
!         echo "</form>\n";
!     }
! 
!     protected function start_table() {
!         echo '<table id="categoryquestions">' . "\n";
!         echo "<thead>\n";
!         $this->print_table_headers();
!         echo "</thead>\n";
!         echo "<tbody>\n";
!     }
! 
!     protected function end_table() {
!         echo "</tbody>\n";
!         echo "</table>\n";
!     }
! 
!     protected function print_table_headers() {
!         echo "<tr>\n";
!         foreach ($this->visiblecolumns as $column) {
!             $column->display_header();
!         }
!         echo "</tr>\n";
!     }
! 
!     protected function get_row_classes($question, $rowcount) {
!         $classes = array();
!         if ($question->hidden) {
!             $classes[] = 'dimmed_text';
!         }
!         if ($question->id == $this->lastchangedid) {
!             $classes[] ='highlight';
!         }
!         if (!empty($this->extrarows)) {
!             $classes[] = 'r' . ($rowcount % 2);
!         }
!         return $classes;
!     }
! 
!     protected function print_table_row($question, $rowcount) {
!         $rowclasses = implode(' ', $this->get_row_classes($question, $rowcount));
!         if ($rowclasses) {
!             echo '<tr class="' . $rowclasses . '">' . "\n";
!         } else {
!             echo "<tr>\n";
!         }
!         foreach ($this->visiblecolumns as $column) {
!             $column->display($question, $rowclasses);
!         }
!         echo "</tr>\n";
!         foreach ($this->extrarows as $row) {
!             $row->display($question, $rowclasses);
!         }
!     }
! 
!     public function process_actions() {
!         global $CFG, $DB;
!         /// Now, check for commands on this page and modify variables as necessary
!         if (optional_param('move', false, PARAM_BOOL) and confirm_sesskey()) {
!             // Move selected questions to new category
!             $category = required_param('category', PARAM_SEQUENCE);
!             list($tocategoryid, $contextid) = explode(',', $category);
!             if (! $tocategory = $DB->get_record('question_categories', array('id' => $tocategoryid, 'contextid' => $contextid))) {
!                 print_error('cannotfindcate', 'question');
!             }
!             $tocontext = get_context_instance_by_id($contextid);
!             require_capability('moodle/question:add', $tocontext);
!             $rawdata = (array) data_submitted();
!             $questionids = array();
!             foreach ($rawdata as $key => $value) {    // Parse input for question ids
!                 if (preg_match('!^q([0-9]+)$!', $key, $matches)) {
!                     $key = $matches[1];
!                     $questionids[] = $key;
!                 }
!             }
!             if ($questionids) {
!                 list($usql, $params) = $DB->get_in_or_equal($questionids);
!                 $sql = "";
!                 $questions = $DB->get_records_sql("
                          SELECT q.*, c.contextid
                          FROM {question} q
                          JOIN {question_categories} c ON c.id = q.category
                          WHERE q.id $usql", $params);
!                 foreach ($questions as $question){
!                     question_require_capability_on($question, 'move');
!                 }
!                 question_move_questions_to_category($questionids, $tocategory->id);
!                 redirect($this->baseurl->out(false,
!                         array('category' => "$tocategoryid,$contextid")));
!             }
!         }
! 
!         if (optional_param('deleteselected', false, PARAM_BOOL)) { // delete selected questions from the category
!             if (($confirm = optional_param('confirm', '', PARAM_ALPHANUM)) and confirm_sesskey()) { // teacher has already confirmed the action
!                 $deleteselected = required_param('deleteselected', PARAM_RAW);
!                 if ($confirm == md5($deleteselected)) {
!                     if ($questionlist = explode(',', $deleteselected)) {
!                         // for each question either hide it if it is in use or delete it
!                         foreach ($questionlist as $questionid) {
!                             $questionid = (int)$questionid;
!                             question_require_capability_on($questionid, 'edit');
!                             if ($DB->record_exists('quiz_question_instances', array('question' => $questionid))) {
!                                 $DB->set_field('question', 'hidden', 1, array('id' => $questionid));
!                             } else {
!                                 delete_question($questionid);
!                             }
!                         }
!                     }
!                     redirect($this->baseurl);
!                 } else {
!                     print_error('invalidconfirm', 'question');
!                 }
!             }
!         }
! 
!         // Unhide a question
!         if(($unhide = optional_param('unhide', '', PARAM_INT)) and confirm_sesskey()) {
!             question_require_capability_on($unhide, 'edit');
!             $DB->set_field('question', 'hidden', 0, array('id' => $unhide));
!             redirect($this->baseurl);
!         }
!     }
! 
!     public function process_actions_needing_ui() {
!         global $DB, $OUTPUT;
!         if (optional_param('deleteselected', false, PARAM_BOOL)) {
!             // make a list of all the questions that are selected
!             $rawquestions = $_REQUEST; // This code is called by both POST forms and GET links, so cannot use data_submitted.
!             $questionlist = '';  // comma separated list of ids of questions to be deleted
!             $questionnames = ''; // string with names of questions separated by <br /> with
!                                  // an asterix in front of those that are in use
!             $inuse = false;      // set to true if at least one of the questions is in use
!             foreach ($rawquestions as $key => $value) {    // Parse input for question ids
!                 if (preg_match('!^q([0-9]+)$!', $key, $matches)) {
!                     $key = $matches[1];
!                     $questionlist .= $key.',';
!                     question_require_capability_on($key, 'edit');
!                     if ($DB->record_exists('quiz_question_instances', array('question' => $key))) {
!                         $questionnames .= '* ';
!                         $inuse = true;
!                     }
!                     $questionnames .= $DB->get_field('question', 'name', array('id' => $key)) . '<br />';
!                 }
!             }
!             if (!$questionlist) { // no questions were selected
!                 redirect($this->baseurl);
!             }
!             $questionlist = rtrim($questionlist, ',');
! 
!             // Add an explanation about questions in use
!             if ($inuse) {
!                 $questionnames .= '<br />'.get_string('questionsinuse', 'quiz');
!             }
!             $baseurl = new moodle_url('edit.php', $this->baseurl->params());
!             $deleteurl = new moodle_url($baseurl, array('deleteselected'=>$questionlist, 'confirm'=>md5($questionlist), 'sesskey'=>sesskey()));
! 
!             echo $OUTPUT->confirm(get_string("deletequestionscheck", "quiz", $questionnames), $deleteurl, $baseurl);
! 
!             return true;
!         }
!     }
  }
  
  /**
--- 768,1493 ----
   *  + outputting table headers.
   */
  class question_bank_view {
! 	const MAX_SORTS = 3;
  
! 	protected $baseurl;
! 	protected $editquestionurl;
! 	protected $quizorcourseid;
! 	protected $contexts;
! 	protected $cm;
! 	protected $course;
! 	protected $knowncolumntypes;
! 	protected $visiblecolumns;
! 	protected $extrarows;
! 	protected $requiredcolumns;
! 	protected $sort;
! 	protected $lastchangedid;
! 	protected $countsql;
! 	protected $loadsql;
! 	protected $sqlparams;
! 
! 	public function __construct($contexts, $pageurl, $course, $cm = null) {
! 		global $CFG, $PAGE;
! 
! 		$this->contexts = $contexts;
! 		$this->baseurl = $pageurl;
! 		$this->course = $course;
! 		$this->cm = $cm;
! 
! 		if (!empty($cm) && $cm->modname == 'quiz') {
! 			$this->quizorcourseid = '&amp;quizid=' . $cm->instance;
! 		} else {
! 			$this->quizorcourseid = '&amp;courseid=' .$this->course->id;
! 		}
! 
! 		// Create the url of the new question page to forward to.
! 		$returnurl = str_replace($CFG->wwwroot, '', $pageurl->out(false));
! 		$this->editquestionurl = new moodle_url('/question/question.php',
! 		array('returnurl' => $returnurl));
! 		if ($cm !== null){
! 			$this->editquestionurl->param('cmid', $cm->id);
! 		} else {
! 			$this->editquestionurl->param('courseid', $this->course->id);
! 		}
! 
! 		$this->lastchangedid = optional_param('lastchanged',0,PARAM_INT);
! 
! 		$this->init_column_types();
! 		$this->init_columns($this->wanted_columns());
! 		$this->init_sort();
  
! 		$PAGE->requires->yui2_lib('container');
! 	}
  
! 	protected function wanted_columns() {
! 		$columns = array('checkbox', 'qtype', 'questionname', 'editaction',
                  'previewaction', 'moveaction', 'deleteaction', 'creatorname',
                  'modifiername');
! 		if (optional_param('qbshowtext', false, PARAM_BOOL)) {
! 			$columns[] = 'questiontext';
! 		}
! 		return $columns;
! 	}
! 
! 	protected function known_field_types() {
! 		return array(
! 		new question_bank_checkbox_column($this),
! 		new question_bank_question_type_column($this),
! 		new question_bank_question_name_column($this),
! 		new question_bank_creator_name_column($this),
! 		new question_bank_modifier_name_column($this),
! 		new question_bank_edit_action_column($this),
! 		new question_bank_preview_action_column($this),
! 		new question_bank_move_action_column($this),
! 		new question_bank_delete_action_column($this),
! 		new question_bank_question_text_row($this),
! 		);
! 	}
! 
! 	protected function init_column_types() {
! 		$this->knowncolumntypes = array();
! 		foreach ($this->known_field_types() as $col) {
! 			$this->knowncolumntypes[$col->get_name()] = $col;
! 		}
! 	}
! 
! 	protected function init_columns($wanted) {
! 		$this->visiblecolumns = array();
! 		$this->extrarows = array();
! 		foreach ($wanted as $colname) {
! 			if (!isset($this->knowncolumntypes[$colname])) {
! 				throw new coding_exception('Unknown column type ' . $colname . ' requested in init columns.');
! 			}
! 			$column = $this->knowncolumntypes[$colname];
! 			if ($column->is_extra_row()) {
! 				$this->extrarows[$colname] = $column;
! 			} else {
! 				$this->visiblecolumns[$colname] = $column;
! 			}
! 		}
! 		$this->requiredcolumns = array_merge($this->visiblecolumns, $this->extrarows);
! 	}
! 
! 	/**
! 	 * @param string $colname a column internal name.
! 	 * @return boolean is this column included in the output?
! 	 */
! 	public function has_column($colname) {
! 		return isset($this->visiblecolumns[$colname]);
! 	}
! 
! 	/**
! 	 * @return integer The number of columns in the table.
! 	 */
! 	public function get_column_count() {
! 		return count($this->visiblecolumns);
! 	}
! 
! 	public function get_courseid() {
! 		return $this->course->id;
! 	}
! 
! 	protected function init_sort() {
! 		$this->init_sort_from_params();
! 		if (empty($this->sort)) {
! 			$this->sort = $this->default_sort();
! 		}
! 	}
! 
! 	/**
! 	 * Deal with a sort name of the forum columnname, or colname_subsort by
! 	 * breaking it up, validating the bits that are presend, and returning them.
! 	 * If there is no subsort, then $subsort is returned as ''.
! 	 * @return array array($colname, $subsort).
! 	 */
! 	protected function parse_subsort($sort) {
! 		/// Do the parsing.
! 		if (strpos($sort, '_') !== false) {
! 			list($colname, $subsort) = explode('_', $sort, 2);
! 		} else {
! 			$colname = $sort;
! 			$subsort = '';
! 		}
! 		/// Validate the column name.
! 		if (!isset($this->knowncolumntypes[$colname]) || !$this->knowncolumntypes[$colname]->is_sortable()) {
! 			for ($i = 1; $i <= question_bank_view::MAX_SORTS; $i++) {
! 				$this->baseurl->remove_params('qbs' . $i);
! 			}
! 			throw new moodle_exception('unknownsortcolumn', '', $link = $this->baseurl->out(), $colname);
! 		}
! 		/// Validate the subsort, if present.
! 		if ($subsort) {
! 			$subsorts = $this->knowncolumntypes[$colname]->is_sortable();
! 			if (!is_array($subsorts) || !isset($subsorts[$subsort])) {
! 				throw new moodle_exception('unknownsortcolumn', '', $link = $this->baseurl->out(), $sort);
! 			}
! 		}
! 		return array($colname, $subsort);
! 	}
! 
! 	protected function init_sort_from_params() {
! 		$this->sort = array();
! 		for ($i = 1; $i <= question_bank_view::MAX_SORTS; $i++) {
! 			if (!$sort = optional_param('qbs' . $i, '', PARAM_ALPHAEXT)) {
! 				break;
! 			}
! 			// Work out the appropriate order.
! 			$order = 1;
! 			if ($sort[0] == '-') {
! 				$order = -1;
! 				$sort = substr($sort, 1);
! 				if (!$sort) {
! 					break;
! 				}
! 			}
! 			// Deal with subsorts.
! 			list($colname, $subsort) = $this->parse_subsort($sort);
! 			$this->requiredcolumns[$colname] = $this->knowncolumntypes[$colname];
! 			$this->sort[$sort] = $order;
! 		}
! 	}
! 
! 	protected function sort_to_params($sorts) {
! 		$params = array();
! 		$i = 0;
! 		foreach ($sorts as $sort => $order) {
! 			$i += 1;
! 			if ($order < 0) {
! 				$sort = '-' . $sort;
! 			}
! 			$params['qbs' . $i] = $sort;
! 		}
! 		return $params;
! 	}
! 
! 	protected function default_sort() {
! 		return array('qtype' => 1, 'questionname' => 1);
! 	}
! 
! 	/**
! 	 * @param $sort a column or column_subsort name.
! 	 * @return integer the current sort order for this column -1, 0, 1
! 	 */
! 	public function get_primary_sort_order($sort) {
! 		$order = reset($this->sort);
! 		$primarysort = key($this->sort);
! 		if ($sort == $primarysort) {
! 			return $order;
! 		} else {
! 			return 0;
! 		}
! 	}
! 
! 	/**
! 	 * Get a URL to redisplay the page with a new sort for the question bank.
! 	 * @param string $sort the column, or column_subsort to sort on.
! 	 * @param boolean $newsortreverse whether to sort in reverse order.
! 	 * @return string The new URL.
! 	 */
! 	public function new_sort_url($sort, $newsortreverse) {
! 		if ($newsortreverse) {
! 			$order = -1;
! 		} else {
! 			$order = 1;
! 		}
! 		// Tricky code to add the new sort at the start, removing it from where it was before, if it was present.
! 		$newsort = array_reverse($this->sort);
! 		if (isset($newsort[$sort])) {
! 			unset($newsort[$sort]);
! 		}
! 		$newsort[$sort] = $order;
! 		$newsort = array_reverse($newsort);
! 		if (count($newsort) > question_bank_view::MAX_SORTS) {
! 			$newsort = array_slice($newsort, 0, question_bank_view::MAX_SORTS, true);
! 		}
! 		return $this->baseurl->out(true, $this->sort_to_params($newsort));
! 	}
! 
! 	protected function build_query_sql($category, $recurse, $showhidden) {
! 		global $DB;
! 
! 		/// Get the required tables.
! 		$joins = array();
! 		foreach ($this->requiredcolumns as $column) {
! 			$extrajoins = $column->get_extra_joins();
! 			foreach ($extrajoins as $prefix => $join) {
! 				if (isset($joins[$prefix]) && $joins[$prefix] != $join) {
! 					throw new coding_exception('Join ' . $join . ' conflicts with previous join ' . $joins[$prefix]);
! 				}
! 				$joins[$prefix] = $join;
! 			}
! 		}
! 
! 		/// Get the required fields.
! 		$fields = array('q.hidden', 'q.category');
! 		foreach ($this->visiblecolumns as $column) {
! 			$fields = array_merge($fields, $column->get_required_fields());
! 		}
! 		foreach ($this->extrarows as $row) {
! 			$fields = array_merge($fields, $row->get_required_fields());
! 		}
! 		$fields = array_unique($fields);
! 
! 		/// Build the order by clause.
! 		$sorts = array();
! 		foreach ($this->sort as $sort => $order) {
! 			list($colname, $subsort) = $this->parse_subsort($sort);
! 			$sorts[] = $this->knowncolumntypes[$colname]->sort_expression($order < 0, $subsort);
! 		}
! 
! 		/// Build the where clause.
! 		$tests = array('parent = 0');
! 
! 		if (!$showhidden) {
! 			$tests[] = 'hidden = 0';
! 		}
! 
! 		if ($recurse) {
! 			$categoryids = explode(',', question_categorylist($category->id));
! 		} else {
! 			$categoryids = array($category->id);
! 		}
! 		list($catidtest, $params) = $DB->get_in_or_equal($categoryids, SQL_PARAMS_NAMED, 'cat');
! 		$tests[] = 'q.category ' . $catidtest;
! 		$this->sqlparams = $params;
! 
! 		/// Build the SQL.
! 		$sql = ' FROM {question} q ' . implode(' ', $joins);
! 		$sql .= ' WHERE ' . implode(' AND ', $tests);
! 		$this->countsql = 'SELECT count(1)' . $sql;
! 		$this->loadsql = 'SELECT ' . implode(', ', $fields) . $sql . ' ORDER BY ' . implode(', ', $sorts);
! 		$this->sqlparams = $params;
! 	}
! 
! 	protected function get_question_count() {
! 		global $DB;
! 		return $DB->count_records_sql($this->countsql, $this->sqlparams);
! 	}
! 
! 	protected function load_page_questions($page, $perpage) {
! 		global $DB;
! 		$questions = $DB->get_recordset_sql($this->loadsql, $this->sqlparams, $page*$perpage, $perpage);
! 		if (!$questions->valid()) {
! 			/// No questions on this page. Reset to page 0.
! 			$questions = $DB->get_recordset_sql($this->loadsql, $this->sqlparams, 0, $perpage);
! 		}
! 		return $questions;
! 	}
! 
! 	public function base_url() {
! 		return $this->baseurl;
! 	}
! 
! 	public function edit_question_url($questionid) {
! 		return $this->editquestionurl->out(true, array('id' => $questionid));
! 	}
! 
! 	public function move_question_url($questionid) {
! 		return $this->editquestionurl->out(true, array('id' => $questionid, 'movecontext' => 1));
! 	}
! 
! 	public function preview_question_url($questionid) {
! 		global $CFG;
! 		return $CFG->wwwroot . '/question/preview.php?id=' . $questionid . '&amp;courseid=' . $this->course->id;
! 	}
! 
! 	/**
! 	 * Shows the question bank editing interface.
! 	 *
! 	 * The function also processes a number of actions:
! 	 *
! 	 * Actions affecting the question pool:
! 	 * move           Moves a question to a different category
! 	 * deleteselected Deletes the selected questions from the category
! 	 * Other actions:
! 	 * category      Chooses the category
! 	 * displayoptions Sets display options
! 	 */
! 	public function display($tabname, $page, $perpage, $sortorder,
! 	$sortorderdecoded, $cat, $recurse, $showhidden, $showquestiontext){
! 		global $PAGE, $OUTPUT;
! 
! 		if ($this->process_actions_needing_ui()) {
! 			return;
! 		}
! 
! 		$PAGE->requires->js('/question/qbank.js');
! 
! 		// Category selection form
! 		echo $OUTPUT->heading(get_string('questionbank', 'question'), 2);
! 
! 		$this->display_category_form($this->contexts->having_one_edit_tab_cap($tabname),
! 		$this->baseurl, $cat);
! 		$this->display_options($recurse, $showhidden, $showquestiontext);
! 
! 		if (!$category = $this->get_current_category($cat)) {
! 			return;
! 		}
! 		$this->print_category_info($category);
! 
! 		// continues with list of questions
! 		$this->display_question_list($this->contexts->having_one_edit_tab_cap($tabname), $this->baseurl, $cat, $this->cm,
! 		$recurse, $page, $perpage, $showhidden, $sortorder, $sortorderdecoded, $showquestiontext,
! 		$this->contexts->having_cap('moodle/question:add'));
! 	}
! 
! 	protected function print_choose_category_message($categoryandcontext) {
! 		echo "<p style=\"text-align:center;\"><b>";
! 		print_string("selectcategoryabove", "quiz");
! 		echo "</b></p>";
! 	}
! 
! 	protected function get_current_category($categoryandcontext) {
! 		global $DB, $OUTPUT;
! 		list($categoryid, $contextid) = explode(',', $categoryandcontext);
! 		if (!$categoryid) {
! 			$this->print_choose_category_message($categoryandcontext);
! 			return false;
! 		}
! 
! 		if (!$category = $DB->get_record('question_categories',
! 		array('id' => $categoryid, 'contextid' => $contextid))) {
! 			echo $OUTPUT->box_start('generalbox questionbank');
! 			echo $OUTPUT->notification('Category not found!');
! 			echo $OUTPUT->box_end();
! 			return false;
! 		}
! 
! 		return $category;
! 	}
! 
! 	protected function print_category_info($category) {
! 		$formatoptions = new stdClass;
! 		$formatoptions->noclean = true;
! 		$formatoptions->overflowdiv = true;
! 		echo '<div class="boxaligncenter">';
! 		echo format_text($category->info, FORMAT_MOODLE, $formatoptions, $this->course->id);
! 		echo "</div>\n";
! 	}
! 
! 	/**
! 	 * prints a form to choose categories
! 	 */
! 	protected function display_category_form($contexts, $pageurl, $current) {
! 		global $CFG, $OUTPUT;
! 
! 		/// Get all the existing categories now
! 		echo '<div class="choosecategory">';
! 		$catmenu = question_category_options($contexts, false, 0, true);
! 
! 		$select = new single_select($this->baseurl, 'category', $catmenu, $current, null, 'catmenu');
! 		$select->set_label(get_string('selectacategory', 'question'));
! 		echo $OUTPUT->render($select);
! 		echo "</div>\n";
! 	}
! 
! 	protected function display_options($recurse = 1, $showhidden = false, $showquestiontext = false) {
! 		echo '<form method="get" action="edit.php" id="displayoptions">';
! 		echo "<fieldset class='invisiblefieldset'>";
! 		echo html_writer::input_hidden_params($this->baseurl, array('recurse', 'showhidden', 'showquestiontext'));
! 		$this->display_category_form_checkbox('recurse', get_string('recurse', 'quiz'));
! 		$this->display_category_form_checkbox('showhidden', get_string('showhidden', 'quiz'));
! 		$this->display_category_form_checkbox('qbshowtext', get_string('showquestiontext', 'quiz'));
! 		echo '<noscript><div class="centerpara"><input type="submit" value="'. get_string('go') .'" />';
! 		echo '</div></noscript></fieldset></form>';
! 	}
! 
! 	/**
! 	 * Print a single option checkbox. Used by the preceeding.
! 	 */
! 	protected function display_category_form_checkbox($name, $label) {
! 		echo '<div><input type="hidden" id="' . $name . '_off" name="' . $name . '" value="0" />';
! 		echo '<input type="checkbox" id="' . $name . '_on" name="' . $name . '" value="1"';
! 		if (optional_param($name, false, PARAM_BOOL)) {
! 			echo ' checked="checked"';
! 		}
! 		echo ' onchange="getElementById(\'displayoptions\').submit(); return true;" />';
! 		echo '<label for="' . $name . '_on">' . $label . '</label>';
! 		echo "</div>\n";
! 	}
! 
! 	protected function create_new_question_form($category, $canadd) {
! 		global $CFG;
! 		echo '<div class="createnewquestion">';
! 		if ($canadd) {
! 			create_new_question_button($category->id, $this->editquestionurl->params(),
! 			get_string('createnewquestion', 'question'));
! 		} else {
! 			print_string('nopermissionadd', 'question');
! 		}
! 		echo '</div>';
! 	}
! 
! 	/**
! 	 * Prints the table of questions in a category with interactions
! 	 *
! 	 * @param object $course   The course object
! 	 * @param int $categoryid  The id of the question category to be displayed
! 	 * @param int $cm      The course module record if we are in the context of a particular module, 0 otherwise
! 	 * @param int $recurse     This is 1 if subcategories should be included, 0 otherwise
! 	 * @param int $page        The number of the page to be displayed
! 	 * @param int $perpage     Number of questions to show per page
! 	 * @param boolean $showhidden   True if also hidden questions should be displayed
! 	 * @param boolean $showquestiontext whether the text of each question should be shown in the list
! 	 */
! 	protected function display_question_list($contexts, $pageurl, $categoryandcontext,
! 	$cm = null, $recurse=1, $page=0, $perpage=100, $showhidden=false,
! 	$sortorder='typename', $sortorderdecoded='qtype, name ASC',
! 	$showquestiontext = false, $addcontexts = array()) {
! 		global $CFG, $DB, $OUTPUT;
! 
! 		$category = $this->get_current_category($categoryandcontext);
! 
! 		$cmoptions = new stdClass;
! 		$cmoptions->hasattempts = !empty($this->quizhasattempts);
! 
! 		$strselectall = get_string("selectall", "quiz");
! 		$strselectnone = get_string("selectnone", "quiz");
! 		$strdelete = get_string("delete");
! 
! 		list($categoryid, $contextid) = explode(',', $categoryandcontext);
! 		$catcontext = get_context_instance_by_id($contextid);
! 
! 		$canadd = has_capability('moodle/question:add', $catcontext);
! 		$caneditall =has_capability('moodle/question:editall', $catcontext);
! 		$canuseall =has_capability('moodle/question:useall', $catcontext);
! 		$canmoveall =has_capability('moodle/question:moveall', $catcontext);
! 
! 		$this->create_new_question_form($category, $canadd);
! 
! 		$this->build_query_sql($category, $recurse, $showhidden);
! 		$totalnumber = $this->get_question_count();
! 		if ($totalnumber == 0) {
! 			return;
! 		}
! 
! 		$questions = $this->load_page_questions($page, $perpage);
! 
! 		echo '<div class="categorypagingbarcontainer">';
! 		$pageing_url = new moodle_url('edit.php');
! 		$r = $pageing_url->params($pageurl->params());
! 		$pagingbar = new paging_bar($totalnumber, $page, $perpage, $pageing_url);
! 		$pagingbar->pagevar = 'qpage';
! 		echo $OUTPUT->render($pagingbar);
! 		echo '</div>';
! 
! 		echo '<form method="post" action="edit.php">';
! 		echo '<fieldset class="invisiblefieldset" style="display: block;">';
! 		echo '<input type="hidden" name="sesskey" value="'.sesskey().'" />';
! 		echo html_writer::input_hidden_params($pageurl);
! 
! 		echo '<div class="categoryquestionscontainer">';
! 		$this->start_table();
! 		$rowcount = 0;
! 		foreach ($questions as $question) {
! 			$this->print_table_row($question, $rowcount);
! 			$rowcount += 1;
! 		}
! 		$this->end_table();
! 		echo "</div>\n";
! 
! 		echo '<div class="categorypagingbarcontainer pagingbottom">';
! 		echo $OUTPUT->render($pagingbar);
! 		if ($totalnumber > DEFAULT_QUESTIONS_PER_PAGE) {
! 			if ($perpage == DEFAULT_QUESTIONS_PER_PAGE) {
! 				$url = new moodle_url('edit.php', ($pageurl->params()+array('qperpage'=>1000)));
! 				$showall = '<a href="'.$url.'">'.get_string('showall', 'moodle', $totalnumber).'</a>';
! 			} else {
! 				$url = new moodle_url('edit.php', ($pageurl->params()+array('qperpage'=>DEFAULT_QUESTIONS_PER_PAGE)));
! 				$showall = '<a href="'.$url.'">'.get_string('showperpage', 'moodle', DEFAULT_QUESTIONS_PER_PAGE).'</a>';
! 			}
! 			echo "<div class='paging'>$showall</div>";
! 		}
! 		echo '</div>';
! 
! 		echo '<div class="modulespecificbuttonscontainer">';
! 		if ($caneditall || $canmoveall || $canuseall){
! 			echo '<strong>&nbsp;'.get_string('withselected', 'quiz').':</strong><br />';
! 
! 			if (function_exists('module_specific_buttons')) {
! 				echo module_specific_buttons($this->cm->id,$cmoptions);
! 			}
! 
! 			// print delete and move selected question
! 			if ($caneditall) {
! 				echo '<input type="submit" name="deleteselected" value="' . $strdelete . "\" />\n";
! 			}
! 
! 			if ($canmoveall && count($addcontexts)) {
! 				echo '<input type="submit" name="move" value="'.get_string('moveto', 'quiz')."\" />\n";
! 				question_category_select_menu($addcontexts, false, 0, "$category->id,$category->contextid");
! 			}
! 
! 			if (function_exists('module_specific_controls') && $canuseall) {
! 				$modulespecific = module_specific_controls($totalnumber, $recurse, $category, $this->cm->id,$cmoptions);
! 				if(!empty($modulespecific)){
! 					echo "<hr />$modulespecific";
! 				}
! 			}
! 		}
! 		echo "</div>\n";
! 
! 		echo '</fieldset>';
! 		echo "</form>\n";
! 	}
! 
! 	protected function start_table() {
! 		echo '<table id="categoryquestions">' . "\n";
! 		echo "<thead>\n";
! 		$this->print_table_headers();
! 		echo "</thead>\n";
! 		echo "<tbody>\n";
! 	}
! 
! 	protected function end_table() {
! 		echo "</tbody>\n";
! 		echo "</table>\n";
! 	}
! 
! 	protected function print_table_headers() {
! 		echo "<tr>\n";
! 		foreach ($this->visiblecolumns as $column) {
! 			$column->display_header();
! 		}
! 		echo "</tr>\n";
! 	}
! 
! 	protected function get_row_classes($question, $rowcount) {
! 		$classes = array();
! 		if ($question->hidden) {
! 			$classes[] = 'dimmed_text';
! 		}
! 		if ($question->id == $this->lastchangedid) {
! 			$classes[] ='highlight';
! 		}
! 		if (!empty($this->extrarows)) {
! 			$classes[] = 'r' . ($rowcount % 2);
! 		}
! 		return $classes;
! 	}
! 
! 	protected function print_table_row($question, $rowcount) {
! 		$rowclasses = implode(' ', $this->get_row_classes($question, $rowcount));
! 		if ($rowclasses) {
! 			echo '<tr class="' . $rowclasses . '">' . "\n";
! 		} else {
! 			echo "<tr>\n";
! 		}
! 		foreach ($this->visiblecolumns as $column) {
! 			$column->display($question, $rowclasses);
! 		}
! 		echo "</tr>\n";
! 		foreach ($this->extrarows as $row) {
! 			$row->display($question, $rowclasses);
! 		}
! 	}
! 
! 	public function process_actions() {
! 		global $CFG, $DB;
! 		/// Now, check for commands on this page and modify variables as necessary
! 		if (optional_param('move', false, PARAM_BOOL) and confirm_sesskey()) {
! 			// Move selected questions to new category
! 			$category = required_param('category', PARAM_SEQUENCE);
! 			list($tocategoryid, $contextid) = explode(',', $category);
! 			if (! $tocategory = $DB->get_record('question_categories', array('id' => $tocategoryid, 'contextid' => $contextid))) {
! 				print_error('cannotfindcate', 'question');
! 			}
! 			$tocontext = get_context_instance_by_id($contextid);
! 			require_capability('moodle/question:add', $tocontext);
! 			$rawdata = (array) data_submitted();
! 			$questionids = array();
! 			foreach ($rawdata as $key => $value) {    // Parse input for question ids
! 				if (preg_match('!^q([0-9]+)$!', $key, $matches)) {
! 					$key = $matches[1];
! 					$questionids[] = $key;
! 				}
! 			}
! 			if ($questionids) {
! 				list($usql, $params) = $DB->get_in_or_equal($questionids);
! 				$sql = "";
! 				$questions = $DB->get_records_sql("
                          SELECT q.*, c.contextid
                          FROM {question} q
                          JOIN {question_categories} c ON c.id = q.category
                          WHERE q.id $usql", $params);
! 				foreach ($questions as $question){
! 					question_require_capability_on($question, 'move');
! 				}
! 				question_move_questions_to_category($questionids, $tocategory->id);
! 				redirect($this->baseurl->out(false,
! 				array('category' => "$tocategoryid,$contextid")));
! 			}
! 		}
! 
! 		if (optional_param('deleteselected', false, PARAM_BOOL)) { // delete selected questions from the category
! 			if (($confirm = optional_param('confirm', '', PARAM_ALPHANUM)) and confirm_sesskey()) { // teacher has already confirmed the action
! 				$deleteselected = required_param('deleteselected', PARAM_RAW);
! 				if ($confirm == md5($deleteselected)) {
! 					if ($questionlist = explode(',', $deleteselected)) {
! 						// for each question either hide it if it is in use or delete it
! 						foreach ($questionlist as $questionid) {
! 							$questionid = (int)$questionid;
! 							question_require_capability_on($questionid, 'edit');
! 							if ($DB->record_exists('quiz_question_instances', array('question' => $questionid))) {
! 								$DB->set_field('question', 'hidden', 1, array('id' => $questionid));
! 							} else {
! 								delete_question($questionid);
! 							}
! 						}
! 					}
! 					redirect($this->baseurl);
! 				} else {
! 					print_error('invalidconfirm', 'question');
! 				}
! 			}
! 		}
! 
! 		// Unhide a question
! 		if(($unhide = optional_param('unhide', '', PARAM_INT)) and confirm_sesskey()) {
! 			question_require_capability_on($unhide, 'edit');
! 			$DB->set_field('question', 'hidden', 0, array('id' => $unhide));
! 			redirect($this->baseurl);
! 		}
! 	}
! 
! 	public function process_actions_needing_ui() {
! 		global $DB, $OUTPUT;
! 		if (optional_param('deleteselected', false, PARAM_BOOL)) {
! 			// make a list of all the questions that are selected
! 			$rawquestions = $_REQUEST; // This code is called by both POST forms and GET links, so cannot use data_submitted.
! 			$questionlist = '';  // comma separated list of ids of questions to be deleted
! 			$questionnames = ''; // string with names of questions separated by <br /> with
! 			// an asterix in front of those that are in use
! 			$inuse = false;      // set to true if at least one of the questions is in use
! 			foreach ($rawquestions as $key => $value) {    // Parse input for question ids
! 				if (preg_match('!^q([0-9]+)$!', $key, $matches)) {
! 					$key = $matches[1];
! 					$questionlist .= $key.',';
! 					question_require_capability_on($key, 'edit');
! 					if ($DB->record_exists('quiz_question_instances', array('question' => $key))) {
! 						$questionnames .= '* ';
! 						$inuse = true;
! 					}
! 					$questionnames .= $DB->get_field('question', 'name', array('id' => $key)) . '<br />';
! 				}
! 			}
! 			if (!$questionlist) { // no questions were selected
! 				redirect($this->baseurl);
! 			}
! 			$questionlist = rtrim($questionlist, ',');
! 
! 			// Add an explanation about questions in use
! 			if ($inuse) {
! 				$questionnames .= '<br />'.get_string('questionsinuse', 'quiz');
! 			}
! 			$baseurl = new moodle_url('edit.php', $this->baseurl->params());
! 			$deleteurl = new moodle_url($baseurl, array('deleteselected'=>$questionlist, 'confirm'=>md5($questionlist), 'sesskey'=>sesskey()));
! 
! 			echo $OUTPUT->confirm(get_string("deletequestionscheck", "quiz", $questionnames), $deleteurl, $baseurl);
! 
! 			return true;
! 		}
! 	}
  }
  
  /**
***************
*** 1499,1640 ****
   * @return array $thispageurl, $contexts, $cmid, $cm, $module, $pagevars
   */
  function question_edit_setup($edittab, $baseurl, $requirecmid = false, $requirecourseid = true) {
!     global $DB, $PAGE;
  
!     //$thispageurl is used to construct urls for all question edit pages we link to from this page. It contains an array
!     //of parameters that are passed from page to page.
! //    $thispageurl = new moodle_url($PAGE->url); //TODO: this looks dumb, because this method is called BEFORE $PAGE->set_page() !!!!
!     $thispageurl = new moodle_url($baseurl);
!     $thispageurl->remove_all_params(); // We are going to explicity add back everything important - this avoids unwanted params from being retained.
! 
!     if ($requirecmid){
!         $cmid =required_param('cmid', PARAM_INT);
!     } else {
!         $cmid = optional_param('cmid', 0, PARAM_INT);
!     }
!     if ($cmid){
!         list($module, $cm) = get_module_from_cmid($cmid);
!         $courseid = $cm->course;
!         $thispageurl->params(compact('cmid'));
!         require_login($courseid, false, $cm);
!         $thiscontext = get_context_instance(CONTEXT_MODULE, $cmid);
!     } else {
!         $module = null;
!         $cm = null;
!         if ($requirecourseid){
!             $courseid  = required_param('courseid', PARAM_INT);
!         } else {
!             $courseid  = optional_param('courseid', 0, PARAM_INT);
!         }
!         if ($courseid){
!             $thispageurl->params(compact('courseid'));
!             require_login($courseid, false);
!             $thiscontext = get_context_instance(CONTEXT_COURSE, $courseid);
!         } else {
!             $thiscontext = null;
!         }
!     }
!     if (strpos($baseurl, '/question/') === 0) {
!         navigation_node::override_active_url($thispageurl);
!     }
! 
!     if ($thiscontext){
!         $contexts = new question_edit_contexts($thiscontext);
!         $contexts->require_one_edit_tab_cap($edittab);
! 
!     } else {
!         $contexts = null;
!     }
! 
! 
! 
!     $pagevars['qpage'] = optional_param('qpage', -1, PARAM_INT);
! 
!     //pass 'cat' from page to page and when 'category' comes from a drop down menu
!     //then we also reset the qpage so we go to page 1 of
!     //a new cat.
!     $pagevars['cat'] = optional_param('cat', 0, PARAM_SEQUENCE);// if empty will be set up later
!     if  ($category = optional_param('category', 0, PARAM_SEQUENCE)){
!         if ($pagevars['cat'] != $category){ // is this a move to a new category?
!             $pagevars['cat'] = $category;
!             $pagevars['qpage'] = 0;
!         }
!     }
!     if ($pagevars['cat']){
!         $thispageurl->param('cat', $pagevars['cat']);
!     }
!     if ($pagevars['qpage'] > -1) {
!         $thispageurl->param('qpage', $pagevars['qpage']);
!     } else {
!         $pagevars['qpage'] = 0;
!     }
! 
!     $pagevars['qperpage'] = optional_param('qperpage', -1, PARAM_INT);
!     if ($pagevars['qperpage'] > -1) {
!         $thispageurl->param('qperpage', $pagevars['qperpage']);
!     } else {
!         $pagevars['qperpage'] = DEFAULT_QUESTIONS_PER_PAGE;
!     }
  
!     $sortoptions = array('alpha' => 'name, qtype ASC',
                            'typealpha' => 'qtype, name ASC',
                            'age' => 'id ASC');
  
!     if ($sortorder = optional_param('qsortorder', '', PARAM_ALPHA)) {
!         $pagevars['qsortorderdecoded'] = $sortoptions[$sortorder];
!         $pagevars['qsortorder'] = $sortorder;
!         $thispageurl->param('qsortorder', $sortorder);
!     } else {
!         $pagevars['qsortorderdecoded'] = $sortoptions['typealpha'];
!         $pagevars['qsortorder'] = 'typealpha';
!     }
! 
!     $defaultcategory = question_make_default_categories($contexts->all());
! 
!     $contextlistarr = array();
!     foreach ($contexts->having_one_edit_tab_cap($edittab) as $context){
!         $contextlistarr[] = "'$context->id'";
!     }
!     $contextlist = join($contextlistarr, ' ,');
!     if (!empty($pagevars['cat'])){
!         $catparts = explode(',', $pagevars['cat']);
!         if (!$catparts[0] || (FALSE !== array_search($catparts[1], $contextlistarr)) ||
!                 !$DB->count_records_select("question_categories", "id = ? AND contextid = ?", array($catparts[0], $catparts[1]))) {
!             print_error('invalidcategory', 'quiz');
!         }
!     } else {
!         $category = $defaultcategory;
!         $pagevars['cat'] = "$category->id,$category->contextid";
!     }
! 
!     if(($recurse = optional_param('recurse', -1, PARAM_BOOL)) != -1) {
!         $pagevars['recurse'] = $recurse;
!         $thispageurl->param('recurse', $recurse);
!     } else {
!         $pagevars['recurse'] = 1;
!     }
! 
!     if(($showhidden = optional_param('showhidden', -1, PARAM_BOOL)) != -1) {
!         $pagevars['showhidden'] = $showhidden;
!         $thispageurl->param('showhidden', $showhidden);
!     } else {
!         $pagevars['showhidden'] = 0;
!     }
! 
!     if(($showquestiontext = optional_param('showquestiontext', -1, PARAM_BOOL)) != -1) {
!         $pagevars['showquestiontext'] = $showquestiontext;
!         $thispageurl->param('showquestiontext', $showquestiontext);
!     } else {
!         $pagevars['showquestiontext'] = 0;
!     }
! 
!     //category list page
!     $pagevars['cpage'] = optional_param('cpage', 1, PARAM_INT);
!     if ($pagevars['cpage'] != 1){
!         $thispageurl->param('cpage', $pagevars['cpage']);
!     }
  
!     return array($thispageurl, $contexts, $cmid, $cm, $module, $pagevars);
  }
  
  /**
--- 1499,1640 ----
   * @return array $thispageurl, $contexts, $cmid, $cm, $module, $pagevars
   */
  function question_edit_setup($edittab, $baseurl, $requirecmid = false, $requirecourseid = true) {
! 	global $DB, $PAGE;
  
! 	//$thispageurl is used to construct urls for all question edit pages we link to from this page. It contains an array
! 	//of parameters that are passed from page to page.
! 	//    $thispageurl = new moodle_url($PAGE->url); //TODO: this looks dumb, because this method is called BEFORE $PAGE->set_page() !!!!
! 	$thispageurl = new moodle_url($baseurl);
! 	$thispageurl->remove_all_params(); // We are going to explicity add back everything important - this avoids unwanted params from being retained.
! 
! 	if ($requirecmid){
! 		$cmid =required_param('cmid', PARAM_INT);
! 	} else {
! 		$cmid = optional_param('cmid', 0, PARAM_INT);
! 	}
! 	if ($cmid){
! 		list($module, $cm) = get_module_from_cmid($cmid);
! 		$courseid = $cm->course;
! 		$thispageurl->params(compact('cmid'));
! 		require_login($courseid, false, $cm);
! 		$thiscontext = get_context_instance(CONTEXT_MODULE, $cmid);
! 	} else {
! 		$module = null;
! 		$cm = null;
! 		if ($requirecourseid){
! 			$courseid  = required_param('courseid', PARAM_INT);
! 		} else {
! 			$courseid  = optional_param('courseid', 0, PARAM_INT);
! 		}
! 		if ($courseid){
! 			$thispageurl->params(compact('courseid'));
! 			require_login($courseid, false);
! 			$thiscontext = get_context_instance(CONTEXT_COURSE, $courseid);
! 		} else {
! 			$thiscontext = null;
! 		}
! 	}
! 	if (strpos($baseurl, '/question/') === 0) {
! 		navigation_node::override_active_url($thispageurl);
! 	}
! 
! 	if ($thiscontext){
! 		$contexts = new question_edit_contexts($thiscontext);
! 		$contexts->require_one_edit_tab_cap($edittab);
! 
! 	} else {
! 		$contexts = null;
! 	}
! 
! 
! 
! 	$pagevars['qpage'] = optional_param('qpage', -1, PARAM_INT);
! 
! 	//pass 'cat' from page to page and when 'category' comes from a drop down menu
! 	//then we also reset the qpage so we go to page 1 of
! 	//a new cat.
! 	$pagevars['cat'] = optional_param('cat', 0, PARAM_SEQUENCE);// if empty will be set up later
! 	if  ($category = optional_param('category', 0, PARAM_SEQUENCE)){
! 		if ($pagevars['cat'] != $category){ // is this a move to a new category?
! 			$pagevars['cat'] = $category;
! 			$pagevars['qpage'] = 0;
! 		}
! 	}
! 	if ($pagevars['cat']){
! 		$thispageurl->param('cat', $pagevars['cat']);
! 	}
! 	if ($pagevars['qpage'] > -1) {
! 		$thispageurl->param('qpage', $pagevars['qpage']);
! 	} else {
! 		$pagevars['qpage'] = 0;
! 	}
! 
! 	$pagevars['qperpage'] = optional_param('qperpage', -1, PARAM_INT);
! 	if ($pagevars['qperpage'] > -1) {
! 		$thispageurl->param('qperpage', $pagevars['qperpage']);
! 	} else {
! 		$pagevars['qperpage'] = DEFAULT_QUESTIONS_PER_PAGE;
! 	}
  
! 	$sortoptions = array('alpha' => 'name, qtype ASC',
                            'typealpha' => 'qtype, name ASC',
                            'age' => 'id ASC');
  
! 	if ($sortorder = optional_param('qsortorder', '', PARAM_ALPHA)) {
! 		$pagevars['qsortorderdecoded'] = $sortoptions[$sortorder];
! 		$pagevars['qsortorder'] = $sortorder;
! 		$thispageurl->param('qsortorder', $sortorder);
! 	} else {
! 		$pagevars['qsortorderdecoded'] = $sortoptions['typealpha'];
! 		$pagevars['qsortorder'] = 'typealpha';
! 	}
! 
! 	$defaultcategory = question_make_default_categories($contexts->all());
! 
! 	$contextlistarr = array();
! 	foreach ($contexts->having_one_edit_tab_cap($edittab) as $context){
! 		$contextlistarr[] = "'$context->id'";
! 	}
! 	$contextlist = join($contextlistarr, ' ,');
! 	if (!empty($pagevars['cat'])){
! 		$catparts = explode(',', $pagevars['cat']);
! 		if (!$catparts[0] || (FALSE !== array_search($catparts[1], $contextlistarr)) ||
! 		!$DB->count_records_select("question_categories", "id = ? AND contextid = ?", array($catparts[0], $catparts[1]))) {
! 			print_error('invalidcategory', 'quiz');
! 		}
! 	} else {
! 		$category = $defaultcategory;
! 		$pagevars['cat'] = "$category->id,$category->contextid";
! 	}
! 
! 	if(($recurse = optional_param('recurse', -1, PARAM_BOOL)) != -1) {
! 		$pagevars['recurse'] = $recurse;
! 		$thispageurl->param('recurse', $recurse);
! 	} else {
! 		$pagevars['recurse'] = 1;
! 	}
! 
! 	if(($showhidden = optional_param('showhidden', -1, PARAM_BOOL)) != -1) {
! 		$pagevars['showhidden'] = $showhidden;
! 		$thispageurl->param('showhidden', $showhidden);
! 	} else {
! 		$pagevars['showhidden'] = 0;
! 	}
! 
! 	if(($showquestiontext = optional_param('showquestiontext', -1, PARAM_BOOL)) != -1) {
! 		$pagevars['showquestiontext'] = $showquestiontext;
! 		$thispageurl->param('showquestiontext', $showquestiontext);
! 	} else {
! 		$pagevars['showquestiontext'] = 0;
! 	}
! 
! 	//category list page
! 	$pagevars['cpage'] = optional_param('cpage', 1, PARAM_INT);
! 	if ($pagevars['cpage'] != 1){
! 		$thispageurl->param('cpage', $pagevars['cpage']);
! 	}
  
! 	return array($thispageurl, $contexts, $cmid, $cm, $module, $pagevars);
  }
  
  /**
***************
*** 1647,1678 ****
   * Make sure user is logged in as required in this context.
   */
  function require_login_in_context($contextorid = null){
!     global $DB, $CFG;
!     if (!is_object($contextorid)){
!         $context = get_context_instance_by_id($contextorid);
!     } else {
!         $context = $contextorid;
!     }
!     if ($context && ($context->contextlevel == CONTEXT_COURSE)) {
!         require_login($context->instanceid);
!     } else if ($context && ($context->contextlevel == CONTEXT_MODULE)) {
!         if ($cm = $DB->get_record('course_modules',array('id' =>$context->instanceid))) {
!             if (!$course = $DB->get_record('course', array('id' => $cm->course))) {
!                 print_error('invalidcourseid');
!             }
!             require_course_login($course, true, $cm);
! 
!         } else {
!             print_error('invalidcoursemodule');
!         }
!     } else if ($context && ($context->contextlevel == CONTEXT_SYSTEM)) {
!         if (!empty($CFG->forcelogin)) {
!             require_login();
!         }
! 
!     } else {
!         require_login();
!     }
  }
  
  /**
--- 1647,1678 ----
   * Make sure user is logged in as required in this context.
   */
  function require_login_in_context($contextorid = null){
! 	global $DB, $CFG;
! 	if (!is_object($contextorid)){
! 		$context = get_context_instance_by_id($contextorid);
! 	} else {
! 		$context = $contextorid;
! 	}
! 	if ($context && ($context->contextlevel == CONTEXT_COURSE)) {
! 		require_login($context->instanceid);
! 	} else if ($context && ($context->contextlevel == CONTEXT_MODULE)) {
! 		if ($cm = $DB->get_record('course_modules',array('id' =>$context->instanceid))) {
! 			if (!$course = $DB->get_record('course', array('id' => $cm->course))) {
! 				print_error('invalidcourseid');
! 			}
! 			require_course_login($course, true, $cm);
! 
! 		} else {
! 			print_error('invalidcoursemodule');
! 		}
! 	} else if ($context && ($context->contextlevel == CONTEXT_SYSTEM)) {
! 		if (!empty($CFG->forcelogin)) {
! 			require_login();
! 		}
! 
! 	} else {
! 		require_login();
! 	}
  }
  
  /**
***************
*** 1682,1723 ****
   * the qtype radio buttons.
   */
  function print_choose_qtype_to_add_form($hiddenparams) {
!     global $CFG, $QTYPES, $PAGE, $OUTPUT;
!     $PAGE->requires->js('/question/qbank.js');
!     echo '<div id="chooseqtypehead" class="hd">' . "\n";
!     echo $OUTPUT->heading(get_string('chooseqtypetoadd', 'question'), 3);
!     echo "</div>\n";
!     echo '<div id="chooseqtype">' . "\n";
!     echo '<form action="' . $CFG->wwwroot . '/question/question.php" method="get"><div id="qtypeformdiv">' . "\n";
!     foreach ($hiddenparams as $name => $value) {
!         echo '<input type="hidden" name="' . s($name) . '" value="' . s($value) . '" />' . "\n";
!     }
!     echo "</div>\n";
!     echo '<div class="qtypes">' . "\n";
!     echo '<div class="instruction">' . get_string('selectaqtypefordescription', 'question') . "</div>\n";
!     echo '<div class="realqtypes">' . "\n";
!     $types = question_type_menu();
!     $fakeqtypes = array();
!     foreach ($types as $qtype => $localizedname) {
!         if ($QTYPES[$qtype]->is_real_question_type()) {
!             print_qtype_to_add_option($qtype, $localizedname);
!         } else {
!             $fakeqtypes[$qtype] = $localizedname;
!         }
!     }
!     echo "</div>\n";
!     echo '<div class="fakeqtypes">' . "\n";
!     foreach ($fakeqtypes as $qtype => $localizedname) {
!         print_qtype_to_add_option($qtype, $localizedname);
!     }
!     echo "</div>\n";
!     echo "</div>\n";
!     echo '<div class="submitbuttons">' . "\n";
!     echo '<input type="submit" value="' . get_string('next') . '" id="chooseqtype_submit" />' . "\n";
!     echo '<input type="submit" id="chooseqtypecancel" name="addcancel" value="' . get_string('cancel') . '" />' . "\n";
!     echo "</div></form>\n";
!     echo "</div>\n";
!     $PAGE->requires->js_function_call('qtype_chooser.init', array('chooseqtype'));
  }
  
  /**
--- 1682,1723 ----
   * the qtype radio buttons.
   */
  function print_choose_qtype_to_add_form($hiddenparams) {
! 	global $CFG, $QTYPES, $PAGE, $OUTPUT;
! 	$PAGE->requires->js('/question/qbank.js');
! 	echo '<div id="chooseqtypehead" class="hd">' . "\n";
! 	echo $OUTPUT->heading(get_string('chooseqtypetoadd', 'question'), 3);
! 	echo "</div>\n";
! 	echo '<div id="chooseqtype">' . "\n";
! 	echo '<form action="' . $CFG->wwwroot . '/question/question.php" method="get"><div id="qtypeformdiv">' . "\n";
! 	foreach ($hiddenparams as $name => $value) {
! 		echo '<input type="hidden" name="' . s($name) . '" value="' . s($value) . '" />' . "\n";
! 	}
! 	echo "</div>\n";
! 	echo '<div class="qtypes">' . "\n";
! 	echo '<div class="instruction">' . get_string('selectaqtypefordescription', 'question') . "</div>\n";
! 	echo '<div class="realqtypes">' . "\n";
! 	$types = question_type_menu();
! 	$fakeqtypes = array();
! 	foreach ($types as $qtype => $localizedname) {
! 		if ($QTYPES[$qtype]->is_real_question_type()) {
! 			print_qtype_to_add_option($qtype, $localizedname);
! 		} else {
! 			$fakeqtypes[$qtype] = $localizedname;
! 		}
! 	}
! 	echo "</div>\n";
! 	echo '<div class="fakeqtypes">' . "\n";
! 	foreach ($fakeqtypes as $qtype => $localizedname) {
! 		print_qtype_to_add_option($qtype, $localizedname);
! 	}
! 	echo "</div>\n";
! 	echo "</div>\n";
! 	echo '<div class="submitbuttons">' . "\n";
! 	echo '<input type="submit" value="' . get_string('next') . '" id="chooseqtype_submit" />' . "\n";
! 	echo '<input type="submit" id="chooseqtypecancel" name="addcancel" value="' . get_string('cancel') . '" />' . "\n";
! 	echo "</div></form>\n";
! 	echo "</div>\n";
! 	$PAGE->requires->js_function_call('qtype_chooser.init', array('chooseqtype'));
  }
  
  /**
***************
*** 1726,1742 ****
   * @param $localizedname the localized name of this question type.
   */
  function print_qtype_to_add_option($qtype, $localizedname) {
!     global $QTYPES;
!     echo '<div class="qtypeoption">' . "\n";
!     echo '<label for="qtype_' . $qtype . '">';
!     echo '<input type="radio" name="qtype" id="qtype_' . $qtype . '" value="' . $qtype . '" />';
!     echo '<span class="qtypename">';
!     $fakequestion = new stdClass;
!     $fakequestion->qtype = $qtype;
!     print_question_icon($fakequestion);
!     echo $localizedname . '</span><span class="qtypesummary">' . get_string($qtype . 'summary', 'qtype_' . $qtype);
!     echo "</span></label>\n";
!     echo "</div>\n";
  }
  
  /**
--- 1726,1742 ----
   * @param $localizedname the localized name of this question type.
   */
  function print_qtype_to_add_option($qtype, $localizedname) {
! 	global $QTYPES;
! 	echo '<div class="qtypeoption">' . "\n";
! 	echo '<label for="qtype_' . $qtype . '">';
! 	echo '<input type="radio" name="qtype" id="qtype_' . $qtype . '" value="' . $qtype . '" />';
! 	echo '<span class="qtypename">';
! 	$fakequestion = new stdClass;
! 	$fakequestion->qtype = $qtype;
! 	print_question_icon($fakequestion);
! 	echo $localizedname . '</span><span class="qtypesummary">' . get_string($qtype . 'summary', 'qtype_' . $qtype);
! 	echo "</span></label>\n";
! 	echo "</div>\n";
  }
  
  /**
***************
*** 1752,1771 ****
   * @param boolean $disabled if true, the button will be disabled.
   */
  function create_new_question_button($categoryid, $params, $caption, $tooltip = '', $disabled = false) {
!     global $CFG, $PAGE, $OUTPUT;
!     static $choiceformprinted = false;
!     $params['category'] = $categoryid;
!     $url = new moodle_url('/question/addquestion.php', $params);
!     echo $OUTPUT->single_button($url, $caption, 'get', array('disabled'=>$disabled, 'title'=>$tooltip));
! 
!     $PAGE->requires->yui2_lib('dragdrop');
!     $PAGE->requires->yui2_lib('container');
!     if (!$choiceformprinted) {
!         echo '<div id="qtypechoicecontainer">';
!         print_choose_qtype_to_add_form(array());
!         echo "</div>\n";
!         $choiceformprinted = true;
!     }
  }
  
  
--- 1752,1771 ----
   * @param boolean $disabled if true, the button will be disabled.
   */
  function create_new_question_button($categoryid, $params, $caption, $tooltip = '', $disabled = false) {
! 	global $CFG, $PAGE, $OUTPUT;
! 	static $choiceformprinted = false;
! 	$params['category'] = $categoryid;
! 	$url = new moodle_url('/question/addquestion.php', $params);
! 	echo $OUTPUT->single_button($url, $caption, 'get', array('disabled'=>$disabled, 'title'=>$tooltip));
! 
! 	$PAGE->requires->yui2_lib('dragdrop');
! 	$PAGE->requires->yui2_lib('container');
! 	if (!$choiceformprinted) {
! 		echo '<div id="qtypechoicecontainer">';
! 		print_choose_qtype_to_add_form(array());
! 		echo "</div>\n";
! 		$choiceformprinted = true;
! 	}
  }
  
  
diff -crB questionorg/edit.php questionupd/edit.php
*** questionorg/edit.php	2012-04-13 12:31:10.711178243 +0500
--- questionupd/edit.php	2012-04-13 09:42:52.000000000 +0500
***************
*** 30,81 ****
   * @package questionbank
   */
  
!     require_once("../config.php");
!     require_once("editlib.php");
  
!     $url = new moodle_url('/question/edit.php');
!     if (($lastchanged = optional_param('lastchanged', 0, PARAM_INT)) !== 0) {
!         $url->param('lastchanged', $lastchanged);
!     }
!     if (($category = optional_param('category', 0, PARAM_TEXT)) !== 0) {
!         $url->param('category', $category);
!     }
!     if (($qpage = optional_param('qpage', 0, PARAM_INT)) !== 0) {
!         $url->param('qpage', $qpage);
!     }
!     if (($cat = optional_param('cat', 0, PARAM_TEXT)) !== 0) {
!         $url->param('cat', $cat);
!     }
!     if (($courseid = optional_param('courseid', 0, PARAM_INT)) !== 0) {
!         $url->param('courseid', $courseid);
!     }
!     if (($returnurl = optional_param('returnurl', 0, PARAM_INT)) !== 0) {
!         $url->param('returnurl', $returnurl);
!     }
!     if (($cmid = optional_param('cmid', 0, PARAM_INT)) !== 0) {
!         $url->param('cmid', $cmid);
!     }
!     $PAGE->set_url($url);
!     $PAGE->set_pagelayout('standard');
! 
!     list($thispageurl, $contexts, $cmid, $cm, $module, $pagevars) =
!             question_edit_setup('questions', '/question/edit.php');
!     $questionbank = new question_bank_view($contexts, $thispageurl, $COURSE, $cm);
!     $questionbank->process_actions();
! 
!     // TODO log this page view.
! 
!     $context = $contexts->lowest();
!     $streditingquestions = get_string('editquestions', "quiz");
!     $PAGE->set_title($streditingquestions);
!     $PAGE->set_heading($COURSE->fullname);
!     echo $OUTPUT->header();
! 
!     echo '<div class="questionbankwindow boxwidthwide boxaligncenter">';
!     $questionbank->display('questions', $pagevars['qpage'],
!             $pagevars['qperpage'], $pagevars['qsortorder'], $pagevars['qsortorderdecoded'],
!             $pagevars['cat'], $pagevars['recurse'], $pagevars['showhidden'], $pagevars['showquestiontext']);
!     echo "</div>\n";
  
!     echo $OUTPUT->footer();
  
--- 30,81 ----
   * @package questionbank
   */
  
! require_once("../config.php");
! require_once("editlib.php");
  
! $url = new moodle_url('/question/edit.php');
! if (($lastchanged = optional_param('lastchanged', 0, PARAM_INT)) !== 0) {
! 	$url->param('lastchanged', $lastchanged);
! }
! if (($category = optional_param('category', 0, PARAM_TEXT)) !== 0) {
! 	$url->param('category', $category);
! }
! if (($qpage = optional_param('qpage', 0, PARAM_INT)) !== 0) {
! 	$url->param('qpage', $qpage);
! }
! if (($cat = optional_param('cat', 0, PARAM_TEXT)) !== 0) {
! 	$url->param('cat', $cat);
! }
! if (($courseid = optional_param('courseid', 0, PARAM_INT)) !== 0) {
! 	$url->param('courseid', $courseid);
! }
! if (($returnurl = optional_param('returnurl', 0, PARAM_INT)) !== 0) {
! 	$url->param('returnurl', $returnurl);
! }
! if (($cmid = optional_param('cmid', 0, PARAM_INT)) !== 0) {
! 	$url->param('cmid', $cmid);
! }
! $PAGE->set_url($url);
! $PAGE->set_pagelayout('standard');
! 
! list($thispageurl, $contexts, $cmid, $cm, $module, $pagevars) =
! question_edit_setup('questions', '/question/edit.php');
! $questionbank = new question_bank_view($contexts, $thispageurl, $COURSE, $cm);
! $questionbank->process_actions();
! 
! // TODO log this page view.
! 
! $context = $contexts->lowest();
! $streditingquestions = get_string('editquestions', "quiz");
! $PAGE->set_title($streditingquestions);
! $PAGE->set_heading($COURSE->fullname);
! echo $OUTPUT->header();
! 
! echo '<div class="questionbankwindow boxwidthwide boxaligncenter">';
! $questionbank->display('questions', $pagevars['qpage'],
! $pagevars['qperpage'], $pagevars['qsortorder'], $pagevars['qsortorderdecoded'],
! $pagevars['cat'], $pagevars['recurse'], $pagevars['showhidden'], $pagevars['showquestiontext']);
! echo "</div>\n";
  
! echo $OUTPUT->footer();
  
diff -crB questionorg/export_form.php questionupd/export_form.php
*** questionorg/export_form.php	2012-04-13 12:31:14.446178304 +0500
--- questionupd/export_form.php	2012-04-13 09:42:52.000000000 +0500
***************
*** 1,57 ****
  <?php
  
  if (!defined('MOODLE_INTERNAL')) {
!     die('Direct access to this script is forbidden.');    ///  It must be included from a Moodle page
  }
  
  require_once($CFG->libdir.'/formslib.php');
  
  class question_export_form extends moodleform {
  
!     function definition() {
!         $mform    =& $this->_form;
  
!         $defaultcategory   = $this->_customdata['defaultcategory'];
!         $contexts   = $this->_customdata['contexts'];
! //--------------------------------------------------------------------------------
!         $mform->addElement('header','fileformat',get_string('fileformat','quiz'));
!         $fileformatnames = get_import_export_formats('export');
!         $radioarray = array();
!         $i = 0 ;
!         foreach ($fileformatnames as $shortname => $fileformatname) {
!             $currentgrp1 = array();
!             $currentgrp1[] = &$mform->createElement('radio','format','',$fileformatname,$shortname);
!             $mform->addGroup($currentgrp1,"formathelp[$i]",'',array('<br />'),false);
!             $mform->addHelpButton("formathelp[$i]", $shortname, 'qformat_'.$shortname);
!             $i++ ;
!         }
!         $mform->addRule("formathelp[0]",null,'required',null,'client');
! //--------------------------------------------------------------------------------
!         $mform->addElement('header','general', get_string('general', 'form'));
! 
!         $mform->addElement('questioncategory', 'category', get_string('exportcategory', 'question'), compact('contexts'));
!         $mform->setDefault('category', $defaultcategory);
!         $mform->addHelpButton('category', 'exportcategory', 'question');
! 
!         $categorygroup = array();
!         $categorygroup[] =& $mform->createElement('checkbox', 'cattofile', '', get_string('tofilecategory', 'question'));
!         $categorygroup[] =& $mform->createElement('checkbox', 'contexttofile', '', get_string('tofilecontext', 'question'));
!         $mform->addGroup($categorygroup, 'categorygroup', '', '', false);
!         $mform->disabledIf('categorygroup', 'cattofile', 'notchecked');
!         $mform->setDefault('cattofile', 1);
!         $mform->setDefault('contexttofile', 1);
! 
! //        $fileformatnames = get_import_export_formats('export');
! //        $mform->addElement('select', 'format', get_string('fileformat','quiz'), $fileformatnames);
! //        $mform->setDefault('format', 'gift');
! 
!         // set a template for the format select elements
!         $renderer =& $mform->defaultRenderer();
!         $template = "{help} {element}\n";
!         $renderer->setGroupElementTemplate($template, 'format');
! 
! //--------------------------------------------------------------------------------
!         $this->add_action_buttons(false, get_string('exportquestions', 'quiz'));
! //--------------------------------------------------------------------------------
!     }
  }
--- 1,57 ----
  <?php
  
  if (!defined('MOODLE_INTERNAL')) {
! 	die('Direct access to this script is forbidden.');    ///  It must be included from a Moodle page
  }
  
  require_once($CFG->libdir.'/formslib.php');
  
  class question_export_form extends moodleform {
  
! 	function definition() {
! 		$mform    =& $this->_form;
  
! 		$defaultcategory   = $this->_customdata['defaultcategory'];
! 		$contexts   = $this->_customdata['contexts'];
! 		//--------------------------------------------------------------------------------
! 		$mform->addElement('header','fileformat',get_string('fileformat','quiz'));
! 		$fileformatnames = get_import_export_formats('export');
! 		$radioarray = array();
! 		$i = 0 ;
! 		foreach ($fileformatnames as $shortname => $fileformatname) {
! 			$currentgrp1 = array();
! 			$currentgrp1[] = &$mform->createElement('radio','format','',$fileformatname,$shortname);
! 			$mform->addGroup($currentgrp1,"formathelp[$i]",'',array('<br />'),false);
! 			$mform->addHelpButton("formathelp[$i]", $shortname, 'qformat_'.$shortname);
! 			$i++ ;
! 		}
! 		$mform->addRule("formathelp[0]",null,'required',null,'client');
! 		//--------------------------------------------------------------------------------
! 		$mform->addElement('header','general', get_string('general', 'form'));
! 
! 		$mform->addElement('questioncategory', 'category', get_string('exportcategory', 'question'), compact('contexts'));
! 		$mform->setDefault('category', $defaultcategory);
! 		$mform->addHelpButton('category', 'exportcategory', 'question');
! 
! 		$categorygroup = array();
! 		$categorygroup[] =& $mform->createElement('checkbox', 'cattofile', '', get_string('tofilecategory', 'question'));
! 		$categorygroup[] =& $mform->createElement('checkbox', 'contexttofile', '', get_string('tofilecontext', 'question'));
! 		$mform->addGroup($categorygroup, 'categorygroup', '', '', false);
! 		$mform->disabledIf('categorygroup', 'cattofile', 'notchecked');
! 		$mform->setDefault('cattofile', 1);
! 		$mform->setDefault('contexttofile', 1);
! 
! 		//        $fileformatnames = get_import_export_formats('export');
! 		//        $mform->addElement('select', 'format', get_string('fileformat','quiz'), $fileformatnames);
! 		//        $mform->setDefault('format', 'gift');
! 
! 		// set a template for the format select elements
! 		$renderer =& $mform->defaultRenderer();
! 		$template = "{help} {element}\n";
! 		$renderer->setGroupElementTemplate($template, 'format');
! 
! 		//--------------------------------------------------------------------------------
! 		$this->add_action_buttons(false, get_string('exportquestions', 'quiz'));
! 		//--------------------------------------------------------------------------------
! 	}
  }
diff -crB questionorg/export.php questionupd/export.php
*** questionorg/export.php	2012-04-13 12:31:14.445178304 +0500
--- questionupd/export.php	2012-04-13 09:42:52.000000000 +0500
***************
*** 9,80 ****
   * @subpackage importexport
   */
  
!     require_once("../config.php");
!     require_once("editlib.php");
!     require_once("export_form.php");
! 
!     $PAGE->set_pagelayout('standard');
! 
!     list($thispageurl, $contexts, $cmid, $cm, $module, $pagevars) =
!             question_edit_setup('export', '/question/export.php');
! 
!     // get display strings
!     $strexportquestions = get_string('exportquestions', 'question');
! 
!     // make sure we are using the user's most recent category choice
!     if (empty($categoryid)) {
!         $categoryid = $pagevars['cat'];
!     }
! 
!     list($catid, $catcontext) = explode(',', $pagevars['cat']);
!     if (!$category = $DB->get_record("question_categories", array("id" => $catid, 'contextid' => $catcontext))) {
!         print_error('nocategory','quiz');
!     }
! 
!     /// Header
!     $PAGE->set_url($thispageurl->out());
!     $PAGE->set_title($strexportquestions);
!     $PAGE->set_heading($COURSE->fullname);
!     echo $OUTPUT->header();
! 
!     $export_form = new question_export_form($thispageurl, array('contexts'=>$contexts->having_one_edit_tab_cap('export'), 'defaultcategory'=>$pagevars['cat']));
! 
! 
!     if ($from_form = $export_form->get_data()) {
!         $thiscontext = $contexts->lowest();
!         if (!is_readable("format/$from_form->format/format.php")) {
!             print_error('unknowformat', '', '', $from_form->format);
!         }
!         $withcategories = 'nocategories';
!         if (!empty($from_form->cattofile)) {
!             $withcategories = 'withcategories';
!         }
!         $withcontexts = 'nocontexts';
!         if (!empty($from_form->contexttofile)) {
!             $withcontexts = 'withcontexts';
!         }
! 
!         $classname = 'qformat_' . $from_form->format;
!         $qformat = new $classname();
!         $filename = question_default_export_filename($COURSE, $category) .
!                 $qformat->export_file_extension();
!         $export_url = question_make_export_url($thiscontext->id, $category->id,
!                 $from_form->format, $withcategories, $withcontexts, $filename);
! 
!         echo $OUTPUT->box_start();
!         echo get_string('yourfileshoulddownload', 'question', $export_url->out());
!         echo $OUTPUT->box_end();
! 
!         $PAGE->requires->js_function_call('document.location.replace', array($export_url->out()), false, 1);
! 
!         echo $OUTPUT->continue_button(new moodle_url('edit.php', $thispageurl->params()));
!         echo $OUTPUT->footer();
!         exit;
!     }
  
!     /// Display export form
!     echo $OUTPUT->heading_with_help($strexportquestions, 'exportquestions', 'question');
  
!     $export_form->display();
  
!     echo $OUTPUT->footer();
--- 9,80 ----
   * @subpackage importexport
   */
  
! require_once("../config.php");
! require_once("editlib.php");
! require_once("export_form.php");
! 
! $PAGE->set_pagelayout('standard');
! 
! list($thispageurl, $contexts, $cmid, $cm, $module, $pagevars) =
! question_edit_setup('export', '/question/export.php');
! 
! // get display strings
! $strexportquestions = get_string('exportquestions', 'question');
! 
! // make sure we are using the user's most recent category choice
! if (empty($categoryid)) {
! 	$categoryid = $pagevars['cat'];
! }
! 
! list($catid, $catcontext) = explode(',', $pagevars['cat']);
! if (!$category = $DB->get_record("question_categories", array("id" => $catid, 'contextid' => $catcontext))) {
! 	print_error('nocategory','quiz');
! }
! 
! /// Header
! $PAGE->set_url($thispageurl->out());
! $PAGE->set_title($strexportquestions);
! $PAGE->set_heading($COURSE->fullname);
! echo $OUTPUT->header();
! 
! $export_form = new question_export_form($thispageurl, array('contexts'=>$contexts->having_one_edit_tab_cap('export'), 'defaultcategory'=>$pagevars['cat']));
! 
! 
! if ($from_form = $export_form->get_data()) {
! 	$thiscontext = $contexts->lowest();
! 	if (!is_readable("format/$from_form->format/format.php")) {
! 		print_error('unknowformat', '', '', $from_form->format);
! 	}
! 	$withcategories = 'nocategories';
! 	if (!empty($from_form->cattofile)) {
! 		$withcategories = 'withcategories';
! 	}
! 	$withcontexts = 'nocontexts';
! 	if (!empty($from_form->contexttofile)) {
! 		$withcontexts = 'withcontexts';
! 	}
! 
! 	$classname = 'qformat_' . $from_form->format;
! 	$qformat = new $classname();
! 	$filename = question_default_export_filename($COURSE, $category) .
! 	$qformat->export_file_extension();
! 	$export_url = question_make_export_url($thiscontext->id, $category->id,
! 	$from_form->format, $withcategories, $withcontexts, $filename);
! 
! 	echo $OUTPUT->box_start();
! 	echo get_string('yourfileshoulddownload', 'question', $export_url->out());
! 	echo $OUTPUT->box_end();
! 
! 	$PAGE->requires->js_function_call('document.location.replace', array($export_url->out()), false, 1);
! 
! 	echo $OUTPUT->continue_button(new moodle_url('edit.php', $thispageurl->params()));
! 	echo $OUTPUT->footer();
! 	exit;
! }
  
! /// Display export form
! echo $OUTPUT->heading_with_help($strexportquestions, 'exportquestions', 'question');
  
! $export_form->display();
  
! echo $OUTPUT->footer();
diff -crB questionorg/file.php questionupd/file.php
*** questionorg/file.php	2012-04-13 12:31:10.709178243 +0500
--- questionupd/file.php	2012-04-13 09:42:52.000000000 +0500
***************
*** 1,86 ****
  <?php
!       // This script fetches files from the dataroot/questionattempt directory
!       // It is based on the top-level file.php
!       //
!       // On a module-by-module basis (currently only implemented for quiz), it checks
!       // whether the user has permission to view the file.
!       //
!       // Syntax:      question/file.php/attemptid/questionid/filename.ext
!       // Workaround:  question/file.php?file=/attemptid/questionid/filename.ext
  
  // disable moodle specific debug messages and any errors in output
  define('NO_DEBUG_DISPLAY', true);
  
!     require_once('../config.php');
!     require_once('../lib/filelib.php');
  
!     $relativepath = get_file_argument();
!     // force download for any student-submitted files to prevent XSS attacks.
!     $forcedownload = 1;
! 
!     // relative path must start with '/', because of backup/restore!!!
!     if (!$relativepath) {
!         print_error('invalidarguments');
!     } else if ($relativepath{0} != '/') {
!         print_error('pathdoesnotstartslash');
!     }
! 
!     $pathname = $CFG->dataroot.'/questionattempt'.$relativepath;
! 
!     // extract relative path components
!     $args = explode('/', trim($relativepath, '/'));
! 
!     // check for the right number of directories in the path
!     if (count($args) != 3) {
!         print_error('invalidarguments');
!     }
! 
!     // security: require login
!     require_login();
! 
!     // security: do not return directory node!
!     if (is_dir($pathname)) {
!         question_attempt_not_found();
!     }
! 
!     $lifetime = 0;  // do not cache because students may reupload files
! 
!     // security: check that the user has permission to access this file
!     $haspermission = false;
!     if ($attempt = $DB->get_record("question_attempts", array("id" => $args[0]))) {
!         $modfile = $CFG->dirroot .'/mod/'. $attempt->modulename .'/lib.php';
!         $modcheckfileaccess = $attempt->modulename .'_check_file_access';
!         if (file_exists($modfile)) {
!             @require_once($modfile);
!             if (function_exists($modcheckfileaccess)) {
!                 $haspermission = $modcheckfileaccess($args[0], $args[1]);
!             }
!         }
!     } else if ($args[0][0] == 0) {
!         global $USER;
!         $list = explode('_', $args[0]);
!         if ($list[1] == $USER->id) {
!             $haspermission = true;
!         }
!     }
! 
!     if ($haspermission) {
!         // check that file exists
!         if (!file_exists($pathname)) {
!             question_attempt_not_found();
!         }
! 
!         // send the file
!         session_get_instance()->write_close(); // unlock session during fileserving
!         $filename = $args[count($args)-1];
!         send_file($pathname, $filename, $lifetime, $CFG->filteruploadedfiles, false, $forcedownload);
!     } else {
!         question_attempt_not_found();
!     }
! 
!     function question_attempt_not_found() {
!         global $CFG;
!         header('HTTP/1.0 404 not found');
!         print_error('filenotfound', 'error', $CFG->wwwroot); //this is not displayed on IIS??
!     }
  
--- 1,86 ----
  <?php
! // This script fetches files from the dataroot/questionattempt directory
! // It is based on the top-level file.php
! //
! // On a module-by-module basis (currently only implemented for quiz), it checks
! // whether the user has permission to view the file.
! //
! // Syntax:      question/file.php/attemptid/questionid/filename.ext
! // Workaround:  question/file.php?file=/attemptid/questionid/filename.ext
  
  // disable moodle specific debug messages and any errors in output
  define('NO_DEBUG_DISPLAY', true);
  
! require_once('../config.php');
! require_once('../lib/filelib.php');
  
! $relativepath = get_file_argument();
! // force download for any student-submitted files to prevent XSS attacks.
! $forcedownload = 1;
! 
! // relative path must start with '/', because of backup/restore!!!
! if (!$relativepath) {
! 	print_error('invalidarguments');
! } else if ($relativepath{0} != '/') {
! 	print_error('pathdoesnotstartslash');
! }
! 
! $pathname = $CFG->dataroot.'/questionattempt'.$relativepath;
! 
! // extract relative path components
! $args = explode('/', trim($relativepath, '/'));
! 
! // check for the right number of directories in the path
! if (count($args) != 3) {
! 	print_error('invalidarguments');
! }
! 
! // security: require login
! require_login();
! 
! // security: do not return directory node!
! if (is_dir($pathname)) {
! 	question_attempt_not_found();
! }
! 
! $lifetime = 0;  // do not cache because students may reupload files
! 
! // security: check that the user has permission to access this file
! $haspermission = false;
! if ($attempt = $DB->get_record("question_attempts", array("id" => $args[0]))) {
! 	$modfile = $CFG->dirroot .'/mod/'. $attempt->modulename .'/lib.php';
! 	$modcheckfileaccess = $attempt->modulename .'_check_file_access';
! 	if (file_exists($modfile)) {
! 		@require_once($modfile);
! 		if (function_exists($modcheckfileaccess)) {
! 			$haspermission = $modcheckfileaccess($args[0], $args[1]);
! 		}
! 	}
! } else if ($args[0][0] == 0) {
! 	global $USER;
! 	$list = explode('_', $args[0]);
! 	if ($list[1] == $USER->id) {
! 		$haspermission = true;
! 	}
! }
! 
! if ($haspermission) {
! 	// check that file exists
! 	if (!file_exists($pathname)) {
! 		question_attempt_not_found();
! 	}
! 
! 	// send the file
! 	session_get_instance()->write_close(); // unlock session during fileserving
! 	$filename = $args[count($args)-1];
! 	send_file($pathname, $filename, $lifetime, $CFG->filteruploadedfiles, false, $forcedownload);
! } else {
! 	question_attempt_not_found();
! }
! 
! function question_attempt_not_found() {
! 	global $CFG;
! 	header('HTTP/1.0 404 not found');
! 	print_error('filenotfound', 'error', $CFG->wwwroot); //this is not displayed on IIS??
! }
  
diff -crB questionorg/format/aiken/format.php questionupd/format/aiken/format.php
*** questionorg/format/aiken/format.php	2012-04-13 12:31:11.711178259 +0500
--- questionupd/format/aiken/format.php	2012-04-13 09:42:52.000000000 +0500
***************
*** 47,108 ****
   */
  class qformat_aiken extends qformat_default {
  
!   function provide_import() {
!     return true;
!   }
! 
!     function readquestions($lines) {
!         $questions = array();
!         $question = $this->defaultquestion();
!         $endchar = chr(13);
!         foreach ($lines as $line) {
!             $stp = strpos($line, $endchar, 0);
!             $newlines = explode($endchar, $line);
!             $foundQ = 0;
!             $linescount = count($newlines);
!             for ($i=0; $i < $linescount; $i++) {
!                 $nowline = trim($newlines[$i]);
!                 // Go through the array and build an object called $question
!                 // When done, add $question to $questions
!                 if (strlen($nowline) < 2) {
!                     continue;
!                 }
!                 if (preg_match('/^[A-Z][).][ \t]/', $nowline)) {
!                     // A choice. Trim off the label and space, then save
!                     $question->answer[] = htmlspecialchars(trim(substr($nowline, 2)), ENT_NOQUOTES);
!                     $question->fraction[] = 0;
!                     $question->feedback[] = '';
!                     continue;
!                 }
!                 if (preg_match('/^ANSWER:/', $nowline)) {
!                     // The line that indicates the correct answer. This question is finised.
!                     $ans = trim(substr($nowline, strpos($nowline, ':') + 1));
!                     $ans = substr($ans, 0, 1);
!                     // We want to map A to 0, B to 1, etc.
!                     $rightans = ord($ans) - ord('A');
!                     $question->fraction[$rightans] = 1;
!                     $questions[] = $question;
! 
!                     // Clear array for next question set
!                     $question = $this->defaultquestion();
!                     continue;
!                 } else {
!                     // Must be the first line of a new question, since no recognised prefix.
!                     $question->qtype = MULTICHOICE;
!                     $question->name = htmlspecialchars(substr($nowline, 0, 50));
!                     $question->questiontext = htmlspecialchars($nowline);
!                     $question->single = 1;
!                     $question->feedback[] = '';
!                 }
!             }
!         }
!         return $questions;
!     }
! 
!     function readquestion($lines) {
!         //this is no longer needed but might still be called by default.php
!         return;
!     }
  }
  
  
--- 47,108 ----
   */
  class qformat_aiken extends qformat_default {
  
! 	function provide_import() {
! 		return true;
! 	}
! 
! 	function readquestions($lines) {
! 		$questions = array();
! 		$question = $this->defaultquestion();
! 		$endchar = chr(13);
! 		foreach ($lines as $line) {
! 			$stp = strpos($line, $endchar, 0);
! 			$newlines = explode($endchar, $line);
! 			$foundQ = 0;
! 			$linescount = count($newlines);
! 			for ($i=0; $i < $linescount; $i++) {
! 				$nowline = trim($newlines[$i]);
! 				// Go through the array and build an object called $question
! 				// When done, add $question to $questions
! 				if (strlen($nowline) < 2) {
! 					continue;
! 				}
! 				if (preg_match('/^[A-Z][).][ \t]/', $nowline)) {
! 					// A choice. Trim off the label and space, then save
! 					$question->answer[] = htmlspecialchars(trim(substr($nowline, 2)), ENT_NOQUOTES);
! 					$question->fraction[] = 0;
! 					$question->feedback[] = '';
! 					continue;
! 				}
! 				if (preg_match('/^ANSWER:/', $nowline)) {
! 					// The line that indicates the correct answer. This question is finised.
! 					$ans = trim(substr($nowline, strpos($nowline, ':') + 1));
! 					$ans = substr($ans, 0, 1);
! 					// We want to map A to 0, B to 1, etc.
! 					$rightans = ord($ans) - ord('A');
! 					$question->fraction[$rightans] = 1;
! 					$questions[] = $question;
! 
! 					// Clear array for next question set
! 					$question = $this->defaultquestion();
! 					continue;
! 				} else {
! 					// Must be the first line of a new question, since no recognised prefix.
! 					$question->qtype = MULTICHOICE;
! 					$question->name = htmlspecialchars(substr($nowline, 0, 50));
! 					$question->questiontext = htmlspecialchars($nowline);
! 					$question->single = 1;
! 					$question->feedback[] = '';
! 				}
! 			}
! 		}
! 		return $questions;
! 	}
! 
! 	function readquestion($lines) {
! 		//this is no longer needed but might still be called by default.php
! 		return;
! 	}
  }
  
  
diff -crB questionorg/format/blackboard/format.php questionupd/format/blackboard/format.php
*** questionorg/format/blackboard/format.php	2012-04-13 12:31:10.884178246 +0500
--- questionupd/format/blackboard/format.php	2012-04-13 09:42:52.000000000 +0500
***************
*** 18,397 ****
  
  class qformat_blackboard extends qformat_default {
  
!     function provide_import() {
!         return true;
!     }
  
  
!   function readquestions ($lines) {
!     /// Parses an array of lines into an array of questions,
!     /// where each item is a question object as defined by
!     /// readquestion().
  
!     $text = implode($lines, " ");
!     $xml = xmlize($text, 0);
  
!     $questions = array();
! 
!     $this->process_tf($xml, $questions);
!     $this->process_mc($xml, $questions);
!     $this->process_ma($xml, $questions);
!     $this->process_fib($xml, $questions);
!     $this->process_matching($xml, $questions);
!     $this->process_essay($xml, $questions);
! 
!     return $questions;
! }
! 
! //----------------------------------------
! // Process Essay Questions
! //----------------------------------------
! function process_essay($xml, &$questions ) {
! 
!     if (isset($xml["POOL"]["#"]["QUESTION_ESSAY"])) {
!         $essayquestions = $xml["POOL"]["#"]["QUESTION_ESSAY"];
!     }
!     else {
!         return;
!     }
! 
!     foreach ($essayquestions as $essayquestion) {
! 
!         $question = $this->defaultquestion();
! 
!         $question->qtype = ESSAY;
! 
!         // determine if the question is already escaped html
!         $ishtml = $essayquestion["#"]["BODY"][0]["#"]["FLAGS"][0]["#"]["ISHTML"][0]["@"]["value"];
! 
!         // put questiontext in question object
!         if ($ishtml) {
!             $question->questiontext = html_entity_decode(trim($essayquestion["#"]["BODY"][0]["#"]["TEXT"][0]["#"]));
!         }
! 
!         // put name in question object
!         $question->name = substr($question->questiontext, 0, 254);
!         $question->answer = '';
!         $question->feedback = '';
!         $question->fraction = 0;
! 
!         $questions[] = $question;
!     }
! }
! 
! //----------------------------------------
! // Process True / False Questions
! //----------------------------------------
! function process_tf($xml, &$questions) {
! 
!     if (isset($xml["POOL"]["#"]["QUESTION_TRUEFALSE"])) {
!         $tfquestions = $xml["POOL"]["#"]["QUESTION_TRUEFALSE"];
!     }
!     else {
!         return;
!     }
! 
!     for ($i = 0; $i < sizeof ($tfquestions); $i++) {
! 
!         $question = $this->defaultquestion();
! 
!         $question->qtype = TRUEFALSE;
!         $question->single = 1; // Only one answer is allowed
! 
!         $thisquestion = $tfquestions[$i];
! 
!         // determine if the question is already escaped html
!         $ishtml = $thisquestion["#"]["BODY"][0]["#"]["FLAGS"][0]["#"]["ISHTML"][0]["@"]["value"];
! 
!         // put questiontext in question object
!         if ($ishtml) {
!             $question->questiontext = html_entity_decode(trim($thisquestion["#"]["BODY"][0]["#"]["TEXT"][0]["#"]),ENT_QUOTES,'UTF-8');
!         }
!         $question->questiontext = $question->questiontext;
!         // put name in question object
!         $question->name = shorten_text($question->questiontext, 254);
! 
!         $choices = $thisquestion["#"]["ANSWER"];
! 
!         $correct_answer = $thisquestion["#"]["GRADABLE"][0]["#"]["CORRECTANSWER"][0]["@"]["answer_id"];
! 
!         // first choice is true, second is false.
!         $id = $choices[0]["@"]["id"];
! 
!         if (strcmp($id, $correct_answer) == 0) {  // true is correct
!             $question->answer = 1;
!             $question->feedbacktrue = trim(@$thisquestion["#"]["GRADABLE"][0]["#"]["FEEDBACK_WHEN_CORRECT"][0]["#"]);
!             $question->feedbackfalse = trim(@$thisquestion["#"]["GRADABLE"][0]["#"]["FEEDBACK_WHEN_INCORRECT"][0]["#"]);
!         } else {  // false is correct
!             $question->answer = 0;
!             $question->feedbacktrue = trim(@$thisquestion["#"]["GRADABLE"][0]["#"]["FEEDBACK_WHEN_INCORRECT"][0]["#"]);
!             $question->feedbackfalse = trim(@$thisquestion["#"]["GRADABLE"][0]["#"]["FEEDBACK_WHEN_CORRECT"][0]["#"]);
!         }
!         $question->correctanswer = $question->answer;
!         $questions[] = $question;
!       }
! }
! 
! //----------------------------------------
! // Process Multiple Choice Questions
! //----------------------------------------
! function process_mc($xml, &$questions) {
! 
!     if (isset($xml["POOL"]["#"]["QUESTION_MULTIPLECHOICE"])) {
!         $mcquestions = $xml["POOL"]["#"]["QUESTION_MULTIPLECHOICE"];
!     }
!     else {
!         return;
!     }
! 
!     for ($i = 0; $i < sizeof ($mcquestions); $i++) {
! 
!         $question = $this->defaultquestion();
! 
!         $question->qtype = MULTICHOICE;
!         $question->single = 1; // Only one answer is allowed
! 
!         $thisquestion = $mcquestions[$i];
! 
!         // determine if the question is already escaped html
!         $ishtml = $thisquestion["#"]["BODY"][0]["#"]["FLAGS"][0]["#"]["ISHTML"][0]["@"]["value"];
! 
!         // put questiontext in question object
!         if ($ishtml) {
!             $question->questiontext = html_entity_decode(trim($thisquestion["#"]["BODY"][0]["#"]["TEXT"][0]["#"]),ENT_QUOTES,'UTF-8');
!         }
!         $question->questiontext = $question->questiontext;
! 
!         // put name of question in question object, careful of length
!         $question->name = shorten_text($question->questiontext, 254);
! 
!         $choices = $thisquestion["#"]["ANSWER"];
!         for ($j = 0; $j < sizeof ($choices); $j++) {
! 
!             $choice = trim($choices[$j]["#"]["TEXT"][0]["#"]);
!             // put this choice in the question object.
!             if ($ishtml) {
!                 $question->answer[$j] = html_entity_decode($choice,ENT_QUOTES,'UTF-8');
!             }
!             $question->answer[$j] = $question->answer[$j];
! 
!             $id = $choices[$j]["@"]["id"];
!             $correct_answer_id = $thisquestion["#"]["GRADABLE"][0]["#"]["CORRECTANSWER"][0]["@"]["answer_id"];
!             // if choice is the answer, give 100%, otherwise give 0%
!             if (strcmp ($id, $correct_answer_id) == 0) {
!                 $question->fraction[$j] = 1;
!                 if ($ishtml) {
!                     $question->feedback[$j] = html_entity_decode(trim(@$thisquestion["#"]["GRADABLE"][0]["#"]["FEEDBACK_WHEN_CORRECT"][0]["#"]),ENT_QUOTES,'UTF-8');
!                 }
!                 $question->feedback[$j] = $question->feedback[$j];
!             } else {
!                 $question->fraction[$j] = 0;
!                 if ($ishtml) {
!                     $question->feedback[$j] = html_entity_decode(trim(@$thisquestion["#"]["GRADABLE"][0]["#"]["FEEDBACK_WHEN_INCORRECT"][0]["#"]),ENT_QUOTES,'UTF-8');
!                 }
!                 $question->feedback[$j] = $question->feedback[$j];
!             }
!         }
!         $questions[] = $question;
!     }
! }
! 
! //----------------------------------------
! // Process Multiple Choice Questions With Multiple Answers
! //----------------------------------------
! function process_ma($xml, &$questions) {
! 
!     if (isset($xml["POOL"]["#"]["QUESTION_MULTIPLEANSWER"])) {
!         $maquestions = $xml["POOL"]["#"]["QUESTION_MULTIPLEANSWER"];
!     }
!     else {
!         return;
!     }
! 
!     for ($i = 0; $i < sizeof ($maquestions); $i++) {
! 
!         $question = $this->defaultquestion();
! 
!         $question->qtype = MULTICHOICE;
!         $question->defaultgrade = 1;
!         $question->single = 0; // More than one answers allowed
!         $question->image = ""; // No images with this format
! 
!         $thisquestion = $maquestions[$i];
! 
!         // determine if the question is already escaped html
!         $ishtml = $thisquestion["#"]["BODY"][0]["#"]["FLAGS"][0]["#"]["ISHTML"][0]["@"]["value"];
! 
!         // put questiontext in question object
!         if ($ishtml) {
!             $question->questiontext = html_entity_decode(trim($thisquestion["#"]["BODY"][0]["#"]["TEXT"][0]["#"]),ENT_QUOTES,'UTF-8');
!         }
!         $question->questiontext = $question->questiontext;
!         // put name of question in question object
!         $question->name = shorten_text($question->questiontext, 254);
! 
!         $choices = $thisquestion["#"]["ANSWER"];
!         $correctanswers = $thisquestion["#"]["GRADABLE"][0]["#"]["CORRECTANSWER"];
! 
!         for ($j = 0; $j < sizeof ($choices); $j++) {
! 
!             $choice = trim($choices[$j]["#"]["TEXT"][0]["#"]);
!             // put this choice in the question object.
!             $question->answer[$j] = $choice;
! 
!             $correctanswercount = sizeof($correctanswers);
!             $id = $choices[$j]["@"]["id"];
!             $iscorrect = 0;
!             for ($k = 0; $k < $correctanswercount; $k++) {
! 
!                 $correct_answer_id = trim($correctanswers[$k]["@"]["answer_id"]);
!                 if (strcmp ($id, $correct_answer_id) == 0) {
!                     $iscorrect = 1;
!                 }
! 
!             }
!             if ($iscorrect) {
!                 $question->fraction[$j] = floor(100000/$correctanswercount)/100000; // strange behavior if we have more than 5 decimal places
!                 $question->feedback[$j] = trim($thisquestion["#"]["GRADABLE"][$j]["#"]["FEEDBACK_WHEN_CORRECT"][0]["#"]);
!             } else {
!                 $question->fraction[$j] = 0;
!                 $question->feedback[$j] = trim($thisquestion["#"]["GRADABLE"][$j]["#"]["FEEDBACK_WHEN_INCORRECT"][0]["#"]);
!             }
!         }
! 
!         $questions[] = $question;
!     }
! }
! 
! //----------------------------------------
! // Process Fill in the Blank Questions
! //----------------------------------------
! function process_fib($xml, &$questions) {
! 
!     if (isset($xml["POOL"]["#"]["QUESTION_FILLINBLANK"])) {
!         $fibquestions = $xml["POOL"]["#"]["QUESTION_FILLINBLANK"];
!     }
!     else {
!         return;
!     }
! 
!     for ($i = 0; $i < sizeof ($fibquestions); $i++) {
!         $question = $this->defaultquestion();
! 
!         $question->qtype = SHORTANSWER;
!         $question->usecase = 0; // Ignore case
! 
!         $thisquestion = $fibquestions[$i];
! 
!         // determine if the question is already escaped html
!         $ishtml = $thisquestion["#"]["BODY"][0]["#"]["FLAGS"][0]["#"]["ISHTML"][0]["@"]["value"];
! 
!         // put questiontext in question object
!         if ($ishtml) {
!             $question->questiontext = html_entity_decode(trim($thisquestion["#"]["BODY"][0]["#"]["TEXT"][0]["#"]),ENT_QUOTES,'UTF-8');
!         }
!         $question->questiontext = $question->questiontext;
!         // put name of question in question object
!         $question->name = shorten_text($question->questiontext, 254);
! 
!         $answer = trim($thisquestion["#"]["ANSWER"][0]["#"]["TEXT"][0]["#"]);
! 
!         $question->answer[] = $answer;
!         $question->fraction[] = 1;
!         $question->feedback = array();
! 
!         if (is_array( $thisquestion['#']['GRADABLE'][0]['#'] )) {
!             $question->feedback[0] = trim($thisquestion["#"]["GRADABLE"][0]["#"]["FEEDBACK_WHEN_CORRECT"][0]["#"]);
!         }
!         else {
!             $question->feedback[0] = '';
!         }
!         if (is_array( $thisquestion["#"]["GRADABLE"][0]["#"] )) {
!             $question->feedback[1] = trim($thisquestion["#"]["GRADABLE"][0]["#"]["FEEDBACK_WHEN_INCORRECT"][0]["#"]);
!         }
!         else {
!             $question->feedback[1] = '';
!         }
! 
!         $questions[] = $question;
!     }
! }
! 
! //----------------------------------------
! // Process Matching Questions
! //----------------------------------------
! function process_matching($xml, &$questions) {
! 
!     if (isset($xml["POOL"]["#"]["QUESTION_MATCH"])) {
!         $matchquestions = $xml["POOL"]["#"]["QUESTION_MATCH"];
!     }
!     else {
!         return;
!     }
! 
!     for ($i = 0; $i < sizeof ($matchquestions); $i++) {
! 
!         $question = $this->defaultquestion();
! 
!         $question->qtype = MATCH;
! 
!         $thisquestion = $matchquestions[$i];
! 
!         // determine if the question is already escaped html
!         $ishtml = $thisquestion["#"]["BODY"][0]["#"]["FLAGS"][0]["#"]["ISHTML"][0]["@"]["value"];
! 
!         // put questiontext in question object
!         if ($ishtml) {
!             $question->questiontext = html_entity_decode(trim($thisquestion["#"]["BODY"][0]["#"]["TEXT"][0]["#"]),ENT_QUOTES,'UTF-8');
!         }
!         $question->questiontext = $question->questiontext;
!         // put name of question in question object
!         $question->name = shorten_text($question->questiontext, 254);
! 
!         $choices = $thisquestion["#"]["CHOICE"];
!         for ($j = 0; $j < sizeof ($choices); $j++) {
! 
!             $subquestion = NULL;
! 
!             $choice = $choices[$j]["#"]["TEXT"][0]["#"];
!             $choice_id = $choices[$j]["@"]["id"];
! 
!             $question->subanswers[] = trim($choice);
! 
!             $correctanswers = $thisquestion["#"]["GRADABLE"][0]["#"]["CORRECTANSWER"];
!             for ($k = 0; $k < sizeof ($correctanswers); $k++) {
! 
!                 if (strcmp($choice_id, $correctanswers[$k]["@"]["choice_id"]) == 0) {
! 
!                     $answer_id = $correctanswers[$k]["@"]["answer_id"];
! 
!                     $answers = $thisquestion["#"]["ANSWER"];
!                     for ($m = 0; $m < sizeof ($answers); $m++) {
! 
!                         $answer = $answers[$m];
!                         $current_ans_id = $answer["@"]["id"];
!                         if (strcmp ($current_ans_id, $answer_id) == 0) {
! 
!                             $answer = $answer["#"]["TEXT"][0]["#"];
!                             $question->subquestions[] = trim($answer);
!                             break;
! 
!                         }
! 
!                     }
! 
!                     break;
! 
!                 }
! 
!             }
! 
!         }
! 
!         $questions[] = $question;
! 
!     }
! }
  
  }
  
--- 18,397 ----
  
  class qformat_blackboard extends qformat_default {
  
! 	function provide_import() {
! 		return true;
! 	}
! 
! 
! 	function readquestions ($lines) {
! 		/// Parses an array of lines into an array of questions,
! 		/// where each item is a question object as defined by
! 		/// readquestion().
! 
! 		$text = implode($lines, " ");
! 		$xml = xmlize($text, 0);
! 
! 		$questions = array();
! 
! 		$this->process_tf($xml, $questions);
! 		$this->process_mc($xml, $questions);
! 		$this->process_ma($xml, $questions);
! 		$this->process_fib($xml, $questions);
! 		$this->process_matching($xml, $questions);
! 		$this->process_essay($xml, $questions);
! 
! 		return $questions;
! 	}
! 
! 	//----------------------------------------
! 	// Process Essay Questions
! 	//----------------------------------------
! 	function process_essay($xml, &$questions ) {
! 
! 		if (isset($xml["POOL"]["#"]["QUESTION_ESSAY"])) {
! 			$essayquestions = $xml["POOL"]["#"]["QUESTION_ESSAY"];
! 		}
! 		else {
! 			return;
! 		}
! 
! 		foreach ($essayquestions as $essayquestion) {
! 
! 			$question = $this->defaultquestion();
! 
! 			$question->qtype = ESSAY;
! 
! 			// determine if the question is already escaped html
! 			$ishtml = $essayquestion["#"]["BODY"][0]["#"]["FLAGS"][0]["#"]["ISHTML"][0]["@"]["value"];
! 
! 			// put questiontext in question object
! 			if ($ishtml) {
! 				$question->questiontext = html_entity_decode(trim($essayquestion["#"]["BODY"][0]["#"]["TEXT"][0]["#"]));
! 			}
! 
! 			// put name in question object
! 			$question->name = substr($question->questiontext, 0, 254);
! 			$question->answer = '';
! 			$question->feedback = '';
! 			$question->fraction = 0;
! 
! 			$questions[] = $question;
! 		}
! 	}
! 
! 	//----------------------------------------
! 	// Process True / False Questions
! 	//----------------------------------------
! 	function process_tf($xml, &$questions) {
! 
! 		if (isset($xml["POOL"]["#"]["QUESTION_TRUEFALSE"])) {
! 			$tfquestions = $xml["POOL"]["#"]["QUESTION_TRUEFALSE"];
! 		}
! 		else {
! 			return;
! 		}
! 
! 		for ($i = 0; $i < sizeof ($tfquestions); $i++) {
! 
! 			$question = $this->defaultquestion();
! 
! 			$question->qtype = TRUEFALSE;
! 			$question->single = 1; // Only one answer is allowed
! 
! 			$thisquestion = $tfquestions[$i];
! 
! 			// determine if the question is already escaped html
! 			$ishtml = $thisquestion["#"]["BODY"][0]["#"]["FLAGS"][0]["#"]["ISHTML"][0]["@"]["value"];
! 
! 			// put questiontext in question object
! 			if ($ishtml) {
! 				$question->questiontext = html_entity_decode(trim($thisquestion["#"]["BODY"][0]["#"]["TEXT"][0]["#"]),ENT_QUOTES,'UTF-8');
! 			}
! 			$question->questiontext = $question->questiontext;
! 			// put name in question object
! 			$question->name = shorten_text($question->questiontext, 254);
! 
! 			$choices = $thisquestion["#"]["ANSWER"];
! 
! 			$correct_answer = $thisquestion["#"]["GRADABLE"][0]["#"]["CORRECTANSWER"][0]["@"]["answer_id"];
! 
! 			// first choice is true, second is false.
! 			$id = $choices[0]["@"]["id"];
! 
! 			if (strcmp($id, $correct_answer) == 0) {  // true is correct
! 				$question->answer = 1;
! 				$question->feedbacktrue = trim(@$thisquestion["#"]["GRADABLE"][0]["#"]["FEEDBACK_WHEN_CORRECT"][0]["#"]);
! 				$question->feedbackfalse = trim(@$thisquestion["#"]["GRADABLE"][0]["#"]["FEEDBACK_WHEN_INCORRECT"][0]["#"]);
! 			} else {  // false is correct
! 				$question->answer = 0;
! 				$question->feedbacktrue = trim(@$thisquestion["#"]["GRADABLE"][0]["#"]["FEEDBACK_WHEN_INCORRECT"][0]["#"]);
! 				$question->feedbackfalse = trim(@$thisquestion["#"]["GRADABLE"][0]["#"]["FEEDBACK_WHEN_CORRECT"][0]["#"]);
! 			}
! 			$question->correctanswer = $question->answer;
! 			$questions[] = $question;
! 		}
! 	}
! 
! 	//----------------------------------------
! 	// Process Multiple Choice Questions
! 	//----------------------------------------
! 	function process_mc($xml, &$questions) {
! 
! 		if (isset($xml["POOL"]["#"]["QUESTION_MULTIPLECHOICE"])) {
! 			$mcquestions = $xml["POOL"]["#"]["QUESTION_MULTIPLECHOICE"];
! 		}
! 		else {
! 			return;
! 		}
! 
! 		for ($i = 0; $i < sizeof ($mcquestions); $i++) {
! 
! 			$question = $this->defaultquestion();
! 
! 			$question->qtype = MULTICHOICE;
! 			$question->single = 1; // Only one answer is allowed
! 
! 			$thisquestion = $mcquestions[$i];
! 
! 			// determine if the question is already escaped html
! 			$ishtml = $thisquestion["#"]["BODY"][0]["#"]["FLAGS"][0]["#"]["ISHTML"][0]["@"]["value"];
! 
! 			// put questiontext in question object
! 			if ($ishtml) {
! 				$question->questiontext = html_entity_decode(trim($thisquestion["#"]["BODY"][0]["#"]["TEXT"][0]["#"]),ENT_QUOTES,'UTF-8');
! 			}
! 			$question->questiontext = $question->questiontext;
! 
! 			// put name of question in question object, careful of length
! 			$question->name = shorten_text($question->questiontext, 254);
! 
! 			$choices = $thisquestion["#"]["ANSWER"];
! 			for ($j = 0; $j < sizeof ($choices); $j++) {
! 
! 				$choice = trim($choices[$j]["#"]["TEXT"][0]["#"]);
! 				// put this choice in the question object.
! 				if ($ishtml) {
! 					$question->answer[$j] = html_entity_decode($choice,ENT_QUOTES,'UTF-8');
! 				}
! 				$question->answer[$j] = $question->answer[$j];
! 
! 				$id = $choices[$j]["@"]["id"];
! 				$correct_answer_id = $thisquestion["#"]["GRADABLE"][0]["#"]["CORRECTANSWER"][0]["@"]["answer_id"];
! 				// if choice is the answer, give 100%, otherwise give 0%
! 				if (strcmp ($id, $correct_answer_id) == 0) {
! 					$question->fraction[$j] = 1;
! 					if ($ishtml) {
! 						$question->feedback[$j] = html_entity_decode(trim(@$thisquestion["#"]["GRADABLE"][0]["#"]["FEEDBACK_WHEN_CORRECT"][0]["#"]),ENT_QUOTES,'UTF-8');
! 					}
! 					$question->feedback[$j] = $question->feedback[$j];
! 				} else {
! 					$question->fraction[$j] = 0;
! 					if ($ishtml) {
! 						$question->feedback[$j] = html_entity_decode(trim(@$thisquestion["#"]["GRADABLE"][0]["#"]["FEEDBACK_WHEN_INCORRECT"][0]["#"]),ENT_QUOTES,'UTF-8');
! 					}
! 					$question->feedback[$j] = $question->feedback[$j];
! 				}
! 			}
! 			$questions[] = $question;
! 		}
! 	}
! 
! 	//----------------------------------------
! 	// Process Multiple Choice Questions With Multiple Answers
! 	//----------------------------------------
! 	function process_ma($xml, &$questions) {
! 
! 		if (isset($xml["POOL"]["#"]["QUESTION_MULTIPLEANSWER"])) {
! 			$maquestions = $xml["POOL"]["#"]["QUESTION_MULTIPLEANSWER"];
! 		}
! 		else {
! 			return;
! 		}
! 
! 		for ($i = 0; $i < sizeof ($maquestions); $i++) {
! 
! 			$question = $this->defaultquestion();
! 
! 			$question->qtype = MULTICHOICE;
! 			$question->defaultgrade = 1;
! 			$question->single = 0; // More than one answers allowed
! 			$question->image = ""; // No images with this format
! 
! 			$thisquestion = $maquestions[$i];
! 
! 			// determine if the question is already escaped html
! 			$ishtml = $thisquestion["#"]["BODY"][0]["#"]["FLAGS"][0]["#"]["ISHTML"][0]["@"]["value"];
! 
! 			// put questiontext in question object
! 			if ($ishtml) {
! 				$question->questiontext = html_entity_decode(trim($thisquestion["#"]["BODY"][0]["#"]["TEXT"][0]["#"]),ENT_QUOTES,'UTF-8');
! 			}
! 			$question->questiontext = $question->questiontext;
! 			// put name of question in question object
! 			$question->name = shorten_text($question->questiontext, 254);
! 
! 			$choices = $thisquestion["#"]["ANSWER"];
! 			$correctanswers = $thisquestion["#"]["GRADABLE"][0]["#"]["CORRECTANSWER"];
! 
! 			for ($j = 0; $j < sizeof ($choices); $j++) {
! 
! 				$choice = trim($choices[$j]["#"]["TEXT"][0]["#"]);
! 				// put this choice in the question object.
! 				$question->answer[$j] = $choice;
! 
! 				$correctanswercount = sizeof($correctanswers);
! 				$id = $choices[$j]["@"]["id"];
! 				$iscorrect = 0;
! 				for ($k = 0; $k < $correctanswercount; $k++) {
! 
! 					$correct_answer_id = trim($correctanswers[$k]["@"]["answer_id"]);
! 					if (strcmp ($id, $correct_answer_id) == 0) {
! 						$iscorrect = 1;
! 					}
! 
! 				}
! 				if ($iscorrect) {
! 					$question->fraction[$j] = floor(100000/$correctanswercount)/100000; // strange behavior if we have more than 5 decimal places
! 					$question->feedback[$j] = trim($thisquestion["#"]["GRADABLE"][$j]["#"]["FEEDBACK_WHEN_CORRECT"][0]["#"]);
! 				} else {
! 					$question->fraction[$j] = 0;
! 					$question->feedback[$j] = trim($thisquestion["#"]["GRADABLE"][$j]["#"]["FEEDBACK_WHEN_INCORRECT"][0]["#"]);
! 				}
! 			}
! 
! 			$questions[] = $question;
! 		}
! 	}
! 
! 	//----------------------------------------
! 	// Process Fill in the Blank Questions
! 	//----------------------------------------
! 	function process_fib($xml, &$questions) {
! 
! 		if (isset($xml["POOL"]["#"]["QUESTION_FILLINBLANK"])) {
! 			$fibquestions = $xml["POOL"]["#"]["QUESTION_FILLINBLANK"];
! 		}
! 		else {
! 			return;
! 		}
! 
! 		for ($i = 0; $i < sizeof ($fibquestions); $i++) {
! 			$question = $this->defaultquestion();
! 
! 			$question->qtype = SHORTANSWER;
! 			$question->usecase = 0; // Ignore case
! 
! 			$thisquestion = $fibquestions[$i];
! 
! 			// determine if the question is already escaped html
! 			$ishtml = $thisquestion["#"]["BODY"][0]["#"]["FLAGS"][0]["#"]["ISHTML"][0]["@"]["value"];
! 
! 			// put questiontext in question object
! 			if ($ishtml) {
! 				$question->questiontext = html_entity_decode(trim($thisquestion["#"]["BODY"][0]["#"]["TEXT"][0]["#"]),ENT_QUOTES,'UTF-8');
! 			}
! 			$question->questiontext = $question->questiontext;
! 			// put name of question in question object
! 			$question->name = shorten_text($question->questiontext, 254);
! 
! 			$answer = trim($thisquestion["#"]["ANSWER"][0]["#"]["TEXT"][0]["#"]);
! 
! 			$question->answer[] = $answer;
! 			$question->fraction[] = 1;
! 			$question->feedback = array();
! 
! 			if (is_array( $thisquestion['#']['GRADABLE'][0]['#'] )) {
! 				$question->feedback[0] = trim($thisquestion["#"]["GRADABLE"][0]["#"]["FEEDBACK_WHEN_CORRECT"][0]["#"]);
! 			}
! 			else {
! 				$question->feedback[0] = '';
! 			}
! 			if (is_array( $thisquestion["#"]["GRADABLE"][0]["#"] )) {
! 				$question->feedback[1] = trim($thisquestion["#"]["GRADABLE"][0]["#"]["FEEDBACK_WHEN_INCORRECT"][0]["#"]);
! 			}
! 			else {
! 				$question->feedback[1] = '';
! 			}
! 
! 			$questions[] = $question;
! 		}
! 	}
! 
! 	//----------------------------------------
! 	// Process Matching Questions
! 	//----------------------------------------
! 	function process_matching($xml, &$questions) {
! 
! 		if (isset($xml["POOL"]["#"]["QUESTION_MATCH"])) {
! 			$matchquestions = $xml["POOL"]["#"]["QUESTION_MATCH"];
! 		}
! 		else {
! 			return;
! 		}
! 
! 		for ($i = 0; $i < sizeof ($matchquestions); $i++) {
! 
! 			$question = $this->defaultquestion();
! 
! 			$question->qtype = MATCH;
! 
! 			$thisquestion = $matchquestions[$i];
! 
! 			// determine if the question is already escaped html
! 			$ishtml = $thisquestion["#"]["BODY"][0]["#"]["FLAGS"][0]["#"]["ISHTML"][0]["@"]["value"];
! 
! 			// put questiontext in question object
! 			if ($ishtml) {
! 				$question->questiontext = html_entity_decode(trim($thisquestion["#"]["BODY"][0]["#"]["TEXT"][0]["#"]),ENT_QUOTES,'UTF-8');
! 			}
! 			$question->questiontext = $question->questiontext;
! 			// put name of question in question object
! 			$question->name = shorten_text($question->questiontext, 254);
! 
! 			$choices = $thisquestion["#"]["CHOICE"];
! 			for ($j = 0; $j < sizeof ($choices); $j++) {
! 
! 				$subquestion = NULL;
! 
! 				$choice = $choices[$j]["#"]["TEXT"][0]["#"];
! 				$choice_id = $choices[$j]["@"]["id"];
! 
! 				$question->subanswers[] = trim($choice);
! 
! 				$correctanswers = $thisquestion["#"]["GRADABLE"][0]["#"]["CORRECTANSWER"];
! 				for ($k = 0; $k < sizeof ($correctanswers); $k++) {
! 
! 					if (strcmp($choice_id, $correctanswers[$k]["@"]["choice_id"]) == 0) {
! 
! 						$answer_id = $correctanswers[$k]["@"]["answer_id"];
! 
! 						$answers = $thisquestion["#"]["ANSWER"];
! 						for ($m = 0; $m < sizeof ($answers); $m++) {
! 
! 							$answer = $answers[$m];
! 							$current_ans_id = $answer["@"]["id"];
! 							if (strcmp ($current_ans_id, $answer_id) == 0) {
! 
! 								$answer = $answer["#"]["TEXT"][0]["#"];
! 								$question->subquestions[] = trim($answer);
! 								break;
! 
! 							}
! 
! 						}
! 
! 						break;
! 
! 					}
  
+ 				}
  
! 			}
  
! 			$questions[] = $question;
  
! 		}
! 	}
  
  }
  
diff -crB questionorg/format/blackboard_six/format.php questionupd/format/blackboard_six/format.php
*** questionorg/format/blackboard_six/format.php	2012-04-13 12:31:11.289178254 +0500
--- questionupd/format/blackboard_six/format.php	2012-04-13 09:42:52.000000000 +0500
***************
*** 16,924 ****
  require_once ("$CFG->libdir/xmlize.php");
  
  class qformat_blackboard_six extends qformat_default {
!     function provide_import() {
!         return true;
!     }
! 
! 
!     //Function to check and create the needed dir to unzip file to
!     function check_and_create_import_dir($unique_code) {
! 
!         global $CFG;
! 
!         $status = $this->check_dir_exists($CFG->dataroot."/temp",true);
!         if ($status) {
!             $status = $this->check_dir_exists($CFG->dataroot."/temp/bbquiz_import",true);
!         }
!         if ($status) {
!             $status = $this->check_dir_exists($CFG->dataroot."/temp/bbquiz_import/".$unique_code,true);
!         }
! 
!         return $status;
!     }
! 
!     function clean_temp_dir($dir='') {
!         global $CFG;
! 
!         // for now we will just say everything happened okay note
!         // that a mess may be piling up in $CFG->dataroot/temp/bbquiz_import
!         // TODO return true at top of the function renders all the following code useless
!         return true;
! 
!         if ($dir == '') {
!             $dir = $this->temp_dir;
!         }
!         $slash = "/";
! 
!         // Create arrays to store files and directories
!         $dir_files      = array();
!         $dir_subdirs    = array();
! 
!         // Make sure we can delete it
!         chmod($dir, $CFG->directorypermissions);
! 
!         if ((($handle = opendir($dir))) == FALSE) {
!             // The directory could not be opened
!             return false;
!         }
! 
!         // Loop through all directory entries, and construct two temporary arrays containing files and sub directories
!         while(false !== ($entry = readdir($handle))) {
!             if (is_dir($dir. $slash .$entry) && $entry != ".." && $entry != ".") {
!                 $dir_subdirs[] = $dir. $slash .$entry;
!             }
!             else if ($entry != ".." && $entry != ".") {
!                 $dir_files[] = $dir. $slash .$entry;
!             }
!         }
! 
!         // Delete all files in the curent directory return false and halt if a file cannot be removed
!         $countdir_files = count($dir_files);
!         for($i=0; $i<$countdir_files; $i++) {
!             chmod($dir_files[$i], $CFG->directorypermissions);
!             if (((unlink($dir_files[$i]))) == FALSE) {
!                 return false;
!             }
!         }
! 
!         // Empty sub directories and then remove the directory
!         $countdir_subdirs = count($dir_subdirs);
!         for($i=0; $i<$countdir_subdirs; $i++) {
!             chmod($dir_subdirs[$i], $CFG->directorypermissions);
!             if ($this->clean_temp_dir($dir_subdirs[$i]) == FALSE) {
!                 return false;
!             }
!             else {
!                 if (rmdir($dir_subdirs[$i]) == FALSE) {
!                 return false;
!                 }
!             }
!         }
! 
!         // Close directory
!         closedir($handle);
!         if (rmdir($this->temp_dir) == FALSE) {
!             return false;
!         }
!         // Success, every thing is gone return true
!         return true;
!     }
! 
!     //Function to check if a directory exists and, optionally, create it
!     function check_dir_exists($dir,$create=false) {
! 
!         global $CFG;
! 
!         $status = true;
!         if(!is_dir($dir)) {
!             if (!$create) {
!                 $status = false;
!             } else {
!                 umask(0000);
!                 $status = mkdir ($dir,$CFG->directorypermissions);
!             }
!         }
!         return $status;
!     }
! 
!     function importpostprocess() {
!     /// Does any post-processing that may be desired
!     /// Argument is a simple array of question ids that
!     /// have just been added.
! 
!         // need to clean up temporary directory
!         return $this->clean_temp_dir();
!     }
! 
!     function copy_file_to_course($filename) {
!         global $CFG, $COURSE;
!         $filename = str_replace('\\','/',$filename);
!         $fullpath = $this->temp_dir.'/res00001/'.$filename;
!         $basename = basename($filename);
! 
!         $copy_to = $CFG->dataroot.'/'.$COURSE->id.'/bb_import';
! 
!         if ($this->check_dir_exists($copy_to,true)) {
!             if(is_readable($fullpath)) {
!                 $copy_to.= '/'.$basename;
!                 if (!copy($fullpath, $copy_to)) {
!                     return false;
!                 }
!                 else {
!                     return $copy_to;
!                 }
!             }
!         }
!         else {
!             return false;
!         }
!     }
! 
!     function readdata($filename) {
!     /// Returns complete file with an array, one item per line
!         global $CFG;
! 
!         // if the extension is .dat we just return that,
!         // if .zip we unzip the file and get the data
!         $ext = substr($this->realfilename, strpos($this->realfilename,'.'), strlen($this->realfilename)-1);
!         if ($ext=='.dat') {
!             if (!is_readable($filename)) {
!                 print_error('filenotreadable', 'error');
!             }
!             return file($filename);
!         }
! 
!         $unique_code = time();
!         $temp_dir = $CFG->dataroot."/temp/bbquiz_import/".$unique_code;
!         $this->temp_dir = $temp_dir;
!         if ($this->check_and_create_import_dir($unique_code)) {
!             if(is_readable($filename)) {
!                 if (!copy($filename, "$temp_dir/bboard.zip")) {
!                     print_error('cannotcopybackup', 'question');
!                 }
!                 if(unzip_file("$temp_dir/bboard.zip", '', false)) {
!                     // assuming that the information is in res0001.dat
!                     // after looking at 6 examples this was always the case
!                     $q_file = "$temp_dir/res00001.dat";
!                     if (is_file($q_file)) {
!                         if (is_readable($q_file)) {
!                             $filearray = file($q_file);
!                             /// Check for Macintosh OS line returns (ie file on one line), and fix
!                             if (preg_match("~\r~", $filearray[0]) AND !preg_match("~\n~", $filearray[0])) {
!                                 return explode("\r", $filearray[0]);
!                             } else {
!                                 return $filearray;
!                             }
!                         }
!                     }
!                     else {
!                         print_error('cannotfindquestionfile', 'questioni');
!                     }
!                 }
!                 else {
!                     print "filename: $filename<br />tempdir: $temp_dir <br />";
!                     print_error('cannotunzip', 'question');
!                 }
!             }
!             else {
!                 print_error('cannotreaduploadfile');
!             }
!         }
!         else {
!             print_error('cannotcreatetempdir');
!         }
!     }
! 
!     function save_question_options($question) {
!         return true;
!     }
! 
! 
! 
!   function readquestions ($lines) {
!     /// Parses an array of lines into an array of questions,
!     /// where each item is a question object as defined by
!     /// readquestion().
! 
!     $text = implode($lines, " ");
!     $xml = xmlize($text, 0);
! 
!     $raw_questions = $xml['questestinterop']['#']['assessment'][0]['#']['section'][0]['#']['item'];
!     $questions = array();
! 
!     foreach($raw_questions as $quest) {
!         $question = $this->create_raw_question($quest);
! 
!         switch($question->qtype) {
!             case "Matching":
!                 $this->process_matching($question, $questions);
!                 break;
!             case "Multiple Choice":
!                 $this->process_mc($question, $questions);
!                 break;
!             case "Essay":
!                 $this->process_essay($question, $questions);
!                 break;
!             case "Multiple Answer":
!                 $this->process_ma($question, $questions);
!                 break;
!             case "True/False":
!                 $this->process_tf($question, $questions);
!                 break;
!             case 'Fill in the Blank':
!                 $this->process_fblank($question, $questions);
!                 break;
!             case 'Short Response':
!                 $this->process_essay($question, $questions);
!                 break;
!             default:
!                 print "Unknown or unhandled question type: \"$question->qtype\"<br />";
!                 break;
!         }
! 
!     }
!     return $questions;
!   }
! 
! 
! // creates a cleaner object to deal with for processing into moodle
! // the object created is NOT a moodle question object
! function create_raw_question($quest) {
! 
!     $question = new StdClass;
!     $question->qtype = $quest['#']['itemmetadata'][0]['#']['bbmd_questiontype'][0]['#'];
!     $question->id = $quest['#']['itemmetadata'][0]['#']['bbmd_asi_object_id'][0]['#'];
!     $presentation->blocks = $quest['#']['presentation'][0]['#']['flow'][0]['#']['flow'];
! 
!     foreach($presentation->blocks as $pblock) {
! 
!         $block = NULL;
!         $block->type = $pblock['@']['class'];
! 
!         switch($block->type) {
!             case 'QUESTION_BLOCK':
!                 $sub_blocks = $pblock['#']['flow'];
!                 foreach($sub_blocks as $sblock) {
!                     //echo "Calling process_block from line 263<br>";
!                     $this->process_block($sblock, $block);
!                 }
!                 break;
! 
!             case 'RESPONSE_BLOCK':
!                 $choices = NULL;
!                 switch($question->qtype) {
!                     case 'Matching':
!                         $bb_subquestions = $pblock['#']['flow'];
!                         $sub_questions = array();
!                         foreach($bb_subquestions as $bb_subquestion) {
!                             $sub_question = NULL;
!                             $sub_question->ident = $bb_subquestion['#']['response_lid'][0]['@']['ident'];
!                             $this->process_block($bb_subquestion['#']['flow'][0], $sub_question);
!                             $bb_choices = $bb_subquestion['#']['response_lid'][0]['#']['render_choice'][0]['#']['flow_label'][0]['#']['response_label'];
!                             $choices = array();
!                             $this->process_choices($bb_choices, $choices);
!                             $sub_question->choices = $choices;
!                             if (!isset($block->subquestions)) {
!                                 $block->subquestions = array();
!                             }
!                             $block->subquestions[] = $sub_question;
!                         }
!                         break;
!                     case 'Multiple Answer':
!                         $bb_choices = $pblock['#']['response_lid'][0]['#']['render_choice'][0]['#']['flow_label'];
!                         $choices = array();
!                         $this->process_choices($bb_choices, $choices);
!                         $block->choices = $choices;
!                         break;
!                     case 'Essay':
!                         // Doesn't apply since the user responds with text input
!                         break;
!                     case 'Multiple Choice':
!                         $mc_choices = $pblock['#']['response_lid'][0]['#']['render_choice'][0]['#']['flow_label'];
!                             foreach($mc_choices as $mc_choice) {
!                             $choices = NULL;
!                             $choices = $this->process_block($mc_choice, $choices);
!                             $block->choices[] = $choices;
!                         }
!                         break;
!                     case 'Short Response':
!                         // do nothing?
!                         break;
!                     case 'Fill in the Blank':
!                         // do nothing?
!                         break;
!                     default:
!                         $bb_choices = $pblock['#']['response_lid'][0]['#']['render_choice'][0]['#']['flow_label'][0]['#']['response_label'];
!                         $choices = array();
!                         $this->process_choices($bb_choices, $choices);
!                         $block->choices = $choices;
!                 }
!                 break;
!             case 'RIGHT_MATCH_BLOCK':
!                 $matching_answerset = $pblock['#']['flow'];
! 
!                 $answerset = array();
!                 foreach($matching_answerset as $answer) {
!                     // $answerset[] = $this->process_block($answer, $bb_answer);
!                     $bb_answer = null;
!                     $bb_answer->text = $answer['#']['flow'][0]['#']['material'][0]['#']['mat_extension'][0]['#']['mat_formattedtext'][0]['#'];
!                     $answerset[] = $bb_answer;
!                 }
!                 $block->matching_answerset = $answerset;
!                 break;
!             default:
!                 print "UNHANDLED PRESENTATION BLOCK";
!                 break;
!         }
!         $question->{$block->type} = $block;
!     }
! 
!     // determine response processing
!     // there is a section called 'outcomes' that I don't know what to do with
!     $resprocessing = $quest['#']['resprocessing'];
!     $respconditions = $resprocessing[0]['#']['respcondition'];
!     $reponses = array();
!     if ($question->qtype == 'Matching') {
!         $this->process_matching_responses($respconditions, $responses);
!     }
!     else {
!         $this->process_responses($respconditions, $responses);
!     }
!     $question->responses = $responses;
!     $feedbackset = $quest['#']['itemfeedback'];
!     $feedbacks = array();
!     $this->process_feedback($feedbackset, $feedbacks);
!     $question->feedback = $feedbacks;
!     return $question;
! }
! 
! function process_block($cur_block, &$block) {
!     global $COURSE, $CFG;
! 
!     $cur_type = $cur_block['@']['class'];
!     switch($cur_type) {
!         case 'FORMATTED_TEXT_BLOCK':
!             $block->text = $this->strip_applet_tags_get_mathml($cur_block['#']['material'][0]['#']['mat_extension'][0]['#']['mat_formattedtext'][0]['#']);
!             break;
!         case 'FILE_BLOCK':
!             //revisit this to make sure it is working correctly
!             // Commented out ['matapplication']..., etc. because I
!             // noticed that when I imported a new Blackboard 6 file
!             // and printed out the block, the tree did not extend past ['material'][0]['#'] - CT 8/3/06
!             $block->file = $cur_block['#']['material'][0]['#'];//['matapplication'][0]['@']['uri'];
!             if ($block->file != '') {
!                 // if we have a file copy it to the course dir and adjust its name to be visible over the web.
!                 $block->file = $this->copy_file_to_course($block->file);
!                 $block->file = $CFG->wwwroot.'/file.php/'.$COURSE->id.'/bb_import/'.basename($block->file);
!             }
!             break;
!         case 'Block':
!             if (isset($cur_block['#']['material'][0]['#']['mattext'][0]['#'])) {
!             $block->text = $cur_block['#']['material'][0]['#']['mattext'][0]['#'];
!             }
!             else if (isset($cur_block['#']['material'][0]['#']['mat_extension'][0]['#']['mat_formattedtext'][0]['#'])) {
!                 $block->text = $cur_block['#']['material'][0]['#']['mat_extension'][0]['#']['mat_formattedtext'][0]['#'];
!             }
!             else if (isset($cur_block['#']['response_label'])) {
!                 // this is a response label block
!                 $sub_blocks = $cur_block['#']['response_label'][0];
!                 if(!isset($block->ident)) {
!                     if(isset($sub_blocks['@']['ident'])) {
!                         $block->ident = $sub_blocks['@']['ident'];
!                     }
!                 }
!                 foreach($sub_blocks['#']['flow_mat'] as $sub_block) {
!                     $this->process_block($sub_block, $block);
!                 }
!             }
!             else {
!                 if (isset($cur_block['#']['flow_mat']) || isset($cur_block['#']['flow'])) {
!                     if (isset($cur_block['#']['flow_mat'])) {
!                         $sub_blocks = $cur_block['#']['flow_mat'];
!                     }
!                     elseif (isset($cur_block['#']['flow'])) {
!                         $sub_blocks = $cur_block['#']['flow'];
!                     }
!                    foreach ($sub_blocks as $sblock) {
!                         // this will recursively grab the sub blocks which should be of one of the other types
!                         $this->process_block($sblock, $block);
!                     }
!                 }
!             }
!             break;
!         case 'LINK_BLOCK':
!             // not sure how this should be included
!             if (!empty($cur_block['#']['material'][0]['#']['mattext'][0]['@']['uri'])) {
!                 $block->link = $cur_block['#']['material'][0]['#']['mattext'][0]['@']['uri'];
!             }
!             else {
!                $block->link = '';
!             }
!             break;
!     }
!     return $block;
! }
! 
! function process_choices($bb_choices, &$choices) {
!     foreach($bb_choices as $choice) {
!             if (isset($choice['@']['ident'])) {
!             $cur_choice = $choice['@']['ident'];
!         }
!         else { //for multiple answer
!             $cur_choice = $choice['#']['response_label'][0];//['@']['ident'];
!         }
!         if (isset($choice['#']['flow_mat'][0])) { //for multiple answer
!             $cur_block = $choice['#']['flow_mat'][0];
!             // Reset $cur_choice to NULL because process_block is expecting an object
!             // for the second argument and not a string, which is what is was set as
!             // originally - CT 8/7/06
!             $cur_choice = null;
!             $this->process_block($cur_block, $cur_choice);
!         }
!         elseif (isset($choice['#']['response_label'])) {
!             // Reset $cur_choice to NULL because process_block is expecting an object
!             // for the second argument and not a string, which is what is was set as
!             // originally - CT 8/7/06
!             $cur_choice = null;
!             $this->process_block($choice, $cur_choice);
!         }
!         $choices[] = $cur_choice;
!     }
! }
! 
! function process_matching_responses($bb_responses, &$responses) {
!     foreach($bb_responses as $bb_response) {
!         $response = NULL;
!         if (isset($bb_response['#']['conditionvar'][0]['#']['varequal'])) {
!             $response->correct = $bb_response['#']['conditionvar'][0]['#']['varequal'][0]['#'];
!             $response->ident = $bb_response['#']['conditionvar'][0]['#']['varequal'][0]['@']['respident'];
!         }
!         else {
!             $response->correct =  'Broken Question?';
!             $response->ident = 'Broken Question?';
!         }
!         $response->feedback = $bb_response['#']['displayfeedback'][0]['@']['linkrefid'];
!         $responses[] = $response;
!     }
! }
! 
! function process_responses($bb_responses, &$responses) {
!     foreach($bb_responses as $bb_response) {
!         //Added this line to instantiate $response.
!         // Without instantiating the $response variable, the same object
!         // gets added to the array
!         $response = null;
!         if (isset($bb_response['@']['title'])) {
!                 $response->title = $bb_response['@']['title'];
!             }
!             else {
!                 $reponse->title = $bb_response['#']['displayfeedback'][0]['@']['linkrefid'];
!             }
!             $reponse->ident = array();
!             if (isset($bb_response['#']['conditionvar'][0]['#'])){//['varequal'][0]['#'])) {
!                 $response->ident[0] = $bb_response['#']['conditionvar'][0]['#'];//['varequal'][0]['#'];
!             }
!             else if (isset($bb_response['#']['conditionvar'][0]['#']['other'][0]['#'])) {
!                 $response->ident[0] = $bb_response['#']['conditionvar'][0]['#']['other'][0]['#'];
!             }
! 
!             if (isset($bb_response['#']['conditionvar'][0]['#']['and'])){//[0]['#'])) {
!                 $responseset = $bb_response['#']['conditionvar'][0]['#']['and'];//[0]['#']['varequal'];
!                 foreach($responseset as $rs) {
!                     $response->ident[] = $rs['#'];
!                     if(!isset($response->feedback) and isset( $rs['@'] ) ) {
!                         $response->feedback = $rs['@']['respident'];
!                     }
!                 }
!             }
!             else {
!                 $response->feedback = $bb_response['#']['displayfeedback'][0]['@']['linkrefid'];
!             }
! 
!             // determine what point value to give response
!             if (isset($bb_response['#']['setvar'])) {
!                 switch ($bb_response['#']['setvar'][0]['#']) {
!                     case "SCORE.max":
!                         $response->fraction = 1;
!                         break;
!                     default:
!                         // I have only seen this being 0 or unset
!                         // there are probably fractional values of SCORE.max, but I'm not sure what they look like
!                         $response->fraction = 0;
!                         break;
!                 }
!             }
!             else {
!                // just going to assume this is the case this is probably not correct.
!                $response->fraction = 0;
!             }
! 
!             $responses[] = $response;
!         }
! }
! 
! function process_feedback($feedbackset, &$feedbacks) {
!     foreach($feedbackset as $bb_feedback) {
!         // Added line $feedback=null so that $feedback does not get reused in the loop
!         // and added the the $feedbacks[] array multiple times
!         $feedback = null;
!         $feedback->ident = $bb_feedback['@']['ident'];
!         if (isset($bb_feedback['#']['flow_mat'][0])) {
!             $this->process_block($bb_feedback['#']['flow_mat'][0], $feedback);
!         }
!         elseif (isset($bb_feedback['#']['solution'][0]['#']['solutionmaterial'][0]['#']['flow_mat'][0])) {
!             $this->process_block($bb_feedback['#']['solution'][0]['#']['solutionmaterial'][0]['#']['flow_mat'][0], $feedback);
!         }
!         $feedbacks[] = $feedback;
!     }
! }
! 
! /**
!  * Create common parts of question
!  */
! function process_common( $quest ) {
!     $question = $this->defaultquestion();
!     $question->questiontext = $quest->QUESTION_BLOCK->text;
!     $question->name = shorten_text( $quest->id, 250 );
! 
!     return $question;
! }
! 
! //----------------------------------------
! // Process True / False Questions
! //----------------------------------------
! function process_tf($quest, &$questions) {
!     $question = $this->process_common( $quest );
! 
!     $question->qtype = TRUEFALSE;
!     $question->single = 1; // Only one answer is allowed
!     // 0th [response] is the correct answer.
!     $responses = $quest->responses;
!     $correctresponse = $responses[0]->ident[0]['varequal'][0]['#'];
!     if ($correctresponse != 'false') {
!         $correct = true;
!     }
!     else {
!         $correct = false;
!     }
! 
!     foreach($quest->feedback as $fb) {
!         $fback->{$fb->ident} = $fb->text;
!     }
! 
!     if ($correct) {  // true is correct
!         $question->answer = 1;
!         $question->feedbacktrue = $fback->correct;
!         $question->feedbackfalse = $fback->incorrect;
!     } else {  // false is correct
!         $question->answer = 0;
!         $question->feedbacktrue = $fback->incorrect;
!         $question->feedbackfalse = $fback->correct;
!     }
!     $question->correctanswer = $question->answer;
!     $questions[] = $question;
! }
! 
! 
! //----------------------------------------
! // Process Fill in the Blank
! //----------------------------------------
! function process_fblank($quest, &$questions) {
!     $question = $this->process_common( $quest );
!     $question->qtype = SHORTANSWER;
!     $question->single = 1;
! 
!     $answers = array();
!     $fractions = array();
!     $feedbacks = array();
! 
!     // extract the feedback
!     $feedback = array();
!     foreach($quest->feedback as $fback) {
!         if (isset($fback->ident)) {
!             if ($fback->ident == 'correct' || $fback->ident == 'incorrect') {
!                 $feedback[$fback->ident] = $fback->text;
!             }
!         }
!     }
! 
!     foreach($quest->responses as $response) {
!         if(isset($response->title)) {
!             if (isset($response->ident[0]['varequal'][0]['#'])) {
!                 //for BB Fill in the Blank, only interested in correct answers
!                 if ($response->feedback = 'correct') {
!                     $answers[] = $response->ident[0]['varequal'][0]['#'];
!                     $fractions[] = 1;
!                     if (isset($feedback['correct'])) {
!                         $feedbacks[] = $feedback['correct'];
!                     }
!                     else {
!                         $feedbacks[] = '';
!                     }
!                 }
!             }
! 
!         }
!     }
! 
!     //Adding catchall to so that students can see feedback for incorrect answers when they enter something the
!     //instructor did not enter
!     $answers[] = '*';
!     $fractions[] = 0;
!     if (isset($feedback['incorrect'])) {
!         $feedbacks[] = $feedback['incorrect'];
!     }
!     else {
!         $feedbacks[] = '';
!     }
! 
!     $question->answer = $answers;
!     $question->fraction = $fractions;
!     $question->feedback = $feedbacks; // Changed to assign $feedbacks to $question->feedback instead of
! 
!     if (!empty($question)) {
!         $questions[] = $question;
!     }
! 
! }
! 
! //----------------------------------------
! // Process Multiple Choice Questions
! //----------------------------------------
! function process_mc($quest, &$questions) {
!     $question = $this->process_common( $quest );
!     $question->qtype = MULTICHOICE;
!     $question->single = 1;
! 
!     $feedback = array();
!     foreach($quest->feedback as $fback) {
!         $feedback[$fback->ident] = $fback->text;
!     }
! 
!     foreach($quest->responses as $response) {
!         if (isset($response->title)) {
!             if ($response->title == 'correct') {
!                 // only one answer possible for this qtype so first index is correct answer
!                 $correct = $response->ident[0]['varequal'][0]['#'];
!             }
!         }
!         else {
!             // fallback method for when the title is not set
!             if ($response->feedback == 'correct') {
!                // only one answer possible for this qtype so first index is correct answer
!                $correct = $response->ident[0]['varequal'][0]['#']; // added [0]['varequal'][0]['#'] to $response->ident - CT 8/9/06
!             }
!         }
!     }
! 
!     $i = 0;
!     foreach($quest->RESPONSE_BLOCK->choices as $response) {
!         $question->answer[$i] = $response->text;
!         if ($correct == $response->ident) {
!             $question->fraction[$i] = 1;
!             // this is a bit of a hack to catch the feedback... first we see if a 'correct' feedback exists
!             // then specific feedback for this question (maybe this should be switched?, but from my example
!             // question pools I have not seen response specific feedback, only correct or incorrect feedback
!             if (!empty($feedback['correct'])) {
!                 $question->feedback[$i] = $feedback['correct'];
!             }
!             elseif (!empty($feedback[$i])) {
!                 $question->feedback[$i] = $feedback[$i];
!             }
!             else {
!                 // failsafe feedback (should be '' instead?)
!                 $question->feedback[$i] = "correct";
!             }
!         }
!         else {
!             $question->fraction[$i] = 0;
!             if (!empty($feedback['incorrect'])) {
!                 $question->feedback[$i] = $feedback['incorrect'];
!             }
!             elseif (!empty($feedback[$i])) {
!                 $question->feedback[$i] = $feedback[$i];
!             }
!             else {
!                 // failsafe feedback (should be '' instead?)
!                 $question->feedback[$i] = 'incorrect';
!             }
!         }
!         $i++;
!     }
! 
!     if (!empty($question)) {
!         $questions[] = $question;
!     }
! }
! 
! //----------------------------------------
! // Process Multiple Choice Questions With Multiple Answers
! //----------------------------------------
! function process_ma($quest, &$questions) {
!     $question = $this->process_common( $quest ); // copied this from process_mc
!     $question->qtype = MULTICHOICE;
!     $question->single = 0; // More than one answer allowed
! 
!     $answers = $quest->responses;
!     $correct_answers = array();
!     foreach($answers as $answer) {
!         if($answer->title == 'correct') {
!             $answerset = $answer->ident[0]['and'][0]['#']['varequal'];
!             foreach($answerset as $ans) {
!                 $correct_answers[] = $ans['#'];
!             }
!         }
!     }
! 
!     foreach ($quest->feedback as $fb) {
!         $feedback->{$fb->ident} = trim($fb->text);
!     }
! 
!     $correct_answer_count = count($correct_answers);
!     $choiceset = $quest->RESPONSE_BLOCK->choices;
!     $i = 0;
!     foreach($choiceset as $choice) {
!         $question->answer[$i] = trim($choice->text);
!         if (in_array($choice->ident, $correct_answers)) {
!             // correct answer
!             $question->fraction[$i] = floor(100000/$correct_answer_count)/100000; // strange behavior if we have more than 5 decimal places
!             $question->feedback[$i] = $feedback->correct;
!         }
!         else {
!             // wrong answer
!             $question->fraction[$i] = 0;
!             $question->feedback[$i] = $feedback->incorrect;
!         }
!         $i++;
!     }
! 
!     $questions[] = $question;
! }
! 
! //----------------------------------------
! // Process Essay Questions
! //----------------------------------------
! function process_essay($quest, &$questions) {
! // this should be rewritten to accomodate moodle 1.6 essay question type eventually
! 
!     if (defined("ESSAY")) {
!         // treat as short answer
!         $question = $this->process_common( $quest ); // copied this from process_mc
!         $question->qtype = ESSAY;
! 
!         $question->feedback = array();
!         // not sure where to get the correct answer from
!         foreach($quest->feedback as $feedback) {
!             // Added this code to put the possible solution that the
!             // instructor gives as the Moodle answer for an essay question
!             if ($feedback->ident == 'solution') {
!                 $question->feedback = $feedback->text;
!             }
!         }
!         //Added because essay/questiontype.php:save_question_option is expecting a
!         //fraction property - CT 8/10/06
!         $question->fraction[] = 1;
!         if (!empty($question)) {
!             $questions[]=$question;
!         }
!     }
!     else {
!         print "Essay question types are not handled because the quiz question type 'Essay' does not exist in this installation of Moodle<br/>";
!         print "&nbsp;&nbsp;&nbsp;&nbsp;Omitted Question: ".$quest->QUESTION_BLOCK->text.'<br/><br/>';
!     }
! }
! 
! //----------------------------------------
! // Process Matching Questions
! //----------------------------------------
! function process_matching($quest, &$questions) {
!     global $QTYPES;
! 
!     // renderedmatch is an optional plugin, so we need to check if it is defined
!     if (array_key_exists('renderedmatch', $QTYPES)) {
!         $question = $this->process_common( $quest );
!         $question->valid = true;
!         $question->qtype = 'renderedmatch';
! 
!         foreach($quest->RESPONSE_BLOCK->subquestions as $qid => $subq) {
!             foreach($quest->responses as $rid => $resp) {
!                 if ($resp->ident == $subq->ident) {
!                     $correct = $resp->correct;
!                     $feedback = $resp->feedback;
!                 }
!             }
! 
!             foreach($subq->choices as $cid => $choice) {
!                 if ($choice == $correct) {
!                     $question->subquestions[] = $subq->text;
!                     $question->subanswers[] = $quest->RIGHT_MATCH_BLOCK->matching_answerset[$cid]->text;
!                 }
!             }
!         }
! 
!         // check format
!         $status = true;
!         if ( count($quest->RESPONSE_BLOCK->subquestions) > count($quest->RIGHT_MATCH_BLOCK->matching_answerset) || count($question->subquestions) < 2) {
!             $status = false;
!         }
!         else {
!             // need to redo to make sure that no two questions have the same answer (rudimentary now)
!             foreach($question->subanswers as $qstn) {
!                 if(isset($previous)) {
!                     if ($qstn == $previous) {
!                         $status = false;
!                     }
!                 }
!                 $previous = $qstn;
!                 if ($qstn == '') {
!                     $status = false;
!                 }
!             }
!         }
! 
!         if ($status) {
!             $questions[] = $question;
!         }
!         else {
!             global $COURSE, $CFG;
!             print '<table class="boxaligncenter" border="1">';
!             print '<tr><td colspan="2" style="background-color:#FF8888;">This matching question is malformed. Please ensure there are no blank answers, no two questions have the same answer, and/or there are correct answers for each question. There must be at least as many subanswers as subquestions, and at least one subquestion.</td></tr>';
! 
!             print "<tr><td>Question:</td><td>".$quest->QUESTION_BLOCK->text;
!             if (isset($quest->QUESTION_BLOCK->file)) {
!                 print '<br/><font color="red">There is a subfile contained in the zipfile that has been copied to course files: bb_import/'.basename($quest->QUESTION_BLOCK->file).'</font>';
!                 if (preg_match('/(gif|jpg|jpeg|png)$/i', $quest->QUESTION_BLOCK->file)) {
!                     print '<img src="'.$CFG->wwwroot.'/file.php/'.$COURSE->id.'/bb_import/'.basename($quest->QUESTION_BLOCK->file).'" />';
!                 }
!             }
!             print "</td></tr>";
!             print "<tr><td>Subquestions:</td><td><ul>";
!             foreach($quest->responses as $rs) {
!                 $correct_responses->{$rs->ident} = $rs->correct;
!             }
!             foreach($quest->RESPONSE_BLOCK->subquestions as $subq) {
!                 print '<li>'.$subq->text.'<ul>';
!                 foreach($subq->choices as $id=>$choice) {
!                     print '<li>';
!                     if ($choice == $correct_responses->{$subq->ident}) {
!                         print '<font color="green">';
!                     }
!                     else {
!                         print '<font color="red">';
!                     }
!                     print $quest->RIGHT_MATCH_BLOCK->matching_answerset[$id]->text.'</font></li>';
!                 }
!                 print '</ul>';
!             }
!             print '</ul></td></tr>';
! 
!             print '<tr><td>Feedback:</td><td><ul>';
!             foreach($quest->feedback as $fb) {
!                 print '<li>'.$fb->ident.': '.$fb->text.'</li>';
!             }
!             print '</ul></td></tr></table>';
!         }
!     }
!     else {
!         print "Matching question types are not handled because the quiz question type 'Rendered Matching' does not exist in this installation of Moodle<br/>";
!         print "&nbsp;&nbsp;&nbsp;&nbsp;Omitted Question: ".$quest->QUESTION_BLOCK->text.'<br/><br/>';
!     }
! }
! 
! 
! function strip_applet_tags_get_mathml($string) {
!     if(stristr($string, '</APPLET>') === FALSE) {
!         return $string;
!     }
!     else {
!         // strip all applet tags keeping stuff before/after and inbetween (if mathml) them
!         while (stristr($string, '</APPLET>') !== FALSE) {
!             preg_match("/(.*)\<applet.*value=\"(\<math\>.*\<\/math\>)\".*\<\/applet\>(.*)/i",$string, $mathmls);
!             $string = $mathmls[1].$mathmls[2].$mathmls[3];
!         }
!         return $string;
!     }
! }
  
  } // close object
  
--- 16,924 ----
  require_once ("$CFG->libdir/xmlize.php");
  
  class qformat_blackboard_six extends qformat_default {
! 	function provide_import() {
! 		return true;
! 	}
! 
! 
! 	//Function to check and create the needed dir to unzip file to
! 	function check_and_create_import_dir($unique_code) {
! 
! 		global $CFG;
! 
! 		$status = $this->check_dir_exists($CFG->dataroot."/temp",true);
! 		if ($status) {
! 			$status = $this->check_dir_exists($CFG->dataroot."/temp/bbquiz_import",true);
! 		}
! 		if ($status) {
! 			$status = $this->check_dir_exists($CFG->dataroot."/temp/bbquiz_import/".$unique_code,true);
! 		}
! 
! 		return $status;
! 	}
! 
! 	function clean_temp_dir($dir='') {
! 		global $CFG;
! 
! 		// for now we will just say everything happened okay note
! 		// that a mess may be piling up in $CFG->dataroot/temp/bbquiz_import
! 		// TODO return true at top of the function renders all the following code useless
! 		return true;
! 
! 		if ($dir == '') {
! 			$dir = $this->temp_dir;
! 		}
! 		$slash = "/";
! 
! 		// Create arrays to store files and directories
! 		$dir_files      = array();
! 		$dir_subdirs    = array();
! 
! 		// Make sure we can delete it
! 		chmod($dir, $CFG->directorypermissions);
! 
! 		if ((($handle = opendir($dir))) == FALSE) {
! 			// The directory could not be opened
! 			return false;
! 		}
! 
! 		// Loop through all directory entries, and construct two temporary arrays containing files and sub directories
! 		while(false !== ($entry = readdir($handle))) {
! 			if (is_dir($dir. $slash .$entry) && $entry != ".." && $entry != ".") {
! 				$dir_subdirs[] = $dir. $slash .$entry;
! 			}
! 			else if ($entry != ".." && $entry != ".") {
! 				$dir_files[] = $dir. $slash .$entry;
! 			}
! 		}
! 
! 		// Delete all files in the curent directory return false and halt if a file cannot be removed
! 		$countdir_files = count($dir_files);
! 		for($i=0; $i<$countdir_files; $i++) {
! 			chmod($dir_files[$i], $CFG->directorypermissions);
! 			if (((unlink($dir_files[$i]))) == FALSE) {
! 				return false;
! 			}
! 		}
! 
! 		// Empty sub directories and then remove the directory
! 		$countdir_subdirs = count($dir_subdirs);
! 		for($i=0; $i<$countdir_subdirs; $i++) {
! 			chmod($dir_subdirs[$i], $CFG->directorypermissions);
! 			if ($this->clean_temp_dir($dir_subdirs[$i]) == FALSE) {
! 				return false;
! 			}
! 			else {
! 				if (rmdir($dir_subdirs[$i]) == FALSE) {
! 					return false;
! 				}
! 			}
! 		}
! 
! 		// Close directory
! 		closedir($handle);
! 		if (rmdir($this->temp_dir) == FALSE) {
! 			return false;
! 		}
! 		// Success, every thing is gone return true
! 		return true;
! 	}
! 
! 	//Function to check if a directory exists and, optionally, create it
! 	function check_dir_exists($dir,$create=false) {
! 
! 		global $CFG;
! 
! 		$status = true;
! 		if(!is_dir($dir)) {
! 			if (!$create) {
! 				$status = false;
! 			} else {
! 				umask(0000);
! 				$status = mkdir ($dir,$CFG->directorypermissions);
! 			}
! 		}
! 		return $status;
! 	}
! 
! 	function importpostprocess() {
! 		/// Does any post-processing that may be desired
! 		/// Argument is a simple array of question ids that
! 		/// have just been added.
! 
! 		// need to clean up temporary directory
! 		return $this->clean_temp_dir();
! 	}
! 
! 	function copy_file_to_course($filename) {
! 		global $CFG, $COURSE;
! 		$filename = str_replace('\\','/',$filename);
! 		$fullpath = $this->temp_dir.'/res00001/'.$filename;
! 		$basename = basename($filename);
! 
! 		$copy_to = $CFG->dataroot.'/'.$COURSE->id.'/bb_import';
! 
! 		if ($this->check_dir_exists($copy_to,true)) {
! 			if(is_readable($fullpath)) {
! 				$copy_to.= '/'.$basename;
! 				if (!copy($fullpath, $copy_to)) {
! 					return false;
! 				}
! 				else {
! 					return $copy_to;
! 				}
! 			}
! 		}
! 		else {
! 			return false;
! 		}
! 	}
! 
! 	function readdata($filename) {
! 		/// Returns complete file with an array, one item per line
! 		global $CFG;
! 
! 		// if the extension is .dat we just return that,
! 		// if .zip we unzip the file and get the data
! 		$ext = substr($this->realfilename, strpos($this->realfilename,'.'), strlen($this->realfilename)-1);
! 		if ($ext=='.dat') {
! 			if (!is_readable($filename)) {
! 				print_error('filenotreadable', 'error');
! 			}
! 			return file($filename);
! 		}
! 
! 		$unique_code = time();
! 		$temp_dir = $CFG->dataroot."/temp/bbquiz_import/".$unique_code;
! 		$this->temp_dir = $temp_dir;
! 		if ($this->check_and_create_import_dir($unique_code)) {
! 			if(is_readable($filename)) {
! 				if (!copy($filename, "$temp_dir/bboard.zip")) {
! 					print_error('cannotcopybackup', 'question');
! 				}
! 				if(unzip_file("$temp_dir/bboard.zip", '', false)) {
! 					// assuming that the information is in res0001.dat
! 					// after looking at 6 examples this was always the case
! 					$q_file = "$temp_dir/res00001.dat";
! 					if (is_file($q_file)) {
! 						if (is_readable($q_file)) {
! 							$filearray = file($q_file);
! 							/// Check for Macintosh OS line returns (ie file on one line), and fix
! 							if (preg_match("~\r~", $filearray[0]) AND !preg_match("~\n~", $filearray[0])) {
! 								return explode("\r", $filearray[0]);
! 							} else {
! 								return $filearray;
! 							}
! 						}
! 					}
! 					else {
! 						print_error('cannotfindquestionfile', 'questioni');
! 					}
! 				}
! 				else {
! 					print "filename: $filename<br />tempdir: $temp_dir <br />";
! 					print_error('cannotunzip', 'question');
! 				}
! 			}
! 			else {
! 				print_error('cannotreaduploadfile');
! 			}
! 		}
! 		else {
! 			print_error('cannotcreatetempdir');
! 		}
! 	}
! 
! 	function save_question_options($question) {
! 		return true;
! 	}
! 
! 
! 
! 	function readquestions ($lines) {
! 		/// Parses an array of lines into an array of questions,
! 		/// where each item is a question object as defined by
! 		/// readquestion().
! 
! 		$text = implode($lines, " ");
! 		$xml = xmlize($text, 0);
! 
! 		$raw_questions = $xml['questestinterop']['#']['assessment'][0]['#']['section'][0]['#']['item'];
! 		$questions = array();
! 
! 		foreach($raw_questions as $quest) {
! 			$question = $this->create_raw_question($quest);
! 
! 			switch($question->qtype) {
! 				case "Matching":
! 					$this->process_matching($question, $questions);
! 					break;
! 				case "Multiple Choice":
! 					$this->process_mc($question, $questions);
! 					break;
! 				case "Essay":
! 					$this->process_essay($question, $questions);
! 					break;
! 				case "Multiple Answer":
! 					$this->process_ma($question, $questions);
! 					break;
! 				case "True/False":
! 					$this->process_tf($question, $questions);
! 					break;
! 				case 'Fill in the Blank':
! 					$this->process_fblank($question, $questions);
! 					break;
! 				case 'Short Response':
! 					$this->process_essay($question, $questions);
! 					break;
! 				default:
! 					print "Unknown or unhandled question type: \"$question->qtype\"<br />";
! 					break;
! 			}
! 
! 		}
! 		return $questions;
! 	}
! 
! 
! 	// creates a cleaner object to deal with for processing into moodle
! 	// the object created is NOT a moodle question object
! 	function create_raw_question($quest) {
! 
! 		$question = new StdClass;
! 		$question->qtype = $quest['#']['itemmetadata'][0]['#']['bbmd_questiontype'][0]['#'];
! 		$question->id = $quest['#']['itemmetadata'][0]['#']['bbmd_asi_object_id'][0]['#'];
! 		$presentation->blocks = $quest['#']['presentation'][0]['#']['flow'][0]['#']['flow'];
! 
! 		foreach($presentation->blocks as $pblock) {
! 
! 			$block = NULL;
! 			$block->type = $pblock['@']['class'];
! 
! 			switch($block->type) {
! 				case 'QUESTION_BLOCK':
! 					$sub_blocks = $pblock['#']['flow'];
! 					foreach($sub_blocks as $sblock) {
! 						//echo "Calling process_block from line 263<br>";
! 						$this->process_block($sblock, $block);
! 					}
! 					break;
! 
! 				case 'RESPONSE_BLOCK':
! 					$choices = NULL;
! 					switch($question->qtype) {
! 						case 'Matching':
! 							$bb_subquestions = $pblock['#']['flow'];
! 							$sub_questions = array();
! 							foreach($bb_subquestions as $bb_subquestion) {
! 								$sub_question = NULL;
! 								$sub_question->ident = $bb_subquestion['#']['response_lid'][0]['@']['ident'];
! 								$this->process_block($bb_subquestion['#']['flow'][0], $sub_question);
! 								$bb_choices = $bb_subquestion['#']['response_lid'][0]['#']['render_choice'][0]['#']['flow_label'][0]['#']['response_label'];
! 								$choices = array();
! 								$this->process_choices($bb_choices, $choices);
! 								$sub_question->choices = $choices;
! 								if (!isset($block->subquestions)) {
! 									$block->subquestions = array();
! 								}
! 								$block->subquestions[] = $sub_question;
! 							}
! 							break;
! 						case 'Multiple Answer':
! 							$bb_choices = $pblock['#']['response_lid'][0]['#']['render_choice'][0]['#']['flow_label'];
! 							$choices = array();
! 							$this->process_choices($bb_choices, $choices);
! 							$block->choices = $choices;
! 							break;
! 						case 'Essay':
! 							// Doesn't apply since the user responds with text input
! 							break;
! 						case 'Multiple Choice':
! 							$mc_choices = $pblock['#']['response_lid'][0]['#']['render_choice'][0]['#']['flow_label'];
! 							foreach($mc_choices as $mc_choice) {
! 								$choices = NULL;
! 								$choices = $this->process_block($mc_choice, $choices);
! 								$block->choices[] = $choices;
! 							}
! 							break;
! 						case 'Short Response':
! 							// do nothing?
! 							break;
! 						case 'Fill in the Blank':
! 							// do nothing?
! 							break;
! 						default:
! 							$bb_choices = $pblock['#']['response_lid'][0]['#']['render_choice'][0]['#']['flow_label'][0]['#']['response_label'];
! 							$choices = array();
! 							$this->process_choices($bb_choices, $choices);
! 							$block->choices = $choices;
! 					}
! 					break;
! 				case 'RIGHT_MATCH_BLOCK':
! 					$matching_answerset = $pblock['#']['flow'];
! 
! 					$answerset = array();
! 					foreach($matching_answerset as $answer) {
! 						// $answerset[] = $this->process_block($answer, $bb_answer);
! 						$bb_answer = null;
! 						$bb_answer->text = $answer['#']['flow'][0]['#']['material'][0]['#']['mat_extension'][0]['#']['mat_formattedtext'][0]['#'];
! 						$answerset[] = $bb_answer;
! 					}
! 					$block->matching_answerset = $answerset;
! 					break;
! 				default:
! 					print "UNHANDLED PRESENTATION BLOCK";
! 					break;
! 			}
! 			$question->{$block->type} = $block;
! 		}
! 
! 		// determine response processing
! 		// there is a section called 'outcomes' that I don't know what to do with
! 		$resprocessing = $quest['#']['resprocessing'];
! 		$respconditions = $resprocessing[0]['#']['respcondition'];
! 		$reponses = array();
! 		if ($question->qtype == 'Matching') {
! 			$this->process_matching_responses($respconditions, $responses);
! 		}
! 		else {
! 			$this->process_responses($respconditions, $responses);
! 		}
! 		$question->responses = $responses;
! 		$feedbackset = $quest['#']['itemfeedback'];
! 		$feedbacks = array();
! 		$this->process_feedback($feedbackset, $feedbacks);
! 		$question->feedback = $feedbacks;
! 		return $question;
! 	}
! 
! 	function process_block($cur_block, &$block) {
! 		global $COURSE, $CFG;
! 
! 		$cur_type = $cur_block['@']['class'];
! 		switch($cur_type) {
! 			case 'FORMATTED_TEXT_BLOCK':
! 				$block->text = $this->strip_applet_tags_get_mathml($cur_block['#']['material'][0]['#']['mat_extension'][0]['#']['mat_formattedtext'][0]['#']);
! 				break;
! 			case 'FILE_BLOCK':
! 				//revisit this to make sure it is working correctly
! 				// Commented out ['matapplication']..., etc. because I
! 				// noticed that when I imported a new Blackboard 6 file
! 				// and printed out the block, the tree did not extend past ['material'][0]['#'] - CT 8/3/06
! 				$block->file = $cur_block['#']['material'][0]['#'];//['matapplication'][0]['@']['uri'];
! 				if ($block->file != '') {
! 					// if we have a file copy it to the course dir and adjust its name to be visible over the web.
! 					$block->file = $this->copy_file_to_course($block->file);
! 					$block->file = $CFG->wwwroot.'/file.php/'.$COURSE->id.'/bb_import/'.basename($block->file);
! 				}
! 				break;
! 			case 'Block':
! 				if (isset($cur_block['#']['material'][0]['#']['mattext'][0]['#'])) {
! 					$block->text = $cur_block['#']['material'][0]['#']['mattext'][0]['#'];
! 				}
! 				else if (isset($cur_block['#']['material'][0]['#']['mat_extension'][0]['#']['mat_formattedtext'][0]['#'])) {
! 					$block->text = $cur_block['#']['material'][0]['#']['mat_extension'][0]['#']['mat_formattedtext'][0]['#'];
! 				}
! 				else if (isset($cur_block['#']['response_label'])) {
! 					// this is a response label block
! 					$sub_blocks = $cur_block['#']['response_label'][0];
! 					if(!isset($block->ident)) {
! 						if(isset($sub_blocks['@']['ident'])) {
! 							$block->ident = $sub_blocks['@']['ident'];
! 						}
! 					}
! 					foreach($sub_blocks['#']['flow_mat'] as $sub_block) {
! 						$this->process_block($sub_block, $block);
! 					}
! 				}
! 				else {
! 					if (isset($cur_block['#']['flow_mat']) || isset($cur_block['#']['flow'])) {
! 						if (isset($cur_block['#']['flow_mat'])) {
! 							$sub_blocks = $cur_block['#']['flow_mat'];
! 						}
! 						elseif (isset($cur_block['#']['flow'])) {
! 							$sub_blocks = $cur_block['#']['flow'];
! 						}
! 						foreach ($sub_blocks as $sblock) {
! 							// this will recursively grab the sub blocks which should be of one of the other types
! 							$this->process_block($sblock, $block);
! 						}
! 					}
! 				}
! 				break;
! 			case 'LINK_BLOCK':
! 				// not sure how this should be included
! 				if (!empty($cur_block['#']['material'][0]['#']['mattext'][0]['@']['uri'])) {
! 					$block->link = $cur_block['#']['material'][0]['#']['mattext'][0]['@']['uri'];
! 				}
! 				else {
! 					$block->link = '';
! 				}
! 				break;
! 		}
! 		return $block;
! 	}
! 
! 	function process_choices($bb_choices, &$choices) {
! 		foreach($bb_choices as $choice) {
! 			if (isset($choice['@']['ident'])) {
! 				$cur_choice = $choice['@']['ident'];
! 			}
! 			else { //for multiple answer
! 				$cur_choice = $choice['#']['response_label'][0];//['@']['ident'];
! 			}
! 			if (isset($choice['#']['flow_mat'][0])) { //for multiple answer
! 				$cur_block = $choice['#']['flow_mat'][0];
! 				// Reset $cur_choice to NULL because process_block is expecting an object
! 				// for the second argument and not a string, which is what is was set as
! 				// originally - CT 8/7/06
! 				$cur_choice = null;
! 				$this->process_block($cur_block, $cur_choice);
! 			}
! 			elseif (isset($choice['#']['response_label'])) {
! 				// Reset $cur_choice to NULL because process_block is expecting an object
! 				// for the second argument and not a string, which is what is was set as
! 				// originally - CT 8/7/06
! 				$cur_choice = null;
! 				$this->process_block($choice, $cur_choice);
! 			}
! 			$choices[] = $cur_choice;
! 		}
! 	}
! 
! 	function process_matching_responses($bb_responses, &$responses) {
! 		foreach($bb_responses as $bb_response) {
! 			$response = NULL;
! 			if (isset($bb_response['#']['conditionvar'][0]['#']['varequal'])) {
! 				$response->correct = $bb_response['#']['conditionvar'][0]['#']['varequal'][0]['#'];
! 				$response->ident = $bb_response['#']['conditionvar'][0]['#']['varequal'][0]['@']['respident'];
! 			}
! 			else {
! 				$response->correct =  'Broken Question?';
! 				$response->ident = 'Broken Question?';
! 			}
! 			$response->feedback = $bb_response['#']['displayfeedback'][0]['@']['linkrefid'];
! 			$responses[] = $response;
! 		}
! 	}
! 
! 	function process_responses($bb_responses, &$responses) {
! 		foreach($bb_responses as $bb_response) {
! 			//Added this line to instantiate $response.
! 			// Without instantiating the $response variable, the same object
! 			// gets added to the array
! 			$response = null;
! 			if (isset($bb_response['@']['title'])) {
! 				$response->title = $bb_response['@']['title'];
! 			}
! 			else {
! 				$reponse->title = $bb_response['#']['displayfeedback'][0]['@']['linkrefid'];
! 			}
! 			$reponse->ident = array();
! 			if (isset($bb_response['#']['conditionvar'][0]['#'])){//['varequal'][0]['#'])) {
! 				$response->ident[0] = $bb_response['#']['conditionvar'][0]['#'];//['varequal'][0]['#'];
! 			}
! 			else if (isset($bb_response['#']['conditionvar'][0]['#']['other'][0]['#'])) {
! 				$response->ident[0] = $bb_response['#']['conditionvar'][0]['#']['other'][0]['#'];
! 			}
! 
! 			if (isset($bb_response['#']['conditionvar'][0]['#']['and'])){//[0]['#'])) {
! 				$responseset = $bb_response['#']['conditionvar'][0]['#']['and'];//[0]['#']['varequal'];
! 				foreach($responseset as $rs) {
! 					$response->ident[] = $rs['#'];
! 					if(!isset($response->feedback) and isset( $rs['@'] ) ) {
! 						$response->feedback = $rs['@']['respident'];
! 					}
! 				}
! 			}
! 			else {
! 				$response->feedback = $bb_response['#']['displayfeedback'][0]['@']['linkrefid'];
! 			}
! 
! 			// determine what point value to give response
! 			if (isset($bb_response['#']['setvar'])) {
! 				switch ($bb_response['#']['setvar'][0]['#']) {
! 					case "SCORE.max":
! 						$response->fraction = 1;
! 						break;
! 					default:
! 						// I have only seen this being 0 or unset
! 						// there are probably fractional values of SCORE.max, but I'm not sure what they look like
! 						$response->fraction = 0;
! 						break;
! 				}
! 			}
! 			else {
! 				// just going to assume this is the case this is probably not correct.
! 				$response->fraction = 0;
! 			}
! 
! 			$responses[] = $response;
! 		}
! 	}
! 
! 	function process_feedback($feedbackset, &$feedbacks) {
! 		foreach($feedbackset as $bb_feedback) {
! 			// Added line $feedback=null so that $feedback does not get reused in the loop
! 			// and added the the $feedbacks[] array multiple times
! 			$feedback = null;
! 			$feedback->ident = $bb_feedback['@']['ident'];
! 			if (isset($bb_feedback['#']['flow_mat'][0])) {
! 				$this->process_block($bb_feedback['#']['flow_mat'][0], $feedback);
! 			}
! 			elseif (isset($bb_feedback['#']['solution'][0]['#']['solutionmaterial'][0]['#']['flow_mat'][0])) {
! 				$this->process_block($bb_feedback['#']['solution'][0]['#']['solutionmaterial'][0]['#']['flow_mat'][0], $feedback);
! 			}
! 			$feedbacks[] = $feedback;
! 		}
! 	}
! 
! 	/**
! 	 * Create common parts of question
! 	 */
! 	function process_common( $quest ) {
! 		$question = $this->defaultquestion();
! 		$question->questiontext = $quest->QUESTION_BLOCK->text;
! 		$question->name = shorten_text( $quest->id, 250 );
! 
! 		return $question;
! 	}
! 
! 	//----------------------------------------
! 	// Process True / False Questions
! 	//----------------------------------------
! 	function process_tf($quest, &$questions) {
! 		$question = $this->process_common( $quest );
! 
! 		$question->qtype = TRUEFALSE;
! 		$question->single = 1; // Only one answer is allowed
! 		// 0th [response] is the correct answer.
! 		$responses = $quest->responses;
! 		$correctresponse = $responses[0]->ident[0]['varequal'][0]['#'];
! 		if ($correctresponse != 'false') {
! 			$correct = true;
! 		}
! 		else {
! 			$correct = false;
! 		}
! 
! 		foreach($quest->feedback as $fb) {
! 			$fback->{$fb->ident} = $fb->text;
! 		}
! 
! 		if ($correct) {  // true is correct
! 			$question->answer = 1;
! 			$question->feedbacktrue = $fback->correct;
! 			$question->feedbackfalse = $fback->incorrect;
! 		} else {  // false is correct
! 			$question->answer = 0;
! 			$question->feedbacktrue = $fback->incorrect;
! 			$question->feedbackfalse = $fback->correct;
! 		}
! 		$question->correctanswer = $question->answer;
! 		$questions[] = $question;
! 	}
! 
! 
! 	//----------------------------------------
! 	// Process Fill in the Blank
! 	//----------------------------------------
! 	function process_fblank($quest, &$questions) {
! 		$question = $this->process_common( $quest );
! 		$question->qtype = SHORTANSWER;
! 		$question->single = 1;
! 
! 		$answers = array();
! 		$fractions = array();
! 		$feedbacks = array();
! 
! 		// extract the feedback
! 		$feedback = array();
! 		foreach($quest->feedback as $fback) {
! 			if (isset($fback->ident)) {
! 				if ($fback->ident == 'correct' || $fback->ident == 'incorrect') {
! 					$feedback[$fback->ident] = $fback->text;
! 				}
! 			}
! 		}
! 
! 		foreach($quest->responses as $response) {
! 			if(isset($response->title)) {
! 				if (isset($response->ident[0]['varequal'][0]['#'])) {
! 					//for BB Fill in the Blank, only interested in correct answers
! 					if ($response->feedback = 'correct') {
! 						$answers[] = $response->ident[0]['varequal'][0]['#'];
! 						$fractions[] = 1;
! 						if (isset($feedback['correct'])) {
! 							$feedbacks[] = $feedback['correct'];
! 						}
! 						else {
! 							$feedbacks[] = '';
! 						}
! 					}
! 				}
! 
! 			}
! 		}
! 
! 		//Adding catchall to so that students can see feedback for incorrect answers when they enter something the
! 		//instructor did not enter
! 		$answers[] = '*';
! 		$fractions[] = 0;
! 		if (isset($feedback['incorrect'])) {
! 			$feedbacks[] = $feedback['incorrect'];
! 		}
! 		else {
! 			$feedbacks[] = '';
! 		}
! 
! 		$question->answer = $answers;
! 		$question->fraction = $fractions;
! 		$question->feedback = $feedbacks; // Changed to assign $feedbacks to $question->feedback instead of
! 
! 		if (!empty($question)) {
! 			$questions[] = $question;
! 		}
! 
! 	}
! 
! 	//----------------------------------------
! 	// Process Multiple Choice Questions
! 	//----------------------------------------
! 	function process_mc($quest, &$questions) {
! 		$question = $this->process_common( $quest );
! 		$question->qtype = MULTICHOICE;
! 		$question->single = 1;
! 
! 		$feedback = array();
! 		foreach($quest->feedback as $fback) {
! 			$feedback[$fback->ident] = $fback->text;
! 		}
! 
! 		foreach($quest->responses as $response) {
! 			if (isset($response->title)) {
! 				if ($response->title == 'correct') {
! 					// only one answer possible for this qtype so first index is correct answer
! 					$correct = $response->ident[0]['varequal'][0]['#'];
! 				}
! 			}
! 			else {
! 				// fallback method for when the title is not set
! 				if ($response->feedback == 'correct') {
! 					// only one answer possible for this qtype so first index is correct answer
! 					$correct = $response->ident[0]['varequal'][0]['#']; // added [0]['varequal'][0]['#'] to $response->ident - CT 8/9/06
! 				}
! 			}
! 		}
! 
! 		$i = 0;
! 		foreach($quest->RESPONSE_BLOCK->choices as $response) {
! 			$question->answer[$i] = $response->text;
! 			if ($correct == $response->ident) {
! 				$question->fraction[$i] = 1;
! 				// this is a bit of a hack to catch the feedback... first we see if a 'correct' feedback exists
! 				// then specific feedback for this question (maybe this should be switched?, but from my example
! 				// question pools I have not seen response specific feedback, only correct or incorrect feedback
! 				if (!empty($feedback['correct'])) {
! 					$question->feedback[$i] = $feedback['correct'];
! 				}
! 				elseif (!empty($feedback[$i])) {
! 					$question->feedback[$i] = $feedback[$i];
! 				}
! 				else {
! 					// failsafe feedback (should be '' instead?)
! 					$question->feedback[$i] = "correct";
! 				}
! 			}
! 			else {
! 				$question->fraction[$i] = 0;
! 				if (!empty($feedback['incorrect'])) {
! 					$question->feedback[$i] = $feedback['incorrect'];
! 				}
! 				elseif (!empty($feedback[$i])) {
! 					$question->feedback[$i] = $feedback[$i];
! 				}
! 				else {
! 					// failsafe feedback (should be '' instead?)
! 					$question->feedback[$i] = 'incorrect';
! 				}
! 			}
! 			$i++;
! 		}
! 
! 		if (!empty($question)) {
! 			$questions[] = $question;
! 		}
! 	}
! 
! 	//----------------------------------------
! 	// Process Multiple Choice Questions With Multiple Answers
! 	//----------------------------------------
! 	function process_ma($quest, &$questions) {
! 		$question = $this->process_common( $quest ); // copied this from process_mc
! 		$question->qtype = MULTICHOICE;
! 		$question->single = 0; // More than one answer allowed
! 
! 		$answers = $quest->responses;
! 		$correct_answers = array();
! 		foreach($answers as $answer) {
! 			if($answer->title == 'correct') {
! 				$answerset = $answer->ident[0]['and'][0]['#']['varequal'];
! 				foreach($answerset as $ans) {
! 					$correct_answers[] = $ans['#'];
! 				}
! 			}
! 		}
! 
! 		foreach ($quest->feedback as $fb) {
! 			$feedback->{$fb->ident} = trim($fb->text);
! 		}
! 
! 		$correct_answer_count = count($correct_answers);
! 		$choiceset = $quest->RESPONSE_BLOCK->choices;
! 		$i = 0;
! 		foreach($choiceset as $choice) {
! 			$question->answer[$i] = trim($choice->text);
! 			if (in_array($choice->ident, $correct_answers)) {
! 				// correct answer
! 				$question->fraction[$i] = floor(100000/$correct_answer_count)/100000; // strange behavior if we have more than 5 decimal places
! 				$question->feedback[$i] = $feedback->correct;
! 			}
! 			else {
! 				// wrong answer
! 				$question->fraction[$i] = 0;
! 				$question->feedback[$i] = $feedback->incorrect;
! 			}
! 			$i++;
! 		}
! 
! 		$questions[] = $question;
! 	}
! 
! 	//----------------------------------------
! 	// Process Essay Questions
! 	//----------------------------------------
! 	function process_essay($quest, &$questions) {
! 		// this should be rewritten to accomodate moodle 1.6 essay question type eventually
! 
! 		if (defined("ESSAY")) {
! 			// treat as short answer
! 			$question = $this->process_common( $quest ); // copied this from process_mc
! 			$question->qtype = ESSAY;
! 
! 			$question->feedback = array();
! 			// not sure where to get the correct answer from
! 			foreach($quest->feedback as $feedback) {
! 				// Added this code to put the possible solution that the
! 				// instructor gives as the Moodle answer for an essay question
! 				if ($feedback->ident == 'solution') {
! 					$question->feedback = $feedback->text;
! 				}
! 			}
! 			//Added because essay/questiontype.php:save_question_option is expecting a
! 			//fraction property - CT 8/10/06
! 			$question->fraction[] = 1;
! 			if (!empty($question)) {
! 				$questions[]=$question;
! 			}
! 		}
! 		else {
! 			print "Essay question types are not handled because the quiz question type 'Essay' does not exist in this installation of Moodle<br/>";
! 			print "&nbsp;&nbsp;&nbsp;&nbsp;Omitted Question: ".$quest->QUESTION_BLOCK->text.'<br/><br/>';
! 		}
! 	}
! 
! 	//----------------------------------------
! 	// Process Matching Questions
! 	//----------------------------------------
! 	function process_matching($quest, &$questions) {
! 		global $QTYPES;
! 
! 		// renderedmatch is an optional plugin, so we need to check if it is defined
! 		if (array_key_exists('renderedmatch', $QTYPES)) {
! 			$question = $this->process_common( $quest );
! 			$question->valid = true;
! 			$question->qtype = 'renderedmatch';
! 
! 			foreach($quest->RESPONSE_BLOCK->subquestions as $qid => $subq) {
! 				foreach($quest->responses as $rid => $resp) {
! 					if ($resp->ident == $subq->ident) {
! 						$correct = $resp->correct;
! 						$feedback = $resp->feedback;
! 					}
! 				}
! 
! 				foreach($subq->choices as $cid => $choice) {
! 					if ($choice == $correct) {
! 						$question->subquestions[] = $subq->text;
! 						$question->subanswers[] = $quest->RIGHT_MATCH_BLOCK->matching_answerset[$cid]->text;
! 					}
! 				}
! 			}
! 
! 			// check format
! 			$status = true;
! 			if ( count($quest->RESPONSE_BLOCK->subquestions) > count($quest->RIGHT_MATCH_BLOCK->matching_answerset) || count($question->subquestions) < 2) {
! 				$status = false;
! 			}
! 			else {
! 				// need to redo to make sure that no two questions have the same answer (rudimentary now)
! 				foreach($question->subanswers as $qstn) {
! 					if(isset($previous)) {
! 						if ($qstn == $previous) {
! 							$status = false;
! 						}
! 					}
! 					$previous = $qstn;
! 					if ($qstn == '') {
! 						$status = false;
! 					}
! 				}
! 			}
! 
! 			if ($status) {
! 				$questions[] = $question;
! 			}
! 			else {
! 				global $COURSE, $CFG;
! 				print '<table class="boxaligncenter" border="1">';
! 				print '<tr><td colspan="2" style="background-color:#FF8888;">This matching question is malformed. Please ensure there are no blank answers, no two questions have the same answer, and/or there are correct answers for each question. There must be at least as many subanswers as subquestions, and at least one subquestion.</td></tr>';
! 
! 				print "<tr><td>Question:</td><td>".$quest->QUESTION_BLOCK->text;
! 				if (isset($quest->QUESTION_BLOCK->file)) {
! 					print '<br/><font color="red">There is a subfile contained in the zipfile that has been copied to course files: bb_import/'.basename($quest->QUESTION_BLOCK->file).'</font>';
! 					if (preg_match('/(gif|jpg|jpeg|png)$/i', $quest->QUESTION_BLOCK->file)) {
! 						print '<img src="'.$CFG->wwwroot.'/file.php/'.$COURSE->id.'/bb_import/'.basename($quest->QUESTION_BLOCK->file).'" />';
! 					}
! 				}
! 				print "</td></tr>";
! 				print "<tr><td>Subquestions:</td><td><ul>";
! 				foreach($quest->responses as $rs) {
! 					$correct_responses->{$rs->ident} = $rs->correct;
! 				}
! 				foreach($quest->RESPONSE_BLOCK->subquestions as $subq) {
! 					print '<li>'.$subq->text.'<ul>';
! 					foreach($subq->choices as $id=>$choice) {
! 						print '<li>';
! 						if ($choice == $correct_responses->{$subq->ident}) {
! 							print '<font color="green">';
! 						}
! 						else {
! 							print '<font color="red">';
! 						}
! 						print $quest->RIGHT_MATCH_BLOCK->matching_answerset[$id]->text.'</font></li>';
! 					}
! 					print '</ul>';
! 				}
! 				print '</ul></td></tr>';
! 
! 				print '<tr><td>Feedback:</td><td><ul>';
! 				foreach($quest->feedback as $fb) {
! 					print '<li>'.$fb->ident.': '.$fb->text.'</li>';
! 				}
! 				print '</ul></td></tr></table>';
! 			}
! 		}
! 		else {
! 			print "Matching question types are not handled because the quiz question type 'Rendered Matching' does not exist in this installation of Moodle<br/>";
! 			print "&nbsp;&nbsp;&nbsp;&nbsp;Omitted Question: ".$quest->QUESTION_BLOCK->text.'<br/><br/>';
! 		}
! 	}
! 
! 
! 	function strip_applet_tags_get_mathml($string) {
! 		if(stristr($string, '</APPLET>') === FALSE) {
! 			return $string;
! 		}
! 		else {
! 			// strip all applet tags keeping stuff before/after and inbetween (if mathml) them
! 			while (stristr($string, '</APPLET>') !== FALSE) {
! 				preg_match("/(.*)\<applet.*value=\"(\<math\>.*\<\/math\>)\".*\<\/applet\>(.*)/i",$string, $mathmls);
! 				$string = $mathmls[1].$mathmls[2].$mathmls[3];
! 			}
! 			return $string;
! 		}
! 	}
  
  } // close object
  
diff -crB questionorg/format/examview/format.php questionupd/format/examview/format.php
*** questionorg/format/examview/format.php	2012-04-13 12:31:10.970178249 +0500
--- questionupd/format/examview/format.php	2012-04-13 09:42:52.000000000 +0500
***************
*** 10,16 ****
  
  class qformat_examview extends qformat_default {
  
!     public $qtypes = array(
          'tf' => TRUEFALSE,
          'mc' => MULTICHOICE,
          'yn' => TRUEFALSE,
--- 10,16 ----
  
  class qformat_examview extends qformat_default {
  
! 	public $qtypes = array(
          'tf' => TRUEFALSE,
          'mc' => MULTICHOICE,
          'yn' => TRUEFALSE,
***************
*** 23,284 ****
          'ca' => 99,
          'ot' => 99,
          'sa' => ESSAY
!         );
  
!     public $matching_questions = array();
  
!     function provide_import() {
!         return true;
!     }
! 
!     /**
!      * unxmlise reconstructs part of the xml data structure in order
!      * to identify the actual data therein
!      * @param array $xml section of the xml data structure
!      * @return string data with evrything else removed
!      */
!     function unxmlise( $xml ) {
!         // if it's not an array then it's probably just data
!         if (!is_array($xml)) {
!             $text = s($xml);
!         }
!         else {
!             // otherwise parse the array
!             $text = '';
!             foreach ($xml as $tag=>$data) {
!                 // if tag is '@' then it's attributes and we don't care
!                 if ($tag!=='@') {
!                     $text = $text . $this->unxmlise( $data );
!                 }
!             }
!         }
! 
!         // currently we throw the tags we found
!         $text = strip_tags($text);
!         return $text;
!     }
! 
!     function parse_matching_groups($matching_groups)
!     {
!         if (empty($matching_groups)) {
!             return;
!         }
!         foreach($matching_groups as $match_group) {
!             $newgroup = NULL;
!             $groupname = trim($match_group['@']['name']);
!             $questiontext = $this->unxmlise($match_group['#']['text'][0]['#']);
!             $newgroup->questiontext = trim($questiontext);
!             $newgroup->subchoices = array();
!             $newgroup->subquestions = array();
!             $newgroup->subanswers = array();
!             $choices = $match_group['#']['choices']['0']['#'];
!             foreach($choices as $key => $value) {
!                 if (strpos(trim($key),'choice-') !== FALSE) {
!                     $key = strtoupper(trim(str_replace('choice-', '', $key)));
!                     $newgroup->subchoices[$key] = trim($value['0']['#']);
!                 }
!             }
!             $this->matching_questions[$groupname] = $newgroup;
!         }
!     }
! 
!     function parse_ma($qrec, $groupname)
!     {
!         $match_group = $this->matching_questions[$groupname];
!         $phrase = trim($this->unxmlise($qrec['text']['0']['#']));
!         $answer = trim($this->unxmlise($qrec['answer']['0']['#']));
!         $answer = strip_tags( $answer );
!         $match_group->subquestions[] = $phrase;
!         $match_group->subanswers[] = $match_group->subchoices[$answer];
!         $this->matching_questions[$groupname] = $match_group;
!         return NULL;
!     }
! 
!     function process_matches(&$questions)
!     {
!         if (empty($this->matching_questions)) {
!             return;
!         }
!         foreach($this->matching_questions as $match_group) {
!             $question = $this->defaultquestion();
!             $htmltext = s($match_group->questiontext);
!             $question->questiontext = $htmltext;
!             $question->name = $question->questiontext;
!             $question->qtype = MATCH;
!             $question->subquestions = array();
!             $question->subanswers = array();
!             foreach($match_group->subquestions as $key => $value) {
!                 $htmltext = s($value);
!                 $question->subquestions[] = $htmltext;
! 
!                 $htmltext = s($match_group->subanswers[$key]);
!                 $question->subanswers[] = $htmltext;
!             }
!             $questions[] = $question;
!         }
!     }
! 
!     function cleanUnicode($text) {
!         return str_replace('&#x2019;', "'", $text);
!     }
! 
!     function readquestions($lines) {
!         /// Parses an array of lines into an array of questions,
!         /// where each item is a question object as defined by
!         /// readquestion().
! 
!         $questions = array();
!         $currentquestion = array();
! 
!         $text = implode($lines, ' ');
!         $text = $this->cleanUnicode($text);
! 
!         $xml = xmlize($text, 0);
!         if (!empty($xml['examview']['#']['matching-group'])) {
!             $this->parse_matching_groups($xml['examview']['#']['matching-group']);
!         }
! 
!         $questionNode = $xml['examview']['#']['question'];
!         foreach($questionNode as $currentquestion) {
!             if ($question = $this->readquestion($currentquestion)) {
!                 $questions[] = $question;
!             }
!         }
! 
!         $this->process_matches($questions);
!         return $questions;
!     }
!     // end readquestions
! 
!     function readquestion($qrec)
!     {
! 
!         $type = trim($qrec['@']['type']);
!         $question = $this->defaultquestion();
!         if (array_key_exists($type, $this->qtypes)) {
!             $question->qtype = $this->qtypes[$type];
!         }
!         else {
!             $question->qtype = null;
!         }
!         $question->single = 1;
!         // Only one answer is allowed
!         $htmltext = $this->unxmlise($qrec['#']['text'][0]['#']);
!         $question->questiontext = $htmltext;
!         $question->name = shorten_text( $question->questiontext, 250 );
! 
!         switch ($question->qtype) {
!         case MULTICHOICE:
!             $question = $this->parse_mc($qrec['#'], $question);
!             break;
!         case MATCH:
!             $groupname = trim($qrec['@']['group']);
!             $question = $this->parse_ma($qrec['#'], $groupname);
!             break;
!         case TRUEFALSE:
!             $question = $this->parse_tf_yn($qrec['#'], $question);
!             break;
!         case SHORTANSWER:
!             $question = $this->parse_co($qrec['#'], $question);
!             break;
!         case ESSAY:
!             $question = $this->parse_sa($qrec['#'], $question);
!             break;
!         case NUMERICAL:
!             $question = $this->parse_nr($qrec['#'], $question);
!             break;
!             break;
!             default:
!             print("<p>Question type ".$type." import not supported for ".$question->questiontext."<p>");
!             $question = NULL;
!         }
!         // end switch ($question->qtype)
! 
!         return $question;
!     }
!     // end readquestion
! 
!     function parse_tf_yn($qrec, $question)
!     {
!         $choices = array('T' => 1, 'Y' => 1, 'F' => 0, 'N' => 0 );
!         $answer = trim($qrec['answer'][0]['#']);
!         $question->answer = $choices[$answer];
!         $question->correctanswer = $question->answer;
!         if ($question->answer == 1) {
!             $question->feedbacktrue = 'Correct';
!             $question->feedbackfalse = 'Incorrect';
!         } else {
!             $question->feedbacktrue = 'Incorrect';
!             $question->feedbackfalse = 'Correct';
!         }
!         return $question;
!     }
! 
!     function parse_mc($qrec, $question)
!     {
!         $answer = 'choice-'.strtolower(trim($qrec['answer'][0]['#']));
! 
!         $choices = $qrec['choices'][0]['#'];
!         foreach($choices as $key => $value) {
!             if (strpos(trim($key),'choice-') !== FALSE) {
! 
!                 $question->answer[$key] = s($this->unxmlise($value[0]['#']));
!                 if (strcmp($key, $answer) == 0) {
!                     $question->fraction[$key] = 1;
!                     $question->feedback[$key] = 'Correct';
!                 } else {
!                     $question->fraction[$key] = 0;
!                     $question->feedback[$key] = 'Incorrect';
!                 }
!             }
!         }
!         return $question;
!     }
! 
!     function parse_co($qrec, $question)
!     {
!         $question->usecase = 0;
!         $answer = trim($this->unxmlise($qrec['answer'][0]['#']));
!         $answer = strip_tags( $answer );
!         $answers = explode("\n",$answer);
! 
!         foreach($answers as $key => $value) {
!             $value = trim($value);
!             if (strlen($value) > 0) {
!                 $question->answer[$key] = $value;
!                 $question->fraction[$key] = 1;
!                 $question->feedback[$key] = "Correct";
!             }
!         }
!         return $question;
!     }
! 
!     function parse_sa($qrec, $question) {
!         $feedback = trim($this->unxmlise($qrec['answer'][0]['#']));
!         $question->feedback = $feedback;
!         $question->fraction = 0;
!         return $question;
!     }
! 
!     function parse_nr($qrec, $question)
!     {
!         $answer = trim($this->unxmlise($qrec['answer'][0]['#']));
!         $answer = strip_tags( $answer );
!         $answers = explode("\n",$answer);
! 
!         foreach($answers as $key => $value) {
!             $value = trim($value);
!             if (is_numeric($value)) {
!                 $errormargin = 0;
!                 $question->answer[$key] = $value;
!                 $question->fraction[$key] = 1;
!                 $question->feedback[$key] = "Correct";
!                 $question->min[$key] = $question->answer[$key] - $errormargin;
!                 $question->max[$key] = $question->answer[$key] + $errormargin;
!             }
!         }
!         return $question;
!     }
  
  }
  // end class
--- 23,284 ----
          'ca' => 99,
          'ot' => 99,
          'sa' => ESSAY
! 	);
  
! 	public $matching_questions = array();
  
! 	function provide_import() {
! 		return true;
! 	}
! 
! 	/**
! 	 * unxmlise reconstructs part of the xml data structure in order
! 	 * to identify the actual data therein
! 	 * @param array $xml section of the xml data structure
! 	 * @return string data with evrything else removed
! 	 */
! 	function unxmlise( $xml ) {
! 		// if it's not an array then it's probably just data
! 		if (!is_array($xml)) {
! 			$text = s($xml);
! 		}
! 		else {
! 			// otherwise parse the array
! 			$text = '';
! 			foreach ($xml as $tag=>$data) {
! 				// if tag is '@' then it's attributes and we don't care
! 				if ($tag!=='@') {
! 					$text = $text . $this->unxmlise( $data );
! 				}
! 			}
! 		}
! 
! 		// currently we throw the tags we found
! 		$text = strip_tags($text);
! 		return $text;
! 	}
! 
! 	function parse_matching_groups($matching_groups)
! 	{
! 		if (empty($matching_groups)) {
! 			return;
! 		}
! 		foreach($matching_groups as $match_group) {
! 			$newgroup = NULL;
! 			$groupname = trim($match_group['@']['name']);
! 			$questiontext = $this->unxmlise($match_group['#']['text'][0]['#']);
! 			$newgroup->questiontext = trim($questiontext);
! 			$newgroup->subchoices = array();
! 			$newgroup->subquestions = array();
! 			$newgroup->subanswers = array();
! 			$choices = $match_group['#']['choices']['0']['#'];
! 			foreach($choices as $key => $value) {
! 				if (strpos(trim($key),'choice-') !== FALSE) {
! 					$key = strtoupper(trim(str_replace('choice-', '', $key)));
! 					$newgroup->subchoices[$key] = trim($value['0']['#']);
! 				}
! 			}
! 			$this->matching_questions[$groupname] = $newgroup;
! 		}
! 	}
! 
! 	function parse_ma($qrec, $groupname)
! 	{
! 		$match_group = $this->matching_questions[$groupname];
! 		$phrase = trim($this->unxmlise($qrec['text']['0']['#']));
! 		$answer = trim($this->unxmlise($qrec['answer']['0']['#']));
! 		$answer = strip_tags( $answer );
! 		$match_group->subquestions[] = $phrase;
! 		$match_group->subanswers[] = $match_group->subchoices[$answer];
! 		$this->matching_questions[$groupname] = $match_group;
! 		return NULL;
! 	}
! 
! 	function process_matches(&$questions)
! 	{
! 		if (empty($this->matching_questions)) {
! 			return;
! 		}
! 		foreach($this->matching_questions as $match_group) {
! 			$question = $this->defaultquestion();
! 			$htmltext = s($match_group->questiontext);
! 			$question->questiontext = $htmltext;
! 			$question->name = $question->questiontext;
! 			$question->qtype = MATCH;
! 			$question->subquestions = array();
! 			$question->subanswers = array();
! 			foreach($match_group->subquestions as $key => $value) {
! 				$htmltext = s($value);
! 				$question->subquestions[] = $htmltext;
! 
! 				$htmltext = s($match_group->subanswers[$key]);
! 				$question->subanswers[] = $htmltext;
! 			}
! 			$questions[] = $question;
! 		}
! 	}
! 
! 	function cleanUnicode($text) {
! 		return str_replace('&#x2019;', "'", $text);
! 	}
! 
! 	function readquestions($lines) {
! 		/// Parses an array of lines into an array of questions,
! 		/// where each item is a question object as defined by
! 		/// readquestion().
! 
! 		$questions = array();
! 		$currentquestion = array();
! 
! 		$text = implode($lines, ' ');
! 		$text = $this->cleanUnicode($text);
! 
! 		$xml = xmlize($text, 0);
! 		if (!empty($xml['examview']['#']['matching-group'])) {
! 			$this->parse_matching_groups($xml['examview']['#']['matching-group']);
! 		}
! 
! 		$questionNode = $xml['examview']['#']['question'];
! 		foreach($questionNode as $currentquestion) {
! 			if ($question = $this->readquestion($currentquestion)) {
! 				$questions[] = $question;
! 			}
! 		}
! 
! 		$this->process_matches($questions);
! 		return $questions;
! 	}
! 	// end readquestions
! 
! 	function readquestion($qrec)
! 	{
! 
! 		$type = trim($qrec['@']['type']);
! 		$question = $this->defaultquestion();
! 		if (array_key_exists($type, $this->qtypes)) {
! 			$question->qtype = $this->qtypes[$type];
! 		}
! 		else {
! 			$question->qtype = null;
! 		}
! 		$question->single = 1;
! 		// Only one answer is allowed
! 		$htmltext = $this->unxmlise($qrec['#']['text'][0]['#']);
! 		$question->questiontext = $htmltext;
! 		$question->name = shorten_text( $question->questiontext, 250 );
! 
! 		switch ($question->qtype) {
! 			case MULTICHOICE:
! 				$question = $this->parse_mc($qrec['#'], $question);
! 				break;
! 			case MATCH:
! 				$groupname = trim($qrec['@']['group']);
! 				$question = $this->parse_ma($qrec['#'], $groupname);
! 				break;
! 			case TRUEFALSE:
! 				$question = $this->parse_tf_yn($qrec['#'], $question);
! 				break;
! 			case SHORTANSWER:
! 				$question = $this->parse_co($qrec['#'], $question);
! 				break;
! 			case ESSAY:
! 				$question = $this->parse_sa($qrec['#'], $question);
! 				break;
! 			case NUMERICAL:
! 				$question = $this->parse_nr($qrec['#'], $question);
! 				break;
! 				break;
! 			default:
! 				print("<p>Question type ".$type." import not supported for ".$question->questiontext."<p>");
! 				$question = NULL;
! 		}
! 		// end switch ($question->qtype)
! 
! 		return $question;
! 	}
! 	// end readquestion
! 
! 	function parse_tf_yn($qrec, $question)
! 	{
! 		$choices = array('T' => 1, 'Y' => 1, 'F' => 0, 'N' => 0 );
! 		$answer = trim($qrec['answer'][0]['#']);
! 		$question->answer = $choices[$answer];
! 		$question->correctanswer = $question->answer;
! 		if ($question->answer == 1) {
! 			$question->feedbacktrue = 'Correct';
! 			$question->feedbackfalse = 'Incorrect';
! 		} else {
! 			$question->feedbacktrue = 'Incorrect';
! 			$question->feedbackfalse = 'Correct';
! 		}
! 		return $question;
! 	}
! 
! 	function parse_mc($qrec, $question)
! 	{
! 		$answer = 'choice-'.strtolower(trim($qrec['answer'][0]['#']));
! 
! 		$choices = $qrec['choices'][0]['#'];
! 		foreach($choices as $key => $value) {
! 			if (strpos(trim($key),'choice-') !== FALSE) {
! 
! 				$question->answer[$key] = s($this->unxmlise($value[0]['#']));
! 				if (strcmp($key, $answer) == 0) {
! 					$question->fraction[$key] = 1;
! 					$question->feedback[$key] = 'Correct';
! 				} else {
! 					$question->fraction[$key] = 0;
! 					$question->feedback[$key] = 'Incorrect';
! 				}
! 			}
! 		}
! 		return $question;
! 	}
! 
! 	function parse_co($qrec, $question)
! 	{
! 		$question->usecase = 0;
! 		$answer = trim($this->unxmlise($qrec['answer'][0]['#']));
! 		$answer = strip_tags( $answer );
! 		$answers = explode("\n",$answer);
! 
! 		foreach($answers as $key => $value) {
! 			$value = trim($value);
! 			if (strlen($value) > 0) {
! 				$question->answer[$key] = $value;
! 				$question->fraction[$key] = 1;
! 				$question->feedback[$key] = "Correct";
! 			}
! 		}
! 		return $question;
! 	}
! 
! 	function parse_sa($qrec, $question) {
! 		$feedback = trim($this->unxmlise($qrec['answer'][0]['#']));
! 		$question->feedback = $feedback;
! 		$question->fraction = 0;
! 		return $question;
! 	}
! 
! 	function parse_nr($qrec, $question)
! 	{
! 		$answer = trim($this->unxmlise($qrec['answer'][0]['#']));
! 		$answer = strip_tags( $answer );
! 		$answers = explode("\n",$answer);
! 
! 		foreach($answers as $key => $value) {
! 			$value = trim($value);
! 			if (is_numeric($value)) {
! 				$errormargin = 0;
! 				$question->answer[$key] = $value;
! 				$question->fraction[$key] = 1;
! 				$question->feedback[$key] = "Correct";
! 				$question->min[$key] = $question->answer[$key] - $errormargin;
! 				$question->max[$key] = $question->answer[$key] + $errormargin;
! 			}
! 		}
! 		return $question;
! 	}
  
  }
  // end class
diff -crB questionorg/format/gift/format.php questionupd/format/gift/format.php
*** questionorg/format/gift/format.php	2012-04-13 12:31:11.758178257 +0500
--- questionupd/format/gift/format.php	2012-04-13 09:42:52.000000000 +0500
***************
*** 37,734 ****
   */
  class qformat_gift extends qformat_default {
  
!     function provide_import() {
!         return true;
!     }
! 
!     function provide_export() {
!         return true;
!     }
! 
!     function export_file_extension() {
!         return '.txt';
!     }
! 
!     function answerweightparser(&$answer) {
!         $answer = substr($answer, 1);                        // removes initial %
!         $end_position  = strpos($answer, "%");
!         $answer_weight = substr($answer, 0, $end_position);  // gets weight as integer
!         $answer_weight = $answer_weight/100;                 // converts to percent
!         $answer = substr($answer, $end_position+1);          // removes comment from answer
!         return $answer_weight;
!     }
! 
!     function commentparser($answer, $defaultformat) {
!         $bits = explode('#', $answer, 2);
!         $ans = $this->parse_text_with_format(trim($bits[0]), $defaultformat);
!         if (count($bits) > 1) {
!             $feedback = $this->parse_text_with_format(trim($bits[1]), $defaultformat);
!         } else {
!             $feedback = array('text' => '', 'format' => $defaultformat, 'files' => array());
!         }
!         return array($ans, $feedback);
!     }
! 
!     function split_truefalse_comment($answer, $defaultformat) {
!         $bits = explode('#', $answer, 3);
!         $ans = $this->parse_text_with_format(trim($bits[0]), $defaultformat);
!         if (count($bits) > 1) {
!             $wrongfeedback = $this->parse_text_with_format(trim($bits[1]), $defaultformat);
!         } else {
!             $wrongfeedback = array('text' => '', 'format' => $defaultformat, 'files' => array());
!         }
!         if (count($bits) > 2) {
!             $rightfeedback = $this->parse_text_with_format(trim($bits[2]), $defaultformat);
!         } else {
!             $rightfeedback = array('text' => '', 'format' => $defaultformat, 'files' => array());
!         }
!         return array($ans, $wrongfeedback, $rightfeedback);
!     }
! 
!     function escapedchar_pre($string) {
!         //Replaces escaped control characters with a placeholder BEFORE processing
! 
!         $escapedcharacters = array("\\:",    "\\#",    "\\=",    "\\{",    "\\}",    "\\~",    "\\n"  );  //dlnsk
!         $placeholders      = array("&&058;", "&&035;", "&&061;", "&&123;", "&&125;", "&&126;", "&&010");  //dlnsk
! 
!         $string = str_replace("\\\\", "&&092;", $string);
!         $string = str_replace($escapedcharacters, $placeholders, $string);
!         $string = str_replace("&&092;", "\\", $string);
!         return $string;
!     }
! 
!     function escapedchar_post($string) {
!         //Replaces placeholders with corresponding character AFTER processing is done
!         $placeholders = array("&&058;", "&&035;", "&&061;", "&&123;", "&&125;", "&&126;", "&&010"); //dlnsk
!         $characters   = array(":",     "#",      "=",      "{",      "}",      "~",      "\n"  ); //dlnsk
!         $string = str_replace($placeholders, $characters, $string);
!         return $string;
!     }
! 
!     function check_answer_count($min, $answers, $text) {
!         $countanswers = count($answers);
!         if ($countanswers < $min) {
!             $importminerror = get_string('importminerror', 'quiz');
!             $this->error($importminerror, $text);
!             return false;
!         }
  
!         return true;
!     }
  
!     protected function parse_text_with_format($text, $defaultformat = FORMAT_MOODLE) {
!         $result = array(
              'text' => $text,
              'format' => $defaultformat,
              'files' => array(),
!         );
!         if (strpos($text, '[') === 0) {
!             $formatend = strpos($text, ']');
!             $result['format'] = $this->format_name_to_const(substr($text, 1, $formatend - 1));
!             if ($result['format'] == -1) {
!                 $result['format'] = $defaultformat;
!             } else {
!                 $result['text'] = substr($text, $formatend + 1);
!             }
!         }
!         $result['text'] = trim($this->escapedchar_post($result['text']));
!         return $result;
!     }
! 
!     function readquestion($lines) {
!     // Given an array of lines known to define a question in this format, this function
!     // converts it into a question object suitable for processing and insertion into Moodle.
! 
!         $question = $this->defaultquestion();
!         $comment = NULL;
!         // define replaced by simple assignment, stop redefine notices
!         $gift_answerweight_regex = '/^%\-*([0-9]{1,2})\.?([0-9]*)%/';
! 
!         // REMOVED COMMENTED LINES and IMPLODE
!         foreach ($lines as $key => $line) {
!             $line = trim($line);
!             if (substr($line, 0, 2) == '//') {
!                 $lines[$key] = ' ';
!             }
!         }
! 
!         $text = trim(implode(' ', $lines));
! 
!         if ($text == '') {
!             return false;
!         }
! 
!         // Substitute escaped control characters with placeholders
!         $text = $this->escapedchar_pre($text);
! 
!         // Look for category modifier
!         if (preg_match('~^\$CATEGORY:~', $text)) {
!             // $newcategory = $matches[1];
!             $newcategory = trim(substr($text, 10));
! 
!             // build fake question to contain category
!             $question->qtype = 'category';
!             $question->category = $newcategory;
!             return $question;
!         }
! 
!         // QUESTION NAME parser
!         if (substr($text, 0, 2) == '::') {
!             $text = substr($text, 2);
! 
!             $namefinish = strpos($text, '::');
!             if ($namefinish === false) {
!                 $question->name = false;
!                 // name will be assigned after processing question text below
!             } else {
!                 $questionname = substr($text, 0, $namefinish);
!                 $question->name = trim($this->escapedchar_post($questionname));
!                 $text = trim(substr($text, $namefinish+2)); // Remove name from text
!             }
!         } else {
!             $question->name = false;
!         }
! 
! 
!         // FIND ANSWER section
!         // no answer means its a description
!         $answerstart = strpos($text, '{');
!         $answerfinish = strpos($text, '}');
! 
!         $description = false;
!         if (($answerstart === false) and ($answerfinish === false)) {
!             $description = true;
!             $answertext = '';
!             $answerlength = 0;
!         } else if (!(($answerstart !== false) and ($answerfinish !== false))) {
!             $this->error(get_string('braceerror', 'quiz'), $text);
!             return false;
!         } else {
!             $answerlength = $answerfinish - $answerstart;
!             $answertext = trim(substr($text, $answerstart + 1, $answerlength - 1));
!         }
! 
!         // Format QUESTION TEXT without answer, inserting "_____" as necessary
!         if ($description) {
!             $questiontext = $text;
!         } else if (substr($text, -1) == "}") {
!             // no blank line if answers follow question, outside of closing punctuation
!             $questiontext = substr_replace($text, "", $answerstart, $answerlength+1);
!         } else {
!             // inserts blank line for missing word format
!             $questiontext = substr_replace($text, "_____", $answerstart, $answerlength+1);
!         }
! 
!         // Get questiontext format from questiontext
!         $text = $this->parse_text_with_format($questiontext);
!         $question->questiontextformat = $text['format'];
!         $question->generalfeedbackformat = $text['format'];
!         $question->questiontext = $text['text'];
! 
!         // set question name if not already set
!         if ($question->name === false) {
!             $question->name = $question->questiontext;
!         }
! 
!         // ensure name is not longer than 250 characters
!         $question->name = shorten_text($question->name, 200);
!         $question->name = strip_tags(substr($question->name, 0, 250));
! 
!         // determine QUESTION TYPE
!         $question->qtype = NULL;
! 
!         // give plugins first try
!         // plugins must promise not to intercept standard qtypes
!         // MDL-12346, this could be called from lesson mod which has its own base class =(
!         if (method_exists($this, 'try_importing_using_qtypes') && ($try_question = $this->try_importing_using_qtypes($lines, $question, $answertext))) {
!             return $try_question;
!         }
! 
!         if ($description) {
!             $question->qtype = DESCRIPTION;
! 
!         } else if ($answertext == '') {
!             $question->qtype = ESSAY;
! 
!         } else if ($answertext{0} == '#') {
!             $question->qtype = NUMERICAL;
! 
!         } else if (strpos($answertext, '~') !== false)  {
!             // only Multiplechoice questions contain tilde ~
!             $question->qtype = MULTICHOICE;
! 
!         } else if (strpos($answertext, '=')  !== false
!                 && strpos($answertext, '->') !== false) {
!             // only Matching contains both = and ->
!             $question->qtype = MATCH;
! 
!         } else { // either TRUEFALSE or SHORTANSWER
! 
!             // TRUEFALSE question check
!             $truefalse_check = $answertext;
!             if (strpos($answertext, '#') > 0) {
!                 // strip comments to check for TrueFalse question
!                 $truefalse_check = trim(substr($answertext, 0, strpos($answertext,"#")));
!             }
! 
!             $valid_tf_answers = array('T', 'TRUE', 'F', 'FALSE');
!             if (in_array($truefalse_check, $valid_tf_answers)) {
!                 $question->qtype = TRUEFALSE;
! 
!             } else { // Must be SHORTANSWER
!                 $question->qtype = SHORTANSWER;
!             }
!         }
! 
!         if (!isset($question->qtype)) {
!             $giftqtypenotset = get_string('giftqtypenotset', 'quiz');
!             $this->error($giftqtypenotset, $text);
!             return false;
!         }
! 
!         switch ($question->qtype) {
!             case DESCRIPTION:
!                 $question->defaultgrade = 0;
!                 $question->length = 0;
!                 return $question;
!                 break;
!             case ESSAY:
!                 $question->fraction = 0;
!                 $question->feedback['text'] = '';
!                 $question->feedback['format'] = $question->questiontextformat;
!                 $question->feedback['files'] = array();
!                 return $question;
!                 break;
!             case MULTICHOICE:
!                 if (strpos($answertext,"=") === false) {
!                     $question->single = 0; // multiple answers are enabled if no single answer is 100% correct
!                 } else {
!                     $question->single = 1; // only one answer allowed (the default)
!                 }
!                 $question->correctfeedback['text'] = '';
!                 $question->correctfeedback['format'] = $question->questiontextformat;
!                 $question->correctfeedback['files'] = array();
!                 $question->partiallycorrectfeedback['text'] = '';
!                 $question->partiallycorrectfeedback['format'] = $question->questiontextformat;
!                 $question->partiallycorrectfeedback['files'] = array();
!                 $question->incorrectfeedback['text'] = '';
!                 $question->incorrectfeedback['format'] = $question->questiontextformat;
!                 $question->incorrectfeedback['files'] = array();
! 
!                 $answertext = str_replace("=", "~=", $answertext);
!                 $answers = explode("~", $answertext);
!                 if (isset($answers[0])) {
!                     $answers[0] = trim($answers[0]);
!                 }
!                 if (empty($answers[0])) {
!                     array_shift($answers);
!                 }
! 
!                 $countanswers = count($answers);
! 
!                 if (!$this->check_answer_count(2, $answers, $text)) {
!                     return false;
!                     break;
!                 }
! 
!                 foreach ($answers as $key => $answer) {
!                     $answer = trim($answer);
! 
!                     // determine answer weight
!                     if ($answer[0] == '=') {
!                         $answer_weight = 1;
!                         $answer = substr($answer, 1);
! 
!                     } else if (preg_match($gift_answerweight_regex, $answer)) {    // check for properly formatted answer weight
!                         $answer_weight = $this->answerweightparser($answer);
! 
!                     } else {     //default, i.e., wrong anwer
!                         $answer_weight = 0;
!                     }
!                     list($question->answer[$key], $question->feedback[$key]) =
!                             $this->commentparser($answer, $question->questiontextformat);
!                     $question->fraction[$key] = $answer_weight;
!                 }  // end foreach answer
! 
!                 //$question->defaultgrade = 1;
!                 //$question->image = "";   // No images with this format
!                 return $question;
!                 break;
! 
!             case MATCH:
!                 $answers = explode('=', $answertext);
!                 if (isset($answers[0])) {
!                     $answers[0] = trim($answers[0]);
!                 }
!                 if (empty($answers[0])) {
!                     array_shift($answers);
!                 }
! 
!                 if (!$this->check_answer_count(2,$answers,$text)) {
!                     return false;
!                     break;
!                 }
! 
!                 foreach ($answers as $key => $answer) {
!                     $answer = trim($answer);
!                     if (strpos($answer, "->") === false) {
!                         $giftmatchingformat = get_string('giftmatchingformat','quiz');
!                         $this->error($giftmatchingformat, $answer);
!                         return false;
!                         break 2;
!                     }
! 
!                     $marker = strpos($answer, '->');
!                     $question->subquestions[$key] = $this->parse_text_with_format(
!                             substr($answer, 0, $marker), $question->questiontextformat);
!                     $question->subanswers[$key] = trim($this->escapedchar_post(
!                             substr($answer, $marker + 2)));
!                 }
! 
!                 return $question;
!                 break;
! 
!             case TRUEFALSE:
!                 list($answer, $wrongfeedback, $rightfeedback) =
!                         $this->split_truefalse_comment($answertext, $question->questiontextformat);
! 
!                 if ($answer['text'] == "T" OR $answer['text'] == "TRUE") {
!                     $question->correctanswer = 1;
!                     $question->feedbacktrue = $rightfeedback;
!                     $question->feedbackfalse = $wrongfeedback;
!                 } else {
!                     $question->correctanswer = 0;
!                     $question->feedbacktrue = $wrongfeedback;
!                     $question->feedbackfalse = $rightfeedback;
!                 }
! 
!                 $question->penalty = 1;
! 
!                 return $question;
!                 break;
! 
!             case SHORTANSWER:
!                 // SHORTANSWER Question
!                 $answers = explode("=", $answertext);
!                 if (isset($answers[0])) {
!                     $answers[0] = trim($answers[0]);
!                 }
!                 if (empty($answers[0])) {
!                     array_shift($answers);
!                 }
! 
!                 if (!$this->check_answer_count(1, $answers, $text)) {
!                     return false;
!                     break;
!                 }
! 
!                 foreach ($answers as $key => $answer) {
!                     $answer = trim($answer);
! 
!                     // Answer weight
!                     if (preg_match($gift_answerweight_regex, $answer)) {    // check for properly formatted answer weight
!                         $answer_weight = $this->answerweightparser($answer);
!                     } else {     //default, i.e., full-credit anwer
!                         $answer_weight = 1;
!                     }
! 
!                     list($answer, $question->feedback[$key]) = $this->commentparser(
!                             $answer, $question->questiontextformat);
! 
!                     $question->answer[$key] = $answer['text'];
!                     $question->fraction[$key] = $answer_weight;
!                 }
! 
!                 return $question;
!                 break;
! 
!             case NUMERICAL:
!                 // Note similarities to ShortAnswer
!                 $answertext = substr($answertext, 1); // remove leading "#"
! 
!                 // If there is feedback for a wrong answer, store it for now.
!                 if (($pos = strpos($answertext, '~')) !== false) {
!                     $wrongfeedback = substr($answertext, $pos);
!                     $answertext = substr($answertext, 0, $pos);
!                 } else {
!                     $wrongfeedback = '';
!                 }
! 
!                 $answers = explode("=", $answertext);
!                 if (isset($answers[0])) {
!                     $answers[0] = trim($answers[0]);
!                 }
!                 if (empty($answers[0])) {
!                     array_shift($answers);
!                 }
! 
!                 if (count($answers) == 0) {
!                     // invalid question
!                     $giftnonumericalanswers = get_string('giftnonumericalanswers','quiz');
!                     $this->error($giftnonumericalanswers, $text);
!                     return false;
!                     break;
!                 }
! 
!                 foreach ($answers as $key => $answer) {
!                     $answer = trim($answer);
! 
!                     // Answer weight
!                     if (preg_match($gift_answerweight_regex, $answer)) {    // check for properly formatted answer weight
!                         $answer_weight = $this->answerweightparser($answer);
!                     } else {     //default, i.e., full-credit anwer
!                         $answer_weight = 1;
!                     }
! 
!                     list($answer, $question->feedback[$key]) = $this->commentparser(
!                             $answer, $question->questiontextformat);
!                     $question->fraction[$key] = $answer_weight;
!                     $answer = $answer['text'];
! 
!                     //Calculate Answer and Min/Max values
!                     if (strpos($answer,"..") > 0) { // optional [min]..[max] format
!                         $marker = strpos($answer,"..");
!                         $max = trim(substr($answer, $marker+2));
!                         $min = trim(substr($answer, 0, $marker));
!                         $ans = ($max + $min)/2;
!                         $tol = $max - $ans;
!                     } else if (strpos($answer, ':') > 0) { // standard [answer]:[errormargin] format
!                         $marker = strpos($answer, ':');
!                         $tol = trim(substr($answer, $marker+1));
!                         $ans = trim(substr($answer, 0, $marker));
!                     } else { // only one valid answer (zero errormargin)
!                         $tol = 0;
!                         $ans = trim($answer);
!                     }
! 
!                     if (!(is_numeric($ans) || $ans = '*') || !is_numeric($tol)) {
!                             $errornotnumbers = get_string('errornotnumbers');
!                             $this->error($errornotnumbers, $text);
!                         return false;
!                         break;
!                     }
! 
!                     // store results
!                     $question->answer[$key] = $ans;
!                     $question->tolerance[$key] = $tol;
!                 }
! 
!                 if ($wrongfeedback) {
!                     $key += 1;
!                     $question->fraction[$key] = 0;
!                     list($notused, $question->feedback[$key]) = $this->commentparser(
!                             $wrongfeedback, $question->questiontextformat);
!                     $question->answer[$key] = '*';
!                     $question->tolerance[$key] = '';
!                 }
! 
!                 return $question;
!                 break;
! 
!                 default:
!                     $this->error(get_string('giftnovalidquestion', 'quiz'), $text);
!                 return fale;
!                 break;
! 
!         }
! 
!     }
! 
!     function repchar($text, $notused = 0) {
!         // Escapes 'reserved' characters # = ~ {) :
!         // Removes new lines
!         $reserved = array( '#', '=', '~', '{', '}', ':', "\n", "\r");
!         $escaped =  array('\#','\=','\~','\{','\}','\:', '\n', '' );
! 
!         $newtext = str_replace($reserved, $escaped, $text);
!         return $newtext;
!     }
! 
!     /**
!      * @param integer $format one of the FORMAT_ constants.
!      * @return string the corresponding name.
!      */
!     function format_const_to_name($format) {
!         if ($format == FORMAT_MOODLE) {
!             return 'moodle';
!         } else if ($format == FORMAT_HTML) {
!             return 'html';
!         } else if ($format == FORMAT_PLAIN) {
!             return 'plain';
!         } else if ($format == FORMAT_MARKDOWN) {
!             return 'markdown';
!         } else {
!             return 'moodle';
!         }
!     }
! 
!     /**
!      * @param integer $format one of the FORMAT_ constants.
!      * @return string the corresponding name.
!      */
!     function format_name_to_const($format) {
!         if ($format == 'moodle') {
!             return FORMAT_MOODLE;
!         } else if ($format == 'html') {
!             return FORMAT_HTML;
!         } else if ($format == 'plain') {
!             return FORMAT_PLAIN;
!         } else if ($format == 'markdown') {
!             return FORMAT_MARKDOWN;
!         } else {
!             return -1;
!         }
!     }
! 
!     public function write_name($name) {
!         return '::' . $this->repchar($name) . '::';
!     }
! 
!     public function write_questiontext($text, $format, $defaultformat = FORMAT_MOODLE) {
!         $output = '';
!         if ($text != '' && $format != $defaultformat) {
!             $output .= '[' . $this->format_const_to_name($format) . ']';
!         }
!         $output .= $this->repchar($text, $format);
!         return $output;
!     }
! 
!     function writequestion($question) {
!         global $QTYPES, $OUTPUT;
! 
!         // Start with a comment
!         $expout = "// question: $question->id  name: $question->name\n";
! 
!         // output depends on question type
!         switch($question->qtype) {
! 
!         case 'category':
!             // not a real question, used to insert category switch
!             $expout .= "\$CATEGORY: $question->category\n";
!             break;
! 
!         case DESCRIPTION:
!             $expout .= $this->write_name($question->name);
!             $expout .= $this->write_questiontext($question->questiontext, $question->questiontextformat);
!             break;
! 
!         case ESSAY:
!             $expout .= $this->write_name($question->name);
!             $expout .= $this->write_questiontext($question->questiontext, $question->questiontextformat);
!             $expout .= "{}\n";
!             break;
! 
!         case TRUEFALSE:
!             $trueanswer = $question->options->answers[$question->options->trueanswer];
!             $falseanswer = $question->options->answers[$question->options->falseanswer];
!             if ($trueanswer->fraction == 1) {
!                 $answertext = 'TRUE';
!                 $rightfeedback = $this->write_questiontext($trueanswer->feedback,
!                         $trueanswer->feedbackformat, $question->questiontextformat);
!                 $wrongfeedback = $this->write_questiontext($falseanswer->feedback,
!                         $falseanswer->feedbackformat, $question->questiontextformat);
!             } else {
!                 $answertext = 'FALSE';
!                 $rightfeedback = $this->write_questiontext($falseanswer->feedback,
!                         $falseanswer->feedbackformat, $question->questiontextformat);
!                 $wrongfeedback = $this->write_questiontext($trueanswer->feedback,
!                         $trueanswer->feedbackformat, $question->questiontextformat);
!             }
! 
!             $expout .= $this->write_name($question->name);
!             $expout .= $this->write_questiontext($question->questiontext, $question->questiontextformat);
!             $expout .= '{' . $this->repchar($answertext);
!             if ($wrongfeedback) {
!                 $expout .= '#' . $wrongfeedback;
!             } else if ($rightfeedback) {
!                 $expout .= '#';
!             }
!             if ($rightfeedback) {
!                 $expout .= '#' . $rightfeedback;
!             }
!             $expout .= "}\n";
!             break;
! 
!         case MULTICHOICE:
!             $expout .= $this->write_name($question->name);
!             $expout .= $this->write_questiontext($question->questiontext, $question->questiontextformat);
!             $expout .= "{\n";
!             foreach($question->options->answers as $answer) {
!                 if ($answer->fraction == 1) {
!                     $answertext = '=';
!                 } else if ($answer->fraction == 0) {
!                     $answertext = '~';
!                 } else {
!                     $weight = $answer->fraction * 100;
!                     $answertext = '~%' . $weight . '%';
!                 }
!                 $expout .= "\t" . $answertext . $this->write_questiontext($answer->answer,
!                             $answer->answerformat, $question->questiontextformat);
!                 if ($answer->feedback != '') {
!                     $expout .= '#' . $this->write_questiontext($answer->feedback,
!                             $answer->feedbackformat, $question->questiontextformat);
!                 }
!                 $expout .= "\n";
!             }
!             $expout .= "}\n";
!             break;
! 
!         case SHORTANSWER:
!             $expout .= $this->write_name($question->name);
!             $expout .= $this->write_questiontext($question->questiontext, $question->questiontextformat);
!             $expout .= "{\n";
!             foreach($question->options->answers as $answer) {
!                 $weight = 100 * $answer->fraction;
!                 $expout .= "\t=%" . $weight . '%' . $this->repchar($answer->answer) .
                          '#' . $this->write_questiontext($answer->feedback,
!                             $answer->feedbackformat, $question->questiontextformat) . "\n";
!             }
!             $expout .= "}\n";
!             break;
! 
!         case NUMERICAL:
!             $expout .= $this->write_name($question->name);
!             $expout .= $this->write_questiontext($question->questiontext, $question->questiontextformat);
!             $expout .= "{#\n";
!             foreach ($question->options->answers as $answer) {
!                 if ($answer->answer != '' && $answer->answer != '*') {
!                     $weight = 100 * $answer->fraction;
!                     $expout .= "\t=%" . $weight . '%' . $answer->answer . ':' .
!                             (float)$answer->tolerance . '#' . $this->write_questiontext($answer->feedback,
!                             $answer->feedbackformat, $question->questiontextformat) . "\n";
!                 } else {
!                     $expout .= "\t~#" . $this->write_questiontext($answer->feedback,
!                             $answer->feedbackformat, $question->questiontextformat) . "\n";
!                 }
!             }
!             $expout .= "}\n";
!             break;
! 
!         case MATCH:
!             $expout .= $this->write_name($question->name);
!             $expout .= $this->write_questiontext($question->questiontext, $question->questiontextformat);
!             $expout .= "{\n";
!             foreach($question->options->subquestions as $subquestion) {
!                 $expout .= "\t=" . $this->repchar($this->write_questiontext($subquestion->questiontext, $subquestion->questiontextformat, $question->questiontextformat)) .
                          ' -> ' . $this->repchar($subquestion->answertext) . "\n";
!             }
!             $expout .= "}\n";
!             break;
! 
!         default:
!             // Check for plugins
!             if ($out = $this->try_exporting_using_qtypes($question->qtype, $question)) {
!                 $expout .= $out;
!             } else {
!                 $expout .= "Question type $question->qtype is not supported\n";
!                 echo $OUTPUT->notification(get_string('nohandler', 'qformat_gift',
!                         $QTYPES[$question->qtype]->local_name()));
!             }
!         }
! 
!         // Add empty line to delimit questions
!         $expout .= "\n";
!         return $expout;
!     }
  }
  
--- 37,734 ----
   */
  class qformat_gift extends qformat_default {
  
! 	function provide_import() {
! 		return true;
! 	}
! 
! 	function provide_export() {
! 		return true;
! 	}
! 
! 	function export_file_extension() {
! 		return '.txt';
! 	}
! 
! 	function answerweightparser(&$answer) {
! 		$answer = substr($answer, 1);                        // removes initial %
! 		$end_position  = strpos($answer, "%");
! 		$answer_weight = substr($answer, 0, $end_position);  // gets weight as integer
! 		$answer_weight = $answer_weight/100;                 // converts to percent
! 		$answer = substr($answer, $end_position+1);          // removes comment from answer
! 		return $answer_weight;
! 	}
! 
! 	function commentparser($answer, $defaultformat) {
! 		$bits = explode('#', $answer, 2);
! 		$ans = $this->parse_text_with_format(trim($bits[0]), $defaultformat);
! 		if (count($bits) > 1) {
! 			$feedback = $this->parse_text_with_format(trim($bits[1]), $defaultformat);
! 		} else {
! 			$feedback = array('text' => '', 'format' => $defaultformat, 'files' => array());
! 		}
! 		return array($ans, $feedback);
! 	}
! 
! 	function split_truefalse_comment($answer, $defaultformat) {
! 		$bits = explode('#', $answer, 3);
! 		$ans = $this->parse_text_with_format(trim($bits[0]), $defaultformat);
! 		if (count($bits) > 1) {
! 			$wrongfeedback = $this->parse_text_with_format(trim($bits[1]), $defaultformat);
! 		} else {
! 			$wrongfeedback = array('text' => '', 'format' => $defaultformat, 'files' => array());
! 		}
! 		if (count($bits) > 2) {
! 			$rightfeedback = $this->parse_text_with_format(trim($bits[2]), $defaultformat);
! 		} else {
! 			$rightfeedback = array('text' => '', 'format' => $defaultformat, 'files' => array());
! 		}
! 		return array($ans, $wrongfeedback, $rightfeedback);
! 	}
! 
! 	function escapedchar_pre($string) {
! 		//Replaces escaped control characters with a placeholder BEFORE processing
! 
! 		$escapedcharacters = array("\\:",    "\\#",    "\\=",    "\\{",    "\\}",    "\\~",    "\\n"  );  //dlnsk
! 		$placeholders      = array("&&058;", "&&035;", "&&061;", "&&123;", "&&125;", "&&126;", "&&010");  //dlnsk
! 
! 		$string = str_replace("\\\\", "&&092;", $string);
! 		$string = str_replace($escapedcharacters, $placeholders, $string);
! 		$string = str_replace("&&092;", "\\", $string);
! 		return $string;
! 	}
! 
! 	function escapedchar_post($string) {
! 		//Replaces placeholders with corresponding character AFTER processing is done
! 		$placeholders = array("&&058;", "&&035;", "&&061;", "&&123;", "&&125;", "&&126;", "&&010"); //dlnsk
! 		$characters   = array(":",     "#",      "=",      "{",      "}",      "~",      "\n"  ); //dlnsk
! 		$string = str_replace($placeholders, $characters, $string);
! 		return $string;
! 	}
! 
! 	function check_answer_count($min, $answers, $text) {
! 		$countanswers = count($answers);
! 		if ($countanswers < $min) {
! 			$importminerror = get_string('importminerror', 'quiz');
! 			$this->error($importminerror, $text);
! 			return false;
! 		}
  
! 		return true;
! 	}
  
! 	protected function parse_text_with_format($text, $defaultformat = FORMAT_MOODLE) {
! 		$result = array(
              'text' => $text,
              'format' => $defaultformat,
              'files' => array(),
! 		);
! 		if (strpos($text, '[') === 0) {
! 			$formatend = strpos($text, ']');
! 			$result['format'] = $this->format_name_to_const(substr($text, 1, $formatend - 1));
! 			if ($result['format'] == -1) {
! 				$result['format'] = $defaultformat;
! 			} else {
! 				$result['text'] = substr($text, $formatend + 1);
! 			}
! 		}
! 		$result['text'] = trim($this->escapedchar_post($result['text']));
! 		return $result;
! 	}
! 
! 	function readquestion($lines) {
! 		// Given an array of lines known to define a question in this format, this function
! 		// converts it into a question object suitable for processing and insertion into Moodle.
! 
! 		$question = $this->defaultquestion();
! 		$comment = NULL;
! 		// define replaced by simple assignment, stop redefine notices
! 		$gift_answerweight_regex = '/^%\-*([0-9]{1,2})\.?([0-9]*)%/';
! 
! 		// REMOVED COMMENTED LINES and IMPLODE
! 		foreach ($lines as $key => $line) {
! 			$line = trim($line);
! 			if (substr($line, 0, 2) == '//') {
! 				$lines[$key] = ' ';
! 			}
! 		}
! 
! 		$text = trim(implode(' ', $lines));
! 
! 		if ($text == '') {
! 			return false;
! 		}
! 
! 		// Substitute escaped control characters with placeholders
! 		$text = $this->escapedchar_pre($text);
! 
! 		// Look for category modifier
! 		if (preg_match('~^\$CATEGORY:~', $text)) {
! 			// $newcategory = $matches[1];
! 			$newcategory = trim(substr($text, 10));
! 
! 			// build fake question to contain category
! 			$question->qtype = 'category';
! 			$question->category = $newcategory;
! 			return $question;
! 		}
! 
! 		// QUESTION NAME parser
! 		if (substr($text, 0, 2) == '::') {
! 			$text = substr($text, 2);
! 
! 			$namefinish = strpos($text, '::');
! 			if ($namefinish === false) {
! 				$question->name = false;
! 				// name will be assigned after processing question text below
! 			} else {
! 				$questionname = substr($text, 0, $namefinish);
! 				$question->name = trim($this->escapedchar_post($questionname));
! 				$text = trim(substr($text, $namefinish+2)); // Remove name from text
! 			}
! 		} else {
! 			$question->name = false;
! 		}
! 
! 
! 		// FIND ANSWER section
! 		// no answer means its a description
! 		$answerstart = strpos($text, '{');
! 		$answerfinish = strpos($text, '}');
! 
! 		$description = false;
! 		if (($answerstart === false) and ($answerfinish === false)) {
! 			$description = true;
! 			$answertext = '';
! 			$answerlength = 0;
! 		} else if (!(($answerstart !== false) and ($answerfinish !== false))) {
! 			$this->error(get_string('braceerror', 'quiz'), $text);
! 			return false;
! 		} else {
! 			$answerlength = $answerfinish - $answerstart;
! 			$answertext = trim(substr($text, $answerstart + 1, $answerlength - 1));
! 		}
! 
! 		// Format QUESTION TEXT without answer, inserting "_____" as necessary
! 		if ($description) {
! 			$questiontext = $text;
! 		} else if (substr($text, -1) == "}") {
! 			// no blank line if answers follow question, outside of closing punctuation
! 			$questiontext = substr_replace($text, "", $answerstart, $answerlength+1);
! 		} else {
! 			// inserts blank line for missing word format
! 			$questiontext = substr_replace($text, "_____", $answerstart, $answerlength+1);
! 		}
! 
! 		// Get questiontext format from questiontext
! 		$text = $this->parse_text_with_format($questiontext);
! 		$question->questiontextformat = $text['format'];
! 		$question->generalfeedbackformat = $text['format'];
! 		$question->questiontext = $text['text'];
! 
! 		// set question name if not already set
! 		if ($question->name === false) {
! 			$question->name = $question->questiontext;
! 		}
! 
! 		// ensure name is not longer than 250 characters
! 		$question->name = shorten_text($question->name, 200);
! 		$question->name = strip_tags(substr($question->name, 0, 250));
! 
! 		// determine QUESTION TYPE
! 		$question->qtype = NULL;
! 
! 		// give plugins first try
! 		// plugins must promise not to intercept standard qtypes
! 		// MDL-12346, this could be called from lesson mod which has its own base class =(
! 		if (method_exists($this, 'try_importing_using_qtypes') && ($try_question = $this->try_importing_using_qtypes($lines, $question, $answertext))) {
! 			return $try_question;
! 		}
! 
! 		if ($description) {
! 			$question->qtype = DESCRIPTION;
! 
! 		} else if ($answertext == '') {
! 			$question->qtype = ESSAY;
! 
! 		} else if ($answertext{0} == '#') {
! 			$question->qtype = NUMERICAL;
! 
! 		} else if (strpos($answertext, '~') !== false)  {
! 			// only Multiplechoice questions contain tilde ~
! 			$question->qtype = MULTICHOICE;
! 
! 		} else if (strpos($answertext, '=')  !== false
! 		&& strpos($answertext, '->') !== false) {
! 			// only Matching contains both = and ->
! 			$question->qtype = MATCH;
! 
! 		} else { // either TRUEFALSE or SHORTANSWER
! 
! 			// TRUEFALSE question check
! 			$truefalse_check = $answertext;
! 			if (strpos($answertext, '#') > 0) {
! 				// strip comments to check for TrueFalse question
! 				$truefalse_check = trim(substr($answertext, 0, strpos($answertext,"#")));
! 			}
! 
! 			$valid_tf_answers = array('T', 'TRUE', 'F', 'FALSE');
! 			if (in_array($truefalse_check, $valid_tf_answers)) {
! 				$question->qtype = TRUEFALSE;
! 
! 			} else { // Must be SHORTANSWER
! 				$question->qtype = SHORTANSWER;
! 			}
! 		}
! 
! 		if (!isset($question->qtype)) {
! 			$giftqtypenotset = get_string('giftqtypenotset', 'quiz');
! 			$this->error($giftqtypenotset, $text);
! 			return false;
! 		}
! 
! 		switch ($question->qtype) {
! 			case DESCRIPTION:
! 				$question->defaultgrade = 0;
! 				$question->length = 0;
! 				return $question;
! 				break;
! 			case ESSAY:
! 				$question->fraction = 0;
! 				$question->feedback['text'] = '';
! 				$question->feedback['format'] = $question->questiontextformat;
! 				$question->feedback['files'] = array();
! 				return $question;
! 				break;
! 			case MULTICHOICE:
! 				if (strpos($answertext,"=") === false) {
! 					$question->single = 0; // multiple answers are enabled if no single answer is 100% correct
! 				} else {
! 					$question->single = 1; // only one answer allowed (the default)
! 				}
! 				$question->correctfeedback['text'] = '';
! 				$question->correctfeedback['format'] = $question->questiontextformat;
! 				$question->correctfeedback['files'] = array();
! 				$question->partiallycorrectfeedback['text'] = '';
! 				$question->partiallycorrectfeedback['format'] = $question->questiontextformat;
! 				$question->partiallycorrectfeedback['files'] = array();
! 				$question->incorrectfeedback['text'] = '';
! 				$question->incorrectfeedback['format'] = $question->questiontextformat;
! 				$question->incorrectfeedback['files'] = array();
! 
! 				$answertext = str_replace("=", "~=", $answertext);
! 				$answers = explode("~", $answertext);
! 				if (isset($answers[0])) {
! 					$answers[0] = trim($answers[0]);
! 				}
! 				if (empty($answers[0])) {
! 					array_shift($answers);
! 				}
! 
! 				$countanswers = count($answers);
! 
! 				if (!$this->check_answer_count(2, $answers, $text)) {
! 					return false;
! 					break;
! 				}
! 
! 				foreach ($answers as $key => $answer) {
! 					$answer = trim($answer);
! 
! 					// determine answer weight
! 					if ($answer[0] == '=') {
! 						$answer_weight = 1;
! 						$answer = substr($answer, 1);
! 
! 					} else if (preg_match($gift_answerweight_regex, $answer)) {    // check for properly formatted answer weight
! 						$answer_weight = $this->answerweightparser($answer);
! 
! 					} else {     //default, i.e., wrong anwer
! 						$answer_weight = 0;
! 					}
! 					list($question->answer[$key], $question->feedback[$key]) =
! 					$this->commentparser($answer, $question->questiontextformat);
! 					$question->fraction[$key] = $answer_weight;
! 				}  // end foreach answer
! 
! 				//$question->defaultgrade = 1;
! 				//$question->image = "";   // No images with this format
! 				return $question;
! 				break;
! 
! 			case MATCH:
! 				$answers = explode('=', $answertext);
! 				if (isset($answers[0])) {
! 					$answers[0] = trim($answers[0]);
! 				}
! 				if (empty($answers[0])) {
! 					array_shift($answers);
! 				}
! 
! 				if (!$this->check_answer_count(2,$answers,$text)) {
! 					return false;
! 					break;
! 				}
! 
! 				foreach ($answers as $key => $answer) {
! 					$answer = trim($answer);
! 					if (strpos($answer, "->") === false) {
! 						$giftmatchingformat = get_string('giftmatchingformat','quiz');
! 						$this->error($giftmatchingformat, $answer);
! 						return false;
! 						break 2;
! 					}
! 
! 					$marker = strpos($answer, '->');
! 					$question->subquestions[$key] = $this->parse_text_with_format(
! 					substr($answer, 0, $marker), $question->questiontextformat);
! 					$question->subanswers[$key] = trim($this->escapedchar_post(
! 					substr($answer, $marker + 2)));
! 				}
! 
! 				return $question;
! 				break;
! 
! 			case TRUEFALSE:
! 				list($answer, $wrongfeedback, $rightfeedback) =
! 				$this->split_truefalse_comment($answertext, $question->questiontextformat);
! 
! 				if ($answer['text'] == "T" OR $answer['text'] == "TRUE") {
! 					$question->correctanswer = 1;
! 					$question->feedbacktrue = $rightfeedback;
! 					$question->feedbackfalse = $wrongfeedback;
! 				} else {
! 					$question->correctanswer = 0;
! 					$question->feedbacktrue = $wrongfeedback;
! 					$question->feedbackfalse = $rightfeedback;
! 				}
! 
! 				$question->penalty = 1;
! 
! 				return $question;
! 				break;
! 
! 			case SHORTANSWER:
! 				// SHORTANSWER Question
! 				$answers = explode("=", $answertext);
! 				if (isset($answers[0])) {
! 					$answers[0] = trim($answers[0]);
! 				}
! 				if (empty($answers[0])) {
! 					array_shift($answers);
! 				}
! 
! 				if (!$this->check_answer_count(1, $answers, $text)) {
! 					return false;
! 					break;
! 				}
! 
! 				foreach ($answers as $key => $answer) {
! 					$answer = trim($answer);
! 
! 					// Answer weight
! 					if (preg_match($gift_answerweight_regex, $answer)) {    // check for properly formatted answer weight
! 						$answer_weight = $this->answerweightparser($answer);
! 					} else {     //default, i.e., full-credit anwer
! 						$answer_weight = 1;
! 					}
! 
! 					list($answer, $question->feedback[$key]) = $this->commentparser(
! 					$answer, $question->questiontextformat);
! 
! 					$question->answer[$key] = $answer['text'];
! 					$question->fraction[$key] = $answer_weight;
! 				}
! 
! 				return $question;
! 				break;
! 
! 			case NUMERICAL:
! 				// Note similarities to ShortAnswer
! 				$answertext = substr($answertext, 1); // remove leading "#"
! 
! 				// If there is feedback for a wrong answer, store it for now.
! 				if (($pos = strpos($answertext, '~')) !== false) {
! 					$wrongfeedback = substr($answertext, $pos);
! 					$answertext = substr($answertext, 0, $pos);
! 				} else {
! 					$wrongfeedback = '';
! 				}
! 
! 				$answers = explode("=", $answertext);
! 				if (isset($answers[0])) {
! 					$answers[0] = trim($answers[0]);
! 				}
! 				if (empty($answers[0])) {
! 					array_shift($answers);
! 				}
! 
! 				if (count($answers) == 0) {
! 					// invalid question
! 					$giftnonumericalanswers = get_string('giftnonumericalanswers','quiz');
! 					$this->error($giftnonumericalanswers, $text);
! 					return false;
! 					break;
! 				}
! 
! 				foreach ($answers as $key => $answer) {
! 					$answer = trim($answer);
! 
! 					// Answer weight
! 					if (preg_match($gift_answerweight_regex, $answer)) {    // check for properly formatted answer weight
! 						$answer_weight = $this->answerweightparser($answer);
! 					} else {     //default, i.e., full-credit anwer
! 						$answer_weight = 1;
! 					}
! 
! 					list($answer, $question->feedback[$key]) = $this->commentparser(
! 					$answer, $question->questiontextformat);
! 					$question->fraction[$key] = $answer_weight;
! 					$answer = $answer['text'];
! 
! 					//Calculate Answer and Min/Max values
! 					if (strpos($answer,"..") > 0) { // optional [min]..[max] format
! 						$marker = strpos($answer,"..");
! 						$max = trim(substr($answer, $marker+2));
! 						$min = trim(substr($answer, 0, $marker));
! 						$ans = ($max + $min)/2;
! 						$tol = $max - $ans;
! 					} else if (strpos($answer, ':') > 0) { // standard [answer]:[errormargin] format
! 						$marker = strpos($answer, ':');
! 						$tol = trim(substr($answer, $marker+1));
! 						$ans = trim(substr($answer, 0, $marker));
! 					} else { // only one valid answer (zero errormargin)
! 						$tol = 0;
! 						$ans = trim($answer);
! 					}
! 
! 					if (!(is_numeric($ans) || $ans = '*') || !is_numeric($tol)) {
! 						$errornotnumbers = get_string('errornotnumbers');
! 						$this->error($errornotnumbers, $text);
! 						return false;
! 						break;
! 					}
! 
! 					// store results
! 					$question->answer[$key] = $ans;
! 					$question->tolerance[$key] = $tol;
! 				}
! 
! 				if ($wrongfeedback) {
! 					$key += 1;
! 					$question->fraction[$key] = 0;
! 					list($notused, $question->feedback[$key]) = $this->commentparser(
! 					$wrongfeedback, $question->questiontextformat);
! 					$question->answer[$key] = '*';
! 					$question->tolerance[$key] = '';
! 				}
! 
! 				return $question;
! 				break;
! 
! 			default:
! 				$this->error(get_string('giftnovalidquestion', 'quiz'), $text);
! 				return fale;
! 				break;
! 
! 		}
! 
! 	}
! 
! 	function repchar($text, $notused = 0) {
! 		// Escapes 'reserved' characters # = ~ {) :
! 		// Removes new lines
! 		$reserved = array( '#', '=', '~', '{', '}', ':', "\n", "\r");
! 		$escaped =  array('\#','\=','\~','\{','\}','\:', '\n', '' );
! 
! 		$newtext = str_replace($reserved, $escaped, $text);
! 		return $newtext;
! 	}
! 
! 	/**
! 	 * @param integer $format one of the FORMAT_ constants.
! 	 * @return string the corresponding name.
! 	 */
! 	function format_const_to_name($format) {
! 		if ($format == FORMAT_MOODLE) {
! 			return 'moodle';
! 		} else if ($format == FORMAT_HTML) {
! 			return 'html';
! 		} else if ($format == FORMAT_PLAIN) {
! 			return 'plain';
! 		} else if ($format == FORMAT_MARKDOWN) {
! 			return 'markdown';
! 		} else {
! 			return 'moodle';
! 		}
! 	}
! 
! 	/**
! 	 * @param integer $format one of the FORMAT_ constants.
! 	 * @return string the corresponding name.
! 	 */
! 	function format_name_to_const($format) {
! 		if ($format == 'moodle') {
! 			return FORMAT_MOODLE;
! 		} else if ($format == 'html') {
! 			return FORMAT_HTML;
! 		} else if ($format == 'plain') {
! 			return FORMAT_PLAIN;
! 		} else if ($format == 'markdown') {
! 			return FORMAT_MARKDOWN;
! 		} else {
! 			return -1;
! 		}
! 	}
! 
! 	public function write_name($name) {
! 		return '::' . $this->repchar($name) . '::';
! 	}
! 
! 	public function write_questiontext($text, $format, $defaultformat = FORMAT_MOODLE) {
! 		$output = '';
! 		if ($text != '' && $format != $defaultformat) {
! 			$output .= '[' . $this->format_const_to_name($format) . ']';
! 		}
! 		$output .= $this->repchar($text, $format);
! 		return $output;
! 	}
! 
! 	function writequestion($question) {
! 		global $QTYPES, $OUTPUT;
! 
! 		// Start with a comment
! 		$expout = "// question: $question->id  name: $question->name\n";
! 
! 		// output depends on question type
! 		switch($question->qtype) {
! 
! 			case 'category':
! 				// not a real question, used to insert category switch
! 				$expout .= "\$CATEGORY: $question->category\n";
! 				break;
! 
! 			case DESCRIPTION:
! 				$expout .= $this->write_name($question->name);
! 				$expout .= $this->write_questiontext($question->questiontext, $question->questiontextformat);
! 				break;
! 
! 			case ESSAY:
! 				$expout .= $this->write_name($question->name);
! 				$expout .= $this->write_questiontext($question->questiontext, $question->questiontextformat);
! 				$expout .= "{}\n";
! 				break;
! 
! 			case TRUEFALSE:
! 				$trueanswer = $question->options->answers[$question->options->trueanswer];
! 				$falseanswer = $question->options->answers[$question->options->falseanswer];
! 				if ($trueanswer->fraction == 1) {
! 					$answertext = 'TRUE';
! 					$rightfeedback = $this->write_questiontext($trueanswer->feedback,
! 					$trueanswer->feedbackformat, $question->questiontextformat);
! 					$wrongfeedback = $this->write_questiontext($falseanswer->feedback,
! 					$falseanswer->feedbackformat, $question->questiontextformat);
! 				} else {
! 					$answertext = 'FALSE';
! 					$rightfeedback = $this->write_questiontext($falseanswer->feedback,
! 					$falseanswer->feedbackformat, $question->questiontextformat);
! 					$wrongfeedback = $this->write_questiontext($trueanswer->feedback,
! 					$trueanswer->feedbackformat, $question->questiontextformat);
! 				}
! 
! 				$expout .= $this->write_name($question->name);
! 				$expout .= $this->write_questiontext($question->questiontext, $question->questiontextformat);
! 				$expout .= '{' . $this->repchar($answertext);
! 				if ($wrongfeedback) {
! 					$expout .= '#' . $wrongfeedback;
! 				} else if ($rightfeedback) {
! 					$expout .= '#';
! 				}
! 				if ($rightfeedback) {
! 					$expout .= '#' . $rightfeedback;
! 				}
! 				$expout .= "}\n";
! 				break;
! 
! 			case MULTICHOICE:
! 				$expout .= $this->write_name($question->name);
! 				$expout .= $this->write_questiontext($question->questiontext, $question->questiontextformat);
! 				$expout .= "{\n";
! 				foreach($question->options->answers as $answer) {
! 					if ($answer->fraction == 1) {
! 						$answertext = '=';
! 					} else if ($answer->fraction == 0) {
! 						$answertext = '~';
! 					} else {
! 						$weight = $answer->fraction * 100;
! 						$answertext = '~%' . $weight . '%';
! 					}
! 					$expout .= "\t" . $answertext . $this->write_questiontext($answer->answer,
! 					$answer->answerformat, $question->questiontextformat);
! 					if ($answer->feedback != '') {
! 						$expout .= '#' . $this->write_questiontext($answer->feedback,
! 						$answer->feedbackformat, $question->questiontextformat);
! 					}
! 					$expout .= "\n";
! 				}
! 				$expout .= "}\n";
! 				break;
! 
! 			case SHORTANSWER:
! 				$expout .= $this->write_name($question->name);
! 				$expout .= $this->write_questiontext($question->questiontext, $question->questiontextformat);
! 				$expout .= "{\n";
! 				foreach($question->options->answers as $answer) {
! 					$weight = 100 * $answer->fraction;
! 					$expout .= "\t=%" . $weight . '%' . $this->repchar($answer->answer) .
                          '#' . $this->write_questiontext($answer->feedback,
! 					$answer->feedbackformat, $question->questiontextformat) . "\n";
! 				}
! 				$expout .= "}\n";
! 				break;
! 
! 			case NUMERICAL:
! 				$expout .= $this->write_name($question->name);
! 				$expout .= $this->write_questiontext($question->questiontext, $question->questiontextformat);
! 				$expout .= "{#\n";
! 				foreach ($question->options->answers as $answer) {
! 					if ($answer->answer != '' && $answer->answer != '*') {
! 						$weight = 100 * $answer->fraction;
! 						$expout .= "\t=%" . $weight . '%' . $answer->answer . ':' .
! 						(float)$answer->tolerance . '#' . $this->write_questiontext($answer->feedback,
! 						$answer->feedbackformat, $question->questiontextformat) . "\n";
! 					} else {
! 						$expout .= "\t~#" . $this->write_questiontext($answer->feedback,
! 						$answer->feedbackformat, $question->questiontextformat) . "\n";
! 					}
! 				}
! 				$expout .= "}\n";
! 				break;
! 
! 			case MATCH:
! 				$expout .= $this->write_name($question->name);
! 				$expout .= $this->write_questiontext($question->questiontext, $question->questiontextformat);
! 				$expout .= "{\n";
! 				foreach($question->options->subquestions as $subquestion) {
! 					$expout .= "\t=" . $this->repchar($this->write_questiontext($subquestion->questiontext, $subquestion->questiontextformat, $question->questiontextformat)) .
                          ' -> ' . $this->repchar($subquestion->answertext) . "\n";
! 				}
! 				$expout .= "}\n";
! 				break;
! 
! 			default:
! 				// Check for plugins
! 				if ($out = $this->try_exporting_using_qtypes($question->qtype, $question)) {
! 					$expout .= $out;
! 				} else {
! 					$expout .= "Question type $question->qtype is not supported\n";
! 					echo $OUTPUT->notification(get_string('nohandler', 'qformat_gift',
! 					$QTYPES[$question->qtype]->local_name()));
! 				}
! 		}
! 
! 		// Add empty line to delimit questions
! 		$expout .= "\n";
! 		return $expout;
! 	}
  }
  
diff -crB questionorg/format/gift/simpletest/testgiftformat.php questionupd/format/gift/simpletest/testgiftformat.php
*** questionorg/format/gift/simpletest/testgiftformat.php	2012-04-13 12:31:11.763178262 +0500
--- questionupd/format/gift/simpletest/testgiftformat.php	2012-04-13 09:42:52.000000000 +0500
***************
*** 36,56 ****
   * @license http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
   */
  class qformat_gift_test extends UnitTestCase {
!     public function assert_same_gift($expectedtext, $text) {
!         $this->assertEqual(str_replace("\r\n", "\n", $expectedtext),
!                 str_replace("\r\n", "\n", $text));
!     }
  
!     public function test_import_essay() {
!         $gift = '
  // essay
  ::Q8:: How are you? {}';
!         $lines = preg_split('/[\\n\\r]/', str_replace("\r\n", "\n", $gift));
  
!         $importer = new qformat_gift();
!         $q = $importer->readquestion($lines);
  
!         $expectedq = (object) array(
              'name' => 'Q8',
              'questiontext' => 'How are you?',
              'questiontextformat' => FORMAT_MOODLE,
--- 36,56 ----
   * @license http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
   */
  class qformat_gift_test extends UnitTestCase {
! 	public function assert_same_gift($expectedtext, $text) {
! 		$this->assertEqual(str_replace("\r\n", "\n", $expectedtext),
! 		str_replace("\r\n", "\n", $text));
! 	}
  
! 	public function test_import_essay() {
! 		$gift = '
  // essay
  ::Q8:: How are you? {}';
! 		$lines = preg_split('/[\\n\\r]/', str_replace("\r\n", "\n", $gift));
  
! 		$importer = new qformat_gift();
! 		$q = $importer->readquestion($lines);
  
! 		$expectedq = (object) array(
              'name' => 'Q8',
              'questiontext' => 'How are you?',
              'questiontextformat' => FORMAT_MOODLE,
***************
*** 64,77 ****
                  'text' => '',
                  'format' => FORMAT_MOODLE,
                  'files' => array(),
!             ),
!         );
  
!         $this->assert(new CheckSpecifiedFieldsExpectation($expectedq), $q);
!     }
  
!     public function test_export_essay() {
!         $qdata = (object) array(
              'id' => 666 ,
              'name' => 'Q8',
              'questiontext' => 'How are you?',
--- 64,77 ----
                  'text' => '',
                  'format' => FORMAT_MOODLE,
                  'files' => array(),
! 		),
! 		);
  
! 		$this->assert(new CheckSpecifiedFieldsExpectation($expectedq), $q);
! 	}
  
! 	public function test_export_essay() {
! 		$qdata = (object) array(
              'id' => 666 ,
              'name' => 'Q8',
              'questiontext' => 'How are you?',
***************
*** 84,114 ****
              'qtype' => 'essay',
              'options' => (object) array(
                  'answers' => array(
!                     123 => (object) array(
                          'id' => 123,
                          'answer' => 666,
                          'answerformat' => FORMAT_MOODLE,
                          'fraction' => 0,
                          'feedback' => '',
                          'feedbackformat' => FORMAT_MOODLE,
!                     ),
!                 ),
!             ),
!         );
  
!         $exporter = new qformat_gift();
!         $gift = $exporter->writequestion($qdata);
  
!         $expectedgift = "// question: 666  name: Q8
  ::Q8::How are you?{}
  
  ";
  
!         $this->assert_same_gift($expectedgift, $gift);
!     }
  
!     public function test_import_match() {
!         $gift = '
  // question: 2  name: Moodle activities
  ::Moodle activities::[html]Match the <b>activity</b> to the description.{
      =[html]An activity supporting asynchronous discussions. -> Forum
--- 84,114 ----
              'qtype' => 'essay',
              'options' => (object) array(
                  'answers' => array(
! 		123 => (object) array(
                          'id' => 123,
                          'answer' => 666,
                          'answerformat' => FORMAT_MOODLE,
                          'fraction' => 0,
                          'feedback' => '',
                          'feedbackformat' => FORMAT_MOODLE,
! 		),
! 		),
! 		),
! 		);
  
! 		$exporter = new qformat_gift();
! 		$gift = $exporter->writequestion($qdata);
  
! 		$expectedgift = "// question: 666  name: Q8
  ::Q8::How are you?{}
  
  ";
  
! 		$this->assert_same_gift($expectedgift, $gift);
! 	}
  
! 	public function test_import_match() {
! 		$gift = '
  // question: 2  name: Moodle activities
  ::Moodle activities::[html]Match the <b>activity</b> to the description.{
      =[html]An activity supporting asynchronous discussions. -> Forum
***************
*** 117,128 ****
      =[markdown]A collection of web pages that anyone can add to or edit. -> Wiki
      = -> Chat
  }';
!         $lines = preg_split('/[\\n\\r]/', str_replace("\r\n", "\n", $gift));
  
!         $importer = new qformat_gift();
!         $q = $importer->readquestion($lines);
  
!         $expectedq = (object) array(
              'name' => 'Moodle activities',
              'questiontext' => 'Match the <b>activity</b> to the description.',
              'questiontextformat' => FORMAT_HTML,
--- 117,128 ----
      =[markdown]A collection of web pages that anyone can add to or edit. -> Wiki
      = -> Chat
  }';
! 		$lines = preg_split('/[\\n\\r]/', str_replace("\r\n", "\n", $gift));
  
! 		$importer = new qformat_gift();
! 		$q = $importer->readquestion($lines);
  
! 		$expectedq = (object) array(
              'name' => 'Moodle activities',
              'questiontext' => 'Match the <b>activity</b> to the description.',
              'questiontextformat' => FORMAT_HTML,
***************
*** 134,181 ****
              'length' => 1,
              'shuffleanswers' => '1',
              'subquestions' => array(
!                 0 => array(
                      'text' => 'An activity supporting asynchronous discussions.',
                      'format' => FORMAT_HTML,
                      'files' => array(),
!                 ),
!                 1 => array(
                      'text' => 'A teacher asks a question and specifies a choice of multiple responses.',
                      'format' => FORMAT_MOODLE,
                      'files' => array(),
!                 ),
!                 2 => array(
                      'text' => 'A bank of record entries which participants can add to.',
                      'format' => FORMAT_PLAIN,
                      'files' => array(),
!                 ),
!                 3 => array(
                      'text' => 'A collection of web pages that anyone can add to or edit.',
                      'format' => FORMAT_MARKDOWN,
                      'files' => array(),
!                 ),
!                 4 => array(
                      'text' => '',
                      'format' => FORMAT_HTML,
                      'files' => array(),
!                 ),
!             ),
              'subanswers' => array(
!                 0 => 'Forum',
!                 1 => 'Choice',
!                 2 => 'Database',
!                 3 => 'Wiki',
!                 4 => 'Chat',
!             ),
!         );
! 
!         // Repeated test for better failure messages.
!         $this->assertEqual($expectedq->subquestions, $q->subquestions);
!         $this->assert(new CheckSpecifiedFieldsExpectation($expectedq), $q);
!     }
  
!     public function test_export_match() {
!         $qdata = (object) array(
              'id' => 666 ,
              'name' => 'Moodle activities',
              'questiontext' => 'Match the <b>activity</b> to the description.',
--- 134,181 ----
              'length' => 1,
              'shuffleanswers' => '1',
              'subquestions' => array(
! 		0 => array(
                      'text' => 'An activity supporting asynchronous discussions.',
                      'format' => FORMAT_HTML,
                      'files' => array(),
! 		),
! 		1 => array(
                      'text' => 'A teacher asks a question and specifies a choice of multiple responses.',
                      'format' => FORMAT_MOODLE,
                      'files' => array(),
! 		),
! 		2 => array(
                      'text' => 'A bank of record entries which participants can add to.',
                      'format' => FORMAT_PLAIN,
                      'files' => array(),
! 		),
! 		3 => array(
                      'text' => 'A collection of web pages that anyone can add to or edit.',
                      'format' => FORMAT_MARKDOWN,
                      'files' => array(),
! 		),
! 		4 => array(
                      'text' => '',
                      'format' => FORMAT_HTML,
                      'files' => array(),
! 		),
! 		),
              'subanswers' => array(
! 		0 => 'Forum',
! 		1 => 'Choice',
! 		2 => 'Database',
! 		3 => 'Wiki',
! 		4 => 'Chat',
! 		),
! 		);
! 
! 		// Repeated test for better failure messages.
! 		$this->assertEqual($expectedq->subquestions, $q->subquestions);
! 		$this->assert(new CheckSpecifiedFieldsExpectation($expectedq), $q);
! 	}
  
! 	public function test_export_match() {
! 		$qdata = (object) array(
              'id' => 666 ,
              'name' => 'Moodle activities',
              'questiontext' => 'Match the <b>activity</b> to the description.',
***************
*** 191,244 ****
                  'question' => 666,
                  'shuffleanswers' => 1,
                  'subquestions' => array(
!                     42 => (object) array(
                          'id' => 1234,
                          'code' => 12341234,
                          'question' => 666,
                          'questiontext' => 'An activity supporting asynchronous discussions.',
                          'questiontextformat' => FORMAT_HTML,
                          'answertext' => 'Forum',
!                     ),
!                     43 => (object) array(
                          'id' => 1234,
                          'code' => 12341234,
                          'question' => 666,
                          'questiontext' => 'A teacher asks a question and specifies a choice of multiple responses.',
                          'questiontextformat' => FORMAT_MOODLE,
                          'answertext' => 'Choice',
!                     ),
!                     44 => (object) array(
                          'id' => 1234,
                          'code' => 12341234,
                          'question' => 666,
                          'questiontext' => 'A bank of record entries which participants can add to.',
                          'questiontextformat' => FORMAT_PLAIN,
                          'answertext' => 'Database',
!                     ),
!                     45 => (object) array(
                          'id' => 1234,
                          'code' => 12341234,
                          'question' => 666,
                          'questiontext' => 'A collection of web pages that anyone can add to or edit.',
                          'questiontextformat' => FORMAT_MARKDOWN,
                          'answertext' => 'Wiki',
!                     ),
!                     46 => (object) array(
                          'id' => 1234,
                          'code' => 12341234,
                          'question' => 666,
                          'questiontext' => '',
                          'questiontextformat' => FORMAT_MARKDOWN,
                          'answertext' => 'Chat',
!                     ),
!                 ),
!             ),
!         );
  
!         $exporter = new qformat_gift();
!         $gift = $exporter->writequestion($qdata);
  
!         $expectedgift = "// question: 666  name: Moodle activities
  ::Moodle activities::[html]Match the <b>activity</b> to the description.{
  \t=An activity supporting asynchronous discussions. -> Forum
  \t=[moodle]A teacher asks a question and specifies a choice of multiple responses. -> Choice
--- 191,244 ----
                  'question' => 666,
                  'shuffleanswers' => 1,
                  'subquestions' => array(
! 		42 => (object) array(
                          'id' => 1234,
                          'code' => 12341234,
                          'question' => 666,
                          'questiontext' => 'An activity supporting asynchronous discussions.',
                          'questiontextformat' => FORMAT_HTML,
                          'answertext' => 'Forum',
! 		),
! 		43 => (object) array(
                          'id' => 1234,
                          'code' => 12341234,
                          'question' => 666,
                          'questiontext' => 'A teacher asks a question and specifies a choice of multiple responses.',
                          'questiontextformat' => FORMAT_MOODLE,
                          'answertext' => 'Choice',
! 		),
! 		44 => (object) array(
                          'id' => 1234,
                          'code' => 12341234,
                          'question' => 666,
                          'questiontext' => 'A bank of record entries which participants can add to.',
                          'questiontextformat' => FORMAT_PLAIN,
                          'answertext' => 'Database',
! 		),
! 		45 => (object) array(
                          'id' => 1234,
                          'code' => 12341234,
                          'question' => 666,
                          'questiontext' => 'A collection of web pages that anyone can add to or edit.',
                          'questiontextformat' => FORMAT_MARKDOWN,
                          'answertext' => 'Wiki',
! 		),
! 		46 => (object) array(
                          'id' => 1234,
                          'code' => 12341234,
                          'question' => 666,
                          'questiontext' => '',
                          'questiontextformat' => FORMAT_MARKDOWN,
                          'answertext' => 'Chat',
! 		),
! 		),
! 		),
! 		);
  
! 		$exporter = new qformat_gift();
! 		$gift = $exporter->writequestion($qdata);
  
! 		$expectedgift = "// question: 666  name: Moodle activities
  ::Moodle activities::[html]Match the <b>activity</b> to the description.{
  \t=An activity supporting asynchronous discussions. -> Forum
  \t=[moodle]A teacher asks a question and specifies a choice of multiple responses. -> Choice
***************
*** 249,259 ****
  
  ";
  
!         $this->assert_same_gift($expectedgift, $gift);
!     }
  
!     public function test_import_multichoice() {
!         $gift = "
  // multiple choice with specified feedback for right and wrong answers
  ::Q2:: What's between orange and green in the spectrum?
  {
--- 249,259 ----
  
  ";
  
! 		$this->assert_same_gift($expectedgift, $gift);
! 	}
  
! 	public function test_import_multichoice() {
! 		$gift = "
  // multiple choice with specified feedback for right and wrong answers
  ::Q2:: What's between orange and green in the spectrum?
  {
***************
*** 261,272 ****
      ~red # [html]wrong, it's yellow
      ~[plain]blue # wrong, it's yellow
  }";
!         $lines = preg_split('/[\\n\\r]/', str_replace("\r\n", "\n", $gift));
  
!         $importer = new qformat_gift();
!         $q = $importer->readquestion($lines);
  
!         $expectedq = (object) array(
              'name' => 'Q2',
              'questiontext' => "What's between orange and green in the spectrum?",
              'questiontextformat' => FORMAT_MOODLE,
--- 261,272 ----
      ~red # [html]wrong, it's yellow
      ~[plain]blue # wrong, it's yellow
  }";
! 		$lines = preg_split('/[\\n\\r]/', str_replace("\r\n", "\n", $gift));
  
! 		$importer = new qformat_gift();
! 		$q = $importer->readquestion($lines);
  
! 		$expectedq = (object) array(
              'name' => 'Q2',
              'questiontext' => "What's between orange and green in the spectrum?",
              'questiontextformat' => FORMAT_MOODLE,
***************
*** 283,344 ****
                  'text' => '',
                  'format' => FORMAT_MOODLE,
                  'files' => array(),
!             ),
              'partiallycorrectfeedback' => array(
                  'text' => '',
                  'format' => FORMAT_MOODLE,
                  'files' => array(),
!             ),
              'incorrectfeedback' => array(
                  'text' => '',
                  'format' => FORMAT_MOODLE,
                  'files' => array(),
!             ),
              'answer' => array(
!                 0 => array(
                      'text' => 'yellow',
                      'format' => FORMAT_MOODLE,
                      'files' => array(),
!                 ),
!                 1 => array(
                      'text' => 'red',
                      'format' => FORMAT_MOODLE,
                      'files' => array(),
!                 ),
!                 2 => array(
                      'text' => 'blue',
                      'format' => FORMAT_PLAIN,
                      'files' => array(),
!                 ),
!             ),
              'fraction' => array(1, 0, 0),
              'feedback' => array(
!                 0 => array(
                      'text' => 'right; good!',
                      'format' => FORMAT_MOODLE,
                      'files' => array(),
!                 ),
!                 1 => array(
                      'text' => "wrong, it's yellow",
                      'format' => FORMAT_HTML,
                      'files' => array(),
!                 ),
!                 2 => array(
                      'text' => "wrong, it's yellow",
                      'format' => FORMAT_MOODLE,
                      'files' => array(),
!                 ),
!             ),
!         );
! 
!         // Repeated test for better failure messages.
!         $this->assertEqual($expectedq->answer, $q->answer);
!         $this->assertEqual($expectedq->feedback, $q->feedback);
!         $this->assert(new CheckSpecifiedFieldsExpectation($expectedq), $q);
!     }
  
!     public function test_import_multichoice_multi() {
!         $gift = "
  // multiple choice, multiple response with specified feedback for right and wrong answers
  ::colours:: What's between orange and green in the spectrum?
  {
--- 283,344 ----
                  'text' => '',
                  'format' => FORMAT_MOODLE,
                  'files' => array(),
! 		),
              'partiallycorrectfeedback' => array(
                  'text' => '',
                  'format' => FORMAT_MOODLE,
                  'files' => array(),
! 		),
              'incorrectfeedback' => array(
                  'text' => '',
                  'format' => FORMAT_MOODLE,
                  'files' => array(),
! 		),
              'answer' => array(
! 		0 => array(
                      'text' => 'yellow',
                      'format' => FORMAT_MOODLE,
                      'files' => array(),
! 		),
! 		1 => array(
                      'text' => 'red',
                      'format' => FORMAT_MOODLE,
                      'files' => array(),
! 		),
! 		2 => array(
                      'text' => 'blue',
                      'format' => FORMAT_PLAIN,
                      'files' => array(),
! 		),
! 		),
              'fraction' => array(1, 0, 0),
              'feedback' => array(
! 		0 => array(
                      'text' => 'right; good!',
                      'format' => FORMAT_MOODLE,
                      'files' => array(),
! 		),
! 		1 => array(
                      'text' => "wrong, it's yellow",
                      'format' => FORMAT_HTML,
                      'files' => array(),
! 		),
! 		2 => array(
                      'text' => "wrong, it's yellow",
                      'format' => FORMAT_MOODLE,
                      'files' => array(),
! 		),
! 		),
! 		);
! 
! 		// Repeated test for better failure messages.
! 		$this->assertEqual($expectedq->answer, $q->answer);
! 		$this->assertEqual($expectedq->feedback, $q->feedback);
! 		$this->assert(new CheckSpecifiedFieldsExpectation($expectedq), $q);
! 	}
  
! 	public function test_import_multichoice_multi() {
! 		$gift = "
  // multiple choice, multiple response with specified feedback for right and wrong answers
  ::colours:: What's between orange and green in the spectrum?
  {
***************
*** 347,358 ****
      ~%50%off-beige # right; good!
      ~%-100%[plain]blue # wrong
  }";
!         $lines = preg_split('/[\\n\\r]/', str_replace("\r\n", "\n", $gift));
  
!         $importer = new qformat_gift();
!         $q = $importer->readquestion($lines);
  
!         $expectedq = (object) array(
              'name' => 'colours',
              'questiontext' => "What's between orange and green in the spectrum?",
              'questiontextformat' => FORMAT_MOODLE,
--- 347,358 ----
      ~%50%off-beige # right; good!
      ~%-100%[plain]blue # wrong
  }";
! 		$lines = preg_split('/[\\n\\r]/', str_replace("\r\n", "\n", $gift));
  
! 		$importer = new qformat_gift();
! 		$q = $importer->readquestion($lines);
  
! 		$expectedq = (object) array(
              'name' => 'colours',
              'questiontext' => "What's between orange and green in the spectrum?",
              'questiontextformat' => FORMAT_MOODLE,
***************
*** 369,440 ****
                  'text' => '',
                  'format' => FORMAT_MOODLE,
                  'files' => array(),
!             ),
              'partiallycorrectfeedback' => array(
                  'text' => '',
                  'format' => FORMAT_MOODLE,
                  'files' => array(),
!             ),
              'incorrectfeedback' => array(
                  'text' => '',
                  'format' => FORMAT_MOODLE,
                  'files' => array(),
!             ),
              'answer' => array(
!                 0 => array(
                      'text' => 'yellow',
                      'format' => FORMAT_MOODLE,
                      'files' => array(),
!                 ),
!                 1 => array(
                      'text' => 'red',
                      'format' => FORMAT_MOODLE,
                      'files' => array(),
!                 ),
!                 2 => array(
                      'text' => 'off-beige',
                      'format' => FORMAT_MOODLE,
                      'files' => array(),
!                 ),
!                 3 => array(
                      'text' => 'blue',
                      'format' => FORMAT_PLAIN,
                      'files' => array(),
!                 ),
!             ),
              'fraction' => array(0.5, -1, 0.5, -1),
              'feedback' => array(
!                 0 => array(
                      'text' => 'right; good!',
                      'format' => FORMAT_MOODLE,
                      'files' => array(),
!                 ),
!                 1 => array(
                      'text' => "wrong",
                      'format' => FORMAT_HTML,
                      'files' => array(),
!                 ),
!                 2 => array(
                      'text' => "right; good!",
                      'format' => FORMAT_MOODLE,
                      'files' => array(),
!                 ),
!                 3 => array(
                      'text' => "wrong",
                      'format' => FORMAT_MOODLE,
                      'files' => array(),
!                 ),
!             ),
!         );
! 
!         // Repeated test for better failure messages.
!         $this->assertEqual($expectedq->answer, $q->answer);
!         $this->assertEqual($expectedq->feedback, $q->feedback);
!         $this->assert(new CheckSpecifiedFieldsExpectation($expectedq), $q);
!     }
  
!     public function test_export_multichoice() {
!         $qdata = (object) array(
              'id' => 666 ,
              'name' => 'Q8',
              'questiontext' => "What's between orange and green in the spectrum?",
--- 369,440 ----
                  'text' => '',
                  'format' => FORMAT_MOODLE,
                  'files' => array(),
! 		),
              'partiallycorrectfeedback' => array(
                  'text' => '',
                  'format' => FORMAT_MOODLE,
                  'files' => array(),
! 		),
              'incorrectfeedback' => array(
                  'text' => '',
                  'format' => FORMAT_MOODLE,
                  'files' => array(),
! 		),
              'answer' => array(
! 		0 => array(
                      'text' => 'yellow',
                      'format' => FORMAT_MOODLE,
                      'files' => array(),
! 		),
! 		1 => array(
                      'text' => 'red',
                      'format' => FORMAT_MOODLE,
                      'files' => array(),
! 		),
! 		2 => array(
                      'text' => 'off-beige',
                      'format' => FORMAT_MOODLE,
                      'files' => array(),
! 		),
! 		3 => array(
                      'text' => 'blue',
                      'format' => FORMAT_PLAIN,
                      'files' => array(),
! 		),
! 		),
              'fraction' => array(0.5, -1, 0.5, -1),
              'feedback' => array(
! 		0 => array(
                      'text' => 'right; good!',
                      'format' => FORMAT_MOODLE,
                      'files' => array(),
! 		),
! 		1 => array(
                      'text' => "wrong",
                      'format' => FORMAT_HTML,
                      'files' => array(),
! 		),
! 		2 => array(
                      'text' => "right; good!",
                      'format' => FORMAT_MOODLE,
                      'files' => array(),
! 		),
! 		3 => array(
                      'text' => "wrong",
                      'format' => FORMAT_MOODLE,
                      'files' => array(),
! 		),
! 		),
! 		);
! 
! 		// Repeated test for better failure messages.
! 		$this->assertEqual($expectedq->answer, $q->answer);
! 		$this->assertEqual($expectedq->feedback, $q->feedback);
! 		$this->assert(new CheckSpecifiedFieldsExpectation($expectedq), $q);
! 	}
  
! 	public function test_export_multichoice() {
! 		$qdata = (object) array(
              'id' => 666 ,
              'name' => 'Q8',
              'questiontext' => "What's between orange and green in the spectrum?",
***************
*** 456,493 ****
                  'incorrectfeedback' => '',
                  'incorrectfeedbackformat' => FORMAT_MOODLE,
                  'answers' => array(
!                     123 => (object) array(
                          'id' => 123,
                          'answer' => 'yellow',
                          'answerformat' => FORMAT_MOODLE,
                          'fraction' => 1,
                          'feedback' => 'right; good!',
                          'feedbackformat' => FORMAT_MOODLE,
!                     ),
!                     124 => (object) array(
                          'id' => 124,
                          'answer' => 'red',
                          'answerformat' => FORMAT_MOODLE,
                          'fraction' => 0,
                          'feedback' => "wrong, it's yellow",
                          'feedbackformat' => FORMAT_HTML,
!                     ),
!                     125 => (object) array(
                          'id' => 125,
                          'answer' => 'blue',
                          'answerformat' => FORMAT_PLAIN,
                          'fraction' => 0,
                          'feedback' => "wrong, it's yellow",
                          'feedbackformat' => FORMAT_MOODLE,
!                     ),
!                 ),
!             ),
!         );
  
!         $exporter = new qformat_gift();
!         $gift = $exporter->writequestion($qdata);
  
!         $expectedgift = "// question: 666  name: Q8
  ::Q8::What's between orange and green in the spectrum?{
  \t=yellow#right; good!
  \t~red#[html]wrong, it's yellow
--- 456,493 ----
                  'incorrectfeedback' => '',
                  'incorrectfeedbackformat' => FORMAT_MOODLE,
                  'answers' => array(
! 		123 => (object) array(
                          'id' => 123,
                          'answer' => 'yellow',
                          'answerformat' => FORMAT_MOODLE,
                          'fraction' => 1,
                          'feedback' => 'right; good!',
                          'feedbackformat' => FORMAT_MOODLE,
! 		),
! 		124 => (object) array(
                          'id' => 124,
                          'answer' => 'red',
                          'answerformat' => FORMAT_MOODLE,
                          'fraction' => 0,
                          'feedback' => "wrong, it's yellow",
                          'feedbackformat' => FORMAT_HTML,
! 		),
! 		125 => (object) array(
                          'id' => 125,
                          'answer' => 'blue',
                          'answerformat' => FORMAT_PLAIN,
                          'fraction' => 0,
                          'feedback' => "wrong, it's yellow",
                          'feedbackformat' => FORMAT_MOODLE,
! 		),
! 		),
! 		),
! 		);
  
! 		$exporter = new qformat_gift();
! 		$gift = $exporter->writequestion($qdata);
  
! 		$expectedgift = "// question: 666  name: Q8
  ::Q8::What's between orange and green in the spectrum?{
  \t=yellow#right; good!
  \t~red#[html]wrong, it's yellow
***************
*** 496,514 ****
  
  ";
  
!         $this->assert_same_gift($expectedgift, $gift);
!     }
  
!     public function test_import_numerical() {
!         $gift = "
  // math range question
  ::Q5:: What is a number from 1 to 5? {#3:2~#Completely wrong}";
!         $lines = preg_split('/[\\n\\r]/', str_replace("\r\n", "\n", $gift));
  
!         $importer = new qformat_gift();
!         $q = $importer->readquestion($lines);
  
!         $expectedq = (object) array(
              'name' => 'Q5',
              'questiontext' => "What is a number from 1 to 5?",
              'questiontextformat' => FORMAT_MOODLE,
--- 496,514 ----
  
  ";
  
! 		$this->assert_same_gift($expectedgift, $gift);
! 	}
  
! 	public function test_import_numerical() {
! 		$gift = "
  // math range question
  ::Q5:: What is a number from 1 to 5? {#3:2~#Completely wrong}";
! 		$lines = preg_split('/[\\n\\r]/', str_replace("\r\n", "\n", $gift));
  
! 		$importer = new qformat_gift();
! 		$q = $importer->readquestion($lines);
  
! 		$expectedq = (object) array(
              'name' => 'Q5',
              'questiontext' => "What is a number from 1 to 5?",
              'questiontextformat' => FORMAT_MOODLE,
***************
*** 521,552 ****
              'answer' => array(
                  '3',
                  '*',
!             ),
              'fraction' => array(1, 0),
              'feedback' => array(
!                 0 => array(
                      'text' => '',
                      'format' => FORMAT_MOODLE,
                      'files' => array(),
!                 ),
!                 1 => array(
                      'text' => "Completely wrong",
                      'format' => FORMAT_MOODLE,
                      'files' => array(),
!                 ),
!             ),
              'tolerance' => array(2, 0),
!         );
  
!         // Repeated test for better failure messages.
!         $this->assertEqual($expectedq->answer, $q->answer);
!         $this->assertEqual($expectedq->fraction, $q->fraction);
!         $this->assertEqual($expectedq->feedback, $q->feedback);
!         $this->assert(new CheckSpecifiedFieldsExpectation($expectedq), $q);
!     }
  
!     public function test_export_numerical() {
!         $qdata = (object) array(
              'id' => 666 ,
              'name' => 'Q5',
              'questiontext' => "What is a number from 1 to 5?",
--- 521,552 ----
              'answer' => array(
                  '3',
                  '*',
! 		),
              'fraction' => array(1, 0),
              'feedback' => array(
! 		0 => array(
                      'text' => '',
                      'format' => FORMAT_MOODLE,
                      'files' => array(),
! 		),
! 		1 => array(
                      'text' => "Completely wrong",
                      'format' => FORMAT_MOODLE,
                      'files' => array(),
! 		),
! 		),
              'tolerance' => array(2, 0),
! 		);
  
! 		// Repeated test for better failure messages.
! 		$this->assertEqual($expectedq->answer, $q->answer);
! 		$this->assertEqual($expectedq->fraction, $q->fraction);
! 		$this->assertEqual($expectedq->feedback, $q->feedback);
! 		$this->assert(new CheckSpecifiedFieldsExpectation($expectedq), $q);
! 	}
  
! 	public function test_export_numerical() {
! 		$qdata = (object) array(
              'id' => 666 ,
              'name' => 'Q5',
              'questiontext' => "What is a number from 1 to 5?",
***************
*** 568,574 ****
                  'unitgradingtype' => 0,
                  'unitpenalty' => 0,
                  'answers' => array(
!                     1 => (object) array(
                          'id' => 123,
                          'answer' => '3',
                          'answerformat' => 0,
--- 568,574 ----
                  'unitgradingtype' => 0,
                  'unitpenalty' => 0,
                  'answers' => array(
! 		1 => (object) array(
                          'id' => 123,
                          'answer' => '3',
                          'answerformat' => 0,
***************
*** 576,583 ****
                          'tolerance' => 2,
                          'feedback' => '',
                          'feedbackformat' => FORMAT_MOODLE,
!                     ),
!                     2 => (object) array(
                          'id' => 124,
                          'answer' => '*',
                          'answerformat' => 0,
--- 576,583 ----
                          'tolerance' => 2,
                          'feedback' => '',
                          'feedbackformat' => FORMAT_MOODLE,
! 		),
! 		2 => (object) array(
                          'id' => 124,
                          'answer' => '*',
                          'answerformat' => 0,
***************
*** 585,599 ****
                          'tolerance' => 0,
                          'feedback' => "Completely wrong",
                          'feedbackformat' => FORMAT_MOODLE,
!                     ),
!                 ),
!             ),
!         );
  
!         $exporter = new qformat_gift();
!         $gift = $exporter->writequestion($qdata);
  
!         $expectedgift = "// question: 666  name: Q5
  ::Q5::What is a number from 1 to 5?{#
  \t=%100%3:2#
  \t~#Completely wrong
--- 585,599 ----
                          'tolerance' => 0,
                          'feedback' => "Completely wrong",
                          'feedbackformat' => FORMAT_MOODLE,
! 		),
! 		),
! 		),
! 		);
  
! 		$exporter = new qformat_gift();
! 		$gift = $exporter->writequestion($qdata);
  
! 		$expectedgift = "// question: 666  name: Q5
  ::Q5::What is a number from 1 to 5?{#
  \t=%100%3:2#
  \t~#Completely wrong
***************
*** 601,623 ****
  
  ";
  
!         $this->assert_same_gift($expectedgift, $gift);
!     }
  
!     public function test_import_shortanswer() {
!         $gift = "
  // question: 666  name: Shortanswer
  ::Shortanswer::Which is the best animal?{
      =Frog#Good!
      =%50%Cat#What is it with Moodlers and cats?
      =%0%*#Completely wrong
  }";
!         $lines = preg_split('/[\\n\\r]/', str_replace("\r\n", "\n", $gift));
  
!         $importer = new qformat_gift();
!         $q = $importer->readquestion($lines);
  
!         $expectedq = (object) array(
              'name' => 'Shortanswer',
              'questiontext' => "Which is the best animal?",
              'questiontextformat' => FORMAT_MOODLE,
--- 601,623 ----
  
  ";
  
! 		$this->assert_same_gift($expectedgift, $gift);
! 	}
  
! 	public function test_import_shortanswer() {
! 		$gift = "
  // question: 666  name: Shortanswer
  ::Shortanswer::Which is the best animal?{
      =Frog#Good!
      =%50%Cat#What is it with Moodlers and cats?
      =%0%*#Completely wrong
  }";
! 		$lines = preg_split('/[\\n\\r]/', str_replace("\r\n", "\n", $gift));
  
! 		$importer = new qformat_gift();
! 		$q = $importer->readquestion($lines);
  
! 		$expectedq = (object) array(
              'name' => 'Shortanswer',
              'questiontext' => "Which is the best animal?",
              'questiontextformat' => FORMAT_MOODLE,
***************
*** 631,666 ****
                  'Frog',
                  'Cat',
                  '*',
!             ),
              'fraction' => array(1, 0.5, 0),
              'feedback' => array(
!                 0 => array(
                      'text' => 'Good!',
                      'format' => FORMAT_MOODLE,
                      'files' => array(),
!                 ),
!                 1 => array(
                      'text' => "What is it with Moodlers and cats?",
                      'format' => FORMAT_MOODLE,
                      'files' => array(),
!                 ),
!                 2 => array(
                      'text' => "Completely wrong",
                      'format' => FORMAT_MOODLE,
                      'files' => array(),
!                 ),
!             ),
!         );
! 
!         // Repeated test for better failure messages.
!         $this->assertEqual($expectedq->answer, $q->answer);
!         $this->assertEqual($expectedq->fraction, $q->fraction);
!         $this->assertEqual($expectedq->feedback, $q->feedback);
!         $this->assert(new CheckSpecifiedFieldsExpectation($expectedq), $q);
!     }
  
!     public function test_export_shortanswer() {
!         $qdata = (object) array(
              'id' => 666 ,
              'name' => 'Shortanswer',
              'questiontext' => "Which is the best animal?",
--- 631,666 ----
                  'Frog',
                  'Cat',
                  '*',
! 		),
              'fraction' => array(1, 0.5, 0),
              'feedback' => array(
! 		0 => array(
                      'text' => 'Good!',
                      'format' => FORMAT_MOODLE,
                      'files' => array(),
! 		),
! 		1 => array(
                      'text' => "What is it with Moodlers and cats?",
                      'format' => FORMAT_MOODLE,
                      'files' => array(),
! 		),
! 		2 => array(
                      'text' => "Completely wrong",
                      'format' => FORMAT_MOODLE,
                      'files' => array(),
! 		),
! 		),
! 		);
! 
! 		// Repeated test for better failure messages.
! 		$this->assertEqual($expectedq->answer, $q->answer);
! 		$this->assertEqual($expectedq->fraction, $q->fraction);
! 		$this->assertEqual($expectedq->feedback, $q->feedback);
! 		$this->assert(new CheckSpecifiedFieldsExpectation($expectedq), $q);
! 	}
  
! 	public function test_export_shortanswer() {
! 		$qdata = (object) array(
              'id' => 666 ,
              'name' => 'Shortanswer',
              'questiontext' => "Which is the best animal?",
***************
*** 676,713 ****
                  'question' => 666,
                  'usecase' => 1,
                  'answers' => array(
!                     1 => (object) array(
                          'id' => 1,
                          'answer' => 'Frog',
                          'answerformat' => 0,
                          'fraction' => 1,
                          'feedback' => 'Good!',
                          'feedbackformat' => FORMAT_MOODLE,
!                     ),
!                     2 => (object) array(
                          'id' => 2,
                          'answer' => 'Cat',
                          'answerformat' => 0,
                          'fraction' => 0.5,
                          'feedback' => "What is it with Moodlers and cats?",
                          'feedbackformat' => FORMAT_MOODLE,
!                     ),
!                     3 => (object) array(
                          'id' => 3,
                          'answer' => '*',
                          'answerformat' => 0,
                          'fraction' => 0,
                          'feedback' => "Completely wrong",
                          'feedbackformat' => FORMAT_MOODLE,
!                     ),
!                 ),
!             ),
!         );
  
!         $exporter = new qformat_gift();
!         $gift = $exporter->writequestion($qdata);
  
!         $expectedgift = "// question: 666  name: Shortanswer
  ::Shortanswer::Which is the best animal?{
  \t=%100%Frog#Good!
  \t=%50%Cat#What is it with Moodlers and cats?
--- 676,713 ----
                  'question' => 666,
                  'usecase' => 1,
                  'answers' => array(
! 		1 => (object) array(
                          'id' => 1,
                          'answer' => 'Frog',
                          'answerformat' => 0,
                          'fraction' => 1,
                          'feedback' => 'Good!',
                          'feedbackformat' => FORMAT_MOODLE,
! 		),
! 		2 => (object) array(
                          'id' => 2,
                          'answer' => 'Cat',
                          'answerformat' => 0,
                          'fraction' => 0.5,
                          'feedback' => "What is it with Moodlers and cats?",
                          'feedbackformat' => FORMAT_MOODLE,
! 		),
! 		3 => (object) array(
                          'id' => 3,
                          'answer' => '*',
                          'answerformat' => 0,
                          'fraction' => 0,
                          'feedback' => "Completely wrong",
                          'feedbackformat' => FORMAT_MOODLE,
! 		),
! 		),
! 		),
! 		);
  
! 		$exporter = new qformat_gift();
! 		$gift = $exporter->writequestion($qdata);
  
! 		$expectedgift = "// question: 666  name: Shortanswer
  ::Shortanswer::Which is the best animal?{
  \t=%100%Frog#Good!
  \t=%50%Cat#What is it with Moodlers and cats?
***************
*** 716,735 ****
  
  ";
  
!         $this->assert_same_gift($expectedgift, $gift);
!     }
  
!     public function test_import_truefalse() {
!         $gift = "
  // true/false
  ::Q1:: 42 is the Absolute Answer to everything.{
  FALSE#42 is the Ultimate Answer.#You gave the right answer.}";
!         $lines = preg_split('/[\\n\\r]/', str_replace("\r\n", "\n", $gift));
  
!         $importer = new qformat_gift();
!         $q = $importer->readquestion($lines);
  
!         $expectedq = (object) array(
              'name' => 'Q1',
              'questiontext' => "42 is the Absolute Answer to everything.",
              'questiontextformat' => FORMAT_MOODLE,
--- 716,735 ----
  
  ";
  
! 		$this->assert_same_gift($expectedgift, $gift);
! 	}
  
! 	public function test_import_truefalse() {
! 		$gift = "
  // true/false
  ::Q1:: 42 is the Absolute Answer to everything.{
  FALSE#42 is the Ultimate Answer.#You gave the right answer.}";
! 		$lines = preg_split('/[\\n\\r]/', str_replace("\r\n", "\n", $gift));
  
! 		$importer = new qformat_gift();
! 		$q = $importer->readquestion($lines);
  
! 		$expectedq = (object) array(
              'name' => 'Q1',
              'questiontext' => "42 is the Absolute Answer to everything.",
              'questiontextformat' => FORMAT_MOODLE,
***************
*** 744,769 ****
                  'text' => '42 is the Ultimate Answer.',
                  'format' => FORMAT_MOODLE,
                  'files' => array(),
!             ),
              'feedbackfalse' => array(
                  'text' => 'You gave the right answer.',
                  'format' => FORMAT_MOODLE,
                  'files' => array(),
!             ),
!         );
  
!         $this->assert(new CheckSpecifiedFieldsExpectation($expectedq), $q);
!     }
  
!     public function test_import_truefalse_true_answer1() {
!         $gift = "// name 0-11
  ::2-08 TSL::TSL is blablabla.{T}";
!         $lines = preg_split('/[\\n\\r]/', str_replace("\r\n", "\n", $gift));
  
!         $importer = new qformat_gift();
!         $q = $importer->readquestion($lines);
  
!         $expectedq = (object) array(
              'name' => '2-08 TSL',
              'questiontext' => "TSL is blablabla.",
              'questiontextformat' => FORMAT_MOODLE,
--- 744,769 ----
                  'text' => '42 is the Ultimate Answer.',
                  'format' => FORMAT_MOODLE,
                  'files' => array(),
! 		),
              'feedbackfalse' => array(
                  'text' => 'You gave the right answer.',
                  'format' => FORMAT_MOODLE,
                  'files' => array(),
! 		),
! 		);
  
! 		$this->assert(new CheckSpecifiedFieldsExpectation($expectedq), $q);
! 	}
  
! 	public function test_import_truefalse_true_answer1() {
! 		$gift = "// name 0-11
  ::2-08 TSL::TSL is blablabla.{T}";
! 		$lines = preg_split('/[\\n\\r]/', str_replace("\r\n", "\n", $gift));
  
! 		$importer = new qformat_gift();
! 		$q = $importer->readquestion($lines);
  
! 		$expectedq = (object) array(
              'name' => '2-08 TSL',
              'questiontext' => "TSL is blablabla.",
              'questiontextformat' => FORMAT_MOODLE,
***************
*** 778,803 ****
                  'text' => '',
                  'format' => FORMAT_MOODLE,
                  'files' => array(),
!             ),
              'feedbackfalse' => array(
                  'text' => '',
                  'format' => FORMAT_MOODLE,
                  'files' => array(),
!             ),
!         );
  
!         $this->assert(new CheckSpecifiedFieldsExpectation($expectedq), $q);
!     }
  
!     public function test_import_truefalse_true_answer2() {
!         $gift = "// name 0-11
  ::2-08 TSL::TSL is blablabla.{TRUE}";
!         $lines = preg_split('/[\\n\\r]/', str_replace("\r\n", "\n", $gift));
  
!         $importer = new qformat_gift();
!         $q = $importer->readquestion($lines);
  
!         $expectedq = (object) array(
              'name' => '2-08 TSL',
              'questiontext' => "TSL is blablabla.",
              'questiontextformat' => FORMAT_MOODLE,
--- 778,803 ----
                  'text' => '',
                  'format' => FORMAT_MOODLE,
                  'files' => array(),
! 		),
              'feedbackfalse' => array(
                  'text' => '',
                  'format' => FORMAT_MOODLE,
                  'files' => array(),
! 		),
! 		);
  
! 		$this->assert(new CheckSpecifiedFieldsExpectation($expectedq), $q);
! 	}
  
! 	public function test_import_truefalse_true_answer2() {
! 		$gift = "// name 0-11
  ::2-08 TSL::TSL is blablabla.{TRUE}";
! 		$lines = preg_split('/[\\n\\r]/', str_replace("\r\n", "\n", $gift));
  
! 		$importer = new qformat_gift();
! 		$q = $importer->readquestion($lines);
  
! 		$expectedq = (object) array(
              'name' => '2-08 TSL',
              'questiontext' => "TSL is blablabla.",
              'questiontextformat' => FORMAT_MOODLE,
***************
*** 812,830 ****
                  'text' => '',
                  'format' => FORMAT_MOODLE,
                  'files' => array(),
!             ),
              'feedbackfalse' => array(
                  'text' => '',
                  'format' => FORMAT_MOODLE,
                  'files' => array(),
!             ),
!         );
  
!         $this->assert(new CheckSpecifiedFieldsExpectation($expectedq), $q);
!     }
  
!     public function test_export_truefalse() {
!         $qdata = (object) array(
              'id' => 666 ,
              'name' => 'Q1',
              'questiontext' => "42 is the Absolute Answer to everything.",
--- 812,830 ----
                  'text' => '',
                  'format' => FORMAT_MOODLE,
                  'files' => array(),
! 		),
              'feedbackfalse' => array(
                  'text' => '',
                  'format' => FORMAT_MOODLE,
                  'files' => array(),
! 		),
! 		);
  
! 		$this->assert(new CheckSpecifiedFieldsExpectation($expectedq), $q);
! 	}
  
! 	public function test_export_truefalse() {
! 		$qdata = (object) array(
              'id' => 666 ,
              'name' => 'Q1',
              'questiontext' => "42 is the Absolute Answer to everything.",
***************
*** 841,874 ****
                  'trueanswer' => 1,
                  'falseanswer' => 2,
                  'answers' => array(
!                     1 => (object) array(
                          'id' => 123,
                          'answer' => 'True',
                          'answerformat' => 0,
                          'fraction' => 1,
                          'feedback' => 'You gave the right answer.',
                          'feedbackformat' => FORMAT_MOODLE,
!                     ),
!                     2 => (object) array(
                          'id' => 124,
                          'answer' => 'False',
                          'answerformat' => 0,
                          'fraction' => 0,
                          'feedback' => "42 is the Ultimate Answer.",
                          'feedbackformat' => FORMAT_HTML,
!                     ),
!                 ),
!             ),
!         );
  
!         $exporter = new qformat_gift();
!         $gift = $exporter->writequestion($qdata);
  
!         $expectedgift = "// question: 666  name: Q1
  ::Q1::42 is the Absolute Answer to everything.{TRUE#[html]42 is the Ultimate Answer.#You gave the right answer.}
  
  ";
  
!         $this->assert_same_gift($expectedgift, $gift);
!     }
  }
--- 841,874 ----
                  'trueanswer' => 1,
                  'falseanswer' => 2,
                  'answers' => array(
! 		1 => (object) array(
                          'id' => 123,
                          'answer' => 'True',
                          'answerformat' => 0,
                          'fraction' => 1,
                          'feedback' => 'You gave the right answer.',
                          'feedbackformat' => FORMAT_MOODLE,
! 		),
! 		2 => (object) array(
                          'id' => 124,
                          'answer' => 'False',
                          'answerformat' => 0,
                          'fraction' => 0,
                          'feedback' => "42 is the Ultimate Answer.",
                          'feedbackformat' => FORMAT_HTML,
! 		),
! 		),
! 		),
! 		);
  
! 		$exporter = new qformat_gift();
! 		$gift = $exporter->writequestion($qdata);
  
! 		$expectedgift = "// question: 666  name: Q1
  ::Q1::42 is the Absolute Answer to everything.{TRUE#[html]42 is the Ultimate Answer.#You gave the right answer.}
  
  ";
  
! 		$this->assert_same_gift($expectedgift, $gift);
! 	}
  }
diff -crB questionorg/format/hotpot/format.php questionupd/format/hotpot/format.php
*** questionorg/format/hotpot/format.php	2012-04-13 12:31:11.584178256 +0500
--- questionupd/format/hotpot/format.php	2012-04-13 09:42:52.000000000 +0500
***************
*** 29,35 ****
  defined('MOODLE_INTERNAL') || die();
  
  if (file_exists($CFG->dirroot.'/mod/hotpot/locallib.php')) {
!     require_once($CFG->dirroot.'/mod/hotpot/locallib.php');
  }
  
  /**
--- 29,35 ----
  defined('MOODLE_INTERNAL') || die();
  
  if (file_exists($CFG->dirroot.'/mod/hotpot/locallib.php')) {
! 	require_once($CFG->dirroot.'/mod/hotpot/locallib.php');
  }
  
  /**
***************
*** 41,676 ****
   */
  class qformat_hotpot extends qformat_default {
  
!     /**
!      * provide_import
!      *
!      * @return xxx
!      */
!     function provide_import()  {
!         global $CFG;
!         // disable import if the HotPot module does not exist
!         // because we need "mod/hotpot/locallib.php"
!         return file_exists($CFG->dirroot.'/mod/hotpot/locallib.php');
!     }
! 
!     /**
!      * mime_type
!      *
!      * @return xxx
!      */
!     public function mime_type() {
!         return 'text/xml';
!     }
! 
!     /**
!      * readquestions
!      *
!      * @param xxx $lines
!      * @param xxx $context (optional, default=null)
!      * @return xxx
!      */
!     function readquestions ($lines, $context=null)  {
!         /// Parses an array of lines into an array of questions,
!         /// where each item is a question object as defined by
!         /// readquestion().
! 
!         global $CFG;
! 
!         // get Hot Potatoes quiz type
!         $quiztype = '';
!         if ($pos = strrpos($this->realfilename, '.')) {
!             $filetype = substr($this->realfilename, $pos+1);
!             switch ($filetype) {
!                 case 'jcl': $quiztype = 'jcloze'; break;
!                 case 'jcw': $quiztype = 'jcross'; break;
!                 case 'jmt': $quiztype = 'jmatch'; break;
!                 case 'jmx': $quiztype = 'jmix'; break;
!                 case 'jqz': $quiztype = 'jquiz'; break;
!             }
!         }
! 
!         if ($quiztype=='') {
!             $this->error('Input file not recognized as a Hot Potatoes XML file');
!             return false;
!         }
! 
!         $classfile = $CFG->dirroot.'/mod/hotpot/source/hp/6/'.$quiztype.'/xml/class.php';
!         if (! file_exists($classfile)) {
!             $this->error('HotPot import class file missing: '.$classfile);
!             return false;
!         }
!         require_once($classfile);
! 
!         $classname = 'hotpot_source_hp_6_'.$quiztype.'_xml';
!         if (! class_exists($classname)) {
!             $this->error('HotPot import class missing: '.$classname);
!             return false;
!         }
!         $source = new $classname(implode($lines, ' '), $this);
! 
!         // build XML tree for this HotPot
!         $source->xml_get_filecontents();
! 
!         // convert xml to questions array
!         $questions = array();
!         switch ($quiztype) {
!             case 'jcloze': $this->process_jcloze($source, $questions); break;
!             case 'jcross': $this->process_jcross($source, $questions); break;
!             case 'jmatch': $this->process_jmatch($source, $questions); break;
!             case 'jmix'  : $this->process_jmix($source, $questions); break;
!             case 'jquiz' : $this->process_jquiz($source, $questions); break;
!         }
! 
!         if (count($questions)==0) {
!             $this->error(get_string('giftnovalidquestion', 'quiz'));
!             return false;
!         }
! 
!         return $questions;
!     }
! 
!     /**
!      * process_jcloze
!      *
!      * @param xxx $source (passed by reference)
!      * @param xxx $questions (passed by reference)
!      */
!     function process_jcloze(&$source, &$questions)  {
!         // define default grade (per cloze gap)
!         $defaultmark = 1;
!         $gap_count = 0;
! 
!         if (strpos($source->filecontents, '<gap-fill><question-record>')) {
!             $startwithgap = true;
!         } else {
!             $startwithgap = false;
!         }
! 
!         // xml tags for the start of the gap-fill exercise
!         $tags = 'data,gap-fill';
! 
!         $x = 0;
!         while (($exercise = "[$x]['#']") && $source->xml_value($tags, $exercise)) {
!             // there is usually only one exercise in a file
! 
!             $question = $this->defaultquestion();
!             $question->qtype = MULTIANSWER;
!             $question->name = $this->hotpot_get_title($source, $x, ($x>0));
!             $question->questiontext = '';
!             $question->questiontextformat = FORMAT_HTML;
! 
!             if (intval($source->xml_value('hotpot-config-file,'.$source->hbs_quiztype.',use-drop-down-list'))) {
!                 $dropdownlist = $this->hotpot_jcloze_wordlist($source);
!                 $answertype = MULTICHOICE;
!             } else {
!                 $dropdownlist = false;
!                 $answertype = SHORTANSWER;
! 
!                 // add wordlist, if required (not required if we are using dropdowns)
!                 if (intval($source->xml_value('hotpot-config-file,'.$source->hbs_quiztype.',include-word-list'))) {
!                     $question->questiontext .= '<p class="hotpotwordlist">'.implode(' ', $this->hotpot_jcloze_wordlist($source)).'</p>';
!                 }
!             }
! 
!             // add reading, if any
!             $question->questiontext .= $this->hotpot_get_reading($source);
! 
!             $question->course = $this->course->id;
!             $question->options = new stdClass();
!             $question->options->questions = array(); // one for each gap
! 
!             $q = 0;
!             $looping = true;
!             while ($looping) {
! 
!                 // get next bit of text
!                 $questiontext = $source->xml_value($tags, $exercise."[$q]");
!                 $questiontext = $this->hotpot_prepare_str($questiontext);
! 
!                 // get next gap
!                 $gap_marker = '';
!                 $question_record = $exercise."['question-record'][$q]['#']";
!                 if ($source->xml_value($tags, $question_record)) {
! 
!                     // add gap marker
!                     $gap_count++;
!                     $gap_marker = '{#'.($q+1).'}';
! 
!                     // initialize gap details
!                     $gap = new stdClass();
!                     $gap->qtype = $answertype;
!                     $gap->defaultmark = $defaultmark; // Moodle 2.1+
!                     $gap->defaultgrade = $defaultmark; // Moodle 2.0
!                     $gap->usecase = 0;
!                     $gap->answer = array();
!                     $gap->fraction = array();
!                     $gap->feedback = array();
! 
!                     if ($answertype==MULTICHOICE) {
!                         $gap->single = 1;
!                         $gap->answernumbering = 0;
!                         $gap->shuffleanswers = 0;
!                         $gap->correctfeedback = array('text'=>'', 'format'=>FORMAT_HTML);
!                         $gap->incorrectfeedback = array('text'=>'', 'format'=>FORMAT_HTML);
!                         $gap->partiallycorrectfeedback = array('text'=>'', 'format'=>FORMAT_HTML);
!                     }
! 
!                     // add answers
!                     $answers = array();
!                     if ($dropdownlist) {
!                         $a = 0;
!                         $correcttext = '';
!                         $correctfeedback = '';
!                         while (($answer=$question_record."['answer'][$a]['#']") && $source->xml_value($tags, $answer)) {
!                             if (intval($source->xml_value($tags,  $answer."['correct'][0]['#']"))) {
!                                 $correcttext = $this->hotpot_prepare_str($source->xml_value($tags,  $answer."['text'][0]['#']"));
!                                 $correctfeedback = $this->hotpot_prepare_str($source->xml_value($tags,  $answer."['feedback'][0]['#']"));
!                                 break;
!                             }
!                             $a++;
!                         }
! 
!                         foreach ($dropdownlist as $text) {
!                             if ($text==$correcttext) {
!                                 $fraction = 1;
!                                 $feedback = $correctfeedback;
!                             } else {
!                                 $fraction = 0;
!                                 $feedback = '';
!                             }
!                             $gap->answer[] = $text;
!                             $gap->fraction[] = $fraction;
!                             $gap->feedback[] = array('text' => $feedback, 'format' => FORMAT_HTML);
!                             $answers[] = ($fraction==0 ? '' : '=').$text.($feedback=='' ? '' : ('#'.$feedback));
!                         }
!                     } else {
!                         $a = 0;
!                         while (($answer=$question_record."['answer'][$a]['#']") && $source->xml_value($tags, $answer)) {
!                             $text = $this->hotpot_prepare_str($source->xml_value($tags,  $answer."['text'][0]['#']"));
!                             $correct = $source->xml_value($tags,  $answer."['correct'][0]['#']");
!                             $feedback = $this->hotpot_prepare_str($source->xml_value($tags,  $answer."['feedback'][0]['#']"));
!                             if (strlen($text)) {
!                                 // set score (0=0%, 1=100%)
!                                 $fraction = empty($correct) ? 0 : 1;
!                                 // store answer
!                                 $gap->answer[] = $text;
!                                 $gap->fraction[] = $fraction;
!                                 $gap->feedback[] = array('text' => $feedback, 'format' => FORMAT_HTML);
!                                 $answers[] = (empty($fraction) ? '' : '=').$text.(empty($feedback) ? '' : ('#'.$feedback));
!                             }
!                             $a++;
!                         }
!                     }
!                     // compile answers into question text
!                     $gap->questiontext = array(
                          'text' => '{'.$defaultmark.':'.$answertype.':'.implode('~', $answers).'}',
                          'format' => FORMAT_MOODLE,
!                     );
!                     $question->options->questions[] = $gap;
!                 } // end if gap
! 
!                 if (strlen($questiontext) || strlen($gap_marker)) {
!                     if ($startwithgap) {
!                         $question->questiontext .= $gap_marker.$questiontext;
!                     } else {
!                         $question->questiontext .= $questiontext.$gap_marker;
!                     }
!                 } else {
!                     $looping = false;
!                 }
! 
!                 $q++;
!             } // end while $looping
! 
!             if ($q) {
!                 // define total grade for this exercise
!                 $question->defaultmark = $gap_count * $defaultmark; // Moodle 2.1+
!                 $question->defaultgrade = $question->defaultmark; // Moodle 2.0
! 
!                 // add this cloze as a single question object
!                 $questions[] = $question;
!             } else {
!                 // no gaps found in this text so don't add this question
!                 // import will fail and error message will be displayed:
!             }
! 
!             $x++;
!         } // end while $exercise
!     }
! 
!     /**
!      * hotpot_jcloze_wordlist
!      *
!      * @param xxx $source (passed by reference)
!      * @return xxx
!      */
!     function hotpot_jcloze_wordlist(&$source) {
!         $wordlist = array();
! 
!         $q = 0;
!         $tags = 'data,gap-fill,question-record';
!         while (($question="[$q]['#']") && $source->xml_value($tags, $question)) {
!             $a = 0;
!             $aa = 0;
!             while (($answer=$question."['answer'][$a]['#']") && $source->xml_value($tags, $answer)) {
!                 $text = $source->xml_value($tags,  $answer."['text'][0]['#']");
!                 $correct = $source->xml_value($tags, $answer."['correct'][0]['#']");
!                 if (strlen($text) && intval($correct)) {
!                     $wordlist[] = $text;
!                     $aa++;
!                 }
!                 $a++;
!             }
!             $q++;
!         }
! 
!         $wordlist = array_unique($wordlist);
!         sort($wordlist);
! 
!         return $wordlist;
!     }
! 
!     /**
!      * process_jcross
!      *
!      * @param xxx $source (passed by reference)
!      * @param xxx $questions (passed by reference)
!      */
!     function process_jcross(&$source, &$questions)  {
!         // xml tags to the start of the crossword exercise clue items
!         $tags = 'data,crossword,clues,item';
! 
!         $x = 0;
!         while (($item = "[$x]['#']") && $source->xml_value($tags, $item)) {
! 
!             $text = $source->xml_value($tags, $item."['def'][0]['#']");
!             $answer = $source->xml_value($tags, $item."['word'][0]['#']");
! 
!             if ($text && $answer) {
!                 $question = $this->defaultquestion();
!                 $question->qtype = SHORTANSWER;
!                 $question->name = $this->hotpot_get_title($source, $x, true);
! 
!                 if ($source->xml_value_bool($source->hbs_software.'-config-file,'.$source->hbs_quiztype.',case-sensitive')) {
!                     $question->usecase = 1;
!                 } else {
!                     $question->usecase = 0;
!                 }
!                 $question->questiontext = $this->hotpot_prepare_str($text);
!                 $question->questiontextformat = FORMAT_HTML;
! 
!                 $question->answer = array($this->hotpot_prepare_str($answer));
!                 $question->fraction = array(1);
!                 $question->feedback = array(array('text'=>'', 'format'=>FORMAT_MOODLE));
! 
!                 $questions[] = $question;
!             }
!             $x++;
!         }
!     }
! 
!     /**
!      * process_jmatch
!      *
!      * @param xxx $source (passed by reference)
!      * @param xxx $questions (passed by reference)
!      */
!     function process_jmatch(&$source, &$questions)  {
!         // define default grade (per matched pair)
!         $defaultmark = 1;
!         $match_count = 0;
! 
!         // xml tags to the start of the matching exercise
!         $tags = 'data,matching-exercise';
! 
!         $x = 0;
!         while (($exercise = "[$x]['#']") && $source->xml_value($tags, $exercise)) {
!             // there is usually only one exercise in a file
! 
!             $question = $this->defaultquestion();
!             $question->qtype = MATCH;
!             $question->name = $this->hotpot_get_title($source, $x, ($x>0));
! 
!             $question->correctfeedback = array('text'=>'', 'format'=>FORMAT_HTML);
!             $question->incorrectfeedback = array('text'=>'', 'format'=>FORMAT_HTML);
!             $question->partiallycorrectfeedback = array('text'=>'', 'format'=>FORMAT_HTML);
! 
!             $question->questiontext = $this->hotpot_get_reading($source);
!             $question->questiontext .= $this->hotpot_get_instructions($source);
!             $question->questiontextformat = FORMAT_HTML;
! 
!             $question->subquestions = array();
!             $question->subanswers = array();
!             $p = 0;
!             while (($pair = $exercise."['pair'][$p]['#']") && $source->xml_value($tags, $pair)) {
!                 $left = $source->xml_value($tags, $pair."['left-item'][0]['#']['text'][0]['#']");
!                 $right = $source->xml_value($tags, $pair."['right-item'][0]['#']['text'][0]['#']");
!                 if ($left && $right) {
!                     $match_count++;
!                     $question->subquestions[$p] = array(
                          'text' => $this->hotpot_prepare_str($left),
                          'format' => FORMAT_HTML
!                     );
!                     $question->subanswers[$p] = $this->hotpot_prepare_str($right);
!                 }
!                 $p++;
!             }
!             $question->defaultmark = $match_count * $defaultmark; // Moodle 2.1+
!             $question->defaultgrade = $question->defaultmark; // Moodle 2.0
!             $questions[] = $question;
!             $x++;
!         }
!     }
! 
!     /**
!      * process_jmix
!      *
!      * @param xxx $source (passed by reference)
!      * @param xxx $questions (passed by reference)
!      */
!     function process_jmix(&$source, &$questions)  {
!         // define default grade (per segment)
!         $defaultmark = 1;
!         $segment_count = 0;
! 
!         // xml tags to the start of the jumbled order exercise
!         $tags = 'data,jumbled-order-exercise';
! 
!         $x = 0;
!         while (($exercise = "[$x]['#']") && $source->xml_value($tags, $exercise)) {
!             // there is usually only one exercise in a file
! 
!             $question = $this->defaultquestion();
!             $question->qtype = SHORTANSWER;
!             $question->name = $this->hotpot_get_title($source, $x, ($x>0));
! 
!             $question->answer = array();
!             $question->fraction = array();
!             $question->feedback = array();
! 
!             $i = 0;
!             $segments = array();
!             while ($segment = $source->xml_value($tags, $exercise."['main-order'][0]['#']['segment'][$i]['#']")) {
!                 $segments[] = $this->hotpot_prepare_str($segment);
!                 $segment_count++;
!                 $i++;
!             }
!             $answer = implode(' ', $segments);
! 
!             shuffle($segments);
! 
!             $question->questiontext = $this->hotpot_get_reading($source);
!             $question->questiontext .= $this->hotpot_get_instructions($source);
!             $question->questiontext .= ' &nbsp; <nobr><b>[ &nbsp; '.implode(' &nbsp; ', $segments).' &nbsp; ]</b></nobr>';
!             $question->questiontextformat = FORMAT_HTML;
! 
!             $a = 0;
!             while (!empty($answer)) {
!                 $question->answer[$a] = $answer;
!                 $question->fraction[$a] = 1;
!                 $question->feedback[$a] = array('text'=>'', 'format'=>FORMAT_MOODLE);
!                 $answer = $this->hotpot_prepare_str($source->xml_value($tags, $exercise."['alternate'][$a]['#']"));
!                 $a++;
!             }
!             $question->defaultmark = $segment_count * $defaultmark; // Moodle 2.1+
!             $question->defaultgrade = $question->defaultmark; // Moodle 2.0
!             $questions[] = $question;
!             $x++;
!         }
!     }
! 
!     /**
!      * process_jquiz
!      *
!      * @param xxx $source (passed by reference)
!      * @param xxx $questions (passed by reference)
!      */
!     function process_jquiz(&$source, &$questions)  {
!         // define default grade (per question)
!         $defaultmark = 1;
! 
!         // xml tags to the start of the questions
!         $tags = 'data,questions';
! 
!         $x = 0;
!         while (($exercise = "[$x]['#']") && $source->xml_value($tags, $exercise)) {
!             // there is usually only one 'questions' object in a single exercise
! 
!             $q = 0;
!             while (($question_record = $exercise."['question-record'][$q]['#']") && $source->xml_value($tags, $question_record)) {
! 
!                 $question = $this->defaultquestion();
!                 $question->defaultmark = $defaultmark; // Moodle 2.1+
!                 $question->defaultgrade = $defaultmark; // Moodle 2.0
!                 $question->name = $this->hotpot_get_title($source, $q, true);
! 
!                 $text = $source->xml_value($tags, $question_record."['question'][0]['#']");
!                 $question->questiontext = $this->hotpot_prepare_str($text);
!                 $question->questiontextformat = FORMAT_HTML;
  
  				// CONTRIB-3565: initialize generalfeedback to prevent "can't be null" errors on Oracle
  				$question->generalfeedback = '';
!                 $question->generalfeedbackformat = FORMAT_HTML;
  
!                 $type = $source->xml_value($tags, $question_record."['question-type'][0]['#']");
!                 //  1 : multiple choice
!                 //  2 : short-answer
!                 //  3 : hybrid
!                 //  4 : multiple select
! 
!                 if ($type==2) {
!                     $question->qtype = SHORTANSWER;
!                 } else {
!                     $question->qtype = MULTICHOICE;
!                     $question->correctfeedback = array('text'=>'', 'format'=>FORMAT_HTML);
!                     $question->incorrectfeedback = array('text'=>'', 'format'=>FORMAT_HTML);
!                     $question->partiallycorrectfeedback = array('text'=>'', 'format'=>FORMAT_HTML);
!                 }
!                 if ($type==4) {
!                     $question->single = 0; // multiple select
!                 } else {
!                     $question->single = 1;
!                 }
! 
!                 // set tags to start of answers array
!                 $answers = $question_record."['answers'][0]['#']";
! 
!                 // workaround required to calculate scores for multiple select answers
!                 $no_of_correct_answers = 0;
!                 if ($type==4) {
!                     $a = 0;
!                     while (($answer = $answers."['answer'][$a]['#']") && $source->xml_value($tags, $answer)) {
!                         $correct = $source->xml_value($tags, $answer."['correct'][0]['#']");
!                         if (empty($correct)) {
!                             // do nothing
!                         } else {
!                             $no_of_correct_answers++;
!                         }
!                         $a++;
!                     }
!                 }
!                 $a = 0;
!                 $question->answer = array();
!                 $question->fraction = array();
!                 $question->feedback = array();
! 
!                 $aa = 0;
!                 $correct_answers = array();
!                 $correct_answers_all_zero = true;
!                 while (($answer = $answers."['answer'][$a]['#']") && $source->xml_value($tags, $answer)) {
!                     $correct = $source->xml_value($tags, $answer."['correct'][0]['#']");
!                     if (empty($correct)) {
!                         $fraction = 0;
!                     } else if ($type==4) { // multiple select
!                         // strange behavior if the $fraction isn't exact to 5 decimal places
!                         $fraction = round(1/$no_of_correct_answers, 5);
!                     } else {
!                         // HP6 JQuiz
!                         $percent = $source->xml_value($tags, $answer."['percent-correct'][0]['#']");
!                         $fraction = $percent/100;
!                     }
!                     $answertext = $this->hotpot_prepare_str($source->xml_value($tags, $answer."['text'][0]['#']"));
!                     if (strlen($answertext)) {
!                         if ($question->qtype==SHORTANSWER) {
!                             $question->answer[$aa] = $answertext;
!                         } else {
!                             $question->answer[$aa] = array('text'=>$answertext, 'format' => FORMAT_HTML);
!                         }
!                         $question->fraction[$aa] = $fraction;
!                         $question->feedback[$aa] = array(
                              'text' => $this->hotpot_prepare_str($source->xml_value($tags, $answer."['feedback'][0]['#']")),
                              'format' => FORMAT_HTML
!                         );
!                         if ($correct) {
!                             if ($fraction) {
!                                 $correct_answers_all_zero = false;
!                             }
!                             $correct_answers[] = $aa;
!                         }
!                         $aa++;
!                     }
!                     $a++;
!                 }
!                 if ($correct_answers_all_zero) {
!                     // correct answers all have score of 0%,
!                     // so reset score for correct answers 100%
!                     foreach ($correct_answers as $aa) {
!                         $question->fraction[$aa] = 1;
!                     }
!                 }
!                 // add a sanity check for empty questions, see MDL-17779
!                 if (strlen($question->questiontext)) {
!                     $questions[] = $question;
!                 }
!                 $q++;
!             }
!             $x++;
!         }
!     }
! 
!     /**
!      * hotpot_get_title
!      *
!      * @param object $source (passed by reference)
!      * @param integer $q the question number
!      * @param boolean $append_q_to_title if true, append ($q) to title
!      * @return xxx
!      */
!     function hotpot_get_title(&$source, $q, $append_q_to_title)  {
!         $title = $source->xml_value('data,title');
!         if ($append_q_to_title) {
!             $title .= ' ('.($q+1).')';
!         }
!         return $this->hotpot_prepare_str($title);
!     }
! 
!     /**
!      * hotpot_get_instructions
!      *
!      * @param xxx $source (passed by reference)
!      * @return xxx
!      */
!     function hotpot_get_instructions(&$source)  {
!         $text = $source->xml_value($source->hbs_software.'-config-file,'.$source->hbs_quiztype.',instructions');
!         if (empty($text)) {
!             switch ($source->hbs_software) {
!                 case 'hotpot': $text = "Hot Potatoes $source->hbs_quiztype"; break;
!                 case 'textoys': $text = "TexToys $source->hbs_quiztype"; break;
!                 default: $text = "$source->hbs_quiztype";
!             }
!         }
!         return $this->hotpot_prepare_str($text);
!     }
! 
!     /**
!      * hotpot_get_reading
!      *
!      * @param xxx $source (passed by reference)
!      * @return xxx
!      */
!     function hotpot_get_reading(&$source)  {
!         $str = '';
!         $tags = 'data,reading';
!         if ($source->xml_value("$tags,include-reading")) {
!             if ($title = $source->xml_value("$tags,reading-title")) {
!                 $str .= "<h3>$title</h3>";
!             }
!             if ($text = $source->xml_value("$tags,reading-text")) {
!                 $str .= "<p>$text</p>";
!             }
!         }
!         return $this->hotpot_prepare_str($str);
!     }
! 
!     /**
!      * hotpot_prepare_str
!      *
!      * @param xxx $str
!      * @return xxx
!      */
!     function hotpot_prepare_str($str)  {
!         // convert html entities to unicode (should we add slashes?)
!         $textlib = textlib_get_instance();
!         return $textlib->entities_to_utf8($str, true);
!     }
  } // end class
--- 41,676 ----
   */
  class qformat_hotpot extends qformat_default {
  
! 	/**
! 	 * provide_import
! 	 *
! 	 * @return xxx
! 	 */
! 	function provide_import()  {
! 		global $CFG;
! 		// disable import if the HotPot module does not exist
! 		// because we need "mod/hotpot/locallib.php"
! 		return file_exists($CFG->dirroot.'/mod/hotpot/locallib.php');
! 	}
! 
! 	/**
! 	 * mime_type
! 	 *
! 	 * @return xxx
! 	 */
! 	public function mime_type() {
! 		return 'text/xml';
! 	}
! 
! 	/**
! 	 * readquestions
! 	 *
! 	 * @param xxx $lines
! 	 * @param xxx $context (optional, default=null)
! 	 * @return xxx
! 	 */
! 	function readquestions ($lines, $context=null)  {
! 		/// Parses an array of lines into an array of questions,
! 		/// where each item is a question object as defined by
! 		/// readquestion().
! 
! 		global $CFG;
! 
! 		// get Hot Potatoes quiz type
! 		$quiztype = '';
! 		if ($pos = strrpos($this->realfilename, '.')) {
! 			$filetype = substr($this->realfilename, $pos+1);
! 			switch ($filetype) {
! 				case 'jcl': $quiztype = 'jcloze'; break;
! 				case 'jcw': $quiztype = 'jcross'; break;
! 				case 'jmt': $quiztype = 'jmatch'; break;
! 				case 'jmx': $quiztype = 'jmix'; break;
! 				case 'jqz': $quiztype = 'jquiz'; break;
! 			}
! 		}
! 
! 		if ($quiztype=='') {
! 			$this->error('Input file not recognized as a Hot Potatoes XML file');
! 			return false;
! 		}
! 
! 		$classfile = $CFG->dirroot.'/mod/hotpot/source/hp/6/'.$quiztype.'/xml/class.php';
! 		if (! file_exists($classfile)) {
! 			$this->error('HotPot import class file missing: '.$classfile);
! 			return false;
! 		}
! 		require_once($classfile);
! 
! 		$classname = 'hotpot_source_hp_6_'.$quiztype.'_xml';
! 		if (! class_exists($classname)) {
! 			$this->error('HotPot import class missing: '.$classname);
! 			return false;
! 		}
! 		$source = new $classname(implode($lines, ' '), $this);
! 
! 		// build XML tree for this HotPot
! 		$source->xml_get_filecontents();
! 
! 		// convert xml to questions array
! 		$questions = array();
! 		switch ($quiztype) {
! 			case 'jcloze': $this->process_jcloze($source, $questions); break;
! 			case 'jcross': $this->process_jcross($source, $questions); break;
! 			case 'jmatch': $this->process_jmatch($source, $questions); break;
! 			case 'jmix'  : $this->process_jmix($source, $questions); break;
! 			case 'jquiz' : $this->process_jquiz($source, $questions); break;
! 		}
! 
! 		if (count($questions)==0) {
! 			$this->error(get_string('giftnovalidquestion', 'quiz'));
! 			return false;
! 		}
! 
! 		return $questions;
! 	}
! 
! 	/**
! 	 * process_jcloze
! 	 *
! 	 * @param xxx $source (passed by reference)
! 	 * @param xxx $questions (passed by reference)
! 	 */
! 	function process_jcloze(&$source, &$questions)  {
! 		// define default grade (per cloze gap)
! 		$defaultmark = 1;
! 		$gap_count = 0;
! 
! 		if (strpos($source->filecontents, '<gap-fill><question-record>')) {
! 			$startwithgap = true;
! 		} else {
! 			$startwithgap = false;
! 		}
! 
! 		// xml tags for the start of the gap-fill exercise
! 		$tags = 'data,gap-fill';
! 
! 		$x = 0;
! 		while (($exercise = "[$x]['#']") && $source->xml_value($tags, $exercise)) {
! 			// there is usually only one exercise in a file
! 
! 			$question = $this->defaultquestion();
! 			$question->qtype = MULTIANSWER;
! 			$question->name = $this->hotpot_get_title($source, $x, ($x>0));
! 			$question->questiontext = '';
! 			$question->questiontextformat = FORMAT_HTML;
! 
! 			if (intval($source->xml_value('hotpot-config-file,'.$source->hbs_quiztype.',use-drop-down-list'))) {
! 				$dropdownlist = $this->hotpot_jcloze_wordlist($source);
! 				$answertype = MULTICHOICE;
! 			} else {
! 				$dropdownlist = false;
! 				$answertype = SHORTANSWER;
! 
! 				// add wordlist, if required (not required if we are using dropdowns)
! 				if (intval($source->xml_value('hotpot-config-file,'.$source->hbs_quiztype.',include-word-list'))) {
! 					$question->questiontext .= '<p class="hotpotwordlist">'.implode(' ', $this->hotpot_jcloze_wordlist($source)).'</p>';
! 				}
! 			}
! 
! 			// add reading, if any
! 			$question->questiontext .= $this->hotpot_get_reading($source);
! 
! 			$question->course = $this->course->id;
! 			$question->options = new stdClass();
! 			$question->options->questions = array(); // one for each gap
! 
! 			$q = 0;
! 			$looping = true;
! 			while ($looping) {
! 
! 				// get next bit of text
! 				$questiontext = $source->xml_value($tags, $exercise."[$q]");
! 				$questiontext = $this->hotpot_prepare_str($questiontext);
! 
! 				// get next gap
! 				$gap_marker = '';
! 				$question_record = $exercise."['question-record'][$q]['#']";
! 				if ($source->xml_value($tags, $question_record)) {
! 
! 					// add gap marker
! 					$gap_count++;
! 					$gap_marker = '{#'.($q+1).'}';
! 
! 					// initialize gap details
! 					$gap = new stdClass();
! 					$gap->qtype = $answertype;
! 					$gap->defaultmark = $defaultmark; // Moodle 2.1+
! 					$gap->defaultgrade = $defaultmark; // Moodle 2.0
! 					$gap->usecase = 0;
! 					$gap->answer = array();
! 					$gap->fraction = array();
! 					$gap->feedback = array();
! 
! 					if ($answertype==MULTICHOICE) {
! 						$gap->single = 1;
! 						$gap->answernumbering = 0;
! 						$gap->shuffleanswers = 0;
! 						$gap->correctfeedback = array('text'=>'', 'format'=>FORMAT_HTML);
! 						$gap->incorrectfeedback = array('text'=>'', 'format'=>FORMAT_HTML);
! 						$gap->partiallycorrectfeedback = array('text'=>'', 'format'=>FORMAT_HTML);
! 					}
! 
! 					// add answers
! 					$answers = array();
! 					if ($dropdownlist) {
! 						$a = 0;
! 						$correcttext = '';
! 						$correctfeedback = '';
! 						while (($answer=$question_record."['answer'][$a]['#']") && $source->xml_value($tags, $answer)) {
! 							if (intval($source->xml_value($tags,  $answer."['correct'][0]['#']"))) {
! 								$correcttext = $this->hotpot_prepare_str($source->xml_value($tags,  $answer."['text'][0]['#']"));
! 								$correctfeedback = $this->hotpot_prepare_str($source->xml_value($tags,  $answer."['feedback'][0]['#']"));
! 								break;
! 							}
! 							$a++;
! 						}
! 
! 						foreach ($dropdownlist as $text) {
! 							if ($text==$correcttext) {
! 								$fraction = 1;
! 								$feedback = $correctfeedback;
! 							} else {
! 								$fraction = 0;
! 								$feedback = '';
! 							}
! 							$gap->answer[] = $text;
! 							$gap->fraction[] = $fraction;
! 							$gap->feedback[] = array('text' => $feedback, 'format' => FORMAT_HTML);
! 							$answers[] = ($fraction==0 ? '' : '=').$text.($feedback=='' ? '' : ('#'.$feedback));
! 						}
! 					} else {
! 						$a = 0;
! 						while (($answer=$question_record."['answer'][$a]['#']") && $source->xml_value($tags, $answer)) {
! 							$text = $this->hotpot_prepare_str($source->xml_value($tags,  $answer."['text'][0]['#']"));
! 							$correct = $source->xml_value($tags,  $answer."['correct'][0]['#']");
! 							$feedback = $this->hotpot_prepare_str($source->xml_value($tags,  $answer."['feedback'][0]['#']"));
! 							if (strlen($text)) {
! 								// set score (0=0%, 1=100%)
! 								$fraction = empty($correct) ? 0 : 1;
! 								// store answer
! 								$gap->answer[] = $text;
! 								$gap->fraction[] = $fraction;
! 								$gap->feedback[] = array('text' => $feedback, 'format' => FORMAT_HTML);
! 								$answers[] = (empty($fraction) ? '' : '=').$text.(empty($feedback) ? '' : ('#'.$feedback));
! 							}
! 							$a++;
! 						}
! 					}
! 					// compile answers into question text
! 					$gap->questiontext = array(
                          'text' => '{'.$defaultmark.':'.$answertype.':'.implode('~', $answers).'}',
                          'format' => FORMAT_MOODLE,
! 					);
! 					$question->options->questions[] = $gap;
! 				} // end if gap
! 
! 				if (strlen($questiontext) || strlen($gap_marker)) {
! 					if ($startwithgap) {
! 						$question->questiontext .= $gap_marker.$questiontext;
! 					} else {
! 						$question->questiontext .= $questiontext.$gap_marker;
! 					}
! 				} else {
! 					$looping = false;
! 				}
! 
! 				$q++;
! 			} // end while $looping
! 
! 			if ($q) {
! 				// define total grade for this exercise
! 				$question->defaultmark = $gap_count * $defaultmark; // Moodle 2.1+
! 				$question->defaultgrade = $question->defaultmark; // Moodle 2.0
! 
! 				// add this cloze as a single question object
! 				$questions[] = $question;
! 			} else {
! 				// no gaps found in this text so don't add this question
! 				// import will fail and error message will be displayed:
! 			}
! 
! 			$x++;
! 		} // end while $exercise
! 	}
! 
! 	/**
! 	 * hotpot_jcloze_wordlist
! 	 *
! 	 * @param xxx $source (passed by reference)
! 	 * @return xxx
! 	 */
! 	function hotpot_jcloze_wordlist(&$source) {
! 		$wordlist = array();
! 
! 		$q = 0;
! 		$tags = 'data,gap-fill,question-record';
! 		while (($question="[$q]['#']") && $source->xml_value($tags, $question)) {
! 			$a = 0;
! 			$aa = 0;
! 			while (($answer=$question."['answer'][$a]['#']") && $source->xml_value($tags, $answer)) {
! 				$text = $source->xml_value($tags,  $answer."['text'][0]['#']");
! 				$correct = $source->xml_value($tags, $answer."['correct'][0]['#']");
! 				if (strlen($text) && intval($correct)) {
! 					$wordlist[] = $text;
! 					$aa++;
! 				}
! 				$a++;
! 			}
! 			$q++;
! 		}
! 
! 		$wordlist = array_unique($wordlist);
! 		sort($wordlist);
! 
! 		return $wordlist;
! 	}
! 
! 	/**
! 	 * process_jcross
! 	 *
! 	 * @param xxx $source (passed by reference)
! 	 * @param xxx $questions (passed by reference)
! 	 */
! 	function process_jcross(&$source, &$questions)  {
! 		// xml tags to the start of the crossword exercise clue items
! 		$tags = 'data,crossword,clues,item';
! 
! 		$x = 0;
! 		while (($item = "[$x]['#']") && $source->xml_value($tags, $item)) {
! 
! 			$text = $source->xml_value($tags, $item."['def'][0]['#']");
! 			$answer = $source->xml_value($tags, $item."['word'][0]['#']");
! 
! 			if ($text && $answer) {
! 				$question = $this->defaultquestion();
! 				$question->qtype = SHORTANSWER;
! 				$question->name = $this->hotpot_get_title($source, $x, true);
! 
! 				if ($source->xml_value_bool($source->hbs_software.'-config-file,'.$source->hbs_quiztype.',case-sensitive')) {
! 					$question->usecase = 1;
! 				} else {
! 					$question->usecase = 0;
! 				}
! 				$question->questiontext = $this->hotpot_prepare_str($text);
! 				$question->questiontextformat = FORMAT_HTML;
! 
! 				$question->answer = array($this->hotpot_prepare_str($answer));
! 				$question->fraction = array(1);
! 				$question->feedback = array(array('text'=>'', 'format'=>FORMAT_MOODLE));
! 
! 				$questions[] = $question;
! 			}
! 			$x++;
! 		}
! 	}
! 
! 	/**
! 	 * process_jmatch
! 	 *
! 	 * @param xxx $source (passed by reference)
! 	 * @param xxx $questions (passed by reference)
! 	 */
! 	function process_jmatch(&$source, &$questions)  {
! 		// define default grade (per matched pair)
! 		$defaultmark = 1;
! 		$match_count = 0;
! 
! 		// xml tags to the start of the matching exercise
! 		$tags = 'data,matching-exercise';
! 
! 		$x = 0;
! 		while (($exercise = "[$x]['#']") && $source->xml_value($tags, $exercise)) {
! 			// there is usually only one exercise in a file
! 
! 			$question = $this->defaultquestion();
! 			$question->qtype = MATCH;
! 			$question->name = $this->hotpot_get_title($source, $x, ($x>0));
! 
! 			$question->correctfeedback = array('text'=>'', 'format'=>FORMAT_HTML);
! 			$question->incorrectfeedback = array('text'=>'', 'format'=>FORMAT_HTML);
! 			$question->partiallycorrectfeedback = array('text'=>'', 'format'=>FORMAT_HTML);
! 
! 			$question->questiontext = $this->hotpot_get_reading($source);
! 			$question->questiontext .= $this->hotpot_get_instructions($source);
! 			$question->questiontextformat = FORMAT_HTML;
! 
! 			$question->subquestions = array();
! 			$question->subanswers = array();
! 			$p = 0;
! 			while (($pair = $exercise."['pair'][$p]['#']") && $source->xml_value($tags, $pair)) {
! 				$left = $source->xml_value($tags, $pair."['left-item'][0]['#']['text'][0]['#']");
! 				$right = $source->xml_value($tags, $pair."['right-item'][0]['#']['text'][0]['#']");
! 				if ($left && $right) {
! 					$match_count++;
! 					$question->subquestions[$p] = array(
                          'text' => $this->hotpot_prepare_str($left),
                          'format' => FORMAT_HTML
! 					);
! 					$question->subanswers[$p] = $this->hotpot_prepare_str($right);
! 				}
! 				$p++;
! 			}
! 			$question->defaultmark = $match_count * $defaultmark; // Moodle 2.1+
! 			$question->defaultgrade = $question->defaultmark; // Moodle 2.0
! 			$questions[] = $question;
! 			$x++;
! 		}
! 	}
! 
! 	/**
! 	 * process_jmix
! 	 *
! 	 * @param xxx $source (passed by reference)
! 	 * @param xxx $questions (passed by reference)
! 	 */
! 	function process_jmix(&$source, &$questions)  {
! 		// define default grade (per segment)
! 		$defaultmark = 1;
! 		$segment_count = 0;
! 
! 		// xml tags to the start of the jumbled order exercise
! 		$tags = 'data,jumbled-order-exercise';
! 
! 		$x = 0;
! 		while (($exercise = "[$x]['#']") && $source->xml_value($tags, $exercise)) {
! 			// there is usually only one exercise in a file
! 
! 			$question = $this->defaultquestion();
! 			$question->qtype = SHORTANSWER;
! 			$question->name = $this->hotpot_get_title($source, $x, ($x>0));
! 
! 			$question->answer = array();
! 			$question->fraction = array();
! 			$question->feedback = array();
! 
! 			$i = 0;
! 			$segments = array();
! 			while ($segment = $source->xml_value($tags, $exercise."['main-order'][0]['#']['segment'][$i]['#']")) {
! 				$segments[] = $this->hotpot_prepare_str($segment);
! 				$segment_count++;
! 				$i++;
! 			}
! 			$answer = implode(' ', $segments);
! 
! 			shuffle($segments);
! 
! 			$question->questiontext = $this->hotpot_get_reading($source);
! 			$question->questiontext .= $this->hotpot_get_instructions($source);
! 			$question->questiontext .= ' &nbsp; <nobr><b>[ &nbsp; '.implode(' &nbsp; ', $segments).' &nbsp; ]</b></nobr>';
! 			$question->questiontextformat = FORMAT_HTML;
! 
! 			$a = 0;
! 			while (!empty($answer)) {
! 				$question->answer[$a] = $answer;
! 				$question->fraction[$a] = 1;
! 				$question->feedback[$a] = array('text'=>'', 'format'=>FORMAT_MOODLE);
! 				$answer = $this->hotpot_prepare_str($source->xml_value($tags, $exercise."['alternate'][$a]['#']"));
! 				$a++;
! 			}
! 			$question->defaultmark = $segment_count * $defaultmark; // Moodle 2.1+
! 			$question->defaultgrade = $question->defaultmark; // Moodle 2.0
! 			$questions[] = $question;
! 			$x++;
! 		}
! 	}
! 
! 	/**
! 	 * process_jquiz
! 	 *
! 	 * @param xxx $source (passed by reference)
! 	 * @param xxx $questions (passed by reference)
! 	 */
! 	function process_jquiz(&$source, &$questions)  {
! 		// define default grade (per question)
! 		$defaultmark = 1;
! 
! 		// xml tags to the start of the questions
! 		$tags = 'data,questions';
! 
! 		$x = 0;
! 		while (($exercise = "[$x]['#']") && $source->xml_value($tags, $exercise)) {
! 			// there is usually only one 'questions' object in a single exercise
! 
! 			$q = 0;
! 			while (($question_record = $exercise."['question-record'][$q]['#']") && $source->xml_value($tags, $question_record)) {
! 
! 				$question = $this->defaultquestion();
! 				$question->defaultmark = $defaultmark; // Moodle 2.1+
! 				$question->defaultgrade = $defaultmark; // Moodle 2.0
! 				$question->name = $this->hotpot_get_title($source, $q, true);
! 
! 				$text = $source->xml_value($tags, $question_record."['question'][0]['#']");
! 				$question->questiontext = $this->hotpot_prepare_str($text);
! 				$question->questiontextformat = FORMAT_HTML;
  
  				// CONTRIB-3565: initialize generalfeedback to prevent "can't be null" errors on Oracle
  				$question->generalfeedback = '';
! 				$question->generalfeedbackformat = FORMAT_HTML;
  
! 				$type = $source->xml_value($tags, $question_record."['question-type'][0]['#']");
! 				//  1 : multiple choice
! 				//  2 : short-answer
! 				//  3 : hybrid
! 				//  4 : multiple select
! 
! 				if ($type==2) {
! 					$question->qtype = SHORTANSWER;
! 				} else {
! 					$question->qtype = MULTICHOICE;
! 					$question->correctfeedback = array('text'=>'', 'format'=>FORMAT_HTML);
! 					$question->incorrectfeedback = array('text'=>'', 'format'=>FORMAT_HTML);
! 					$question->partiallycorrectfeedback = array('text'=>'', 'format'=>FORMAT_HTML);
! 				}
! 				if ($type==4) {
! 					$question->single = 0; // multiple select
! 				} else {
! 					$question->single = 1;
! 				}
! 
! 				// set tags to start of answers array
! 				$answers = $question_record."['answers'][0]['#']";
! 
! 				// workaround required to calculate scores for multiple select answers
! 				$no_of_correct_answers = 0;
! 				if ($type==4) {
! 					$a = 0;
! 					while (($answer = $answers."['answer'][$a]['#']") && $source->xml_value($tags, $answer)) {
! 						$correct = $source->xml_value($tags, $answer."['correct'][0]['#']");
! 						if (empty($correct)) {
! 							// do nothing
! 						} else {
! 							$no_of_correct_answers++;
! 						}
! 						$a++;
! 					}
! 				}
! 				$a = 0;
! 				$question->answer = array();
! 				$question->fraction = array();
! 				$question->feedback = array();
! 
! 				$aa = 0;
! 				$correct_answers = array();
! 				$correct_answers_all_zero = true;
! 				while (($answer = $answers."['answer'][$a]['#']") && $source->xml_value($tags, $answer)) {
! 					$correct = $source->xml_value($tags, $answer."['correct'][0]['#']");
! 					if (empty($correct)) {
! 						$fraction = 0;
! 					} else if ($type==4) { // multiple select
! 						// strange behavior if the $fraction isn't exact to 5 decimal places
! 						$fraction = round(1/$no_of_correct_answers, 5);
! 					} else {
! 						// HP6 JQuiz
! 						$percent = $source->xml_value($tags, $answer."['percent-correct'][0]['#']");
! 						$fraction = $percent/100;
! 					}
! 					$answertext = $this->hotpot_prepare_str($source->xml_value($tags, $answer."['text'][0]['#']"));
! 					if (strlen($answertext)) {
! 						if ($question->qtype==SHORTANSWER) {
! 							$question->answer[$aa] = $answertext;
! 						} else {
! 							$question->answer[$aa] = array('text'=>$answertext, 'format' => FORMAT_HTML);
! 						}
! 						$question->fraction[$aa] = $fraction;
! 						$question->feedback[$aa] = array(
                              'text' => $this->hotpot_prepare_str($source->xml_value($tags, $answer."['feedback'][0]['#']")),
                              'format' => FORMAT_HTML
! 						);
! 						if ($correct) {
! 							if ($fraction) {
! 								$correct_answers_all_zero = false;
! 							}
! 							$correct_answers[] = $aa;
! 						}
! 						$aa++;
! 					}
! 					$a++;
! 				}
! 				if ($correct_answers_all_zero) {
! 					// correct answers all have score of 0%,
! 					// so reset score for correct answers 100%
! 					foreach ($correct_answers as $aa) {
! 						$question->fraction[$aa] = 1;
! 					}
! 				}
! 				// add a sanity check for empty questions, see MDL-17779
! 				if (strlen($question->questiontext)) {
! 					$questions[] = $question;
! 				}
! 				$q++;
! 			}
! 			$x++;
! 		}
! 	}
! 
! 	/**
! 	 * hotpot_get_title
! 	 *
! 	 * @param object $source (passed by reference)
! 	 * @param integer $q the question number
! 	 * @param boolean $append_q_to_title if true, append ($q) to title
! 	 * @return xxx
! 	 */
! 	function hotpot_get_title(&$source, $q, $append_q_to_title)  {
! 		$title = $source->xml_value('data,title');
! 		if ($append_q_to_title) {
! 			$title .= ' ('.($q+1).')';
! 		}
! 		return $this->hotpot_prepare_str($title);
! 	}
! 
! 	/**
! 	 * hotpot_get_instructions
! 	 *
! 	 * @param xxx $source (passed by reference)
! 	 * @return xxx
! 	 */
! 	function hotpot_get_instructions(&$source)  {
! 		$text = $source->xml_value($source->hbs_software.'-config-file,'.$source->hbs_quiztype.',instructions');
! 		if (empty($text)) {
! 			switch ($source->hbs_software) {
! 				case 'hotpot': $text = "Hot Potatoes $source->hbs_quiztype"; break;
! 				case 'textoys': $text = "TexToys $source->hbs_quiztype"; break;
! 				default: $text = "$source->hbs_quiztype";
! 			}
! 		}
! 		return $this->hotpot_prepare_str($text);
! 	}
! 
! 	/**
! 	 * hotpot_get_reading
! 	 *
! 	 * @param xxx $source (passed by reference)
! 	 * @return xxx
! 	 */
! 	function hotpot_get_reading(&$source)  {
! 		$str = '';
! 		$tags = 'data,reading';
! 		if ($source->xml_value("$tags,include-reading")) {
! 			if ($title = $source->xml_value("$tags,reading-title")) {
! 				$str .= "<h3>$title</h3>";
! 			}
! 			if ($text = $source->xml_value("$tags,reading-text")) {
! 				$str .= "<p>$text</p>";
! 			}
! 		}
! 		return $this->hotpot_prepare_str($str);
! 	}
! 
! 	/**
! 	 * hotpot_prepare_str
! 	 *
! 	 * @param xxx $str
! 	 * @return xxx
! 	 */
! 	function hotpot_prepare_str($str)  {
! 		// convert html entities to unicode (should we add slashes?)
! 		$textlib = textlib_get_instance();
! 		return $textlib->entities_to_utf8($str, true);
! 	}
  } // end class
diff -crB questionorg/format/hotpot/lang/en/qformat_hotpot.php questionupd/format/hotpot/lang/en/qformat_hotpot.php
*** questionorg/format/hotpot/lang/en/qformat_hotpot.php	2012-04-13 12:31:11.586178257 +0500
--- questionupd/format/hotpot/lang/en/qformat_hotpot.php	2012-04-13 09:42:52.000000000 +0500
***************
*** 23,34 ****
   * @license   http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
   */
  
!  // Moodle 2.0 - 2.1
  $string['hotpot'] = 'Hot Potatoes XML format';
  $string['hotpot_help'] = 'This is file format for importing questions from Hot Potatoes xml files, JCloze (jcl), JCross (jcw), JMatch (jmt), JMix(jmx), JQuiz (jqz), into the Moodle question bank.';
  $string['hotpot_link'] = 'qformat/hotpot';
  
!  // Moodle >= 2.2 
  $string['pluginname'] = 'Hot Potatoes XML format';
  $string['pluginname_help'] = 'This is file format for importing questions from Hot Potatoes xml files, JCloze (jcl), JCross (jcw), JMatch (jmt), JMix(jmx), JQuiz (jqz), into the Moodle question bank.';
  $string['pluginname_link'] = 'qformat/hotpot';
\ No newline at end of file
--- 23,34 ----
   * @license   http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
   */
  
! // Moodle 2.0 - 2.1
  $string['hotpot'] = 'Hot Potatoes XML format';
  $string['hotpot_help'] = 'This is file format for importing questions from Hot Potatoes xml files, JCloze (jcl), JCross (jcw), JMatch (jmt), JMix(jmx), JQuiz (jqz), into the Moodle question bank.';
  $string['hotpot_link'] = 'qformat/hotpot';
  
! // Moodle >= 2.2
  $string['pluginname'] = 'Hot Potatoes XML format';
  $string['pluginname_help'] = 'This is file format for importing questions from Hot Potatoes xml files, JCloze (jcl), JCross (jcw), JMatch (jmt), JMix(jmx), JQuiz (jqz), into the Moodle question bank.';
  $string['pluginname_link'] = 'qformat/hotpot';
\ No newline at end of file
diff -crB questionorg/format/learnwise/format.php questionupd/format/learnwise/format.php
*** questionorg/format/learnwise/format.php	2012-04-13 12:31:11.152178243 +0500
--- questionupd/format/learnwise/format.php	2012-04-13 09:42:52.000000000 +0500
***************
*** 12,150 ****
  
  class qformat_learnwise extends qformat_default {
  
!     function provide_import() {
!       return true;
!     }
! 
!     function readquestions($lines) {
!         $questions = array();
!         $currentquestion = array();
! 
!         foreach($lines as $line) {
!             $line = trim($line);
!             $currentquestion[] = $line;
! 
!             if ($question = $this->readquestion($currentquestion)) {
!                 $questions[] = $question;
!                 $currentquestion = array();
!             }
!         }
!         return $questions;
!     }
! 
!     function readquestion($lines) {
!         $text = implode(' ', $lines);
!         $text = str_replace(array('\t','\n','\r','\''), array('','','','\\\''), $text);
! 
!         $startpos = strpos($text, '<question type');
!         $endpos = strpos($text, '</question>');
!         if ($startpos === false || $endpos === false) {
!             return false;
!         }
! 
!         preg_match("/<question type=[\"\']([^\"\']+)[\"\']>/i", $text, $matches);
!         $type = strtolower($matches[1]); // multichoice or multianswerchoice
! 
!         $questiontext = $this->unhtmlentities($this->stringbetween($text, '<text>', '</text>'));
!         $questionhint = $this->unhtmlentities($this->stringbetween($text, '<hint>', '</hint>'));
!         $questionaward = $this->stringbetween($text, '<award>', '</award>');
!         $optionlist = $this->stringbetween($text, '<answer>', '</answer>');
! 
!         $optionlist = explode('<option', $optionlist);
! 
!         $n = 0;
! 
!         $optionscorrect = array();
!         $optionstext = array();
! 
!         if ($type == 'multichoice') {
!             foreach ($optionlist as $option) {
!                 $correct = $this->stringbetween($option, ' correct="', '">');
!                 $answer = $this->stringbetween($option, '">', '</option>');
!                 $optionscorrect[$n] = $correct;
!                 $optionstext[$n] = $this->unhtmlentities($answer);
!                 ++$n;
!             }
!         } else if ($type == 'multianswerchoice') {
!             $numcorrect = 0;
!             $totalaward = 0;
! 
!             $optionsaward = array();
! 
!             foreach ($optionlist as $option) {
!                 preg_match("/correct=\"([^\"]*)\"/i", $option, $correctmatch);
!                 preg_match("/award=\"([^\"]*)\"/i", $option, $awardmatch);
! 
!                 $correct = $correctmatch[1];
!                 $award = $awardmatch[1];
!                 if ($correct == 'yes') {
!                     $totalaward += $award;
!                     ++$numcorrect;
!                 }
! 
!                 $answer = $this->stringbetween($option, '">', '</option>');
! 
!                 $optionscorrect[$n] = $correct;
!                 $optionstext[$n] = $this->unhtmlentities($answer);
!                 $optionsaward[$n] = $award;
!                 ++$n;
!             }
! 
!         } else {
!             echo "<p>I don't understand this question type (type = <strong>$type</strong>).</p>\n";
!         }
! 
!         $question = $this->defaultquestion();
!         $question->qtype = MULTICHOICE;
!         $question->name = substr($questiontext, 0, 30);
!         if (strlen($questiontext) > 30) {
!             $question->name .= '...';
!         }
! 
!         $question->questiontext = $questiontext;
!         $question->single = ($type == 'multichoice') ? 1 : 0;
!         $question->feedback[] = '';
! 
!         $question->fraction = array();
!         $question->answer = array();
!         for ($n = 0; $n < count($optionstext); ++$n) {
!             if ($optionstext[$n]) {
!                 if (!isset($numcorrect)) { // single answer
!                     if ($optionscorrect[$n] == 'yes') {
!                         $fraction = (int) $questionaward;
!                     } else {
!                         $fraction = 0;
!                     }
!                 } else { // mulitple answers
!                     if ($optionscorrect[$n] == 'yes') {
!                         $fraction = $optionsaward[$n] / $totalaward;
!                     } else {
!                         $fraction = -$optionsaward[$n] / count($optionstext);
!                     }
!                 }
!                 $question->fraction[] = $fraction;
!                 $question->answer[] = $optionstext[$n];
!                 $question->feedback[] = ''; // no feedback in this type
!             }
!         }
! 
!         return $question;
!     }
! 
!     function stringbetween($text, $start, $end) {
!         $startpos = strpos($text, $start) + strlen($start);
!         $endpos = strpos($text, $end);
! 
!         if ($startpos <= $endpos) {
!             return substr($text, $startpos, $endpos - $startpos);
!         }
!     }
! 
!     function unhtmlentities($string) {
!         $transtable = get_html_translation_table(HTML_ENTITIES);
!         $transtable = array_flip($transtable);
!         return strtr($string, $transtable);
!     }
  
  }
  
--- 12,150 ----
  
  class qformat_learnwise extends qformat_default {
  
! 	function provide_import() {
! 		return true;
! 	}
! 
! 	function readquestions($lines) {
! 		$questions = array();
! 		$currentquestion = array();
! 
! 		foreach($lines as $line) {
! 			$line = trim($line);
! 			$currentquestion[] = $line;
! 
! 			if ($question = $this->readquestion($currentquestion)) {
! 				$questions[] = $question;
! 				$currentquestion = array();
! 			}
! 		}
! 		return $questions;
! 	}
! 
! 	function readquestion($lines) {
! 		$text = implode(' ', $lines);
! 		$text = str_replace(array('\t','\n','\r','\''), array('','','','\\\''), $text);
! 
! 		$startpos = strpos($text, '<question type');
! 		$endpos = strpos($text, '</question>');
! 		if ($startpos === false || $endpos === false) {
! 			return false;
! 		}
! 
! 		preg_match("/<question type=[\"\']([^\"\']+)[\"\']>/i", $text, $matches);
! 		$type = strtolower($matches[1]); // multichoice or multianswerchoice
! 
! 		$questiontext = $this->unhtmlentities($this->stringbetween($text, '<text>', '</text>'));
! 		$questionhint = $this->unhtmlentities($this->stringbetween($text, '<hint>', '</hint>'));
! 		$questionaward = $this->stringbetween($text, '<award>', '</award>');
! 		$optionlist = $this->stringbetween($text, '<answer>', '</answer>');
! 
! 		$optionlist = explode('<option', $optionlist);
! 
! 		$n = 0;
! 
! 		$optionscorrect = array();
! 		$optionstext = array();
! 
! 		if ($type == 'multichoice') {
! 			foreach ($optionlist as $option) {
! 				$correct = $this->stringbetween($option, ' correct="', '">');
! 				$answer = $this->stringbetween($option, '">', '</option>');
! 				$optionscorrect[$n] = $correct;
! 				$optionstext[$n] = $this->unhtmlentities($answer);
! 				++$n;
! 			}
! 		} else if ($type == 'multianswerchoice') {
! 			$numcorrect = 0;
! 			$totalaward = 0;
! 
! 			$optionsaward = array();
! 
! 			foreach ($optionlist as $option) {
! 				preg_match("/correct=\"([^\"]*)\"/i", $option, $correctmatch);
! 				preg_match("/award=\"([^\"]*)\"/i", $option, $awardmatch);
! 
! 				$correct = $correctmatch[1];
! 				$award = $awardmatch[1];
! 				if ($correct == 'yes') {
! 					$totalaward += $award;
! 					++$numcorrect;
! 				}
! 
! 				$answer = $this->stringbetween($option, '">', '</option>');
! 
! 				$optionscorrect[$n] = $correct;
! 				$optionstext[$n] = $this->unhtmlentities($answer);
! 				$optionsaward[$n] = $award;
! 				++$n;
! 			}
! 
! 		} else {
! 			echo "<p>I don't understand this question type (type = <strong>$type</strong>).</p>\n";
! 		}
! 
! 		$question = $this->defaultquestion();
! 		$question->qtype = MULTICHOICE;
! 		$question->name = substr($questiontext, 0, 30);
! 		if (strlen($questiontext) > 30) {
! 			$question->name .= '...';
! 		}
! 
! 		$question->questiontext = $questiontext;
! 		$question->single = ($type == 'multichoice') ? 1 : 0;
! 		$question->feedback[] = '';
! 
! 		$question->fraction = array();
! 		$question->answer = array();
! 		for ($n = 0; $n < count($optionstext); ++$n) {
! 			if ($optionstext[$n]) {
! 				if (!isset($numcorrect)) { // single answer
! 					if ($optionscorrect[$n] == 'yes') {
! 						$fraction = (int) $questionaward;
! 					} else {
! 						$fraction = 0;
! 					}
! 				} else { // mulitple answers
! 					if ($optionscorrect[$n] == 'yes') {
! 						$fraction = $optionsaward[$n] / $totalaward;
! 					} else {
! 						$fraction = -$optionsaward[$n] / count($optionstext);
! 					}
! 				}
! 				$question->fraction[] = $fraction;
! 				$question->answer[] = $optionstext[$n];
! 				$question->feedback[] = ''; // no feedback in this type
! 			}
! 		}
! 
! 		return $question;
! 	}
! 
! 	function stringbetween($text, $start, $end) {
! 		$startpos = strpos($text, $start) + strlen($start);
! 		$endpos = strpos($text, $end);
! 
! 		if ($startpos <= $endpos) {
! 			return substr($text, $startpos, $endpos - $startpos);
! 		}
! 	}
! 
! 	function unhtmlentities($string) {
! 		$transtable = get_html_translation_table(HTML_ENTITIES);
! 		$transtable = array_flip($transtable);
! 		return strtr($string, $transtable);
! 	}
  
  }
  
diff -crB questionorg/format/learnwise/learnwise-example.xml questionupd/format/learnwise/learnwise-example.xml
*** questionorg/format/learnwise/learnwise-example.xml	2012-04-13 12:31:11.110178250 +0500
--- questionupd/format/learnwise/learnwise-example.xml	2012-04-13 09:42:52.000000000 +0500
***************
*** 1,145 ****
  <?xml version="1.0" ?>
  <activityset setno="2">
!     <title>Maths</title>
!     <questions>
!         <question type="multiChoice">
!             <text>The ages, in years, of 10 horses in a field were 3,  3,  4,  5,  7,  7,  7,  8,  8,  8,&lt;p&gt;
! Which one of the following is true?</text>
!             <award>1</award>
!             <hint>mean = (3+3+4+5+7+7+7+8+8+8)/10 = 6&lt;p&gt;
! median = 7 i.e the middle number&lt;p&gt;
! range = 8-3 = 5</hint>
!             <answer>
!                 <option correct="yes">median &gt; mean &gt; range</option>
!                 <option correct="no">mean = median</option>
!                 <option correct="no">mean &gt; median &gt; range</option>
!                 <option correct="no">median &gt; range &gt; mean</option>
!             </answer>
!         </question>
!         <question type="multiChoice">
!             <text>At a college, students are given a points score calculated from their GCSE grades.&lt;p&gt;
! Someone with 4 A grades and 4 B grades gains a score of 36 points.&lt;br&gt;Someone with 2 A grades and 4 B grades gains a score of 26 points.&lt;br&gt;Someone with 3 A grades and 3 B grades would have a score of</text>
!             <award>1</award>
!             <hint>4A + 4B = 36 and 2A + 4B = 26&lt;p&gt;solving simultaneously gives A = 5 and B = 4</hint>
!             <answer>
!                 <option correct="yes">27 points</option>
!                 <option correct="no">21 points</option>
!                 <option correct="no">30 points</option>
!                 <option correct="no">31 points</option>
!             </answer>
!         </question>
!         <question type="multiChoice">
!             <text>A sequence consists of adding the previous three terms together to form the next term. The first three terms of the sequence are 1, 2, 3.&lt;p&gt;
! What is the sixth term in the sequence?</text>
!             <award>1</award>
!             <hint>1, 2, 3, 6, 11, ...</hint>
!             <answer>
!                 <option correct="yes">20</option>
!                 <option correct="no">6</option>
!                 <option correct="no">11</option>
!                 <option correct="no">13</option>
!             </answer>
!         </question>
!         <question type="multiChoice">
!             <text>The value of an item is described as decreasing exponentially. Which description below best matches this statement?</text>
!             <award>1</award>
!             <hint>No hint - you either know this or you don't!</hint>
!             <answer>
!                 <option correct="yes">The value falls by a smaller amount each year.</option>
!                 <option correct="no">The value falls by the same amount each year.</option>
!                 <option correct="no">The value falls by the same amount each year for a while, and then remains constant.</option>
!                 <option correct="no">The value falls by a larger amount each year.</option>
!             </answer>
!         </question>
!         <question type="multiChoice">
!             <text>Consider the statement&lt;p&gt;
! &quot;Schools with high numbers of pupils on free school meals do not do well in league tables.&quot;&lt;p&gt;
! Which of the following statements follows logically from the one above?</text>
!             <award>1</award>
!             <hint>Factors other than the number of pupils on free school meals affect how well a school does in league tables.</hint>
!             <answer>
!                 <option correct="yes">Schools which do well in league tables do not have high numbers of pupils on free school meals.</option>
!                 <option correct="no">Schools with low numbers of pupils on free school meals do well in league tables.</option>
!                 <option correct="no">Making all pupils pay for school meals will improve league table results.</option>
!                 <option correct="no">Schools which do not do well in league tables have high numbers of pupils on free school meals.</option>
!             </answer>
!         </question>
!         <question type="multiChoice">
!             <text>The force between two point electric charges is inversely proportional to the square of their distance apart. What effect does doubling this distance have on the force?</text>
!             <award>1</award>
!             <hint>Inversely proportional means that increasing the distance decreases the force.&lt;br&gt;2 squared gives 4.</hint>
!             <answer>
!                 <option correct="yes">The force decreases by a factor of four.</option>
!                 <option correct="no">The force is halved.</option>
!                 <option correct="no">The force is doubled.</option>
!                 <option correct="no">The force increases by a factor of four.</option>
!             </answer>
!         </question>
!         <question type="multiChoice">
!             <text>Two of the five playing cards that Colin has are aces. He shuffles the five cards, then puts them face down on the table. Madge takes a card and then another. The probability that she now has &lt;b&gt;both&lt;/b&gt; of the aces is</text>
!             <award>1</award>
!             <hint>2/5 x 1/4</hint>
!             <answer>
!                 <option correct="yes">1/10</option>
!                 <option correct="no">4/25</option>
!                 <option correct="no">1/5</option>
!                 <option correct="no">2/5</option>
!             </answer>
!         </question>
!         <question type="multiChoice">
!             <text>A college's guidelines say that classes must have a minimum of 12 students and a maximum of 20 students. For what numbers of students studying a particular subject is it impossible to run classes without breaking the guidelines?</text>
!             <award>1</award>
!             <hint>between 12 and 20 students - one class&lt;br&gt;
! between 24 and 36 students - two classes&lt;br&gt;
! between 36 and 40 students - two classes</hint>
!             <answer>
!                 <option correct="yes">between 20 and 24 students</option>
!                 <option correct="no">between 12 and 20 students</option>
!                 <option correct="no">between 24 and 36 students</option>
!                 <option correct="no">between 36 and 40 students</option>
!             </answer>
!         </question>
!         <question type="multiChoice">
!             <text>The ages of two friends are in the ratio 3:4. In 8 years time their ages will be in the ratio 5:6. How old are they now?</text>
!             <award>1</award>
!             <hint>(12+8):(16+8) = 20:24 = 5:6</hint>
!             <answer>
!                 <option correct="yes">12, 16</option>
!                 <option correct="no">3, 4</option>
!                 <option correct="no">6, 8</option>
!                 <option correct="no">9, 12</option>
!             </answer>
!         </question>
!         <question type="multiChoice">
!             <text>A heavy construction vehicle travels for 40 minutes between sites, at an average speed of 16 km per second. The distance between sites is</text>
!             <award>1</award>
!             <hint>16/60 x 40</hint>
!             <answer>
!                 <option correct="yes">10.7 km</option>
!                 <option correct="no">2.5 km</option>
!                 <option correct="no">6.4 km</option>
!                 <option correct="no">38.4 km</option>
!             </answer>
!         </question>
!         <question type="multianswerchoice">
!             <text>Which of the following are features of a Virtual Learning Environment? (Select all that apply)</text>
!             <hint />
!             <answer>
!                 <option correct="yes" award="1" deduct="0">course resources are available from home and from college</option>
!                 <option correct="yes" award="1" deduct="0">forums enable collaborative work</option>
!                 <option correct="yes" award="1" deduct="0">assessments can give instant feedback</option>
!                 <option correct="yes" award="1" deduct="0">course progress is recorded</option>
!                 <option correct="no" award="1" deduct="0">kettle is put on automatically for tea/coffee</option>
!             </answer>
!         </question>
!         <question type="multianswerchoice">
!             <text>Which of the following may a Virtual Learning Environment be used for? (Select all that apply)</text>
!             <hint />
!             <answer>
!                 <option correct="yes" award="1" deduct="1">delivering a course online</option>
!                 <option correct="yes" award="1" deduct="1">supporting face-to-face teaching</option>
!                 <option correct="no" award="1" deduct="0">as a complete replacement for teachers</option>
!             </answer>
!         </question>
!     </questions>
  </activityset>
--- 1,184 ----
  <?xml version="1.0" ?>
  <activityset setno="2">
! 	<title>Maths</title>
! 	<questions>
! 		<question type="multiChoice">
! 			<text>The ages, in years, of 10 horses in a field were 3, 3, 4, 5, 7,
! 				7, 7, 8, 8, 8,&lt;p&gt;
! 				Which one of the following is true?</text>
! 			<award>1</award>
! 			<hint>mean = (3+3+4+5+7+7+7+8+8+8)/10 = 6&lt;p&gt;
! 				median = 7 i.e the middle number&lt;p&gt;
! 				range = 8-3 = 5</hint>
! 			<answer>
! 				<option correct="yes">median &gt; mean &gt; range</option>
! 				<option correct="no">mean = median</option>
! 				<option correct="no">mean &gt; median &gt; range</option>
! 				<option correct="no">median &gt; range &gt; mean</option>
! 			</answer>
! 		</question>
! 		<question type="multiChoice">
! 			<text>At a college, students are given a points score calculated from
! 				their GCSE grades.&lt;p&gt;
! 				Someone with 4 A grades and 4 B grades gains a score of 36
! 				points.&lt;br&gt;Someone with 2 A grades and 4 B grades gains a
! 				score of 26 points.&lt;br&gt;Someone with 3 A grades and 3 B grades
! 				would have a score of</text>
! 			<award>1</award>
! 			<hint>4A + 4B = 36 and 2A + 4B = 26&lt;p&gt;solving simultaneously
! 				gives A = 5 and B = 4</hint>
! 			<answer>
! 				<option correct="yes">27 points</option>
! 				<option correct="no">21 points</option>
! 				<option correct="no">30 points</option>
! 				<option correct="no">31 points</option>
! 			</answer>
! 		</question>
! 		<question type="multiChoice">
! 			<text>A sequence consists of adding the previous three terms together
! 				to form the next term. The first three terms of the sequence are 1,
! 				2, 3.&lt;p&gt;
! 				What is the sixth term in the sequence?</text>
! 			<award>1</award>
! 			<hint>1, 2, 3, 6, 11, ...</hint>
! 			<answer>
! 				<option correct="yes">20</option>
! 				<option correct="no">6</option>
! 				<option correct="no">11</option>
! 				<option correct="no">13</option>
! 			</answer>
! 		</question>
! 		<question type="multiChoice">
! 			<text>The value of an item is described as decreasing exponentially.
! 				Which description below best matches this statement?</text>
! 			<award>1</award>
! 			<hint>No hint - you either know this or you don't!</hint>
! 			<answer>
! 				<option correct="yes">The value falls by a smaller amount each
! 					year.</option>
! 				<option correct="no">The value falls by the same amount each year.</option>
! 				<option correct="no">The value falls by the same amount each year
! 					for a while, and then remains constant.</option>
! 				<option correct="no">The value falls by a larger amount each year.</option>
! 			</answer>
! 		</question>
! 		<question type="multiChoice">
! 			<text>Consider the statement&lt;p&gt;
! 				&quot;Schools with high numbers of pupils on free school meals do not do well in
! 				league tables.&quot;&lt;p&gt;
! 				Which of the following statements follows logically from the one above?</text>
! 			<award>1</award>
! 			<hint>Factors other than the number of pupils on free school meals
! 				affect how well a school does in league tables.</hint>
! 			<answer>
! 				<option correct="yes">Schools which do well in league tables do not
! 					have high numbers of pupils on free school meals.</option>
! 				<option correct="no">Schools with low numbers of pupils on free
! 					school meals do well in league tables.</option>
! 				<option correct="no">Making all pupils pay for school meals will
! 					improve league table results.</option>
! 				<option correct="no">Schools which do not do well in league tables
! 					have high numbers of pupils on free school meals.</option>
! 			</answer>
! 		</question>
! 		<question type="multiChoice">
! 			<text>The force between two point electric charges is inversely
! 				proportional to the square of their distance apart. What effect does
! 				doubling this distance have on the force?</text>
! 			<award>1</award>
! 			<hint>Inversely proportional means that increasing the distance
! 				decreases the force.&lt;br&gt;2 squared gives 4.</hint>
! 			<answer>
! 				<option correct="yes">The force decreases by a factor of four.</option>
! 				<option correct="no">The force is halved.</option>
! 				<option correct="no">The force is doubled.</option>
! 				<option correct="no">The force increases by a factor of four.</option>
! 			</answer>
! 		</question>
! 		<question type="multiChoice">
! 			<text>Two of the five playing cards that Colin has are aces. He
! 				shuffles the five cards, then puts them face down on the table.
! 				Madge takes a card and then another. The probability that she now
! 				has &lt;b&gt;both&lt;/b&gt; of the aces is</text>
! 			<award>1</award>
! 			<hint>2/5 x 1/4</hint>
! 			<answer>
! 				<option correct="yes">1/10</option>
! 				<option correct="no">4/25</option>
! 				<option correct="no">1/5</option>
! 				<option correct="no">2/5</option>
! 			</answer>
! 		</question>
! 		<question type="multiChoice">
! 			<text>A college's guidelines say that classes must have a minimum of
! 				12 students and a maximum of 20 students. For what numbers of
! 				students studying a particular subject is it impossible to run
! 				classes without breaking the guidelines?</text>
! 			<award>1</award>
! 			<hint>between 12 and 20 students - one class&lt;br&gt;
! 				between 24 and 36 students - two classes&lt;br&gt;
! 				between 36 and 40 students - two classes</hint>
! 			<answer>
! 				<option correct="yes">between 20 and 24 students</option>
! 				<option correct="no">between 12 and 20 students</option>
! 				<option correct="no">between 24 and 36 students</option>
! 				<option correct="no">between 36 and 40 students</option>
! 			</answer>
! 		</question>
! 		<question type="multiChoice">
! 			<text>The ages of two friends are in the ratio 3:4. In 8 years time
! 				their ages will be in the ratio 5:6. How old are they now?</text>
! 			<award>1</award>
! 			<hint>(12+8):(16+8) = 20:24 = 5:6</hint>
! 			<answer>
! 				<option correct="yes">12, 16</option>
! 				<option correct="no">3, 4</option>
! 				<option correct="no">6, 8</option>
! 				<option correct="no">9, 12</option>
! 			</answer>
! 		</question>
! 		<question type="multiChoice">
! 			<text>A heavy construction vehicle travels for 40 minutes between
! 				sites, at an average speed of 16 km per second. The distance between
! 				sites is</text>
! 			<award>1</award>
! 			<hint>16/60 x 40</hint>
! 			<answer>
! 				<option correct="yes">10.7 km</option>
! 				<option correct="no">2.5 km</option>
! 				<option correct="no">6.4 km</option>
! 				<option correct="no">38.4 km</option>
! 			</answer>
! 		</question>
! 		<question type="multianswerchoice">
! 			<text>Which of the following are features of a Virtual Learning
! 				Environment? (Select all that apply)</text>
! 			<hint />
! 			<answer>
! 				<option correct="yes" award="1" deduct="0">course resources are
! 					available from home and from college</option>
! 				<option correct="yes" award="1" deduct="0">forums enable
! 					collaborative work</option>
! 				<option correct="yes" award="1" deduct="0">assessments can give
! 					instant feedback</option>
! 				<option correct="yes" award="1" deduct="0">course progress is
! 					recorded</option>
! 				<option correct="no" award="1" deduct="0">kettle is put on
! 					automatically for tea/coffee</option>
! 			</answer>
! 		</question>
! 		<question type="multianswerchoice">
! 			<text>Which of the following may a Virtual Learning Environment be
! 				used for? (Select all that apply)</text>
! 			<hint />
! 			<answer>
! 				<option correct="yes" award="1" deduct="1">delivering a course
! 					online</option>
! 				<option correct="yes" award="1" deduct="1">supporting
! 					face-to-face teaching</option>
! 				<option correct="no" award="1" deduct="0">as a complete
! 					replacement for teachers</option>
! 			</answer>
! 		</question>
! 	</questions>
  </activityset>
diff -crB questionorg/format/missingword/format.php questionupd/format/missingword/format.php
*** questionorg/format/missingword/format.php	2012-04-13 12:31:11.066178248 +0500
--- questionupd/format/missingword/format.php	2012-04-13 09:42:52.000000000 +0500
***************
*** 31,157 ****
   */
  class qformat_missingword extends qformat_default {
  
!     function provide_import() {
!       return true;
!     }
! 
!     function readquestion($lines) {
!     /// Given an array of lines known to define a question in
!     /// this format, this function converts it into a question
!     /// object suitable for processing and insertion into Moodle.
! 
!         $question = $this->defaultquestion();
!         ///$comment added by T Robb
!         $comment = NULL;
!         $text = implode(" ", $lines);
! 
!         /// Find answer section
! 
!         $answerstart = strpos($text, "{");
!         if ($answerstart === false) {
!             if ($this->displayerrors) {
!                 echo "<p>$text<p>Could not find a {";
!             }
!             return false;
!         }
! 
!         $answerfinish = strpos($text, "}");
!         if ($answerfinish === false) {
!             if ($this->displayerrors) {
!                 echo "<p>$text<p>Could not find a }";
!             }
!             return false;
!         }
! 
!         $answerlength = $answerfinish - $answerstart;
!         $answertext = substr($text, $answerstart + 1, $answerlength - 1);
! 
!         /// Save the new question text
!         $question->questiontext = substr_replace($text, "_____", $answerstart, $answerlength+1);
!         $question->name = $question->questiontext;
! 
! 
!         /// Parse the answers
!         $answertext = str_replace("=", "~=", $answertext);
!         $answers = explode("~", $answertext);
!         if (isset($answers[0])) {
!             $answers[0] = trim($answers[0]);
!         }
!         if (empty($answers[0])) {
!             array_shift($answers);
!         }
! 
!         $countanswers = count($answers);
! 
!         switch ($countanswers) {
!             case 0:  // invalid question
!                 if ($this->displayerrors) {
!                     echo "<p>No answers found in $answertext";
!                 }
!                 return false;
! 
!             case 1:
!                 $question->qtype = SHORTANSWER;
! 
!                 $answer = trim($answers[0]);
!                 if ($answer[0] == "=") {
!                     $answer = substr($answer, 1);
!                 }
!                 $question->answer[]   = $answer;
!                 $question->fraction[] = 1;
!                 $question->feedback[] = "";
! 
!                 return $question;
! 
!             default:
!                 $question->qtype = MULTICHOICE;
! 
!                 foreach ($answers as $key => $answer) {
!                     $answer = trim($answer);
! 
!                     // Tom's addition starts here
!                     $answeight = 0;
!                     if (strspn($answer,"1234567890%") > 0){
!                         //Make sure that the percent sign is the last in the span
!                         if (strpos($answer,"%") == strspn($answer,"1234567890%") - 1) {
!                             $answeight0 = substr($answer,0,strspn($answer,"1234567890%"));
!                             $answeight = round(($answeight0/100),2);
!                             $answer = substr($answer,(strspn($answer,"1234567890%")));
!                         }
!                     }
!                     if ($answer[0] == "="){
!                         $answeight = 1;
!                     }
!                     //remove the protective underscore for leading numbers in answers
!                     if ($answer[0] == "_"){
!                         $answer = substr($answer, 1);
!                     }
!                     $answer = trim($answer);
! 
!                     if (strpos($answer,"#") > 0){
!                         $hashpos = strpos($answer,"#");
!                         $comment = substr(($answer),$hashpos+1);
!                         $answer  = substr($answer,0,$hashpos);
!                     } else {
!                         $comment = " ";
!                     }
!                     // End of Tom's addition
! 
!                     if ($answer[0] == "=") {
! #                       $question->fraction[$key] = 1;
!                         $question->fraction[$key] = $answeight;
!                         $answer = substr($answer, 1);
!                     } else {
! #                       $question->fraction[$key] = 0;
!                         $question->fraction[$key] = $answeight;
!                     }
!                     $question->answer[$key]   = $answer;
!                     $question->feedback[$key] = $comment;
!                 }
! 
!                 return $question;
!         }
!     }
  }
  
  
--- 31,157 ----
   */
  class qformat_missingword extends qformat_default {
  
! 	function provide_import() {
! 		return true;
! 	}
! 
! 	function readquestion($lines) {
! 		/// Given an array of lines known to define a question in
! 		/// this format, this function converts it into a question
! 		/// object suitable for processing and insertion into Moodle.
! 
! 		$question = $this->defaultquestion();
! 		///$comment added by T Robb
! 		$comment = NULL;
! 		$text = implode(" ", $lines);
! 
! 		/// Find answer section
! 
! 		$answerstart = strpos($text, "{");
! 		if ($answerstart === false) {
! 			if ($this->displayerrors) {
! 				echo "<p>$text<p>Could not find a {";
! 			}
! 			return false;
! 		}
! 
! 		$answerfinish = strpos($text, "}");
! 		if ($answerfinish === false) {
! 			if ($this->displayerrors) {
! 				echo "<p>$text<p>Could not find a }";
! 			}
! 			return false;
! 		}
! 
! 		$answerlength = $answerfinish - $answerstart;
! 		$answertext = substr($text, $answerstart + 1, $answerlength - 1);
! 
! 		/// Save the new question text
! 		$question->questiontext = substr_replace($text, "_____", $answerstart, $answerlength+1);
! 		$question->name = $question->questiontext;
! 
! 
! 		/// Parse the answers
! 		$answertext = str_replace("=", "~=", $answertext);
! 		$answers = explode("~", $answertext);
! 		if (isset($answers[0])) {
! 			$answers[0] = trim($answers[0]);
! 		}
! 		if (empty($answers[0])) {
! 			array_shift($answers);
! 		}
! 
! 		$countanswers = count($answers);
! 
! 		switch ($countanswers) {
! 			case 0:  // invalid question
! 				if ($this->displayerrors) {
! 					echo "<p>No answers found in $answertext";
! 				}
! 				return false;
! 
! 			case 1:
! 				$question->qtype = SHORTANSWER;
! 
! 				$answer = trim($answers[0]);
! 				if ($answer[0] == "=") {
! 					$answer = substr($answer, 1);
! 				}
! 				$question->answer[]   = $answer;
! 				$question->fraction[] = 1;
! 				$question->feedback[] = "";
! 
! 				return $question;
! 
! 			default:
! 				$question->qtype = MULTICHOICE;
! 
! 				foreach ($answers as $key => $answer) {
! 					$answer = trim($answer);
! 
! 					// Tom's addition starts here
! 					$answeight = 0;
! 					if (strspn($answer,"1234567890%") > 0){
! 						//Make sure that the percent sign is the last in the span
! 						if (strpos($answer,"%") == strspn($answer,"1234567890%") - 1) {
! 							$answeight0 = substr($answer,0,strspn($answer,"1234567890%"));
! 							$answeight = round(($answeight0/100),2);
! 							$answer = substr($answer,(strspn($answer,"1234567890%")));
! 						}
! 					}
! 					if ($answer[0] == "="){
! 						$answeight = 1;
! 					}
! 					//remove the protective underscore for leading numbers in answers
! 					if ($answer[0] == "_"){
! 						$answer = substr($answer, 1);
! 					}
! 					$answer = trim($answer);
! 
! 					if (strpos($answer,"#") > 0){
! 						$hashpos = strpos($answer,"#");
! 						$comment = substr(($answer),$hashpos+1);
! 						$answer  = substr($answer,0,$hashpos);
! 					} else {
! 						$comment = " ";
! 					}
! 					// End of Tom's addition
! 
! 					if ($answer[0] == "=") {
! 						#                       $question->fraction[$key] = 1;
! 						$question->fraction[$key] = $answeight;
! 						$answer = substr($answer, 1);
! 					} else {
! 						#                       $question->fraction[$key] = 0;
! 						$question->fraction[$key] = $answeight;
! 					}
! 					$question->answer[$key]   = $answer;
! 					$question->feedback[$key] = $comment;
! 				}
! 
! 				return $question;
! 		}
! 	}
  }
  
  
diff -crB questionorg/format/multianswer/format.php questionupd/format/multianswer/format.php
*** questionorg/format/multianswer/format.php	2012-04-13 12:31:10.837178247 +0500
--- questionupd/format/multianswer/format.php	2012-04-13 09:42:52.000000000 +0500
***************
*** 34,77 ****
   */
  class qformat_multianswer extends qformat_default {
  
!     function provide_import() {
!       return true;
!     }
! 
!     function readquestions($lines) {
!         // For this class the method has been simplified as
!         // there can never be more than one question for a
!         // multianswer import
!         $questions = array();
! 
!         $questiontext = array();
!         $questiontext['text'] = implode('', $lines);
!         $questiontext['format'] = 0 ;
!         $questiontext['itemid'] = ''; 
!         $question = qtype_multianswer_extract_question($questiontext);
!         $question->questiontext = $question->questiontext['text'] ;
!         $question->questiontextformat = 0 ;
! 
!         $question->qtype = MULTIANSWER;
!         $question->generalfeedback = '';
!         $question->course = $this->course;
! 
!         if (!empty($question)) {
!             $name = html_to_text(implode(' ', $lines));
!             $name = preg_replace('/{[^}]*}/', '', $name);
!             $name = trim($name);
! 
!             if ($name) {
!                 $question->name = shorten_text($name, 45);
!             } else {
!                 // We need some name, so use the current time, since that will be
!                 // reasonably unique.
!                 $question->name = userdate(time());
!             }
  
!             $questions[] = $question;
!         }
  
!         return $questions;
!     }
  }
--- 34,77 ----
   */
  class qformat_multianswer extends qformat_default {
  
! 	function provide_import() {
! 		return true;
! 	}
! 
! 	function readquestions($lines) {
! 		// For this class the method has been simplified as
! 		// there can never be more than one question for a
! 		// multianswer import
! 		$questions = array();
! 
! 		$questiontext = array();
! 		$questiontext['text'] = implode('', $lines);
! 		$questiontext['format'] = 0 ;
! 		$questiontext['itemid'] = '';
! 		$question = qtype_multianswer_extract_question($questiontext);
! 		$question->questiontext = $question->questiontext['text'] ;
! 		$question->questiontextformat = 0 ;
! 
! 		$question->qtype = MULTIANSWER;
! 		$question->generalfeedback = '';
! 		$question->course = $this->course;
! 
! 		if (!empty($question)) {
! 			$name = html_to_text(implode(' ', $lines));
! 			$name = preg_replace('/{[^}]*}/', '', $name);
! 			$name = trim($name);
! 
! 			if ($name) {
! 				$question->name = shorten_text($name, 45);
! 			} else {
! 				// We need some name, so use the current time, since that will be
! 				// reasonably unique.
! 				$question->name = userdate(time());
! 			}
  
! 			$questions[] = $question;
! 		}
  
! 		return $questions;
! 	}
  }
diff -crB questionorg/format/qti_two/custommediafilter.php questionupd/format/qti_two/custommediafilter.php
*** questionorg/format/qti_two/custommediafilter.php	2012-04-13 12:31:11.383178255 +0500
--- questionupd/format/qti_two/custommediafilter.php	2012-04-13 09:42:52.000000000 +0500
***************
*** 8,44 ****
   * @subpackage importexport
   */
  function custom_mediaplugin_filter($text, $width = null, $height = null) {
!     global $CFG;
!     if (is_null($width) || $width == 0) {
!         $usedefaults = true;
!         $width = 400;
!         $height = 300;
!     } else {
!         $usedefaults = false;
!     }
! 
!     if (empty($CFG->filter_mediaplugin_ignore_mp3)) {
!         $search = '/<a(.*?)href=\"([^<]+)\.mp3\"([^>]*)>(.*?)<\/a>/i';
! 
!         $replace  = '\\0&nbsp;<object classid="clsid:D27CDB6E-AE6D-11cf-96B8-444553540000"';
!         $replace .= ' codebase="http://download.macromedia.com/pub/shockwave/cabs/flash/swflash.cab#version=6,0,0,0" ';
!         $replace .= ' width="35" height="18" id="mp3player" align="">';
!         $replace .= " <param name=movie value=\"$CFG->wwwroot/filter/mediaplugin/mp3player.swf?src=\\2.mp3\">";
!         $replace .= ' <param name=quality value=high>';
!         $replace .= ' <param name=bgcolor value="#333333">';
!         $replace .= " <embed src=\"$CFG->wwwroot/filter/mediaplugin/mp3player.swf?src=\\2.mp3\" ";
!         $replace .= "  quality=high bgcolor=\"#333333\" width=\"35\" height=\"18\" name=\"mp3player\" ";
!         $replace .= ' type="application/x-shockwave-flash" ';
!         $replace .= ' pluginspage="http://www.macromedia.com/go/getflashplayer">';
!         $replace .= '</embed>';
!         $replace .= '</object>&nbsp;';
! 
!         $text = preg_replace($search, $replace, $text);
!     }
! 
!     if (empty($CFG->filter_mediaplugin_ignore_swf)) {
!         $search = '/<a(.*?)href=\"([^<]+)\.swf\"([^>]*)>(.*?)<\/a>/i';
!         $replace  = '\\0<object '.
                              'type="application/x-shockwave-flash" ' .
                              'data="\\2.swf" ' .
                              'width="' . $width . '" ' .
--- 8,44 ----
   * @subpackage importexport
   */
  function custom_mediaplugin_filter($text, $width = null, $height = null) {
! 	global $CFG;
! 	if (is_null($width) || $width == 0) {
! 		$usedefaults = true;
! 		$width = 400;
! 		$height = 300;
! 	} else {
! 		$usedefaults = false;
! 	}
! 
! 	if (empty($CFG->filter_mediaplugin_ignore_mp3)) {
! 		$search = '/<a(.*?)href=\"([^<]+)\.mp3\"([^>]*)>(.*?)<\/a>/i';
! 
! 		$replace  = '\\0&nbsp;<object classid="clsid:D27CDB6E-AE6D-11cf-96B8-444553540000"';
! 		$replace .= ' codebase="http://download.macromedia.com/pub/shockwave/cabs/flash/swflash.cab#version=6,0,0,0" ';
! 		$replace .= ' width="35" height="18" id="mp3player" align="">';
! 		$replace .= " <param name=movie value=\"$CFG->wwwroot/filter/mediaplugin/mp3player.swf?src=\\2.mp3\">";
! 		$replace .= ' <param name=quality value=high>';
! 		$replace .= ' <param name=bgcolor value="#333333">';
! 		$replace .= " <embed src=\"$CFG->wwwroot/filter/mediaplugin/mp3player.swf?src=\\2.mp3\" ";
! 		$replace .= "  quality=high bgcolor=\"#333333\" width=\"35\" height=\"18\" name=\"mp3player\" ";
! 		$replace .= ' type="application/x-shockwave-flash" ';
! 		$replace .= ' pluginspage="http://www.macromedia.com/go/getflashplayer">';
! 		$replace .= '</embed>';
! 		$replace .= '</object>&nbsp;';
! 
! 		$text = preg_replace($search, $replace, $text);
! 	}
! 
! 	if (empty($CFG->filter_mediaplugin_ignore_swf)) {
! 		$search = '/<a(.*?)href=\"([^<]+)\.swf\"([^>]*)>(.*?)<\/a>/i';
! 		$replace  = '\\0<object '.
                              'type="application/x-shockwave-flash" ' .
                              'data="\\2.swf" ' .
                              'width="' . $width . '" ' .
***************
*** 48,148 ****
                          '</object>';
  
  
! /*        $replace  = '\\0<p class="mediaplugin"><object classid="clsid:D27CDB6E-AE6D-11cf-96B8-444553540000"';
!         $replace .= ' codebase="http://download.macromedia.com/pub/shockwave/cabs/flash/swflash.cab#version=6,0,0,0" ';
!         $replace .= ' width="' . $width . '" height="' . $height . '" id="mp3player" align="">';
!         $replace .= " <param name=movie value=\"\\2.swf\">";
!         $replace .= ' <param name=quality value=high>';
!         $replace .= " <embed src=\"\\2.swf\" ";
!         $replace .= "  quality=high width=\"$width\" height=\"$height\" name=\"flashfilter\" ";
!         $replace .= ' type="application/x-shockwave-flash" ';
!         $replace .= ' pluginspage="http://www.macromedia.com/go/getflashplayer">';
!         $replace .= '</embed>';
!         $replace .= '</object></p>';*/
! 
!         $text = preg_replace($search, $replace, $text);
!     }
! 
!     if (empty($CFG->filter_mediaplugin_ignore_mov)) {
!         $search = '/<a(.*?)href=\"([^<]+)\.mov\"([^>]*)>(.*?)<\/a>/i';
! 
!         $replace  = '\\0<p class="mediaplugin"><object classid="CLSID:02BF25D5-8C17-4B23-BC80-D3488ABDDC6B"';
!         $replace .= '        codebase="http://www.apple.com/qtactivex/qtplugin.cab" ';
!         $replace .= '        height="' . $height . '" width="' . $width . '"';
!         $replace .= '        id="quicktime" align="" type="application/x-oleobject">';
!         $replace .= "<param name=\"src\" value=\"\\2.mov\" />";
!         $replace .= '<param name="autoplay" value=false />';
!         $replace .= '<param name="loop" value=true />';
!         $replace .= '<param name="controller" value=true />';
!         $replace .= '<param name="scale" value="aspect" />';
!         $replace .= "\n<embed src=\"\\2.mov\" name=\"quicktime\" type=\"video/quicktime\" ";
!         $replace .= ' height="' . $height . '" width="' . $width . '" scale="aspect" ';
!         $replace .= ' autoplay="false" controller="true" loop="true" ';
!         $replace .= ' pluginspage="http://quicktime.apple.com/">';
!         $replace .= '</embed>';
!         $replace .= '</object>&nbsp;';
! 
!         $text = preg_replace($search, $replace, $text);
!     }
! 
!     if (empty($CFG->filter_mediaplugin_ignore_wmv)) {
!         $search = '/<a(.*?)href=\"([^<]+)\.wmv\"([^>]*)>(.*?)<\/a>/i';
! 
!         $replace  = '\\0<p class="mediaplugin"><object classid="CLSID:22D6f312-B0F6-11D0-94AB-0080C74C7E95"';
!         $replace .= ' codebase="http://activex.microsoft.com/activex/controls/mplayer/en/nsmp2inf.cab#Version=5,1,52,701" ';
!         $replace .= ' standby="Loading Microsoft? Windows? Media Player components..." ';
!         $replace .= ' id="msplayer" align="" type="application/x-oleobject">';
!         $replace .= "<param name=\"Filename\" value=\"\\2.wmv\">";
!         $replace .= '<param name="ShowControls" value=true />';
!         $replace .= '<param name="AutoRewind" value=true />';
!         $replace .= '<param name="AutoStart" value=false />';
!         $replace .= '<param name="Autosize" value=true />';
!         $replace .= '<param name="EnableContextMenu" value=true />';
!         $replace .= '<param name="TransparentAtStart" value=false />';
!         $replace .= '<param name="AnimationAtStart" value=false />';
!         $replace .= '<param name="ShowGotoBar" value=false />';
!         $replace .= '<param name="EnableFullScreenControls" value=true />';
!         $replace .= "\n<embed src=\"\\2.wmv\" name=\"msplayer\" type=\"video/x-ms\" ";
!         $replace .= ' ShowControls="1" AutoRewind="1" AutoStart="0" Autosize="0" EnableContextMenu="1"';
!         $replace .= ' TransparentAtStart="0" AnimationAtStart="0" ShowGotoBar="0" EnableFullScreenControls="1"';
!         $replace .= ' pluginspage="http://www.microsoft.com/Windows/Downloads/Contents/Products/MediaPlayer/">';
!         $replace .= '</embed>';
!         $replace .= '</object>&nbsp;';
! 
!         $text = preg_replace($search, $replace, $text);
!     }
! 
!     if ($usedefaults) {
!         $width = 240;
!         $height = 180;
!     }
! 
!     if (empty($CFG->filter_mediaplugin_ignore_mpg)) {
!         $search = '/<a(.*?)href=\"([^<]+)\.(mpe?g)\"([^>]*)>(.*?)<\/a>/i';
! 
!         $replace = '\\0<p class="mediaplugin"><object width="' . $width . '" height="' . $height . '">';
!         $replace .= '<param name="src" value="\\2.\\3">';
!         $replace .= '<param name="controller" value="true">';
!         $replace .= '<param name="autoplay" value="false">';
!         $replace .= '<embed src="\\2.\\3" width="' . $width . '" height="' . $height . '" controller="true" autoplay="false"> </embed>';
!         $replace .= '</object></p>';
! 
!         $text = preg_replace($search, $replace, $text);
!     }
! 
!     if (empty($CFG->filter_mediaplugin_ignore_avi)) {
!         $search = '/<a(.*?)href=\"([^<]+)\.avi\"([^>]*)>(.*?)<\/a>/i';
! 
!         $replace = '\\0<p class="mediaplugin"><object width="' . $width . '" height="' . $height . '">';
!         $replace .= '<param name="src" value="\\2.avi">';
!         $replace .= '<param name="controller" value="true">';
!         $replace .= '<param name="autoplay" value="false">';
!         $replace .= '<embed src="\\2.avi" width="' . $width . '" height="' . $height . '" controller="true" autoplay="false"> </embed>';
!         $replace .= '</object>&nbsp;';
! 
!         $text = preg_replace($search, $replace, $text);
!     }
!     return $text;
  }
  
  
--- 48,148 ----
                          '</object>';
  
  
! 		/*        $replace  = '\\0<p class="mediaplugin"><object classid="clsid:D27CDB6E-AE6D-11cf-96B8-444553540000"';
! 		 $replace .= ' codebase="http://download.macromedia.com/pub/shockwave/cabs/flash/swflash.cab#version=6,0,0,0" ';
! 		 $replace .= ' width="' . $width . '" height="' . $height . '" id="mp3player" align="">';
! 		 $replace .= " <param name=movie value=\"\\2.swf\">";
! 		 $replace .= ' <param name=quality value=high>';
! 		 $replace .= " <embed src=\"\\2.swf\" ";
! 		 $replace .= "  quality=high width=\"$width\" height=\"$height\" name=\"flashfilter\" ";
! 		 $replace .= ' type="application/x-shockwave-flash" ';
! 		 $replace .= ' pluginspage="http://www.macromedia.com/go/getflashplayer">';
! 		 $replace .= '</embed>';
! 		 $replace .= '</object></p>';*/
! 
! 		$text = preg_replace($search, $replace, $text);
! 	}
! 
! 	if (empty($CFG->filter_mediaplugin_ignore_mov)) {
! 		$search = '/<a(.*?)href=\"([^<]+)\.mov\"([^>]*)>(.*?)<\/a>/i';
! 
! 		$replace  = '\\0<p class="mediaplugin"><object classid="CLSID:02BF25D5-8C17-4B23-BC80-D3488ABDDC6B"';
! 		$replace .= '        codebase="http://www.apple.com/qtactivex/qtplugin.cab" ';
! 		$replace .= '        height="' . $height . '" width="' . $width . '"';
! 		$replace .= '        id="quicktime" align="" type="application/x-oleobject">';
! 		$replace .= "<param name=\"src\" value=\"\\2.mov\" />";
! 		$replace .= '<param name="autoplay" value=false />';
! 		$replace .= '<param name="loop" value=true />';
! 		$replace .= '<param name="controller" value=true />';
! 		$replace .= '<param name="scale" value="aspect" />';
! 		$replace .= "\n<embed src=\"\\2.mov\" name=\"quicktime\" type=\"video/quicktime\" ";
! 		$replace .= ' height="' . $height . '" width="' . $width . '" scale="aspect" ';
! 		$replace .= ' autoplay="false" controller="true" loop="true" ';
! 		$replace .= ' pluginspage="http://quicktime.apple.com/">';
! 		$replace .= '</embed>';
! 		$replace .= '</object>&nbsp;';
! 
! 		$text = preg_replace($search, $replace, $text);
! 	}
! 
! 	if (empty($CFG->filter_mediaplugin_ignore_wmv)) {
! 		$search = '/<a(.*?)href=\"([^<]+)\.wmv\"([^>]*)>(.*?)<\/a>/i';
! 
! 		$replace  = '\\0<p class="mediaplugin"><object classid="CLSID:22D6f312-B0F6-11D0-94AB-0080C74C7E95"';
! 		$replace .= ' codebase="http://activex.microsoft.com/activex/controls/mplayer/en/nsmp2inf.cab#Version=5,1,52,701" ';
! 		$replace .= ' standby="Loading Microsoft? Windows? Media Player components..." ';
! 		$replace .= ' id="msplayer" align="" type="application/x-oleobject">';
! 		$replace .= "<param name=\"Filename\" value=\"\\2.wmv\">";
! 		$replace .= '<param name="ShowControls" value=true />';
! 		$replace .= '<param name="AutoRewind" value=true />';
! 		$replace .= '<param name="AutoStart" value=false />';
! 		$replace .= '<param name="Autosize" value=true />';
! 		$replace .= '<param name="EnableContextMenu" value=true />';
! 		$replace .= '<param name="TransparentAtStart" value=false />';
! 		$replace .= '<param name="AnimationAtStart" value=false />';
! 		$replace .= '<param name="ShowGotoBar" value=false />';
! 		$replace .= '<param name="EnableFullScreenControls" value=true />';
! 		$replace .= "\n<embed src=\"\\2.wmv\" name=\"msplayer\" type=\"video/x-ms\" ";
! 		$replace .= ' ShowControls="1" AutoRewind="1" AutoStart="0" Autosize="0" EnableContextMenu="1"';
! 		$replace .= ' TransparentAtStart="0" AnimationAtStart="0" ShowGotoBar="0" EnableFullScreenControls="1"';
! 		$replace .= ' pluginspage="http://www.microsoft.com/Windows/Downloads/Contents/Products/MediaPlayer/">';
! 		$replace .= '</embed>';
! 		$replace .= '</object>&nbsp;';
! 
! 		$text = preg_replace($search, $replace, $text);
! 	}
! 
! 	if ($usedefaults) {
! 		$width = 240;
! 		$height = 180;
! 	}
! 
! 	if (empty($CFG->filter_mediaplugin_ignore_mpg)) {
! 		$search = '/<a(.*?)href=\"([^<]+)\.(mpe?g)\"([^>]*)>(.*?)<\/a>/i';
! 
! 		$replace = '\\0<p class="mediaplugin"><object width="' . $width . '" height="' . $height . '">';
! 		$replace .= '<param name="src" value="\\2.\\3">';
! 		$replace .= '<param name="controller" value="true">';
! 		$replace .= '<param name="autoplay" value="false">';
! 		$replace .= '<embed src="\\2.\\3" width="' . $width . '" height="' . $height . '" controller="true" autoplay="false"> </embed>';
! 		$replace .= '</object></p>';
! 
! 		$text = preg_replace($search, $replace, $text);
! 	}
! 
! 	if (empty($CFG->filter_mediaplugin_ignore_avi)) {
! 		$search = '/<a(.*?)href=\"([^<]+)\.avi\"([^>]*)>(.*?)<\/a>/i';
! 
! 		$replace = '\\0<p class="mediaplugin"><object width="' . $width . '" height="' . $height . '">';
! 		$replace .= '<param name="src" value="\\2.avi">';
! 		$replace .= '<param name="controller" value="true">';
! 		$replace .= '<param name="autoplay" value="false">';
! 		$replace .= '<embed src="\\2.avi" width="' . $width . '" height="' . $height . '" controller="true" autoplay="false"> </embed>';
! 		$replace .= '</object>&nbsp;';
! 
! 		$text = preg_replace($search, $replace, $text);
! 	}
! 	return $text;
  }
  
  
diff -crB questionorg/format/qti_two/format.php questionupd/format/qti_two/format.php
*** questionorg/format/qti_two/format.php	2012-04-13 12:31:11.338178254 +0500
--- questionupd/format/qti_two/format.php	2012-04-13 09:42:53.000000000 +0500
***************
*** 16,919 ****
  
  class qformat_qti_two extends qformat_default {
  
!     var $lang;
  
!     function provide_export() {
!        return true;
!     }
! 
!     function indent_xhtml($source, $indenter = ' ') {
!         // xml tidier-upper
!         // (c) Ari Koivula http://ventionline.com
! 
!         // Remove all pre-existing formatting.
!         // Remove all newlines.
!         $source = str_replace("\n", '', $source);
!         $source = str_replace("\r", '', $source);
!         // Remove all tabs.
!         $source = str_replace("\t", '', $source);
!         // Remove all space after ">" and before "<".
!         $source = preg_replace("/>( )*", ">/", $source);
!         $source = preg_replace("/( )*<", "</", $source);
! 
!         // Iterate through the source.
!         $level = 0;
!         $source_len = strlen($source);
!         $pt = 0;
!         while ($pt < $source_len) {
!             if ($source{$pt} === '<') {
!                 // We have entered a tag.
!                 // Remember the point where the tag starts.
!                 $started_at = $pt;
!                 $tag_level = 1;
!                 // If the second letter of the tag is "/", assume its an ending tag.
!                 if ($source{$pt+1} === '/') {
!                     $tag_level = -1;
!                 }
!                 // If the second letter of the tag is "!", assume its an "invisible" tag.
!                 if ($source{$pt+1} === '!') {
!                     $tag_level = 0;
!                 }
!                 // Iterate throught the source until the end of tag.
!                 while ($source{$pt} !== '>') {
!                     $pt++;
!                 }
!                 // If the second last letter is "/", assume its a self ending tag.
!                 if ($source{$pt-1} === '/') {
!                     $tag_level = 0;
!                 }
!                 $tag_lenght = $pt+1-$started_at;
! 
!                 // Decide the level of indention for this tag.
!                 // If this was an ending tag, decrease indent level for this tag..
!                 if ($tag_level === -1) {
!                     $level--;
!                 }
!                 // Place the tag in an array with proper indention.
!                 $array[] = str_repeat($indenter, $level).substr($source, $started_at, $tag_lenght);
!                 // If this was a starting tag, increase the indent level after this tag.
!                 if ($tag_level === 1) {
!                     $level++;
!                 }
!                 // if it was a self closing tag, dont do shit.
!             }
!             // Were out of the tag.
!             // If next letter exists...
!             if (($pt+1) < $source_len) {
!                 // ... and its not an "<".
!                 if ($source{$pt+1} !== '<') {
!                     $started_at = $pt+1;
!                     // Iterate through the source until the start of new tag or until we reach the end of file.
!                     while ($source{$pt} !== '<' && $pt < $source_len) {
!                         $pt++;
!                     }
!                     // If we found a "<" (we didnt find the end of file)
!                     if ($source{$pt} === '<') {
!                         $tag_lenght = $pt-$started_at;
!                         // Place the stuff in an array with proper indention.
!                         $array[] = str_repeat($indenter, $level).substr($source, $started_at, $tag_lenght);
!                     }
!                 // If the next tag is "<", just advance pointer and let the tag indenter take care of it.
!                 } else {
!                     $pt++;
!                 }
!             // If the next letter doesnt exist... Were done... well, almost..
!             } else {
!                 break;
!             }
!         }
!         // Replace old source with the new one we just collected into our array.
!         $source = implode($array, "\n");
!         return $source;
!     }
! 
!     function importpreprocess() {
!         global $CFG;
! 
!         print_error('cannotimportformat', 'question', "$CFG->wwwroot/mod/quiz/import.php?category=$category->id");
!     }
! 
!     function exportpreprocess() {
!         global $CFG;
! 
!         require_once("{$CFG->libdir}/smarty/Smarty.class.php");
! 
!         // assign the language for the export: by parameter, SESSION, USER, or the default of 'en'
!         $lang = current_language();
!         $this->lang = $lang;
! 
!         return parent::exportpreprocess();
!     }
! 
! 
!     function export_file_extension() {
!         // override default type so extension is .xml
! 
!         return ".zip";
!     }
! 
!     function get_qtype( $type_id ) {
!         // translates question type code number into actual name
! 
!         switch( $type_id ) {
!         case TRUEFALSE:
!             $name = 'truefalse';
!             break;
!         case MULTICHOICE:
!             $name = 'multichoice';
!             break;
!         case SHORTANSWER:
!             $name = 'shortanswer';
!             break;
!         case NUMERICAL:
!             $name = 'numerical';
!             break;
!         case MATCH:
!             $name = 'matching';
!             break;
!         case DESCRIPTION:
!             $name = 'description';
!             break;
!         case MULTIANSWER:
!             $name = 'multianswer';
!             break;
!         default:
!             $name = 'Unknown';
!         }
!         return $name;
!     }
! 
!     function writetext( $raw ) {
!         // generates <text></text> tags, processing raw text therein
! 
!         // for now, don't allow any additional tags in text
!         // otherwise xml rules would probably get broken
!         $raw = strip_tags( $raw );
! 
!         return "<text>$raw</text>\n";
!     }
! 
! 
! /**
!  * flattens $object['media'], copies $object['media'] to $path, and sets $object['mediamimetype']
!  *
!  * @param array &$object containing a field 'media'
!  * @param string $path the full path name to where the media files need to be copied
!  * @param int $courseid
!  * @return: mixed - true on success or in case of an empty media field, an error string if the file copy fails
!  */
! function copy_and_flatten(&$object, $path, $courseid) {
!     global $CFG;
!     if (!empty($object['media'])) {
!         $location = $object['media'];
!         $object['media'] = $this->flatten_image_name($location);
!         if (!@copy("{$CFG->dataroot}/$courseid/$location", "$path/{$object['media']}")) {
!             return "Failed to copy {$CFG->dataroot}/$courseid/$location to $path/{$object['media']}";
!         }
!         if (empty($object['mediamimetype'])) {
!             $object['mediamimetype'] = mimeinfo('type', $object['media']);
!         }
!     }
!     return true;
! }
! /**
!  * copies all files needed by the questions to the given $path, and flattens the file names
!  *
!  * @param array $questions the question objects
!  * @param string $path the full path name to where the media files need to be copied
!  * @param int $courseid
!  * @return mixed true on success, an array of error messages otherwise
!  */
! function handle_questions_media(&$questions, $path, $courseid) {
!     global $CFG;
!     $errors = array();
!     foreach ($questions as $key=>$question) {
! 
!     // todo: handle in-line media (specified in the question text)
!         if (!empty($question->image)) {
!             $location = $questions[$key]->image;
!             $questions[$key]->mediaurl = $this->flatten_image_name($location);
!             if (!@copy("{$CFG->dataroot}/$courseid/$location", "$path/{$questions[$key]->mediaurl}")) {
!                 $errors[] = "Failed to copy {$CFG->dataroot}/$courseid/$location to $path/{$questions[$key]->mediaurl}";
!             }
!             if (empty($question->mediamimetype)) {
!                 $questions[$key]->mediamimetype = mimeinfo('type', $question->image);
!             }
!         }
!     }
! 
!     return empty($errors) ? true : $errors;
! }
! 
! /**
!  * exports the questions in a question category to the given location
!  *
!  * The parent class method was overridden because the IMS export consists of multiple files
!  *
!  * @param string $filename the directory name which will hold the exported files
!  * @return boolean - or errors out
!  */
!     function exportprocess() {
! 
!         global $CFG, $OUTPUT;
!         $courseid = $this->course->id;
! 
!         // create a directory for the exports (if not already existing)
!         if (!$export_dir = make_upload_directory($this->question_get_export_dir().'/'.$this->filename)) {
!               print_error('cannotcreatepath', 'quiz', '', $export_dir);
!         }
!         $path = $CFG->dataroot.'/'.$this->question_get_export_dir().'/'.$this->filename;
! 
!         // get the questions (from database) in this category
!         $questions = get_questions_category( $this->category );
! 
!         echo $OUTPUT->notification("Exporting ".count($questions)." questions.");
!         $count = 0;
! 
!         // create the imsmanifest file
!         $smarty =& $this->init_smarty();
!         $this->add_qti_info($questions);
!         // copy files used by the main questions to the export directory
!         $result = $this->handle_questions_media($questions, $path, $courseid);
!         if ($result !== true) {
!             echo $OUTPUT->notification(implode("<br />", $result));
!         }
! 
!         $manifestquestions = $this->objects_to_array($questions);
!         $manifestid = str_replace(array(':', '/'), array('-','_'), "question_category_{$this->category->id}---{$CFG->wwwroot}");
!         $smarty->assign('externalfiles', 1);
!         $smarty->assign('manifestidentifier', $manifestid);
!         $smarty->assign('quiztitle', "question_category_{$this->category->id}");
!         $smarty->assign('quizinfo', "All questions in category {$this->category->id}");
!         $smarty->assign('questions', $manifestquestions);
!         $smarty->assign('lang', $this->lang);
!         $smarty->error_reporting = 99;
!         $expout = $smarty->fetch('imsmanifest.tpl');
!         $filepath = $path.'/imsmanifest.xml';
!         if (empty($expout)) {
!             print_error('emptyxml', 'question');
!         }
!         if (!$fh=fopen($filepath,"w")) {
!             print_error('cannotopenforwriting', 'question', '', $filepath);
!         }
!         if (!fwrite($fh, $expout)) {
!             print_error('cannotwriteto', 'question', '', $filepath);
!         }
!         fclose($fh);
! 
!         // iterate through questions
!         foreach($questions as $question) {
! 
!             // results are first written into string (and then to a file)
!             $count++;
!             echo "<hr /><p><b>$count</b>. ".$question->questiontext."</p>";
!             $expout = $this->writequestion( $question , null, true, $path) . "\n";
!             $expout = $this->presave_process( $expout );
! 
!             $filepath = $path.'/'.$this->get_assesment_item_id($question) . ".xml";
!             if (!$fh=fopen($filepath,"w")) {
!                 print_error('cannotopenforwriting', 'question', '', $filepath);
!             }
!             if (!fwrite($fh, $expout)) {
!                 print_error('cannotwriteto', 'question', '', $filepath);
!             }
!             fclose($fh);
! 
!         }
! 
!         // zip files into single export file
!         zip_files( array($path), "$path.zip" );
! 
!         // remove the temporary directory
!         remove_dir( $path );
! 
!         return true;
!     }
! 
! /**
!  * exports a quiz (as opposed to exporting a category of questions)
!  *
!  * The parent class method was overridden because the IMS export consists of multiple files
!  *
!  * @param object $quiz
!  * @param array $questions - an array of question objects
!  * @param object $result - if set, contains result of calling quiz_grade_responses()
!  * @param string $redirect - a URL to redirect to in case of failure
!  * @param string $submiturl - the URL for the qti player to send the results to (e.g. attempt.php)
!  * @todo use $result in the ouput
!  */
!      function export_quiz($course, $quiz, $questions, $result, $redirect, $submiturl = null) {
!         $this->xml_entitize($course);
!         $this->xml_entitize($quiz);
!         $this->xml_entitize($questions);
!         $this->xml_entitize($result);
!         $this->xml_entitize($submiturl);
!         if (! $this->exportpreprocess(0, $course)) {   // Do anything before that we need to
!             print_error('errorpreprocess', 'question', $redirect);
!         }
!         if (! $this->exportprocess_quiz($quiz, $questions, $result, $submiturl, $course)) {         // Process the export data
!             print_error('errorprocess','question', $redirect);
!         }
!         if (! $this->exportpostprocess()) {                    // In case anything needs to be done after
!             print_error('errorpostprocess', 'question', $redirect);
!         }
! 
!     }
! 
! 
! /**
!  * This function is called to export a quiz (as opposed to exporting a category of questions)
!  *
!  * @uses $USER
!  * @param object $quiz
!  * @param array $questions - an array of question objects
!  * @param object $result - if set, contains result of calling quiz_grade_responses()
!  * @todo use $result in the ouput
!  */
!     function exportprocess_quiz($quiz, $questions, $result, $submiturl, $course) {
!         global $USER;
!         global $CFG;
! 
!         $gradingmethod = array (1 => 'GRADEHIGHEST',
!                                 2 => 'GRADEAVERAGE',
!                                 3 => 'ATTEMPTFIRST' ,
!                                 4 => 'ATTEMPTLAST');
! 
!         $questions = $this->quiz_export_prepare_questions($questions, $quiz->id, $course->id, $quiz->shuffleanswers);
! 
!         $smarty =& $this->init_smarty();
!         $smarty->assign('questions', $questions);
! 
!         // quiz level smarty variables
!         $manifestid = str_replace(array(':', '/'), array('-','_'), "quiz{$quiz->id}-{$CFG->wwwroot}");
!         $smarty->assign('manifestidentifier', $manifestid);
!         $smarty->assign('submiturl', $submiturl);
!         $smarty->assign('userid', $USER->id);
!         $smarty->assign('username', htmlspecialchars($USER->username, ENT_COMPAT, 'UTF-8'));
!         $smarty->assign('quiz_level_export', 1);
!         $smarty->assign('quiztitle', format_string($quiz->name,true)); //assigned specifically so as not to cause problems with category-level export
!         $smarty->assign('quiztimeopen', date('Y-m-d\TH:i:s', $quiz->timeopen)); // ditto
!         $smarty->assign('quiztimeclose', date('Y-m-d\TH:i:s', $quiz->timeclose)); // ditto
!         $smarty->assign('grademethod', $gradingmethod[$quiz->grademethod]);
!         $smarty->assign('quiz', $quiz);
!         $smarty->assign('course', $course);
!         $smarty->assign('lang', $this->lang);
!         $expout = $smarty->fetch('imsmanifest.tpl');
!         echo $expout;
!         return true;
!     }
! 
! 
! 
! 
! /**
!  * Prepares questions for quiz export
!  *
!  * The questions are changed as follows:
!  *   - the question answers atached to the questions
!  *   - image set to an http reference instead of a file path
!  *   - qti specific info added
!  *   - exporttext added, which contains an xml-formatted qti assesmentItem
!  *
!  * @param array $questions - an array of question objects
!  * @param int $quizid
!  * @return an array of question arrays
!  */
!     function quiz_export_prepare_questions($questions, $quizid, $courseid, $shuffleanswers = null) {
!         global $CFG;
!         // add the answers to the questions and format the image property
!         foreach ($questions as $key=>$question) {
!             $questions[$key] = get_question_data($question);
!             $questions[$key]->courseid = $courseid;
!             $questions[$key]->quizid = $quizid;
! 
!             if ($question->image) {
! 
!                 if (empty($question->mediamimetype)) {
!                   $questions[$key]->mediamimetype = mimeinfo('type',$question->image);
!                 }
! 
!                 $localfile = (substr(strtolower($question->image), 0, 7) == 'http://') ? false : true;
! 
!                 if ($localfile) {
!                     // create the http url that the player will need to access the file
!                     if ($CFG->slasharguments) {        // Use this method if possible for better caching
!                         $questions[$key]->mediaurl = "$CFG->wwwroot/file.php/$question->image";
!                     } else {
!                         $questions[$key]->mediaurl = "$CFG->wwwroot/file.php?file=$question->image";
!                     }
!                 } else {
!                     $questions[$key]->mediaurl = $question->image;
!                 }
!             }
!         }
! 
!         $this->add_qti_info($questions);
!         $questions = $this->questions_with_export_info($questions, $shuffleanswers);
!         $questions = $this->objects_to_array($questions);
!         return $questions;
!     }
! 
! /**
!  * calls htmlspecialchars for each string field, to convert, for example, & to &amp;
!  *
!  * collections are processed recursively
!  *
!  * @param array $collection - an array or object or string
!  */
! function xml_entitize(&$collection) {
!     if (is_array($collection)) {
!         foreach ($collection as $key=>$var) {
!             if (is_string($var)) {
!                 $collection[$key]= htmlspecialchars($var, ENT_COMPAT, 'UTF-8');
!             } else if (is_array($var) || is_object($var)) {
!                 $this->xml_entitize($collection[$key]);
!             }
!         }
!     } else if (is_object($collection)) {
!         $vars = get_object_vars($collection);
!         foreach ($vars as $key=>$var) {
!             if (is_string($var)) {
!                 $collection->$key = htmlspecialchars($var, ENT_COMPAT, 'UTF-8');
!             } else if (is_array($var) || is_object($var)) {
!                 $this->xml_entitize($collection->$key);
!             }
!         }
!     } else if (is_string($collection)) {
!         $collection = htmlspecialchars($collection, ENT_COMPAT, 'UTF-8');
!     }
! }
! 
! /**
!  * adds exporttext property to the questions
!  *
!  * Adds the qti export text to the questions
!  *
!  * @param array $questions - an array of question objects
!  * @return an array of question objects
!  */
!     function questions_with_export_info($questions, $shuffleanswers = null) {
!         $exportquestions = array();
!         foreach($questions as $key=>$question) {
!             $expout = $this->writequestion( $question , $shuffleanswers) . "\n";
!             $expout = $this->presave_process( $expout );
!             $key = $this->get_assesment_item_id($question);
!             $exportquestions[$key] = $question;
!             $exportquestions[$key]->exporttext = $expout;
!         }
!         return $exportquestions;
!     }
! 
! /**
!  * Creates the export text for a question
!  *
!  * @todo handle in-line media (specified in the question/subquestion/answer text) for course-level exports
!  * @param object $question
!  * @param boolean $shuffleanswers whether or not to shuffle the answers
!  * @param boolean $courselevel whether or not this is a course-level export
!  * @param string $path provide the path to copy question media files to, if $courselevel == true
!  * @return string containing export text
!  */
!     function writequestion($question, $shuffleanswers = null, $courselevel = false, $path = '') {
!         // turns question into string
!         // question reflects database fields for general question and specific to type
!         global $CFG;
!         $expout = '';
!         //need to unencode the html entities in the questiontext field.
!         // the whole question object was earlier run throught htmlspecialchars in xml_entitize().
!         $question->questiontext = html_entity_decode($question->questiontext, ENT_COMPAT);
! 
!         $hasimage = empty($question->image) ? 0 : 1;
!         $hassize = empty($question->mediax) ? 0 : 1;
! 
!         $allowedtags = '<a><br><b><h1><h2><h3><h4><i><img><li><ol><strong><table><tr><td><th><u><ul><object>';  // all other tags will be stripped from question text
!         $smarty =& $this->init_smarty();
!         $assesmentitemid = $this->get_assesment_item_id($question);
!         $question_type = $this->get_qtype( $question->qtype );
!         $questionid = "question{$question->id}$question_type";
!         $smarty->assign('question_has_image', $hasimage);
!         $smarty->assign('hassize', $hassize);
!         $smarty->assign('questionid', $questionid);
!         $smarty->assign('assessmentitemidentifier', $assesmentitemid);
!         $smarty->assign('assessmentitemtitle', $question->name);
!         $smarty->assign('courselevelexport', $courselevel);
! 
!         if ($question->qtype == MULTIANSWER) {
!             $question->questiontext = strip_tags($question->questiontext, $allowedtags . '<intro>');
!             $smarty->assign('questionText',  $this->get_cloze_intro($question->questiontext));
!         } else {
!             $smarty->assign('questionText',  strip_tags($question->questiontext, $allowedtags));
!         }
! 
!         $smarty->assign('question', $question);
!         // the following two are left for compatibility; the templates should be changed, though, to make object tags for the questions
!         //$smarty->assign('questionimage', $question->image);
!         //$smarty->assign('questionimagealt', "image: $question->image");
! 
!         // output depends on question type
!         switch($question->qtype) {
!         case TRUEFALSE:
!             $qanswers = $question->options->answers;
!             $answers[0] = (array)$qanswers['true'];
!             $answers[0]['answer'] = get_string("true", "quiz");
!             $answers[1] = (array)$qanswers['false'];
!             $answers[1]['answer'] = get_string("false", "quiz");
! 
!             if (!empty($shuffleanswers)) {
!                 $answers = $this->shuffle_things($answers);
!             }
! 
!             if (isset($question->response)) {
!               $correctresponseid = $question->response[$questionid];
!               if ($answers[0]['id'] == $correctresponseid) {
!                   $correctresponse = $answers[0];
!               } else {
!                   $correctresponse = $answers[1];
!               }
!             }
!             else {
!               $correctresponse = '';
!             }
! 
!             $smarty->assign('correctresponse', $correctresponse);
!             $smarty->assign('answers', $answers);
!             $expout = $smarty->fetch('choice.tpl');
!             break;
!         case MULTICHOICE:
!             $answers = $this->objects_to_array($question->options->answers);
!             $correctresponses = $this->get_correct_answers($answers);
!             $correctcount = count($correctresponses);
!             $smarty->assign('responsedeclarationcardinality', $question->options->single ? 'single' : 'multiple');
!             $smarty->assign('operator', $question->options->single ? 'match' : 'member');
!             $smarty->assign('correctresponses', $correctresponses);
!             $smarty->assign('answers', $answers);
!             $smarty->assign('maxChoices', $question->options->single ? '1' : count($answers));
!             $smarty->assign('maxChoices', $question->options->single ? '1' : count($answers));
!             $smarty->assign('shuffle', empty($shuffleanswers) ? 'false' : 'true');
!             $smarty->assign('generalfeedback', $question->generalfeedback);
!             $smarty->assign('correctfeedback', $question->options->correctfeedback);
!             $smarty->assign('partiallycorrectfeedback', $question->options->partiallycorrectfeedback);
!             $smarty->assign('incorrectfeedback', $question->options->incorrectfeedback);
!             $expout = $smarty->fetch('choiceMultiple.tpl');
!             break;
!         case SHORTANSWER:
!             $answers = $this->objects_to_array($question->options->answers);
!             if (!empty($shuffleanswers)) {
!                 $answers = $this->shuffle_things($answers);
!             }
! 
!             $correctresponses = $this->get_correct_answers($answers);
!             $correctcount = count($correctresponses);
! 
!             $smarty->assign('responsedeclarationcardinality', $correctcount > 1 ? 'multiple' : 'single');
!             $smarty->assign('correctresponses', $correctresponses);
!             $smarty->assign('answers', $answers);
!             $expout = $smarty->fetch('textEntry.tpl');
!             break;
!         case NUMERICAL:
!             $qanswer = array_pop( $question->options->answers );
!             $smarty->assign('lowerbound', $qanswer->answer - $qanswer->tolerance);
!             $smarty->assign('upperbound', $qanswer->answer + $qanswer->tolerance);
!             $smarty->assign('answer', $qanswer->answer);
!             $expout = $smarty->fetch('numerical.tpl');
!             break;
!         case MATCH:
!             $this->xml_entitize($question->options->subquestions);
!             $subquestions = $this->objects_to_array($question->options->subquestions);
!             if (!empty($shuffleanswers)) {
!                 $subquestions = $this->shuffle_things($subquestions);
!             }
!             $setcount = count($subquestions);
! 
!             $smarty->assign('setcount', $setcount);
!             $smarty->assign('matchsets', $subquestions);
!             $expout = $smarty->fetch('match.tpl');
!             break;
!         case DESCRIPTION:
!             $expout = $smarty->fetch('extendedText.tpl');
!             break;
!         // loss of get_answers() from quiz_embedded_close_qtype class during
!         // Gustav's refactor breaks MULTIANSWER badly - one for another day!!
!         /*
!         case MULTIANSWER:
!             $answers = $this->get_cloze_answers_array($question);
!             $questions = $this->get_cloze_questions($question, $answers, $allowedtags);
! 
!             $smarty->assign('cloze_trailing_text_id', CLOZE_TRAILING_TEXT_ID);
!             $smarty->assign('answers', $answers);
!             $smarty->assign('questions', $questions);
!             $expout = $smarty->fetch('composite.tpl');
!             break; */
!         default:
!             $smarty->assign('questionText', "This question type (Unknown: type $question_type)  has not yet been implemented");
!             $expout = $smarty->fetch('notimplemented.tpl');
!         }
! 
!         // run through xml tidy function
!         //$tidy_expout = $this->indent_xhtml( $expout, '    ' ) . "\n\n";
!         //return $tidy_expout;
!         return $expout;
!     }
! 
! /**
!  * Gets an id to use for a qti assesment item
!  *
!  * @param object $question
!  * @return string containing a qti assesment item id
!  */
!     function get_assesment_item_id($question) {
!         return "question{$question->id}";
!     }
! 
! /**
!  * gets the answers whose grade fraction > 0
!  *
!  * @param array $answers
!  * @return array (0-indexed) containing the answers whose grade fraction > 0
!  */
!     function get_correct_answers($answers)
!     {
!         $correctanswers = array();
!         foreach ($answers as $answer) {
!             if ($answer['fraction'] > 0) {
!                 $correctanswers[] = $answer;
!             }
!         }
!         return $correctanswers;
!     }
! 
! /**
!  * gets a new Smarty object, with the template and compile directories set
!  *
!  * @return object a smarty object
!  */
!     function & init_smarty() {
!         global $CFG;
! 
!         // create smarty compile dir in dataroot
!         $path = $CFG->dataroot."/smarty_c";
!         if (!is_dir($path)) {
!             if (!mkdir($path, $CFG->directorypermissions)) {
!               print_error('cannotcreatepath', 'question', '', $path);
!             }
!         }
!         $smarty = new Smarty;
!         $smarty->template_dir = "{$CFG->dirroot}/question/format/qti_two/templates";
!         $smarty->compile_dir  = "$path";
!         return $smarty;
!     }
! 
! /**
!  * converts an array of objects to an array of arrays (not recursively)
!  *
!  * @param array $objectarray
!  * @return array - an array of answer arrays
!  */
!     function objects_to_array($objectarray)
!     {
!         $arrayarray = array();
!         foreach ($objectarray as $object) {
!             $arrayarray[] = (array)$object;
!         }
!         return $arrayarray;
!     }
! 
! /**
!  * gets a question's cloze answer objects as arrays containing only arrays and basic data types
!  *
!  * @param object $question
!  * @return array - an array of answer arrays
!  */
!     function get_cloze_answers_array($question) {
!         $answers = $this->get_answers($question);
!         $this->xml_entitize($answers);
!         foreach ($answers as $answerkey => $answer) {
!             $answers[$answerkey]->subanswers = $this->objects_to_array($answer->subanswers);
!         }
!         return $this->objects_to_array($answers);
!     }
! 
! /**
!  * gets an array with text and question arrays for the given cloze question
!  *
!  * To make smarty processing easier, the returned text and question sub-arrays have an equal number of elements.
!  * If it is necessary to add a dummy element to the question sub-array, the question will be given an id of CLOZE_TRAILING_TEXT_ID.
!  *
!  * @param object $question
!  * @param array $answers - an array of arrays containing the question's answers
!  * @param string $allowabletags - tags not to strip out of the question text (e.g. '<i><br>')
!  * @return array with text and question arrays for the given cloze question
!  */
!      function get_cloze_questions($question, $answers, $allowabletags) {
!         $questiontext = strip_tags($question->questiontext, $allowabletags);
!         if (preg_match_all('/(.*){#([0-9]+)}/U', $questiontext, $matches)) {
!             // matches[1] contains the text inbetween the question blanks
!             // matches[2] contains the id of the question blanks (db: question_multianswer.positionkey)
! 
!             // find any trailing text after the last {#XX} and add it to the array
!             if (preg_match('/.*{#[0-9]+}(.*)$/', $questiontext, $tail)) {
!                 $matches[1][] = $tail[1];
!                 $tailadded = true;
!             }
!             $questions['text'] = $matches[1];
!             $questions['question'] = array();
!             foreach ($matches[2] as $key => $questionid) {
!                 foreach ($answers as $answer) {
!                     if ($answer['positionkey'] == $questionid) {
!                         $questions['question'][$key] = $answer;
!                         break;
!                     }
!                 }
!             }
!             if ($tailadded) {
!                 // to have a matching number of question and text array entries:
!                 $questions['question'][] = array('id'=>CLOZE_TRAILING_TEXT_ID, 'answertype'=>SHORTANSWER);
!             }
! 
!         } else {
!             $questions['text'][0] = $question->questiontext;
!             $questions['question'][0] = array('id'=>CLOZE_TRAILING_TEXT_ID, 'answertype'=>SHORTANSWER);
!         }
! 
!         return $questions;
!     }
! 
! /**
!  * strips out the <intro>...</intro> section, if any, and returns the text
!  *
!  * changes the text object passed to it.
!  *
!  * @param string $&text
!  * @return string the intro text, if there was an intro tag. '' otherwise.
!  */
!     function get_cloze_intro(&$text) {
!         if (preg_match('/(.*)?\<intro>(.+)?\<\/intro>(.*)/s', $text, $matches)) {
!             $text = $matches[1] . $matches[3];
!             return $matches[2];
!         }
!         else {
!             return '';
!         }
!     }
! 
! 
! /**
!  * adds qti metadata properties to the questions
!  *
!  * The passed array of questions is altered by this function
!  *
!  * @param &questions an array of question objects
!  */
!     function add_qti_info(&$questions)
!     {
!         foreach ($questions as $key=>$question) {
!             $questions[$key]->qtiinteractiontype = $this->get_qti_interaction_type($question->qtype);
!             $questions[$key]->qtiscoreable = $this->get_qti_scoreable($question);
!             $questions[$key]->qtisolutionavailable = $this->get_qti_solution_available($question);
!         }
! 
!     }
! 
! /**
!  * returns whether or not a given question is scoreable
!  *
!  * @param object $question
!  * @return boolean
!  */
!     function get_qti_scoreable($question) {
!         switch ($question->qtype) {
!             case DESCRIPTION:
!                 return 'false';
!             default:
!                 return 'true';
!         }
!     }
! 
! /**
!  * returns whether or not a solution is available for a given question
!  *
!  * The results are based on whether or not Moodle stores answers for the given question type
!  *
!  * @param object $question
!  * @return boolean
!  */
!     function get_qti_solution_available($question) {
!         switch($question->qtype) {
!             case TRUEFALSE:
!                 return 'true';
!             case MULTICHOICE:
!                 return 'true';
!             case SHORTANSWER:
!                 return 'true';
!             case NUMERICAL:
!                 return 'true';
!             case MATCH:
!                 return 'true';
!             case DESCRIPTION:
!                 return 'false';
!             case MULTIANSWER:
!                 return 'true';
!             default:
!                 return 'true';
!         }
! 
!     }
! 
! /**
!  * maps a moodle question type to a qti 2.0 question type
!  *
!  * @param int type_id - the moodle question type
!  * @return string qti 2.0 question type
!  */
!     function get_qti_interaction_type($type_id) {
!         switch( $type_id ) {
!         case TRUEFALSE:
!             $name = 'choiceInteraction';
!             break;
!         case MULTICHOICE:
!             $name = 'choiceInteraction';
!             break;
!         case SHORTANSWER:
!             $name = 'textInteraction';
!             break;
!         case NUMERICAL:
!             $name = 'textInteraction';
!             break;
!         case MATCH:
!             $name = 'matchInteraction';
!             break;
!         case DESCRIPTION:
!             $name = 'extendedTextInteraction';
!             break;
!         case MULTIANSWER:
!             $name = 'textInteraction';
!             break;
!         default:
!             $name = 'textInteraction';
!         }
!         return $name;
!     }
! 
! /**
!  * returns the given array, shuffled
!  *
!  *
!  * @param array $things
!  * @return array
!  */
!     function shuffle_things($things) {
!         $things = swapshuffle_assoc($things);
!         $oldthings = $things;
!         $things = array();
!         foreach ($oldthings as $key=>$value) {
!             $things[] = $value;      // This loses the index key, but doesn't matter
!         }
!         return $things;
!     }
! 
! /**
!  * returns a flattened image name - with all /, \ and : replaced with other characters
!  *
!  * used to convert a file or url to a qti-permissable identifier
!  *
!  * @param string name
!  * @return string
!  */
!     function flatten_image_name($name) {
!         return str_replace(array('/', '\\', ':'), array ('_','-','.'), $name);
!     }
! 
!     function file_full_path($file, $courseid) {
!         global $CFG;
!         if (substr(strtolower($file), 0, 7) == 'http://') {
!             $url = $file;
!         } else if ($CFG->slasharguments) {        // Use this method if possible for better caching
!             $url = "{$CFG->wwwroot}/file.php/$courseid/{$file}";
!         } else {
!             $url = "{$CFG->wwwroot}/file.php?file=/$courseid/{$file}";
!         }
!         return $url;
!     }
  
  }
  
--- 16,919 ----
  
  class qformat_qti_two extends qformat_default {
  
! 	var $lang;
  
! 	function provide_export() {
! 		return true;
! 	}
! 
! 	function indent_xhtml($source, $indenter = ' ') {
! 		// xml tidier-upper
! 		// (c) Ari Koivula http://ventionline.com
! 
! 		// Remove all pre-existing formatting.
! 		// Remove all newlines.
! 		$source = str_replace("\n", '', $source);
! 		$source = str_replace("\r", '', $source);
! 		// Remove all tabs.
! 		$source = str_replace("\t", '', $source);
! 		// Remove all space after ">" and before "<".
! 		$source = preg_replace("/>( )*", ">/", $source);
! 		$source = preg_replace("/( )*<", "</", $source);
! 
! 		// Iterate through the source.
! 		$level = 0;
! 		$source_len = strlen($source);
! 		$pt = 0;
! 		while ($pt < $source_len) {
! 			if ($source{$pt} === '<') {
! 				// We have entered a tag.
! 				// Remember the point where the tag starts.
! 				$started_at = $pt;
! 				$tag_level = 1;
! 				// If the second letter of the tag is "/", assume its an ending tag.
! 				if ($source{$pt+1} === '/') {
! 					$tag_level = -1;
! 				}
! 				// If the second letter of the tag is "!", assume its an "invisible" tag.
! 				if ($source{$pt+1} === '!') {
! 					$tag_level = 0;
! 				}
! 				// Iterate throught the source until the end of tag.
! 				while ($source{$pt} !== '>') {
! 					$pt++;
! 				}
! 				// If the second last letter is "/", assume its a self ending tag.
! 				if ($source{$pt-1} === '/') {
! 					$tag_level = 0;
! 				}
! 				$tag_lenght = $pt+1-$started_at;
! 
! 				// Decide the level of indention for this tag.
! 				// If this was an ending tag, decrease indent level for this tag..
! 				if ($tag_level === -1) {
! 					$level--;
! 				}
! 				// Place the tag in an array with proper indention.
! 				$array[] = str_repeat($indenter, $level).substr($source, $started_at, $tag_lenght);
! 				// If this was a starting tag, increase the indent level after this tag.
! 				if ($tag_level === 1) {
! 					$level++;
! 				}
! 				// if it was a self closing tag, dont do shit.
! 			}
! 			// Were out of the tag.
! 			// If next letter exists...
! 			if (($pt+1) < $source_len) {
! 				// ... and its not an "<".
! 				if ($source{$pt+1} !== '<') {
! 					$started_at = $pt+1;
! 					// Iterate through the source until the start of new tag or until we reach the end of file.
! 					while ($source{$pt} !== '<' && $pt < $source_len) {
! 						$pt++;
! 					}
! 					// If we found a "<" (we didnt find the end of file)
! 					if ($source{$pt} === '<') {
! 						$tag_lenght = $pt-$started_at;
! 						// Place the stuff in an array with proper indention.
! 						$array[] = str_repeat($indenter, $level).substr($source, $started_at, $tag_lenght);
! 					}
! 					// If the next tag is "<", just advance pointer and let the tag indenter take care of it.
! 				} else {
! 					$pt++;
! 				}
! 				// If the next letter doesnt exist... Were done... well, almost..
! 			} else {
! 				break;
! 			}
! 		}
! 		// Replace old source with the new one we just collected into our array.
! 		$source = implode($array, "\n");
! 		return $source;
! 	}
! 
! 	function importpreprocess() {
! 		global $CFG;
! 
! 		print_error('cannotimportformat', 'question', "$CFG->wwwroot/mod/quiz/import.php?category=$category->id");
! 	}
! 
! 	function exportpreprocess() {
! 		global $CFG;
! 
! 		require_once("{$CFG->libdir}/smarty/Smarty.class.php");
! 
! 		// assign the language for the export: by parameter, SESSION, USER, or the default of 'en'
! 		$lang = current_language();
! 		$this->lang = $lang;
! 
! 		return parent::exportpreprocess();
! 	}
! 
! 
! 	function export_file_extension() {
! 		// override default type so extension is .xml
! 
! 		return ".zip";
! 	}
! 
! 	function get_qtype( $type_id ) {
! 		// translates question type code number into actual name
! 
! 		switch( $type_id ) {
! 			case TRUEFALSE:
! 				$name = 'truefalse';
! 				break;
! 			case MULTICHOICE:
! 				$name = 'multichoice';
! 				break;
! 			case SHORTANSWER:
! 				$name = 'shortanswer';
! 				break;
! 			case NUMERICAL:
! 				$name = 'numerical';
! 				break;
! 			case MATCH:
! 				$name = 'matching';
! 				break;
! 			case DESCRIPTION:
! 				$name = 'description';
! 				break;
! 			case MULTIANSWER:
! 				$name = 'multianswer';
! 				break;
! 			default:
! 				$name = 'Unknown';
! 		}
! 		return $name;
! 	}
! 
! 	function writetext( $raw ) {
! 		// generates <text></text> tags, processing raw text therein
! 
! 		// for now, don't allow any additional tags in text
! 		// otherwise xml rules would probably get broken
! 		$raw = strip_tags( $raw );
! 
! 		return "<text>$raw</text>\n";
! 	}
! 
! 
! 	/**
! 	 * flattens $object['media'], copies $object['media'] to $path, and sets $object['mediamimetype']
! 	 *
! 	 * @param array &$object containing a field 'media'
! 	 * @param string $path the full path name to where the media files need to be copied
! 	 * @param int $courseid
! 	 * @return: mixed - true on success or in case of an empty media field, an error string if the file copy fails
! 	 */
! 	function copy_and_flatten(&$object, $path, $courseid) {
! 		global $CFG;
! 		if (!empty($object['media'])) {
! 			$location = $object['media'];
! 			$object['media'] = $this->flatten_image_name($location);
! 			if (!@copy("{$CFG->dataroot}/$courseid/$location", "$path/{$object['media']}")) {
! 				return "Failed to copy {$CFG->dataroot}/$courseid/$location to $path/{$object['media']}";
! 			}
! 			if (empty($object['mediamimetype'])) {
! 				$object['mediamimetype'] = mimeinfo('type', $object['media']);
! 			}
! 		}
! 		return true;
! 	}
! 	/**
! 	 * copies all files needed by the questions to the given $path, and flattens the file names
! 	 *
! 	 * @param array $questions the question objects
! 	 * @param string $path the full path name to where the media files need to be copied
! 	 * @param int $courseid
! 	 * @return mixed true on success, an array of error messages otherwise
! 	 */
! 	function handle_questions_media(&$questions, $path, $courseid) {
! 		global $CFG;
! 		$errors = array();
! 		foreach ($questions as $key=>$question) {
! 
! 			// todo: handle in-line media (specified in the question text)
! 			if (!empty($question->image)) {
! 				$location = $questions[$key]->image;
! 				$questions[$key]->mediaurl = $this->flatten_image_name($location);
! 				if (!@copy("{$CFG->dataroot}/$courseid/$location", "$path/{$questions[$key]->mediaurl}")) {
! 					$errors[] = "Failed to copy {$CFG->dataroot}/$courseid/$location to $path/{$questions[$key]->mediaurl}";
! 				}
! 				if (empty($question->mediamimetype)) {
! 					$questions[$key]->mediamimetype = mimeinfo('type', $question->image);
! 				}
! 			}
! 		}
! 
! 		return empty($errors) ? true : $errors;
! 	}
! 
! 	/**
! 	 * exports the questions in a question category to the given location
! 	 *
! 	 * The parent class method was overridden because the IMS export consists of multiple files
! 	 *
! 	 * @param string $filename the directory name which will hold the exported files
! 	 * @return boolean - or errors out
! 	 */
! 	function exportprocess() {
! 
! 		global $CFG, $OUTPUT;
! 		$courseid = $this->course->id;
! 
! 		// create a directory for the exports (if not already existing)
! 		if (!$export_dir = make_upload_directory($this->question_get_export_dir().'/'.$this->filename)) {
! 			print_error('cannotcreatepath', 'quiz', '', $export_dir);
! 		}
! 		$path = $CFG->dataroot.'/'.$this->question_get_export_dir().'/'.$this->filename;
! 
! 		// get the questions (from database) in this category
! 		$questions = get_questions_category( $this->category );
! 
! 		echo $OUTPUT->notification("Exporting ".count($questions)." questions.");
! 		$count = 0;
! 
! 		// create the imsmanifest file
! 		$smarty =& $this->init_smarty();
! 		$this->add_qti_info($questions);
! 		// copy files used by the main questions to the export directory
! 		$result = $this->handle_questions_media($questions, $path, $courseid);
! 		if ($result !== true) {
! 			echo $OUTPUT->notification(implode("<br />", $result));
! 		}
! 
! 		$manifestquestions = $this->objects_to_array($questions);
! 		$manifestid = str_replace(array(':', '/'), array('-','_'), "question_category_{$this->category->id}---{$CFG->wwwroot}");
! 		$smarty->assign('externalfiles', 1);
! 		$smarty->assign('manifestidentifier', $manifestid);
! 		$smarty->assign('quiztitle', "question_category_{$this->category->id}");
! 		$smarty->assign('quizinfo', "All questions in category {$this->category->id}");
! 		$smarty->assign('questions', $manifestquestions);
! 		$smarty->assign('lang', $this->lang);
! 		$smarty->error_reporting = 99;
! 		$expout = $smarty->fetch('imsmanifest.tpl');
! 		$filepath = $path.'/imsmanifest.xml';
! 		if (empty($expout)) {
! 			print_error('emptyxml', 'question');
! 		}
! 		if (!$fh=fopen($filepath,"w")) {
! 			print_error('cannotopenforwriting', 'question', '', $filepath);
! 		}
! 		if (!fwrite($fh, $expout)) {
! 			print_error('cannotwriteto', 'question', '', $filepath);
! 		}
! 		fclose($fh);
! 
! 		// iterate through questions
! 		foreach($questions as $question) {
! 
! 			// results are first written into string (and then to a file)
! 			$count++;
! 			echo "<hr /><p><b>$count</b>. ".$question->questiontext."</p>";
! 			$expout = $this->writequestion( $question , null, true, $path) . "\n";
! 			$expout = $this->presave_process( $expout );
! 
! 			$filepath = $path.'/'.$this->get_assesment_item_id($question) . ".xml";
! 			if (!$fh=fopen($filepath,"w")) {
! 				print_error('cannotopenforwriting', 'question', '', $filepath);
! 			}
! 			if (!fwrite($fh, $expout)) {
! 				print_error('cannotwriteto', 'question', '', $filepath);
! 			}
! 			fclose($fh);
! 
! 		}
! 
! 		// zip files into single export file
! 		zip_files( array($path), "$path.zip" );
! 
! 		// remove the temporary directory
! 		remove_dir( $path );
! 
! 		return true;
! 	}
! 
! 	/**
! 	 * exports a quiz (as opposed to exporting a category of questions)
! 	 *
! 	 * The parent class method was overridden because the IMS export consists of multiple files
! 	 *
! 	 * @param object $quiz
! 	 * @param array $questions - an array of question objects
! 	 * @param object $result - if set, contains result of calling quiz_grade_responses()
! 	 * @param string $redirect - a URL to redirect to in case of failure
! 	 * @param string $submiturl - the URL for the qti player to send the results to (e.g. attempt.php)
! 	 * @todo use $result in the ouput
! 	 */
! 	function export_quiz($course, $quiz, $questions, $result, $redirect, $submiturl = null) {
! 		$this->xml_entitize($course);
! 		$this->xml_entitize($quiz);
! 		$this->xml_entitize($questions);
! 		$this->xml_entitize($result);
! 		$this->xml_entitize($submiturl);
! 		if (! $this->exportpreprocess(0, $course)) {   // Do anything before that we need to
! 			print_error('errorpreprocess', 'question', $redirect);
! 		}
! 		if (! $this->exportprocess_quiz($quiz, $questions, $result, $submiturl, $course)) {         // Process the export data
! 			print_error('errorprocess','question', $redirect);
! 		}
! 		if (! $this->exportpostprocess()) {                    // In case anything needs to be done after
! 			print_error('errorpostprocess', 'question', $redirect);
! 		}
! 
! 	}
! 
! 
! 	/**
! 	 * This function is called to export a quiz (as opposed to exporting a category of questions)
! 	 *
! 	 * @uses $USER
! 	 * @param object $quiz
! 	 * @param array $questions - an array of question objects
! 	 * @param object $result - if set, contains result of calling quiz_grade_responses()
! 	 * @todo use $result in the ouput
! 	 */
! 	function exportprocess_quiz($quiz, $questions, $result, $submiturl, $course) {
! 		global $USER;
! 		global $CFG;
! 
! 		$gradingmethod = array (1 => 'GRADEHIGHEST',
! 		2 => 'GRADEAVERAGE',
! 		3 => 'ATTEMPTFIRST' ,
! 		4 => 'ATTEMPTLAST');
! 
! 		$questions = $this->quiz_export_prepare_questions($questions, $quiz->id, $course->id, $quiz->shuffleanswers);
! 
! 		$smarty =& $this->init_smarty();
! 		$smarty->assign('questions', $questions);
! 
! 		// quiz level smarty variables
! 		$manifestid = str_replace(array(':', '/'), array('-','_'), "quiz{$quiz->id}-{$CFG->wwwroot}");
! 		$smarty->assign('manifestidentifier', $manifestid);
! 		$smarty->assign('submiturl', $submiturl);
! 		$smarty->assign('userid', $USER->id);
! 		$smarty->assign('username', htmlspecialchars($USER->username, ENT_COMPAT, 'UTF-8'));
! 		$smarty->assign('quiz_level_export', 1);
! 		$smarty->assign('quiztitle', format_string($quiz->name,true)); //assigned specifically so as not to cause problems with category-level export
! 		$smarty->assign('quiztimeopen', date('Y-m-d\TH:i:s', $quiz->timeopen)); // ditto
! 		$smarty->assign('quiztimeclose', date('Y-m-d\TH:i:s', $quiz->timeclose)); // ditto
! 		$smarty->assign('grademethod', $gradingmethod[$quiz->grademethod]);
! 		$smarty->assign('quiz', $quiz);
! 		$smarty->assign('course', $course);
! 		$smarty->assign('lang', $this->lang);
! 		$expout = $smarty->fetch('imsmanifest.tpl');
! 		echo $expout;
! 		return true;
! 	}
! 
! 
! 
! 
! 	/**
! 	 * Prepares questions for quiz export
! 	 *
! 	 * The questions are changed as follows:
! 	 *   - the question answers atached to the questions
! 	 *   - image set to an http reference instead of a file path
! 	 *   - qti specific info added
! 	 *   - exporttext added, which contains an xml-formatted qti assesmentItem
! 	 *
! 	 * @param array $questions - an array of question objects
! 	 * @param int $quizid
! 	 * @return an array of question arrays
! 	 */
! 	function quiz_export_prepare_questions($questions, $quizid, $courseid, $shuffleanswers = null) {
! 		global $CFG;
! 		// add the answers to the questions and format the image property
! 		foreach ($questions as $key=>$question) {
! 			$questions[$key] = get_question_data($question);
! 			$questions[$key]->courseid = $courseid;
! 			$questions[$key]->quizid = $quizid;
! 
! 			if ($question->image) {
! 
! 				if (empty($question->mediamimetype)) {
! 					$questions[$key]->mediamimetype = mimeinfo('type',$question->image);
! 				}
! 
! 				$localfile = (substr(strtolower($question->image), 0, 7) == 'http://') ? false : true;
! 
! 				if ($localfile) {
! 					// create the http url that the player will need to access the file
! 					if ($CFG->slasharguments) {        // Use this method if possible for better caching
! 						$questions[$key]->mediaurl = "$CFG->wwwroot/file.php/$question->image";
! 					} else {
! 						$questions[$key]->mediaurl = "$CFG->wwwroot/file.php?file=$question->image";
! 					}
! 				} else {
! 					$questions[$key]->mediaurl = $question->image;
! 				}
! 			}
! 		}
! 
! 		$this->add_qti_info($questions);
! 		$questions = $this->questions_with_export_info($questions, $shuffleanswers);
! 		$questions = $this->objects_to_array($questions);
! 		return $questions;
! 	}
! 
! 	/**
! 	 * calls htmlspecialchars for each string field, to convert, for example, & to &amp;
! 	 *
! 	 * collections are processed recursively
! 	 *
! 	 * @param array $collection - an array or object or string
! 	 */
! 	function xml_entitize(&$collection) {
! 		if (is_array($collection)) {
! 			foreach ($collection as $key=>$var) {
! 				if (is_string($var)) {
! 					$collection[$key]= htmlspecialchars($var, ENT_COMPAT, 'UTF-8');
! 				} else if (is_array($var) || is_object($var)) {
! 					$this->xml_entitize($collection[$key]);
! 				}
! 			}
! 		} else if (is_object($collection)) {
! 			$vars = get_object_vars($collection);
! 			foreach ($vars as $key=>$var) {
! 				if (is_string($var)) {
! 					$collection->$key = htmlspecialchars($var, ENT_COMPAT, 'UTF-8');
! 				} else if (is_array($var) || is_object($var)) {
! 					$this->xml_entitize($collection->$key);
! 				}
! 			}
! 		} else if (is_string($collection)) {
! 			$collection = htmlspecialchars($collection, ENT_COMPAT, 'UTF-8');
! 		}
! 	}
! 
! 	/**
! 	 * adds exporttext property to the questions
! 	 *
! 	 * Adds the qti export text to the questions
! 	 *
! 	 * @param array $questions - an array of question objects
! 	 * @return an array of question objects
! 	 */
! 	function questions_with_export_info($questions, $shuffleanswers = null) {
! 		$exportquestions = array();
! 		foreach($questions as $key=>$question) {
! 			$expout = $this->writequestion( $question , $shuffleanswers) . "\n";
! 			$expout = $this->presave_process( $expout );
! 			$key = $this->get_assesment_item_id($question);
! 			$exportquestions[$key] = $question;
! 			$exportquestions[$key]->exporttext = $expout;
! 		}
! 		return $exportquestions;
! 	}
! 
! 	/**
! 	 * Creates the export text for a question
! 	 *
! 	 * @todo handle in-line media (specified in the question/subquestion/answer text) for course-level exports
! 	 * @param object $question
! 	 * @param boolean $shuffleanswers whether or not to shuffle the answers
! 	 * @param boolean $courselevel whether or not this is a course-level export
! 	 * @param string $path provide the path to copy question media files to, if $courselevel == true
! 	 * @return string containing export text
! 	 */
! 	function writequestion($question, $shuffleanswers = null, $courselevel = false, $path = '') {
! 		// turns question into string
! 		// question reflects database fields for general question and specific to type
! 		global $CFG;
! 		$expout = '';
! 		//need to unencode the html entities in the questiontext field.
! 		// the whole question object was earlier run throught htmlspecialchars in xml_entitize().
! 		$question->questiontext = html_entity_decode($question->questiontext, ENT_COMPAT);
! 
! 		$hasimage = empty($question->image) ? 0 : 1;
! 		$hassize = empty($question->mediax) ? 0 : 1;
! 
! 		$allowedtags = '<a><br><b><h1><h2><h3><h4><i><img><li><ol><strong><table><tr><td><th><u><ul><object>';  // all other tags will be stripped from question text
! 		$smarty =& $this->init_smarty();
! 		$assesmentitemid = $this->get_assesment_item_id($question);
! 		$question_type = $this->get_qtype( $question->qtype );
! 		$questionid = "question{$question->id}$question_type";
! 		$smarty->assign('question_has_image', $hasimage);
! 		$smarty->assign('hassize', $hassize);
! 		$smarty->assign('questionid', $questionid);
! 		$smarty->assign('assessmentitemidentifier', $assesmentitemid);
! 		$smarty->assign('assessmentitemtitle', $question->name);
! 		$smarty->assign('courselevelexport', $courselevel);
! 
! 		if ($question->qtype == MULTIANSWER) {
! 			$question->questiontext = strip_tags($question->questiontext, $allowedtags . '<intro>');
! 			$smarty->assign('questionText',  $this->get_cloze_intro($question->questiontext));
! 		} else {
! 			$smarty->assign('questionText',  strip_tags($question->questiontext, $allowedtags));
! 		}
! 
! 		$smarty->assign('question', $question);
! 		// the following two are left for compatibility; the templates should be changed, though, to make object tags for the questions
! 		//$smarty->assign('questionimage', $question->image);
! 		//$smarty->assign('questionimagealt', "image: $question->image");
! 
! 		// output depends on question type
! 		switch($question->qtype) {
! 			case TRUEFALSE:
! 				$qanswers = $question->options->answers;
! 				$answers[0] = (array)$qanswers['true'];
! 				$answers[0]['answer'] = get_string("true", "quiz");
! 				$answers[1] = (array)$qanswers['false'];
! 				$answers[1]['answer'] = get_string("false", "quiz");
! 
! 				if (!empty($shuffleanswers)) {
! 					$answers = $this->shuffle_things($answers);
! 				}
! 
! 				if (isset($question->response)) {
! 					$correctresponseid = $question->response[$questionid];
! 					if ($answers[0]['id'] == $correctresponseid) {
! 						$correctresponse = $answers[0];
! 					} else {
! 						$correctresponse = $answers[1];
! 					}
! 				}
! 				else {
! 					$correctresponse = '';
! 				}
! 
! 				$smarty->assign('correctresponse', $correctresponse);
! 				$smarty->assign('answers', $answers);
! 				$expout = $smarty->fetch('choice.tpl');
! 				break;
! 			case MULTICHOICE:
! 				$answers = $this->objects_to_array($question->options->answers);
! 				$correctresponses = $this->get_correct_answers($answers);
! 				$correctcount = count($correctresponses);
! 				$smarty->assign('responsedeclarationcardinality', $question->options->single ? 'single' : 'multiple');
! 				$smarty->assign('operator', $question->options->single ? 'match' : 'member');
! 				$smarty->assign('correctresponses', $correctresponses);
! 				$smarty->assign('answers', $answers);
! 				$smarty->assign('maxChoices', $question->options->single ? '1' : count($answers));
! 				$smarty->assign('maxChoices', $question->options->single ? '1' : count($answers));
! 				$smarty->assign('shuffle', empty($shuffleanswers) ? 'false' : 'true');
! 				$smarty->assign('generalfeedback', $question->generalfeedback);
! 				$smarty->assign('correctfeedback', $question->options->correctfeedback);
! 				$smarty->assign('partiallycorrectfeedback', $question->options->partiallycorrectfeedback);
! 				$smarty->assign('incorrectfeedback', $question->options->incorrectfeedback);
! 				$expout = $smarty->fetch('choiceMultiple.tpl');
! 				break;
! 			case SHORTANSWER:
! 				$answers = $this->objects_to_array($question->options->answers);
! 				if (!empty($shuffleanswers)) {
! 					$answers = $this->shuffle_things($answers);
! 				}
! 
! 				$correctresponses = $this->get_correct_answers($answers);
! 				$correctcount = count($correctresponses);
! 
! 				$smarty->assign('responsedeclarationcardinality', $correctcount > 1 ? 'multiple' : 'single');
! 				$smarty->assign('correctresponses', $correctresponses);
! 				$smarty->assign('answers', $answers);
! 				$expout = $smarty->fetch('textEntry.tpl');
! 				break;
! 			case NUMERICAL:
! 				$qanswer = array_pop( $question->options->answers );
! 				$smarty->assign('lowerbound', $qanswer->answer - $qanswer->tolerance);
! 				$smarty->assign('upperbound', $qanswer->answer + $qanswer->tolerance);
! 				$smarty->assign('answer', $qanswer->answer);
! 				$expout = $smarty->fetch('numerical.tpl');
! 				break;
! 			case MATCH:
! 				$this->xml_entitize($question->options->subquestions);
! 				$subquestions = $this->objects_to_array($question->options->subquestions);
! 				if (!empty($shuffleanswers)) {
! 					$subquestions = $this->shuffle_things($subquestions);
! 				}
! 				$setcount = count($subquestions);
! 
! 				$smarty->assign('setcount', $setcount);
! 				$smarty->assign('matchsets', $subquestions);
! 				$expout = $smarty->fetch('match.tpl');
! 				break;
! 			case DESCRIPTION:
! 				$expout = $smarty->fetch('extendedText.tpl');
! 				break;
! 				// loss of get_answers() from quiz_embedded_close_qtype class during
! 				// Gustav's refactor breaks MULTIANSWER badly - one for another day!!
! 				/*
! 				case MULTIANSWER:
! 				$answers = $this->get_cloze_answers_array($question);
! 				$questions = $this->get_cloze_questions($question, $answers, $allowedtags);
! 
! 				$smarty->assign('cloze_trailing_text_id', CLOZE_TRAILING_TEXT_ID);
! 				$smarty->assign('answers', $answers);
! 				$smarty->assign('questions', $questions);
! 				$expout = $smarty->fetch('composite.tpl');
! 				break; */
! 			default:
! 				$smarty->assign('questionText', "This question type (Unknown: type $question_type)  has not yet been implemented");
! 				$expout = $smarty->fetch('notimplemented.tpl');
! 		}
! 
! 		// run through xml tidy function
! 		//$tidy_expout = $this->indent_xhtml( $expout, '    ' ) . "\n\n";
! 		//return $tidy_expout;
! 		return $expout;
! 	}
! 
! 	/**
! 	 * Gets an id to use for a qti assesment item
! 	 *
! 	 * @param object $question
! 	 * @return string containing a qti assesment item id
! 	 */
! 	function get_assesment_item_id($question) {
! 		return "question{$question->id}";
! 	}
! 
! 	/**
! 	 * gets the answers whose grade fraction > 0
! 	 *
! 	 * @param array $answers
! 	 * @return array (0-indexed) containing the answers whose grade fraction > 0
! 	 */
! 	function get_correct_answers($answers)
! 	{
! 		$correctanswers = array();
! 		foreach ($answers as $answer) {
! 			if ($answer['fraction'] > 0) {
! 				$correctanswers[] = $answer;
! 			}
! 		}
! 		return $correctanswers;
! 	}
! 
! 	/**
! 	 * gets a new Smarty object, with the template and compile directories set
! 	 *
! 	 * @return object a smarty object
! 	 */
! 	function & init_smarty() {
! 		global $CFG;
! 
! 		// create smarty compile dir in dataroot
! 		$path = $CFG->dataroot."/smarty_c";
! 		if (!is_dir($path)) {
! 			if (!mkdir($path, $CFG->directorypermissions)) {
! 				print_error('cannotcreatepath', 'question', '', $path);
! 			}
! 		}
! 		$smarty = new Smarty;
! 		$smarty->template_dir = "{$CFG->dirroot}/question/format/qti_two/templates";
! 		$smarty->compile_dir  = "$path";
! 		return $smarty;
! 	}
! 
! 	/**
! 	 * converts an array of objects to an array of arrays (not recursively)
! 	 *
! 	 * @param array $objectarray
! 	 * @return array - an array of answer arrays
! 	 */
! 	function objects_to_array($objectarray)
! 	{
! 		$arrayarray = array();
! 		foreach ($objectarray as $object) {
! 			$arrayarray[] = (array)$object;
! 		}
! 		return $arrayarray;
! 	}
! 
! 	/**
! 	 * gets a question's cloze answer objects as arrays containing only arrays and basic data types
! 	 *
! 	 * @param object $question
! 	 * @return array - an array of answer arrays
! 	 */
! 	function get_cloze_answers_array($question) {
! 		$answers = $this->get_answers($question);
! 		$this->xml_entitize($answers);
! 		foreach ($answers as $answerkey => $answer) {
! 			$answers[$answerkey]->subanswers = $this->objects_to_array($answer->subanswers);
! 		}
! 		return $this->objects_to_array($answers);
! 	}
! 
! 	/**
! 	 * gets an array with text and question arrays for the given cloze question
! 	 *
! 	 * To make smarty processing easier, the returned text and question sub-arrays have an equal number of elements.
! 	 * If it is necessary to add a dummy element to the question sub-array, the question will be given an id of CLOZE_TRAILING_TEXT_ID.
! 	 *
! 	 * @param object $question
! 	 * @param array $answers - an array of arrays containing the question's answers
! 	 * @param string $allowabletags - tags not to strip out of the question text (e.g. '<i><br>')
! 	 * @return array with text and question arrays for the given cloze question
! 	 */
! 	function get_cloze_questions($question, $answers, $allowabletags) {
! 		$questiontext = strip_tags($question->questiontext, $allowabletags);
! 		if (preg_match_all('/(.*){#([0-9]+)}/U', $questiontext, $matches)) {
! 			// matches[1] contains the text inbetween the question blanks
! 			// matches[2] contains the id of the question blanks (db: question_multianswer.positionkey)
! 
! 			// find any trailing text after the last {#XX} and add it to the array
! 			if (preg_match('/.*{#[0-9]+}(.*)$/', $questiontext, $tail)) {
! 				$matches[1][] = $tail[1];
! 				$tailadded = true;
! 			}
! 			$questions['text'] = $matches[1];
! 			$questions['question'] = array();
! 			foreach ($matches[2] as $key => $questionid) {
! 				foreach ($answers as $answer) {
! 					if ($answer['positionkey'] == $questionid) {
! 						$questions['question'][$key] = $answer;
! 						break;
! 					}
! 				}
! 			}
! 			if ($tailadded) {
! 				// to have a matching number of question and text array entries:
! 				$questions['question'][] = array('id'=>CLOZE_TRAILING_TEXT_ID, 'answertype'=>SHORTANSWER);
! 			}
! 
! 		} else {
! 			$questions['text'][0] = $question->questiontext;
! 			$questions['question'][0] = array('id'=>CLOZE_TRAILING_TEXT_ID, 'answertype'=>SHORTANSWER);
! 		}
! 
! 		return $questions;
! 	}
! 
! 	/**
! 	 * strips out the <intro>...</intro> section, if any, and returns the text
! 	 *
! 	 * changes the text object passed to it.
! 	 *
! 	 * @param string $&text
! 	 * @return string the intro text, if there was an intro tag. '' otherwise.
! 	 */
! 	function get_cloze_intro(&$text) {
! 		if (preg_match('/(.*)?\<intro>(.+)?\<\/intro>(.*)/s', $text, $matches)) {
! 			$text = $matches[1] . $matches[3];
! 			return $matches[2];
! 		}
! 		else {
! 			return '';
! 		}
! 	}
! 
! 
! 	/**
! 	 * adds qti metadata properties to the questions
! 	 *
! 	 * The passed array of questions is altered by this function
! 	 *
! 	 * @param &questions an array of question objects
! 	 */
! 	function add_qti_info(&$questions)
! 	{
! 		foreach ($questions as $key=>$question) {
! 			$questions[$key]->qtiinteractiontype = $this->get_qti_interaction_type($question->qtype);
! 			$questions[$key]->qtiscoreable = $this->get_qti_scoreable($question);
! 			$questions[$key]->qtisolutionavailable = $this->get_qti_solution_available($question);
! 		}
! 
! 	}
! 
! 	/**
! 	 * returns whether or not a given question is scoreable
! 	 *
! 	 * @param object $question
! 	 * @return boolean
! 	 */
! 	function get_qti_scoreable($question) {
! 		switch ($question->qtype) {
! 			case DESCRIPTION:
! 				return 'false';
! 			default:
! 				return 'true';
! 		}
! 	}
! 
! 	/**
! 	 * returns whether or not a solution is available for a given question
! 	 *
! 	 * The results are based on whether or not Moodle stores answers for the given question type
! 	 *
! 	 * @param object $question
! 	 * @return boolean
! 	 */
! 	function get_qti_solution_available($question) {
! 		switch($question->qtype) {
! 			case TRUEFALSE:
! 				return 'true';
! 			case MULTICHOICE:
! 				return 'true';
! 			case SHORTANSWER:
! 				return 'true';
! 			case NUMERICAL:
! 				return 'true';
! 			case MATCH:
! 				return 'true';
! 			case DESCRIPTION:
! 				return 'false';
! 			case MULTIANSWER:
! 				return 'true';
! 			default:
! 				return 'true';
! 		}
! 
! 	}
! 
! 	/**
! 	 * maps a moodle question type to a qti 2.0 question type
! 	 *
! 	 * @param int type_id - the moodle question type
! 	 * @return string qti 2.0 question type
! 	 */
! 	function get_qti_interaction_type($type_id) {
! 		switch( $type_id ) {
! 			case TRUEFALSE:
! 				$name = 'choiceInteraction';
! 				break;
! 			case MULTICHOICE:
! 				$name = 'choiceInteraction';
! 				break;
! 			case SHORTANSWER:
! 				$name = 'textInteraction';
! 				break;
! 			case NUMERICAL:
! 				$name = 'textInteraction';
! 				break;
! 			case MATCH:
! 				$name = 'matchInteraction';
! 				break;
! 			case DESCRIPTION:
! 				$name = 'extendedTextInteraction';
! 				break;
! 			case MULTIANSWER:
! 				$name = 'textInteraction';
! 				break;
! 			default:
! 				$name = 'textInteraction';
! 		}
! 		return $name;
! 	}
! 
! 	/**
! 	 * returns the given array, shuffled
! 	 *
! 	 *
! 	 * @param array $things
! 	 * @return array
! 	 */
! 	function shuffle_things($things) {
! 		$things = swapshuffle_assoc($things);
! 		$oldthings = $things;
! 		$things = array();
! 		foreach ($oldthings as $key=>$value) {
! 			$things[] = $value;      // This loses the index key, but doesn't matter
! 		}
! 		return $things;
! 	}
! 
! 	/**
! 	 * returns a flattened image name - with all /, \ and : replaced with other characters
! 	 *
! 	 * used to convert a file or url to a qti-permissable identifier
! 	 *
! 	 * @param string name
! 	 * @return string
! 	 */
! 	function flatten_image_name($name) {
! 		return str_replace(array('/', '\\', ':'), array ('_','-','.'), $name);
! 	}
! 
! 	function file_full_path($file, $courseid) {
! 		global $CFG;
! 		if (substr(strtolower($file), 0, 7) == 'http://') {
! 			$url = $file;
! 		} else if ($CFG->slasharguments) {        // Use this method if possible for better caching
! 			$url = "{$CFG->wwwroot}/file.php/$courseid/{$file}";
! 		} else {
! 			$url = "{$CFG->wwwroot}/file.php?file=/$courseid/{$file}";
! 		}
! 		return $url;
! 	}
  
  }
  
diff -crB questionorg/format/qti_two/qt_common.php questionupd/format/qti_two/qt_common.php
*** questionorg/format/qti_two/qt_common.php	2012-04-13 12:31:11.568178250 +0500
--- questionupd/format/qti_two/qt_common.php	2012-04-13 09:42:53.000000000 +0500
***************
*** 17,35 ****
   */
  function get_course_media_files($courseid)
  {
! // this code lifted from mod/quiz/question.php and modified
! throw new coding_exception('qti_two not converted to new fil api yet, sorry');
!     /*global $CFG;
!     $images = null;
! 
!     make_upload_directory("$course->id");    // Just in case
!     $coursefiles = get_directory_list("$CFG->dataroot/$courseid", $CFG->moddata);
!     foreach ($coursefiles as $filename) {
!         if (is_media_by_extension($filename)) {
!             $images["$filename"] = $filename;
!         }
!     }
!     return $images;*/
  }
  
  /**
--- 17,35 ----
   */
  function get_course_media_files($courseid)
  {
! 	// this code lifted from mod/quiz/question.php and modified
! 	throw new coding_exception('qti_two not converted to new fil api yet, sorry');
! 	/*global $CFG;
! 	 $images = null;
! 
! 	 make_upload_directory("$course->id");    // Just in case
! 	 $coursefiles = get_directory_list("$CFG->dataroot/$courseid", $CFG->moddata);
! 	 foreach ($coursefiles as $filename) {
! 	 if (is_media_by_extension($filename)) {
! 	 $images["$filename"] = $filename;
! 	 }
! 	 }
! 	 return $images;*/
  }
  
  /**
***************
*** 39,49 ****
   * @return boolean
   */
  function is_image_by_extension($file) {
!     $extensionsregex = '/\.(gif|jpg|jpeg|jpe|png|tif|tiff|bmp|xbm|rgb|svf)$/';
!     if (preg_match($extensionsregex, $file)) {
!         return true;
!     }
!     return false;
  }
  
  
--- 39,49 ----
   * @return boolean
   */
  function is_image_by_extension($file) {
! 	$extensionsregex = '/\.(gif|jpg|jpeg|jpe|png|tif|tiff|bmp|xbm|rgb|svf)$/';
! 	if (preg_match($extensionsregex, $file)) {
! 		return true;
! 	}
! 	return false;
  }
  
  
***************
*** 54,64 ****
   * @return boolean
   */
  function is_media_by_extension($file) {
!     $extensionsregex = '/\.(gif|jpg|jpeg|jpe|png|tif|tiff|bmp|xbm|rgb|svf|swf|mov|mpg|mpeg|wmf|avi|mpe|flv|mp3|ra|ram)$/';
!     if (preg_match($extensionsregex, $file)) {
!         return true;
!     }
!     return false;
  }
  
  /**
--- 54,64 ----
   * @return boolean
   */
  function is_media_by_extension($file) {
! 	$extensionsregex = '/\.(gif|jpg|jpeg|jpe|png|tif|tiff|bmp|xbm|rgb|svf|swf|mov|mpg|mpeg|wmf|avi|mpe|flv|mp3|ra|ram)$/';
! 	if (preg_match($extensionsregex, $file)) {
! 		return true;
! 	}
! 	return false;
  }
  
  /**
***************
*** 68,78 ****
   * @return boolean
   */
  function is_multimedia_by_extension($file) {
!     $extensionsregex = '/\.(swf|mov|mpg|mpeg|wmf|avi|mpe|flv)$/';
!     if (preg_match($extensionsregex, $file)) {
!         return true;
!     }
!     return false;
  }
  
  /**
--- 68,78 ----
   * @return boolean
   */
  function is_multimedia_by_extension($file) {
! 	$extensionsregex = '/\.(swf|mov|mpg|mpeg|wmf|avi|mpe|flv)$/';
! 	if (preg_match($extensionsregex, $file)) {
! 		return true;
! 	}
! 	return false;
  }
  
  /**
***************
*** 82,92 ****
   * @return boolean
   */
  function is_sizable_multimedia($file) {
!     $extensionsregex = '/\.(swf)$/';
!     if (preg_match($extensionsregex, $file)) {
!         return true;
!     }
!     return false;
  }
  
  /**
--- 82,92 ----
   * @return boolean
   */
  function is_sizable_multimedia($file) {
! 	$extensionsregex = '/\.(swf)$/';
! 	if (preg_match($extensionsregex, $file)) {
! 		return true;
! 	}
! 	return false;
  }
  
  /**
***************
*** 98,135 ****
   * @return string either an image tag, or html for an embedded object
   */
  function get_media_tag($file, $courseid = 0, $alt = 'media file', $width = 0, $height = 0) {
!     global $CFG;
  
!     // if it's a moodle library file, it will be served through file.php
!     if (substr(strtolower($file), 0, 7) == 'http://') {
!         $media = $file;
!     } else if ($CFG->slasharguments) {        // Use this method if possible for better caching
!         $media = "{$CFG->wwwroot}/file.php/$courseid/$file";
!     } else {
!         $media = "{$CFG->wwwroot}/file.php?file=/$courseid/$file";
!     }
! 
!     $ismultimedia = false;
!     if (!$isimage = is_image_by_extension($file)) {
!            $ismultimedia = is_multimedia_by_extension($file);
!     }
! 
!     // if there is no known width and height, try to get one
!     if ($width == 0) {
!          if ($isimage || is_sizable_multimedia($file)) {
! 
!          }
! 
!     }
!     // create either an image link or a generic link.
!     // if the moodle multimedia filter is turned on, it'll catch multimedia content in the generic link
!     if (is_image_by_extension($file)) {
!         return "<img src=\"$media\" alt=\"$alt\" width=\"$width\" height=\"$height\" />";
!     }
!     else {
!         require_once("$CFG->dirroot/mod/quiz/format/qti/custommediafilter.php");
!         return custom_mediaplugin_filter('<a href="' . $media . '"></a>', $courseid, $width, $height);
!     }
  }
  
  /**
--- 98,135 ----
   * @return string either an image tag, or html for an embedded object
   */
  function get_media_tag($file, $courseid = 0, $alt = 'media file', $width = 0, $height = 0) {
! 	global $CFG;
  
! 	// if it's a moodle library file, it will be served through file.php
! 	if (substr(strtolower($file), 0, 7) == 'http://') {
! 		$media = $file;
! 	} else if ($CFG->slasharguments) {        // Use this method if possible for better caching
! 		$media = "{$CFG->wwwroot}/file.php/$courseid/$file";
! 	} else {
! 		$media = "{$CFG->wwwroot}/file.php?file=/$courseid/$file";
! 	}
! 
! 	$ismultimedia = false;
! 	if (!$isimage = is_image_by_extension($file)) {
! 		$ismultimedia = is_multimedia_by_extension($file);
! 	}
! 
! 	// if there is no known width and height, try to get one
! 	if ($width == 0) {
! 		if ($isimage || is_sizable_multimedia($file)) {
! 
! 		}
! 
! 	}
! 	// create either an image link or a generic link.
! 	// if the moodle multimedia filter is turned on, it'll catch multimedia content in the generic link
! 	if (is_image_by_extension($file)) {
! 		return "<img src=\"$media\" alt=\"$alt\" width=\"$width\" height=\"$height\" />";
! 	}
! 	else {
! 		require_once("$CFG->dirroot/mod/quiz/format/qti/custommediafilter.php");
! 		return custom_mediaplugin_filter('<a href="' . $media . '"></a>', $courseid, $width, $height);
! 	}
  }
  
  /**
***************
*** 139,150 ****
   * @return array looks like array('x'=>171, 'y'=>323), or array('x'=>0, 'y'=>0) if size can't be determined
   */
  function get_file_dimensions($file) {
!     $imginfo = @getimagesize($file);
!     if ($imginfo !== FALSE) {
!         return array('x'=>$imginfo[0], 'y'=>$imginfo[1]);
!     } else {
!         return array('x'=> 0, 'y'=> 0);
!     }
  }
  
  
--- 139,150 ----
   * @return array looks like array('x'=>171, 'y'=>323), or array('x'=>0, 'y'=>0) if size can't be determined
   */
  function get_file_dimensions($file) {
! 	$imginfo = @getimagesize($file);
! 	if ($imginfo !== FALSE) {
! 		return array('x'=>$imginfo[0], 'y'=>$imginfo[1]);
! 	} else {
! 		return array('x'=> 0, 'y'=> 0);
! 	}
  }
  
  
diff -crB questionorg/format/qti_two/templates/choiceMultiple.tpl questionupd/format/qti_two/templates/choiceMultiple.tpl
*** questionorg/format/qti_two/templates/choiceMultiple.tpl	2012-04-13 12:31:11.522178257 +0500
--- questionupd/format/qti_two/templates/choiceMultiple.tpl	2012-04-13 09:42:53.000000000 +0500
***************
*** 1,111 ****
! {if $courselevelexport}<?xml version="1.0" encoding="UTF-8"?>{/if}
  <assessmentItem xmlns="http://www.imsglobal.org/xsd/imsqti_v2p0"
! 				xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
! 				xsi:schemaLocation="http://www.imsglobal.org/xsd/imsqti_v2p0 imsqti_v2p0.xsd"
! 				identifier="{$assessmentitemidentifier}" title="{$assessmentitemtitle}" adaptive="false" timeDependent="false">
! 	<responseDeclaration identifier="{$questionid}" cardinality="{$responsedeclarationcardinality}" baseType="identifier">
! 		<correctResponse>
! 		{section name=answer loop=$correctresponses}
! 			<value>{$correctresponses[answer].id}</value>
! 		{/section}
! 		</correctResponse>
! 	</responseDeclaration>
! 	<outcomeDeclaration identifier="SCORE" cardinality="single" baseType="float">
! 		<defaultValue>
! 			<value>0</value>
! 		</defaultValue>
! 	</outcomeDeclaration>
! 	<outcomeDeclaration identifier="FEEDBACK" cardinality="{$responsedeclarationcardinality}" baseType="identifier"/>
! 	<outcomeDeclaration identifier="FEEDBACK2" cardinality="single" baseType="identifier"/>
! 	<itemBody>
! 	   <div class="assesmentItemBody">
! 		<p>{$questionText}</p>
!        </div>
! 	{if $question_has_image == 1}
! 		<div class="media">
! 	    {if $hassize == 1}
! 			<object type="{$question->mediamimetype}" data="{$question->mediaurl}" width="{$question->mediax}" height="{$question->mediay}" />
! 		{else}
! 			<object type="{$question->mediamimetype}" data="{$question->mediaurl}" />
! 		{/if}
! 		</div>
  	{/if}
! 		<div class="interactive.choiceMultiple">
! 			<choiceInteraction responseIdentifier="{$questionid}" shuffle="{$shuffle}" maxChoices="{$maxChoices}">
!     		{section name=answer loop=$answers}
! 				<simpleChoice identifier="i{$answers[answer].id}">{$answers[answer].answer}
! 				{if $answers[answer].feedback != ''}
!     				{if $answers[answer].answer != $correctresponse.answer}
! 	   			    <feedbackInline identifier="i{$answers[answer].id}" outcomeIdentifier="FEEDBACK" showHide="show">{$answers[answer].feedback}</feedbackInline>
!                     {/if}
!                 {/if}
! 				</simpleChoice>
!     		{/section}
! 			</choiceInteraction>
! 		</div>
! 	</itemBody>
! 	<responseProcessing>
! 		{section name=answer loop=$answers}
! 		<responseCondition>
! 			<responseIf>
! 				<{$operator}>
! 					<baseValue baseType="identifier">i{$answers[answer].id}</baseValue>
! 					<variable identifier="{$questionid}"/>
! 				</{$operator}>
! 				<setOutcomeValue identifier="SCORE">
  					<sum>
! 						<variable identifier="SCORE"/>
  						<baseValue baseType="float">{$answers[answer].fraction}</baseValue>
  					</sum>
  				</setOutcomeValue>
! 			</responseIf>
! 		</responseCondition>
! 		{/section}
! 		<responseCondition>
! 			<responseIf>
! 				<lte>
! 					<variable identifier="SCORE"/>
! 					<baseValue baseType="float">0</baseValue>
! 				</lte>
! 				<setOutcomeValue identifier="SCORE">
! 					<baseValue baseType="float">0</baseValue>
! 				</setOutcomeValue>
! 				<setOutcomeValue identifier="FEEDBACK2">
! 					<baseValue baseType="identifier">INCORRECT</baseValue>
! 				</setOutcomeValue>
! 			</responseIf>
! 			<responseElseIf>
! 				<gte>
! 					<variable identifier="SCORE"/>
! 					<baseValue baseType="float">0.99</baseValue>
! 				</gte>
! 				<setOutcomeValue identifier="SCORE">
! 					<baseValue baseType="float">1</baseValue>
! 				</setOutcomeValue>
! 				<setOutcomeValue identifier="FEEDBACK2">
! 					<baseValue baseType="identifier">CORRECT</baseValue>
! 				</setOutcomeValue>
! 			</responseElseIf>
! 			<responseElse>
! 				<setOutcomeValue identifier="FEEDBACK2">
! 					<baseValue baseType="identifier">PARTIAL</baseValue>
! 				</setOutcomeValue>
! 			</responseElse>
! 		</responseCondition>
!         <setOutcomeValue identifier="FEEDBACK">
!             <variable identifier="{$questionid}"/>
!         </setOutcomeValue>		
! 	</responseProcessing>
!     {if $correctfeedback != ''}
! 	<modalFeedback outcomeIdentifier="FEEDBACK2" identifier="CORRECT" showHide="show">{$correctfeedback}</modalFeedback>
!  	{/if}
!     {if $partiallycorrectfeedback != ''}
! 	<modalFeedback outcomeIdentifier="FEEDBACK2" identifier="PARTIAL" showHide="show">{$partiallycorrectfeedback}</modalFeedback>
!  	{/if}
!     {if $incorrectfeedback != ''}
! 	<modalFeedback outcomeIdentifier="FEEDBACK2" identifier="INCORRECT" showHide="show">{$incorrectfeedback}</modalFeedback>
!  	{/if}
!     {if $generalfeedback != ''}
! 	<modalFeedback outcomeIdentifier="completionStatus" identifier="not_attempted" showHide="hide">{$generalfeedback}</modalFeedback>
!  	{/if}
! </assessmentItem>
--- 1,73 ----
! {if $courselevelexport}
! <?xml version="1.0" encoding="UTF-8"?>
! {/if}
  <assessmentItem xmlns="http://www.imsglobal.org/xsd/imsqti_v2p0"
! 	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
! 	xsi:schemaLocation="http://www.imsglobal.org/xsd/imsqti_v2p0 imsqti_v2p0.xsd"
! 	identifier="{$assessmentitemidentifier}" title="{$assessmentitemtitle}"
! 	adaptive="false" timeDependent="false"> <responseDeclaration
! 	identifier="{$questionid}"
! 	cardinality="{$responsedeclarationcardinality}" baseType="identifier">
! <correctResponse> {section name=answer loop=$correctresponses} <value>{$correctresponses[answer].id}</value>
! {/section} </correctResponse> </responseDeclaration> <outcomeDeclaration
! 	identifier="SCORE" cardinality="single" baseType="float"> <defaultValue>
! <value>0</value> </defaultValue> </outcomeDeclaration> <outcomeDeclaration
! 	identifier="FEEDBACK" cardinality="{$responsedeclarationcardinality}"
! 	baseType="identifier" /> <outcomeDeclaration identifier="FEEDBACK2"
! 	cardinality="single" baseType="identifier" /> <itemBody>
! <div class="assesmentItemBody">
! 	<p>{$questionText}</p>
! </div>
! {if $question_has_image == 1}
! <div class="media">
! 	{if $hassize == 1}
! 	<object type="{$question->mediamimetype}" data="{$question->mediaurl}"
! 		width="{$question->mediax}" height="{$question->mediay}" />
! 	{else}
! 	<object type="{$question->mediamimetype}" data="{$question->mediaurl}" />
  	{/if}
! </div>
! {/if}
! <div class="interactive.choiceMultiple">
! 	<choiceInteraction responseIdentifier="{$questionid}"
! 		shuffle="{$shuffle}" maxChoices="{$maxChoices}"> {section name=answer
! 	loop=$answers} <simpleChoice identifier="i{$answers[answer].id}">{$answers[answer].answer}
! 	{if $answers[answer].feedback != ''} {if $answers[answer].answer !=
! 	$correctresponse.answer} <feedbackInline
! 		identifier="i{$answers[answer].id}" outcomeIdentifier="FEEDBACK"
! 		showHide="show">{$answers[answer].feedback}</feedbackInline> {/if}
! 	{/if} </simpleChoice> {/section} </choiceInteraction>
! </div>
! </itemBody> <responseProcessing> {section name=answer loop=$answers} <responseCondition>
! <responseIf> <{$operator}> <baseValue baseType="identifier">i{$answers[answer].id}</baseValue>
! <variable identifier="{$questionid}" /> </{$operator}> 
! 
! <setOutcomeValue identifier="SCORE">
  					<sum>
! 						<variable identifier="SCORE" />
  						<baseValue baseType="float">{$answers[answer].fraction}</baseValue>
  					</sum>
  				</setOutcomeValue>
! 			</responseIf> </responseCondition> {/section} <responseCondition> <responseIf>
! <lte> <variable identifier="SCORE" /> <baseValue baseType="float">0</baseValue>
! </lte> <setOutcomeValue identifier="SCORE"> <baseValue baseType="float">0</baseValue>
! </setOutcomeValue> <setOutcomeValue identifier="FEEDBACK2"> <baseValue
! 	baseType="identifier">INCORRECT</baseValue> </setOutcomeValue> </responseIf>
! <responseElseIf> <gte> <variable identifier="SCORE" /> <baseValue
! 	baseType="float">0.99</baseValue> </gte> <setOutcomeValue
! 	identifier="SCORE"> <baseValue baseType="float">1</baseValue> </setOutcomeValue>
! <setOutcomeValue identifier="FEEDBACK2"> <baseValue
! 	baseType="identifier">CORRECT</baseValue> </setOutcomeValue> </responseElseIf>
! <responseElse> <setOutcomeValue identifier="FEEDBACK2"> <baseValue
! 	baseType="identifier">PARTIAL</baseValue> </setOutcomeValue> </responseElse>
! </responseCondition> <setOutcomeValue identifier="FEEDBACK"> <variable
! 	identifier="{$questionid}" /> </setOutcomeValue> </responseProcessing>
! {if $correctfeedback != ''} <modalFeedback outcomeIdentifier="FEEDBACK2"
! 	identifier="CORRECT" showHide="show">{$correctfeedback}</modalFeedback>
! {/if} {if $partiallycorrectfeedback != ''} <modalFeedback
! 	outcomeIdentifier="FEEDBACK2" identifier="PARTIAL" showHide="show">{$partiallycorrectfeedback}</modalFeedback>
! {/if} {if $incorrectfeedback != ''} <modalFeedback
! 	outcomeIdentifier="FEEDBACK2" identifier="INCORRECT" showHide="show">{$incorrectfeedback}</modalFeedback>
! {/if} {if $generalfeedback != ''} <modalFeedback
! 	outcomeIdentifier="completionStatus" identifier="not_attempted"
! 	showHide="hide">{$generalfeedback}</modalFeedback> {/if} </assessmentItem>
diff -crB questionorg/format/qti_two/templates/choice.tpl questionupd/format/qti_two/templates/choice.tpl
*** questionorg/format/qti_two/templates/choice.tpl	2012-04-13 12:31:11.435178254 +0500
--- questionupd/format/qti_two/templates/choice.tpl	2012-04-13 09:42:53.000000000 +0500
***************
*** 1,70 ****
! {if $courselevelexport}<?xml version="1.0" encoding="UTF-8"?>{/if}
! <assessmentItem xmlns="http://www.imsglobal.org/xsd/imsqti_item_v2p0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.imsglobal.org/xsd/imsqti_item_v2p0 ./imsqti_item_v2p0.xsd" identifier="{$assessmentitemidentifier}" title="{$assessmentitemtitle}" adaptive="false" timeDependent="false">
! 	<responseDeclaration identifier="{$questionid}" cardinality="single" baseType="identifier">
! 		<correctResponse>
! 			<value>{$correctresponse.id}</value>
! 		</correctResponse>
! 		<mapping defaultValue="0">
! 			<mapEntry mapKey="{$correctresponse.id}" mappedValue="{$correctresponse.fraction}"/>
! 		</mapping>
! 
! 	</responseDeclaration>
! 	<outcomeDeclaration identifier="SCORE" cardinality="single" baseType="float">
! 		<defaultValue>
! 			<value>0</value>
! 		</defaultValue>
! 	</outcomeDeclaration>
! 	<itemBody>
! 		<p>{$questionText}</p>
! 		<div class="intreactive.choiceSimple">
! 			<choiceInteraction responseIdentifier="{$questionid}" shuffle="false" maxChoices="1">
!     		{section name=answer loop=$answers}
! 				<simpleChoice identifier="{$answers[answer].id}">{$answers[answer].answer}
! 				{if $answers[answer].feedback != ''}
!     				{if $answers[answer].answer != $correctresponse.answer}
! 	   			    <feedbackInline identifier="{$answers[answer].id}" outcomeIdentifier="FEEDBACK" showHide="hide">{$answers[answer].feedback}</feedbackInline>
!                     {/if}
!                 {/if}
! 				</simpleChoice>
!     		{/section}
! 			</choiceInteraction>
  	{if $question_has_image == 1}
!             <div class="media">
! 	    {if $hassize == 1}
! 			 <object type="{$question->mediamimetype}" data="{$question->mediaurl}" width="{$question->mediax}" height="{$question->mediay}" />
  		{else}
! 			 <object type="{$question->mediamimetype}" data="{$question->mediaurl}" />
  		{/if}
!             </div>
  	{/if}
! 		</div>
! 	</itemBody>
! 	<responseProcessing xmlns="http://www.imsglobal.org/xsd/imsqti_item_v2p0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.imsglobal.org/xsd/imsqti_item_v2p0 ../imsqti_item_v2p0.xsd">
! 		<responseCondition>
! 			<responseIf>
! 
! 				<match>
! 					<variable identifier="{$questionid}"/>
! 					<correct identifier="{$questionid}"/>
! 				</match>
! 				<setOutcomeValue identifier="SCORE">
! 					<baseValue baseType="float">1</baseValue>
! 				</setOutcomeValue>
! 			</responseIf>
! 
! 			<responseElse>
! 				<setOutcomeValue identifier="SCORE">
! 					<baseValue baseType="float">0</baseValue>
! 				</setOutcomeValue>
! 			</responseElse>
! 		</responseCondition>
!         <setOutcomeValue identifier="FEEDBACK">
!             <variable identifier="{$questionid}"/>
!         </setOutcomeValue>		
! 	</responseProcessing>
! 	{section name=answer loop=$answers}
!         {if $answers[answer].feedback != ''}
! 	<modalFeedback outcomeIdentifier="FEEDBACK" identifier="{$answers[answer].id}" showHide="hide">{$answers[answer].feedback}</modalFeedback>
!     	{/if}
! 	{/section}
! </assessmentItem>
--- 1,52 ----
! {if $courselevelexport}
! <?xml version="1.0" encoding="UTF-8"?>
! {/if}
! <assessmentItem xmlns="http://www.imsglobal.org/xsd/imsqti_item_v2p0"
! 	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
! 	xsi:schemaLocation="http://www.imsglobal.org/xsd/imsqti_item_v2p0 ./imsqti_item_v2p0.xsd"
! 	identifier="{$assessmentitemidentifier}" title="{$assessmentitemtitle}"
! 	adaptive="false" timeDependent="false"> <responseDeclaration
! 	identifier="{$questionid}" cardinality="single" baseType="identifier">
! <correctResponse> <value>{$correctresponse.id}</value> </correctResponse>
! <mapping defaultValue="0"> <mapEntry mapKey="{$correctresponse.id}"
! 	mappedValue="{$correctresponse.fraction}" /> </mapping> </responseDeclaration>
! <outcomeDeclaration identifier="SCORE" cardinality="single"
! 	baseType="float"> <defaultValue> <value>0</value> </defaultValue> </outcomeDeclaration>
! <itemBody>
! <p>{$questionText}</p>
! <div class="intreactive.choiceSimple">
! 	<choiceInteraction responseIdentifier="{$questionid}" shuffle="false"
! 		maxChoices="1"> {section name=answer loop=$answers} <simpleChoice
! 		identifier="{$answers[answer].id}">{$answers[answer].answer} {if
! 	$answers[answer].feedback != ''} {if $answers[answer].answer !=
! 	$correctresponse.answer} <feedbackInline
! 		identifier="{$answers[answer].id}" outcomeIdentifier="FEEDBACK"
! 		showHide="hide">{$answers[answer].feedback}</feedbackInline> {/if}
! 	{/if} </simpleChoice> {/section} </choiceInteraction>
  	{if $question_has_image == 1}
! 	<div class="media">
! 		{if $hassize == 1}
! 		<object type="{$question->mediamimetype}" data="{$question->mediaurl}"
! 			width="{$question->mediax}" height="{$question->mediay}" />
  		{else}
! 		<object type="{$question->mediamimetype}" data="{$question->mediaurl}" />
  		{/if}
! 	</div>
  	{/if}
! </div>
! </itemBody> <responseProcessing
! 	xmlns="http://www.imsglobal.org/xsd/imsqti_item_v2p0"
! 	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
! 	xsi:schemaLocation="http://www.imsglobal.org/xsd/imsqti_item_v2p0 ../imsqti_item_v2p0.xsd">
! <responseCondition> <responseIf> <match> <variable
! 	identifier="{$questionid}" /> <correct identifier="{$questionid}" /> </match>
! <setOutcomeValue identifier="SCORE"> <baseValue baseType="float">1</baseValue>
! </setOutcomeValue> </responseIf> <responseElse> <setOutcomeValue
! 	identifier="SCORE"> <baseValue baseType="float">0</baseValue> </setOutcomeValue>
! </responseElse> </responseCondition> <setOutcomeValue
! 	identifier="FEEDBACK"> <variable identifier="{$questionid}" /> </setOutcomeValue>
! </responseProcessing> {section name=answer loop=$answers} {if
! $answers[answer].feedback != ''} <modalFeedback
! 	outcomeIdentifier="FEEDBACK" identifier="{$answers[answer].id}"
! 	showHide="hide">{$answers[answer].feedback}</modalFeedback> {/if}
! {/section} </assessmentItem>
diff -crB questionorg/format/qti_two/templates/composite.tpl questionupd/format/qti_two/templates/composite.tpl
*** questionorg/format/qti_two/templates/composite.tpl	2012-04-13 12:31:11.475178256 +0500
--- questionupd/format/qti_two/templates/composite.tpl	2012-04-13 09:42:53.000000000 +0500
***************
*** 1,101 ****
! {if $courselevelexport}<?xml version="1.0" encoding="UTF-8"?>{/if}
! <assessmentItem xmlns="http://www.imsglobal.org/xsd/imsqti_item_v2p0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.imsglobal.org/xsd/imsqti_item_v2p0 ./imsqti_item_v2p0.xsd" identifier="{$assessmentitemidentifier}" title="{$assessmentitemtitle}" adaptive="false" timeDependent="false">
! 	{section name=aid loop=$answers}
! 	{if $answers[aid].answertype == 3}
!     	<responseDeclaration identifier="{$questionid}{$answers[aid].id}" cardinality="single" baseType="identifier">
!     		<correctResponse>
!     	    {section name=subanswer loop=$answers[aid].subanswers}
!     	    {if $answers[aid].subanswers[subanswer].fraction > 0}
!     			<value>{$answers[aid].subanswers[subanswer].id}</value>
!     		{/if}
!     		{/section}
!     		</correctResponse>
!     		<mapping defaultValue="0">
!     	    {section name=subanswer loop=$answers[aid].subanswers}
!     	    {if $answers[aid].subanswers[subanswer].fraction != 0}
!     			<mapEntry mapKey="{$answers[aid].subanswers[subanswer].id}" mappedValue="{$answers[aid].subanswers[subanswer].fraction}"/>
!     		{/if}
!     		{/section}
!     		</mapping>
!     	</responseDeclaration>
!     {elseif $answers[aid].answertype == 1}
!     	<responseDeclaration identifier="{$questionid}{$answers[aid].id}" cardinality="single" baseType="string">
!     		<correctResponse>
!     		{section name=subanswer loop=$answers[aid].subanswers}
!     		{if $answers[aid].subanswers[subanswer].fraction > 0}
!     			<value>{$answers[aid].subanswers[subanswer].answer}</value>
!     		{/if}
!     		{/section}
!     		</correctResponse>
!     		<mapping lowerBound="0" upperBound="1" defaultValue="0">
!     		{section name=subanswer loop=$answers[aid].subanswers}
!     		    {if $answers[aid].subanswers[subanswer].fraction != 0}
!     			<mapEntry mapKey="{$answers[aid].subanswers[subanswer].answer}" mappedValue="{$answers[aid].subanswers[subanswer].fraction}" />
!     			{/if}
!     		{/section}
!     		</mapping>
!     	</responseDeclaration>
  	{/if}
! 	{/section}
! 	<outcomeDeclaration identifier="SCORE" cardinality="single" baseType="float"/>
! 	<itemBody>
! 	{if $questionText != ''}
! 	    <div class="assesmentItemBody">
!     		<p>{$questionText}</p>
! 		</div>
! 	{/if}
! 	<div class="interactive.cloze"><p>
! 	{section name=qid loop=$questions.question}
! 	    {$questions.text[qid]}
! 	    {if $questions.question[qid].id != $cloze_trailing_text_id}
!     		{if $questions.question[qid].answertype == 3}
! 		        <inlineChoiceInteraction responseIdentifier="{$questionid}{$questions.question[qid].id}" shuffle="false">
!                     {section name=aid loop=$questions.question[qid].subanswers}
! 					   <inlineChoice identifier="{$questions.question[qid].subanswers[aid].id}">{$questions.question[qid].subanswers[aid].answer}</inlineChoice>
! 					{/section}
! 				</inlineChoiceInteraction>
!         	{elseif $questions.question[qid].answertype == 1}
!                 <textEntryInteraction responseIdentifier="{$questionid}{$questions.question[qid].id}" expectedLength="15"/>
!            	{/if}
!     	{/if}
! 	{/section}</p></div>
!     	{if $question_has_image == 1}
!     		<div class="media">
!     	    {if $hassize == 1}
!     			<object type="{$question->mediamimetype}" data="{$question->mediaurl}" width="{$question->mediax}" height="{$question->mediay}" />
!     		{else}
!     			<object type="{$question->mediamimetype}" data="{$question->mediaurl}" />
!     		{/if}
!     		</div>
!     	{/if}
! 	</itemBody>
! 	<responseProcessing xmlns="http://www.imsglobal.org/xsd/imsqti_item_v2p0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.imsglobal.org/xsd/imsqti_item_v2p0 ../imsqti_item_v2p0.xsd">
! {section name=answer loop=$answers}{if $answers[answer].answertype == 1 || $answers[answer].answertype == 3}
! 		<responseCondition>
! 			<responseIf>
! 				<isNull>
! 					<variable identifier="{$questionid}{$answers[answer].id}"/>
! 				</isNull>
! 				<setOutcomeValue identifier="SCORE{$questionid}{$answers[answer].id}">
! 					<baseValue baseType="float">0</baseValue>
! 				</setOutcomeValue>
! 			</responseIf>
! 			<responseElse>
! 				<setOutcomeValue identifier="SCORE{$questionid}{$answers[answer].id}">
! 					<mapResponse identifier="{$questionid}{$answers[answer].id}"/>
! 				</setOutcomeValue>
! 			</responseElse>
! 		</responseCondition>
!         <setOutcomeValue identifier="FEEDBACK">
!             <variable identifier="{$questionid}{$answers[answer].id}"/>
!         </setOutcomeValue>		
! {/if}{/section}
! 	</responseProcessing>
! {section name=answer loop=$answers}{if $answers[answer].answertype == 1 || $answers[answer].answertype == 3}
! 	   {section name=subanswer loop=$answers[answer].subanswers}
!        {if $answers[answer].subanswers[subanswer].feedback != ''}
! 	<modalFeedback outcomeIdentifier="FEEDBACK" identifier="{$answers[answer].subanswers[subanswer].id}" showHide="show">{$answers[answer].subanswers[subanswer].feedback}</modalFeedback>
! {/if}{/section}
!     {/if}
! 	{/section}
! </assessmentItem>
--- 1,86 ----
! {if $courselevelexport}
! <?xml version="1.0" encoding="UTF-8"?>
! {/if}
! <assessmentItem xmlns="http://www.imsglobal.org/xsd/imsqti_item_v2p0"
! 	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
! 	xsi:schemaLocation="http://www.imsglobal.org/xsd/imsqti_item_v2p0 ./imsqti_item_v2p0.xsd"
! 	identifier="{$assessmentitemidentifier}" title="{$assessmentitemtitle}"
! 	adaptive="false" timeDependent="false"> {section name=aid
! loop=$answers} {if $answers[aid].answertype == 3} <responseDeclaration
! 	identifier="{$questionid}{$answers[aid].id}" cardinality="single"
! 	baseType="identifier"> <correctResponse> {section name=subanswer
! loop=$answers[aid].subanswers} {if
! $answers[aid].subanswers[subanswer].fraction > 0} <value>{$answers[aid].subanswers[subanswer].id}</value>
! {/if} {/section} </correctResponse> <mapping defaultValue="0"> {section
! name=subanswer loop=$answers[aid].subanswers} {if
! $answers[aid].subanswers[subanswer].fraction != 0} <mapEntry
! 	mapKey="{$answers[aid].subanswers[subanswer].id}"
! 	mappedValue="{$answers[aid].subanswers[subanswer].fraction}" /> {/if}
! {/section} </mapping> </responseDeclaration> {elseif
! $answers[aid].answertype == 1} <responseDeclaration
! 	identifier="{$questionid}{$answers[aid].id}" cardinality="single"
! 	baseType="string"> <correctResponse> {section name=subanswer
! loop=$answers[aid].subanswers} {if
! $answers[aid].subanswers[subanswer].fraction > 0} <value>{$answers[aid].subanswers[subanswer].answer}</value>
! {/if} {/section} </correctResponse> <mapping lowerBound="0"
! 	upperBound="1" defaultValue="0"> {section name=subanswer
! loop=$answers[aid].subanswers} {if
! $answers[aid].subanswers[subanswer].fraction != 0} <mapEntry
! 	mapKey="{$answers[aid].subanswers[subanswer].answer}"
! 	mappedValue="{$answers[aid].subanswers[subanswer].fraction}" /> {/if}
! {/section} </mapping> </responseDeclaration> {/if} {/section} <outcomeDeclaration
! 	identifier="SCORE" cardinality="single" baseType="float" /> <itemBody>
! {if $questionText != ''}
! <div class="assesmentItemBody">
! 	<p>{$questionText}</p>
! </div>
! {/if}
! <div class="interactive.cloze">
! 	<p>
! 		{section name=qid loop=$questions.question} {$questions.text[qid]} {if
! 		$questions.question[qid].id != $cloze_trailing_text_id} {if
! 		$questions.question[qid].answertype == 3}
! 		<inlineChoiceInteraction
! 			responseIdentifier="{$questionid}{$questions.question[qid].id}"
! 			shuffle="false"> {section name=aid
! 		loop=$questions.question[qid].subanswers} <inlineChoice
! 			identifier="{$questions.question[qid].subanswers[aid].id}">{$questions.question[qid].subanswers[aid].answer}</inlineChoice>
! 		{/section} </inlineChoiceInteraction>
! 		{elseif $questions.question[qid].answertype == 1}
! 		<textEntryInteraction
! 			responseIdentifier="{$questionid}{$questions.question[qid].id}"
! 			expectedLength="15" />
! 		{/if} {/if} {/section}
! 	</p>
! </div>
! {if $question_has_image == 1}
! <div class="media">
! 	{if $hassize == 1}
! 	<object type="{$question->mediamimetype}" data="{$question->mediaurl}"
! 		width="{$question->mediax}" height="{$question->mediay}" />
! 	{else}
! 	<object type="{$question->mediamimetype}" data="{$question->mediaurl}" />
  	{/if}
! </div>
! {/if} </itemBody> <responseProcessing
! 	xmlns="http://www.imsglobal.org/xsd/imsqti_item_v2p0"
! 	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
! 	xsi:schemaLocation="http://www.imsglobal.org/xsd/imsqti_item_v2p0 ../imsqti_item_v2p0.xsd">
! {section name=answer loop=$answers}{if $answers[answer].answertype == 1
! || $answers[answer].answertype == 3} <responseCondition> <responseIf> <isNull>
! <variable identifier="{$questionid}{$answers[answer].id}" /> </isNull> <setOutcomeValue
! 	identifier="SCORE{$questionid}{$answers[answer].id}"> <baseValue
! 	baseType="float">0</baseValue> </setOutcomeValue> </responseIf> <responseElse>
! <setOutcomeValue identifier="SCORE{$questionid}{$answers[answer].id}"> <mapResponse
! 	identifier="{$questionid}{$answers[answer].id}" /> </setOutcomeValue> </responseElse>
! </responseCondition> <setOutcomeValue identifier="FEEDBACK"> <variable
! 	identifier="{$questionid}{$answers[answer].id}" /> </setOutcomeValue>
! {/if}{/section} </responseProcessing> {section name=answer
! loop=$answers}{if $answers[answer].answertype == 1 ||
! $answers[answer].answertype == 3} {section name=subanswer
! loop=$answers[answer].subanswers} {if
! $answers[answer].subanswers[subanswer].feedback != ''} <modalFeedback
! 	outcomeIdentifier="FEEDBACK"
! 	identifier="{$answers[answer].subanswers[subanswer].id}"
! 	showHide="show">{$answers[answer].subanswers[subanswer].feedback}</modalFeedback>
! {/if}{/section} {/if} {/section} </assessmentItem>
diff -crB questionorg/format/qti_two/templates/extendedText_simpleEssay.tpl questionupd/format/qti_two/templates/extendedText_simpleEssay.tpl
*** questionorg/format/qti_two/templates/extendedText_simpleEssay.tpl	2012-04-13 12:31:11.523178255 +0500
--- questionupd/format/qti_two/templates/extendedText_simpleEssay.tpl	2012-04-13 09:42:53.000000000 +0500
***************
*** 1,27 ****
! {if $courselevelexport}<?xml version="1.0" encoding="UTF-8"?>{/if}
! <assessmentItem xmlns="http://www.imsglobal.org/xsd/imsqti_item_v2p0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.imsglobal.org/xsd/imsqti_item_v2p0 ./imsqti_item_v2p0.xsd" identifier="{$assessmentitemidentifier}" title="{$assessmentitemtitle}" adaptive="false" timeDependent="false">
! 	<responseDeclaration identifier="{$questionid}" cardinality="single" baseType="string"/>
! 	<outcomeDeclaration identifier="SCORE" cardinality="single" baseType="integer"/>
! 	<itemBody>
! 	    <div class="assesmentItemBody">
!     		<p>{$questionText}</p>
! 		</div>
! 		<div class="interactive.extendedText">
! 			<extendedTextInteraction responseIdentifier="{$questionid}" expectedLength="600">
! 			</extendedTextInteraction>
! 		</div>
! 	{if $question_has_image == 1}
! 		<div class="media">
! 	    {if $hassize == 1}
! 			<object type="{$question->mediamimetype}" data="{$question->mediaurl}" width="{$question->mediax}" height="{$question->mediay}" />
! 		{else}
! 			<object type="{$question->mediamimetype}" data="{$question->mediaurl}" />
! 		{/if}
! 		</div>
! 	{/if}
! 	</itemBody>
! {if $question->feedback != ''}
! 	<modalFeedback outcomeIdentifier="FEEDBACK" identifier="{$questionid}" showHide="hide">{$question->feedback}</modalFeedback>
! 	<modalFeedback outcomeIdentifier="FEEDBACK" identifier="{$questionid}" showHide="show">{$question->feedback}</modalFeedback>
  {/if}
! </assessmentItem>
--- 1,30 ----
! {if $courselevelexport}
! <?xml version="1.0" encoding="UTF-8"?>
  {/if}
! <assessmentItem xmlns="http://www.imsglobal.org/xsd/imsqti_item_v2p0"
! 	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
! 	xsi:schemaLocation="http://www.imsglobal.org/xsd/imsqti_item_v2p0 ./imsqti_item_v2p0.xsd"
! 	identifier="{$assessmentitemidentifier}" title="{$assessmentitemtitle}"
! 	adaptive="false" timeDependent="false"> <responseDeclaration
! 	identifier="{$questionid}" cardinality="single" baseType="string" /> <outcomeDeclaration
! 	identifier="SCORE" cardinality="single" baseType="integer" /> <itemBody>
! <div class="assesmentItemBody">
! 	<p>{$questionText}</p>
! </div>
! <div class="interactive.extendedText">
! 	<extendedTextInteraction responseIdentifier="{$questionid}"
! 		expectedLength="600"> </extendedTextInteraction>
! </div>
! {if $question_has_image == 1}
! <div class="media">
! 	{if $hassize == 1}
! 	<object type="{$question->mediamimetype}" data="{$question->mediaurl}"
! 		width="{$question->mediax}" height="{$question->mediay}" />
! 	{else}
! 	<object type="{$question->mediamimetype}" data="{$question->mediaurl}" />
! 	{/if}
! </div>
! {/if} </itemBody> {if $question->feedback != ''} <modalFeedback
! 	outcomeIdentifier="FEEDBACK" identifier="{$questionid}" showHide="hide">{$question->feedback}</modalFeedback>
! <modalFeedback outcomeIdentifier="FEEDBACK" identifier="{$questionid}"
! 	showHide="show">{$question->feedback}</modalFeedback> {/if} </assessmentItem>
diff -crB questionorg/format/qti_two/templates/extendedText.tpl questionupd/format/qti_two/templates/extendedText.tpl
*** questionorg/format/qti_two/templates/extendedText.tpl	2012-04-13 12:31:11.390178253 +0500
--- questionupd/format/qti_two/templates/extendedText.tpl	2012-04-13 09:42:53.000000000 +0500
***************
*** 1,17 ****
! {if $courselevelexport}<?xml version="1.0" encoding="UTF-8"?>{/if}
! <assessmentItem xmlns="http://www.imsglobal.org/xsd/imsqti_item_v2p0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.imsglobal.org/xsd/imsqti_item_v2p0 ./imsqti_item_v2p0.xsd" identifier="{$assessmentitemidentifier}" title="{$assessmentitemtitle}" adaptive="false" timeDependent="false">
! 	<responseDeclaration identifier="{$questionid}" cardinality="single" baseType="string"/>
! 	<outcomeDeclaration identifier="SCORE" cardinality="single" baseType="integer"/>
! 	<itemBody>
! 		<p>{$questionText}</p>
! 	{if $question_has_image == 1}
! 		<div class="media">
! 	    {if $hassize == 1}
! 			<object type="{$question->mediamimetype}" data="{$question->mediaurl}" width="{$question->mediax}" height="{$question->mediay}" />
! 		{else}
! 			<object type="{$question->mediamimetype}" data="{$question->mediaurl}" />
! 		{/if}
! 		</div>
  	{/if}
! 	</itemBody>
! </assessmentItem>
--- 1,21 ----
! {if $courselevelexport}
! <?xml version="1.0" encoding="UTF-8"?>
! {/if}
! <assessmentItem xmlns="http://www.imsglobal.org/xsd/imsqti_item_v2p0"
! 	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
! 	xsi:schemaLocation="http://www.imsglobal.org/xsd/imsqti_item_v2p0 ./imsqti_item_v2p0.xsd"
! 	identifier="{$assessmentitemidentifier}" title="{$assessmentitemtitle}"
! 	adaptive="false" timeDependent="false"> <responseDeclaration
! 	identifier="{$questionid}" cardinality="single" baseType="string" /> <outcomeDeclaration
! 	identifier="SCORE" cardinality="single" baseType="integer" /> <itemBody>
! <p>{$questionText}</p>
! {if $question_has_image == 1}
! <div class="media">
! 	{if $hassize == 1}
! 	<object type="{$question->mediamimetype}" data="{$question->mediaurl}"
! 		width="{$question->mediax}" height="{$question->mediay}" />
! 	{else}
! 	<object type="{$question->mediamimetype}" data="{$question->mediaurl}" />
  	{/if}
! </div>
! {/if} </itemBody> </assessmentItem>
diff -crB questionorg/format/qti_two/templates/graphicGapMatch.tpl questionupd/format/qti_two/templates/graphicGapMatch.tpl
*** questionorg/format/qti_two/templates/graphicGapMatch.tpl	2012-04-13 12:31:11.432178255 +0500
--- questionupd/format/qti_two/templates/graphicGapMatch.tpl	2012-04-13 09:42:53.000000000 +0500
***************
*** 1,33 ****
! {if $courselevelexport}<?xml version="1.0" encoding="UTF-8"?>{/if}
! <assessmentItem xmlns="http://www.imsglobal.org/xsd/imsqti_item_v2p0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.imsglobal.org/xsd/imsqti_item_v2p0 ../imsqti_item_v2p0.xsd" identifier="{$assessmentitemidentifier}" title="{$assessmentitemtitle}" adaptive="false" timeDependent="false">
! 	<responseDeclaration identifier="{$questionid}" cardinality="multiple" baseType="directedPair">
! 		<correctResponse>
!    		{section name=item loop=$gapitems}
! 				<value>{$gapitems[item].id} {$gapitems[item].id}</value>
!    		{/section}
! 		</correctResponse>
! 		<mapping defaultValue="1">
!    		{section name=item loop=$gapitems}
! 				<mapEntry mapKey="{$gapitems[item].id} {$gapitems[item].id}" mappedValue="1" />
!    		{/section}
! 		</mapping>
! 	</responseDeclaration>
! 	<outcomeDeclaration identifier="SCORE" cardinality="single" baseType="float"/>
! 	<itemBody>
! 		<div class="assesmentItemBody"><p>{$questionText}</p></div>
! 		<div class="interactive.graphicGapMatch">
! 			<graphicGapMatchInteraction responseIdentifier="{$questionid}">
! 				<object type="{$question->mediamimetype}" data="{$question->mediaurl}" width="{$question->mediax}" height="{$question->mediay}"/>
!        		{section name=item loop=$gapitems}
! 				<gapImg identifier="{$gapitems[item].id}" matchMax="1">
! 					<object type="{$gapitems[item].mediamimetype}" data="{$gapitems[item].media}" width="{$gapitems[item].snaptowidth}" height="{$gapitems[item].snaptoheight}" label="{$gapitems[item].questiontext}"/>
! 				</gapImg>
! 			{/section}
!        		{section name=item loop=$gapitems}
!        		<associableHotspot identifier="{$gapitems[item].id}" matchMax="{$hotspotmaxmatch}" shape="rect" coords="{$gapitems[item].targetx},{$gapitems[item].targety},{$gapitems[item].targetrx},{$gapitems[item].targetby}"/>
! 			{/section}
! 			</graphicGapMatchInteraction>
! 		</div>
! 	</itemBody>
! 	<responseProcessing template="http://www.imsglobal.org/xml/imsqti_item_v2p0/rpMapResponse" templateLocation="../RPTemplates/rpMapResponse.xml"/>
! </assessmentItem>
\ No newline at end of file
--- 1,37 ----
! {if $courselevelexport}
! <?xml version="1.0" encoding="UTF-8"?>
! {/if}
! <assessmentItem xmlns="http://www.imsglobal.org/xsd/imsqti_item_v2p0"
! 	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
! 	xsi:schemaLocation="http://www.imsglobal.org/xsd/imsqti_item_v2p0 ../imsqti_item_v2p0.xsd"
! 	identifier="{$assessmentitemidentifier}" title="{$assessmentitemtitle}"
! 	adaptive="false" timeDependent="false"> <responseDeclaration
! 	identifier="{$questionid}" cardinality="multiple"
! 	baseType="directedPair"> <correctResponse> {section name=item
! loop=$gapitems} <value>{$gapitems[item].id} {$gapitems[item].id}</value>
! {/section} </correctResponse> <mapping defaultValue="1"> {section
! name=item loop=$gapitems} <mapEntry
! 	mapKey="{$gapitems[item].id} {$gapitems[item].id}" mappedValue="1" />
! {/section} </mapping> </responseDeclaration> <outcomeDeclaration
! 	identifier="SCORE" cardinality="single" baseType="float" /> <itemBody>
! <div class="assesmentItemBody">
! 	<p>{$questionText}</p>
! </div>
! <div class="interactive.graphicGapMatch">
! 	<graphicGapMatchInteraction responseIdentifier="{$questionid}"> <object
! 		type="{$question->mediamimetype}" data="{$question->mediaurl}"
! 		width="{$question->mediax}" height="{$question->mediay}" /> {section
! 	name=item loop=$gapitems} <gapImg identifier="{$gapitems[item].id}"
! 		matchMax="1"> <object type="{$gapitems[item].mediamimetype}"
! 		data="{$gapitems[item].media}" width="{$gapitems[item].snaptowidth}"
! 		height="{$gapitems[item].snaptoheight}"
! 		label="{$gapitems[item].questiontext}" /> </gapImg> {/section}
! 	{section name=item loop=$gapitems} <associableHotspot
! 		identifier="{$gapitems[item].id}" matchMax="{$hotspotmaxmatch}"
! 		shape="rect"
! 		coords="{$gapitems[item].targetx},{$gapitems[item].targety},{$gapitems[item].targetrx},{$gapitems[item].targetby}" />
! 	{/section} </graphicGapMatchInteraction>
! </div>
! </itemBody> <responseProcessing
! 	template="http://www.imsglobal.org/xml/imsqti_item_v2p0/rpMapResponse"
! 	templateLocation="../RPTemplates/rpMapResponse.xml" /> </assessmentItem>
diff -crB questionorg/format/qti_two/templates/imsmanifest.tpl questionupd/format/qti_two/templates/imsmanifest.tpl
*** questionorg/format/qti_two/templates/imsmanifest.tpl	2012-04-13 12:31:11.431178255 +0500
--- questionupd/format/qti_two/templates/imsmanifest.tpl	2012-04-13 09:42:54.000000000 +0500
***************
*** 1,85 ****
  <?xml version="1.0" encoding="UTF-8"?>
! <manifest xmlns="http://www.imsglobal.org/xsd/imscp_v1p1" xmlns:imsmd="http://www.imsglobal.org/xsd/imsmd_v1p2" xmlns:imsqti="http://www.imsglobal.org/xsd/imsqti_item_v2p0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" identifier="{$manifestidentifier}" xsi:schemaLocation="http://www.imsglobal.org/xsd/imscp_v1p1 imscp_v1p1.xsd   http://www.imsglobal.org/xsd/imsmd_v1p2 imsmd_v1p2p2.xsd  http://www.imsglobal.org/xsd/imsqti_item_v2p0 ./imsqti_item_v2p0.xsd">
! 	<metadata>
! 		<schema>ADL SCORM</schema>
! 		<schemaversion>1.2</schemaversion>
! 		<lom xmlns="http://www.imsglobal.org/xsd/imsmd_v1p2"
!      			xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
!      			xsi:schemaLocation="http://www.imsglobal.org/xsd/imsmd_v1p2 imsmd_v1p2p2.xsd">
!      		<general>
! 				<title><langstring xml:lang="{$lang}">{$quiztitle}</langstring></title>
! 				<description><langstring xml:lang="{$lang}">{$quizinfo}</langstring></description>
! 				<keyword><langstring xml:lang="{$lang}">{$quizkeywords}</langstring></keyword>
! 			</general>
! 		</lom>
!    		{if $quiz_level_export == 1}
!     		<imsqti:var id="submiturl">{$submiturl}</imsqti:var>
!     		<imsqti:var id="userid">{$userid}</imsqti:var>
!     		<imsqti:var id="username">{$username}</imsqti:var>
!     		<imsqti:var id="id">{$quiz->id}</imsqti:var>
!     		<imsqti:var id="course">{$quiz->course}</imsqti:var>
!     		<imsqti:var id="timeopen">{$quiztimeopen}</imsqti:var>
!     		<imsqti:var id="timeclose">{$quiztimeclose}</imsqti:var>
!     		<imsqti:var id="timelimit">{$quiz->timelimit}</imsqti:var>
!     		<imsqti:var id="shufflequestions">{$quiz->shufflequestions}</imsqti:var>
!     		<imsqti:var id="shuffleanswers">{$quiz->shuffleanswers}</imsqti:var>
!     		<imsqti:var id="attempts">{$quiz->attempts}</imsqti:var>
!     		<imsqti:var id="attemptbuildsonlast">{$quiz->attemptonlast}</imsqti:var>
!     		<imsqti:var id="grademethod">{$grademethod}</imsqti:var>
!     		<imsqti:var id="feedback">{$quiz->feedback}</imsqti:var>
!     		<imsqti:var id="feedbackcorrectanswers">{$quiz->correctanswers}</imsqti:var>
!     		<imsqti:var id="maxgrade">{$quiz->grade}</imsqti:var>
!     		<imsqti:var id="rawpointspossible">{$quiz->sumgrades}</imsqti:var>
!     		<imsqti:var id="password">{$quiz->password}</imsqti:var>
!     		<imsqti:var id="subnet">{$quiz->subnet}</imsqti:var>
!     		<imsqti:var id="coursefullname">{$course->fullname}</imsqti:var>
!     		<imsqti:var id="courseshortname">{$course->shortname}</imsqti:var>
! 		{/if}
! 	</metadata>
! 	<organizations/>
! 	<resources>
!     	{section name=question loop=$questions}
! 		<resource identifier="category{$questions[question].category}-question{$questions[question].id}" type="imsqti_item_xmlv2p0" {if $externalfiles == 1}href="./category{$questions[question].category}-question{$questions[question].id}.xml"{/if}>
! 			<metadata>
! 				<schema>IMS QTI Item</schema>
! 				<schemaversion>2.0</schemaversion>
! 				<imsmd:lom>
! 					<imsmd:general>
! 						<imsmd:identifier>category{$questions[question].category}-question{$questions[question].id}</imsmd:identifier>
! 						<imsmd:title>
! 							<imsmd:langstring xml:lang="{$lang}">{$questions[question].name}</imsmd:langstring>
! 						</imsmd:title>
! 						<imsmd:description>
! 							<imsmd:langstring xml:lang="en">Question {$questions[question].id} from category {$questions[question].category}</imsmd:langstring>
! 						</imsmd:description>
! 					</imsmd:general>
! 					<imsmd:lifecycle>
! 						<imsmd:version>
! 							<imsmd:langstring xml:lang="en">1.0</imsmd:langstring>
! 						</imsmd:version>
! 						<imsmd:status>
! 							<imsmd:source>
! 								<imsmd:langstring xml:lang="en">LOMv1.0</imsmd:langstring>
! 							</imsmd:source>
! 							<imsmd:value>
! 								<imsmd:langstring xml:lang="en">Draft</imsmd:langstring>
! 							</imsmd:value>
! 						</imsmd:status>
! 					</imsmd:lifecycle>
! 				</imsmd:lom>
! 				<imsqti:qtiMetadata>
! 					<imsqti:timeDependent>false</imsqti:timeDependent>
! 					<imsqti:interactionType>{$questions[question].qtiinteractiontype}</imsqti:interactionType>
! 					<imsqti:canComputerScore>{$questions[question].qtiscoreable}</imsqti:canComputerScore>
! 					<imsqti:feedbackType>nonadaptive</imsqti:feedbackType>
! 					<imsqti:solutionAvailable>{$questions[question].qtisolutionavailable}</imsqti:solutionAvailable>
! 				</imsqti:qtiMetadata>
! 			</metadata>
! 			{if $questions[question].image != ''}
! 			<file href="{$questions[question].mediaurl}" />
! 			{/if}
! 			{$questions[question].exporttext}
! 		</resource>
! 		{/section}
! 	</resources>
! </manifest>
\ No newline at end of file
--- 1,69 ----
  <?xml version="1.0" encoding="UTF-8"?>
! <manifest xmlns="http://www.imsglobal.org/xsd/imscp_v1p1"
! 	xmlns:imsmd="http://www.imsglobal.org/xsd/imsmd_v1p2"
! 	xmlns:imsqti="http://www.imsglobal.org/xsd/imsqti_item_v2p0"
! 	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
! 	identifier="{$manifestidentifier}"
! 	xsi:schemaLocation="http://www.imsglobal.org/xsd/imscp_v1p1 imscp_v1p1.xsd   http://www.imsglobal.org/xsd/imsmd_v1p2 imsmd_v1p2p2.xsd  http://www.imsglobal.org/xsd/imsqti_item_v2p0 ./imsqti_item_v2p0.xsd">
! <metadata> <schema>ADL SCORM</schema> <schemaversion>1.2</schemaversion>
! <lom xmlns="http://www.imsglobal.org/xsd/imsmd_v1p2"
! 	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
! 	xsi:schemaLocation="http://www.imsglobal.org/xsd/imsmd_v1p2 imsmd_v1p2p2.xsd">
! <general>
! <title><langstring xml:lang="{$lang}">{$quiztitle}</langstring></title>
! <description> <langstring xml:lang="{$lang}">{$quizinfo}</langstring></description>
! <keyword> <langstring xml:lang="{$lang}">{$quizkeywords}</langstring></keyword>
! </general> </lom> {if $quiz_level_export == 1} <imsqti:var
! 	id="submiturl">{$submiturl}</imsqti:var> <imsqti:var id="userid">{$userid}</imsqti:var>
! <imsqti:var id="username">{$username}</imsqti:var> <imsqti:var id="id">{$quiz->id}</imsqti:var>
! <imsqti:var id="course">{$quiz->course}</imsqti:var> <imsqti:var
! 	id="timeopen">{$quiztimeopen}</imsqti:var> <imsqti:var id="timeclose">{$quiztimeclose}</imsqti:var>
! <imsqti:var id="timelimit">{$quiz->timelimit}</imsqti:var> <imsqti:var
! 	id="shufflequestions">{$quiz->shufflequestions}</imsqti:var> <imsqti:var
! 	id="shuffleanswers">{$quiz->shuffleanswers}</imsqti:var> <imsqti:var
! 	id="attempts">{$quiz->attempts}</imsqti:var> <imsqti:var
! 	id="attemptbuildsonlast">{$quiz->attemptonlast}</imsqti:var> <imsqti:var
! 	id="grademethod">{$grademethod}</imsqti:var> <imsqti:var id="feedback">{$quiz->feedback}</imsqti:var>
! <imsqti:var id="feedbackcorrectanswers">{$quiz->correctanswers}</imsqti:var>
! <imsqti:var id="maxgrade">{$quiz->grade}</imsqti:var> <imsqti:var
! 	id="rawpointspossible">{$quiz->sumgrades}</imsqti:var> <imsqti:var
! 	id="password">{$quiz->password}</imsqti:var> <imsqti:var id="subnet">{$quiz->subnet}</imsqti:var>
! <imsqti:var id="coursefullname">{$course->fullname}</imsqti:var> <imsqti:var
! 	id="courseshortname">{$course->shortname}</imsqti:var> {/if} </metadata>
! <organizations /> <resources> {section name=question loop=$questions} <resource
! 	identifier="category{$questions[question].category}-question{$questions[question].id}"
! 	type="imsqti_item_xmlv2p0" {if $externalfiles==
! 	1}href="./category{$questions[question].category}-question{$questions[question].id}.xml"{/if}>
! <metadata> <schema>IMS QTI Item</schema> <schemaversion>2.0</schemaversion>
! <imsmd:lom>
! 	<imsmd:general>
! 		<imsmd:identifier>category{$questions[question].category}-question{$questions[question].id}</imsmd:identifier>
! 		<imsmd:title>
! 			<imsmd:langstring xml:lang="{$lang}">{$questions[question].name}</imsmd:langstring>
! 		</imsmd:title>
! 		<imsmd:description>
! 			<imsmd:langstring xml:lang="en">Question {$questions[question].id} from category {$questions[question].category}</imsmd:langstring>
! 		</imsmd:description>
! 	</imsmd:general>
! 	<imsmd:lifecycle>
! 		<imsmd:version>
! 			<imsmd:langstring xml:lang="en">1.0</imsmd:langstring>
! 		</imsmd:version>
! 		<imsmd:status>
! 			<imsmd:source>
! 				<imsmd:langstring xml:lang="en">LOMv1.0</imsmd:langstring>
! 			</imsmd:source>
! 			<imsmd:value>
! 				<imsmd:langstring xml:lang="en">Draft</imsmd:langstring>
! 			</imsmd:value>
! 		</imsmd:status>
! 	</imsmd:lifecycle>
! </imsmd:lom> <imsqti:qtiMetadata>
! 	<imsqti:timeDependent>false</imsqti:timeDependent>
! 	<imsqti:interactionType>{$questions[question].qtiinteractiontype}</imsqti:interactionType>
! 	<imsqti:canComputerScore>{$questions[question].qtiscoreable}</imsqti:canComputerScore>
! 	<imsqti:feedbackType>nonadaptive</imsqti:feedbackType>
! 	<imsqti:solutionAvailable>{$questions[question].qtisolutionavailable}</imsqti:solutionAvailable>
! </imsqti:qtiMetadata> </metadata> {if $questions[question].image != ''}
! <file href="{$questions[question].mediaurl}" /> {/if}
! {$questions[question].exporttext} </resource> {/section} </resources> </manifest>
diff -crB questionorg/format/qti_two/templates/match.tpl questionupd/format/qti_two/templates/match.tpl
*** questionorg/format/qti_two/templates/match.tpl	2012-04-13 12:31:11.526178255 +0500
--- questionupd/format/qti_two/templates/match.tpl	2012-04-13 09:42:54.000000000 +0500
***************
*** 1,62 ****
! <assessmentItem xmlns="http://www.imsglobal.org/xsd/imsqti_item_v2p0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.imsglobal.org/xsd/imsqti_item_v2p0 ./imsqti_item_v2p0.xsd" identifier="{$assessmentitemidentifier}" title="{$assessmentitemtitle}" adaptive="false" timeDependent="false">
! 	<responseDeclaration identifier="{$questionid}" cardinality="multiple" baseType="directedPair">
! 		<correctResponse>
!    		{section name=set loop=$matchsets}
! 				<value>q{$matchsets[set].id} a{$matchsets[set].id}</value>
!    		{/section}
! 		</correctResponse>
! 
! 		<mapping defaultValue="0">
!    		{section name=set loop=$matchsets}
!    		   <mapEntry mapKey="q{$matchsets[set].id} a{$matchsets[set].id}" mappedValue="1"/>
!    		{/section}
! 		</mapping>
! 	</responseDeclaration>
! 	<outcomeDeclaration identifier="SCORE" cardinality="single" baseType="float"/>
! 
! 	<itemBody>
! 		<p>{$questionText}</p>
! 		<div class="interactive.match">
! 			<matchInteraction responseIdentifier="{$questionid}" shuffle="false" maxAssociations="{$setcount}">
! 				<simpleMatchSet>
!            		{section name=set loop=$matchsets}
!     				<simpleAssociableChoice identifier="q{$matchsets[set].id}" matchMax="1">{$matchsets[set].questiontext}</simpleAssociableChoice>
!            		{/section}
! 				</simpleMatchSet>
! 				<simpleMatchSet>
!            		{section name=set loop=$matchsets}
!     				<simpleAssociableChoice identifier="a{$matchsets[set].id}" matchMax="{$setcount}">{$matchsets[set].answertext}</simpleAssociableChoice>
!            		{/section}
! 				</simpleMatchSet>
! 			</matchInteraction>
! 		</div>
! 	{if $question_has_image == 1}
! 		<div class="media">
! 	    {if $hassize == 1}
! 			<object type="{$question->mediamimetype}" data="{$question->mediaurl}" width="{$question->mediax}" height="{$question->mediay}" />
! 		{else}
! 			<object type="{$question->mediamimetype}" data="{$question->mediaurl}" />
! 		{/if}
! 		</div>
  	{/if}
! 	</itemBody>
! 	<responseProcessing xmlns="http://www.imsglobal.org/xsd/imsqti_item_v2p0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.imsglobal.org/xsd/imsqti_item_v2p0 ../imsqti_item_v2p0.xsd">
! 		<responseCondition>
! 
! 			<responseIf>
! 				<isNull>
! 					<variable identifier="{$questionid}"/>
! 				</isNull>
! 				<setOutcomeValue identifier="SCORE">
! 					<baseValue baseType="integer">0</baseValue>
! 				</setOutcomeValue>
! 			</responseIf>
! 
! 			<responseElse>
! 				<setOutcomeValue identifier="SCORE">
! 					<mapResponse identifier="{$questionid}"/>
! 				</setOutcomeValue>
! 			</responseElse>
! 		</responseCondition>
! 	</responseProcessing>
! </assessmentItem>
--- 1,43 ----
! <assessmentItem xmlns="http://www.imsglobal.org/xsd/imsqti_item_v2p0"
! 	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
! 	xsi:schemaLocation="http://www.imsglobal.org/xsd/imsqti_item_v2p0 ./imsqti_item_v2p0.xsd"
! 	identifier="{$assessmentitemidentifier}" title="{$assessmentitemtitle}"
! 	adaptive="false" timeDependent="false"> <responseDeclaration
! 	identifier="{$questionid}" cardinality="multiple"
! 	baseType="directedPair"> <correctResponse> {section name=set
! loop=$matchsets} <value>q{$matchsets[set].id} a{$matchsets[set].id}</value>
! {/section} </correctResponse> <mapping defaultValue="0"> {section
! name=set loop=$matchsets} <mapEntry
! 	mapKey="q{$matchsets[set].id} a{$matchsets[set].id}" mappedValue="1" />
! {/section} </mapping> </responseDeclaration> <outcomeDeclaration
! 	identifier="SCORE" cardinality="single" baseType="float" /> <itemBody>
! <p>{$questionText}</p>
! <div class="interactive.match">
! 	<matchInteraction responseIdentifier="{$questionid}" shuffle="false"
! 		maxAssociations="{$setcount}"> <simpleMatchSet> {section name=set
! 	loop=$matchsets} <simpleAssociableChoice
! 		identifier="q{$matchsets[set].id}" matchMax="1">{$matchsets[set].questiontext}</simpleAssociableChoice>
! 	{/section} </simpleMatchSet> <simpleMatchSet> {section name=set
! 	loop=$matchsets} <simpleAssociableChoice
! 		identifier="a{$matchsets[set].id}" matchMax="{$setcount}">{$matchsets[set].answertext}</simpleAssociableChoice>
! 	{/section} </simpleMatchSet> </matchInteraction>
! </div>
! {if $question_has_image == 1}
! <div class="media">
! 	{if $hassize == 1}
! 	<object type="{$question->mediamimetype}" data="{$question->mediaurl}"
! 		width="{$question->mediax}" height="{$question->mediay}" />
! 	{else}
! 	<object type="{$question->mediamimetype}" data="{$question->mediaurl}" />
  	{/if}
! </div>
! {/if} </itemBody> <responseProcessing
! 	xmlns="http://www.imsglobal.org/xsd/imsqti_item_v2p0"
! 	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
! 	xsi:schemaLocation="http://www.imsglobal.org/xsd/imsqti_item_v2p0 ../imsqti_item_v2p0.xsd">
! <responseCondition> <responseIf> <isNull> <variable
! 	identifier="{$questionid}" /> </isNull> <setOutcomeValue
! 	identifier="SCORE"> <baseValue baseType="integer">0</baseValue> </setOutcomeValue>
! </responseIf> <responseElse> <setOutcomeValue identifier="SCORE"> <mapResponse
! 	identifier="{$questionid}" /> </setOutcomeValue> </responseElse> </responseCondition>
! </responseProcessing> </assessmentItem>
diff -crB questionorg/format/qti_two/templates/mmchoiceMultiple.tpl questionupd/format/qti_two/templates/mmchoiceMultiple.tpl
*** questionorg/format/qti_two/templates/mmchoiceMultiple.tpl	2012-04-13 12:31:11.388178255 +0500
--- questionupd/format/qti_two/templates/mmchoiceMultiple.tpl	2012-04-13 09:42:54.000000000 +0500
***************
*** 1,88 ****
! {if $courselevelexport}<?xml version="1.0" encoding="UTF-8"?>{/if}
! <assessmentItem xmlns="http://www.imsglobal.org/xsd/imsqti_item_v2p0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.imsglobal.org/xsd/imsqti_item_v2p0 ./imsqti_item_v2p0.xsd" identifier="{$assessmentitemidentifier}" title="{$assessmentitemtitle}" adaptive="false" timeDependent="false">
! 	<responseDeclaration identifier="{$questionid}" cardinality="{$responsedeclarationcardinality}" baseType="identifier">
! 		<correctResponse>
! 		{section name=answer loop=$correctresponses}
! 			<value>{$correctresponses[answer].id}</value>
! 		{/section}
! 		</correctResponse>
! 		<mapping lowerBound="0" upperBound="1" defaultValue="{$defaultvalue}">
! 		{section name=answer loop=$answers}
! 		    {if $answers[answer].fraction != 0}
! 			<mapEntry mapKey="{$answers[answer].id}" mappedValue="{$answers[answer].fraction}" />
! 			{/if}
! 		{/section}
! 		</mapping>
! 	</responseDeclaration>
! 	<outcomeDeclaration identifier="SCORE" cardinality="single" baseType="float" />
! 	<itemBody>
! 	   <div class="assesmentItemBody">
! 		<p>{$questionText}</p>
!        </div>
! 		<div class="interactive.choiceMultiple">
! 			<choiceInteraction responseIdentifier="{$questionid}" shuffle="false" maxChoices="{$maxChoices}">
!     		{section name=answer loop=$answers}
! 				<simpleChoice identifier="{$answers[answer].id}" fixed="false"><p>{$answers[answer].choice}
!     			{if $answers[answer].media != ''}
!     				<object type="{$answers[answer].mediamimetype}" data="{$answers[answer].media}" width="{$answers[answer].mediax}" height="{$answers[answer].mediay}" />
!     			{/if}</p>
!     			{if $answers[answer].feedback != ''}
! 	   			    <feedbackInline identifier="{$answers[answer].id}" outcomeIdentifier="FEEDBACK" showHide="show">{$answers[answer].feedback}</feedbackInline>
!                 {/if}
!     			{if $answers[answer].altfeedback != ''}
! 	   			    <feedbackInline identifier="{$answers[answer].id}" outcomeIdentifier="ALTFEEDBACK" showHide="hide">{$answers[answer].altfeedback}</feedbackInline>
!                 {/if}
! 				</simpleChoice>
!     		{/section}
! 			</choiceInteraction>
! 		</div>
! 	{if $question_has_image == 1}
! 		<div class="media">
! 	    {if $hassize == 1}
! 			<object type="{$question->mediamimetype}" data="{$question->mediaurl}" width="{$question->mediax}" height="{$question->mediay}" />
! 		{else}
! 			<object type="{$question->mediamimetype}" data="{$question->mediaurl}" />
  		{/if}
! 		</div>
  	{/if}
! 	</itemBody>
! 	<responseProcessing xmlns="http://www.imsglobal.org/xsd/imsqti_item_v2p0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.imsglobal.org/xsd/imsqti_item_v2p0 ../imsqti_item_v2p0.xsd">
! 		<responseCondition>
! 			<responseIf>
! 				<isNull>
! 					<variable identifier="{$questionid}"/>
! 				</isNull>
! 				<setOutcomeValue identifier="SCORE">
! 					<baseValue baseType="float">0</baseValue>
! 				</setOutcomeValue>
! 			</responseIf>
! 			<responseElse>
! 				<setOutcomeValue identifier="SCORE">
! 					<mapResponse identifier="{$questionid}"/>
! 				</setOutcomeValue>
! 			</responseElse>
! 		</responseCondition>
! 		<responseCondition>
! 			<responseIf>
! 				<gte>
! 					<variable identifier="SCORE"/>
! 					<baseValue baseType="float">{$question->feedbackfraction}</baseValue>
! 				</gte>
! 				<setOutcomeValue identifier="FEEDBACK">
! 					<variable identifier="feedbackok"/>
! 				</setOutcomeValue>
! 			</responseIf>
! 			<responseElse>
! 				<setOutcomeValue identifier="FEEDBACK">
! 					<variable identifier="feedbackmissed"/>
! 				</setOutcomeValue>
! 			</responseElse>
! 		</responseCondition>
! 	</responseProcessing>
! {if $question->feedbackok != ''}
! 	<modalFeedback outcomeIdentifier="FEEDBACK" identifier="feedbackok" showHide="show">{$question->feedbackok}</modalFeedback>
! {/if}
! {if $question->feedbackmissed != ''}
! 	<modalFeedback outcomeIdentifier="FEEDBACK" identifier="feedbackmissed" showHide="hide">{$question->feedbackmissed}</modalFeedback>
! {/if}
! </assessmentItem>
--- 1,67 ----
! {if $courselevelexport}
! <?xml version="1.0" encoding="UTF-8"?>
! {/if}
! <assessmentItem xmlns="http://www.imsglobal.org/xsd/imsqti_item_v2p0"
! 	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
! 	xsi:schemaLocation="http://www.imsglobal.org/xsd/imsqti_item_v2p0 ./imsqti_item_v2p0.xsd"
! 	identifier="{$assessmentitemidentifier}" title="{$assessmentitemtitle}"
! 	adaptive="false" timeDependent="false"> <responseDeclaration
! 	identifier="{$questionid}"
! 	cardinality="{$responsedeclarationcardinality}" baseType="identifier">
! <correctResponse> {section name=answer loop=$correctresponses} <value>{$correctresponses[answer].id}</value>
! {/section} </correctResponse> <mapping lowerBound="0" upperBound="1"
! 	defaultValue="{$defaultvalue}"> {section name=answer loop=$answers} {if
! $answers[answer].fraction != 0} <mapEntry mapKey="{$answers[answer].id}"
! 	mappedValue="{$answers[answer].fraction}" /> {/if} {/section} </mapping>
! </responseDeclaration> <outcomeDeclaration identifier="SCORE"
! 	cardinality="single" baseType="float" /> <itemBody>
! <div class="assesmentItemBody">
! 	<p>{$questionText}</p>
! </div>
! <div class="interactive.choiceMultiple">
! 	<choiceInteraction responseIdentifier="{$questionid}" shuffle="false"
! 		maxChoices="{$maxChoices}"> {section name=answer loop=$answers} <simpleChoice
! 		identifier="{$answers[answer].id}" fixed="false">
! 	<p>
! 		{$answers[answer].choice} {if $answers[answer].media != ''}
! 		<object type="{$answers[answer].mediamimetype}"
! 			data="{$answers[answer].media}" width="{$answers[answer].mediax}"
! 			height="{$answers[answer].mediay}" />
  		{/if}
! 	</p>
! 	{if $answers[answer].feedback != ''} <feedbackInline
! 		identifier="{$answers[answer].id}" outcomeIdentifier="FEEDBACK"
! 		showHide="show">{$answers[answer].feedback}</feedbackInline> {/if} {if
! 	$answers[answer].altfeedback != ''} <feedbackInline
! 		identifier="{$answers[answer].id}" outcomeIdentifier="ALTFEEDBACK"
! 		showHide="hide">{$answers[answer].altfeedback}</feedbackInline> {/if}
! 	</simpleChoice> {/section} </choiceInteraction>
! </div>
! {if $question_has_image == 1}
! <div class="media">
! 	{if $hassize == 1}
! 	<object type="{$question->mediamimetype}" data="{$question->mediaurl}"
! 		width="{$question->mediax}" height="{$question->mediay}" />
! 	{else}
! 	<object type="{$question->mediamimetype}" data="{$question->mediaurl}" />
  	{/if}
! </div>
! {/if} </itemBody> <responseProcessing
! 	xmlns="http://www.imsglobal.org/xsd/imsqti_item_v2p0"
! 	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
! 	xsi:schemaLocation="http://www.imsglobal.org/xsd/imsqti_item_v2p0 ../imsqti_item_v2p0.xsd">
! <responseCondition> <responseIf> <isNull> <variable
! 	identifier="{$questionid}" /> </isNull> <setOutcomeValue
! 	identifier="SCORE"> <baseValue baseType="float">0</baseValue> </setOutcomeValue>
! </responseIf> <responseElse> <setOutcomeValue identifier="SCORE"> <mapResponse
! 	identifier="{$questionid}" /> </setOutcomeValue> </responseElse> </responseCondition>
! <responseCondition> <responseIf> <gte> <variable identifier="SCORE" /> <baseValue
! 	baseType="float">{$question->feedbackfraction}</baseValue> </gte> <setOutcomeValue
! 	identifier="FEEDBACK"> <variable identifier="feedbackok" /> </setOutcomeValue>
! </responseIf> <responseElse> <setOutcomeValue identifier="FEEDBACK"> <variable
! 	identifier="feedbackmissed" /> </setOutcomeValue> </responseElse> </responseCondition>
! </responseProcessing> {if $question->feedbackok != ''} <modalFeedback
! 	outcomeIdentifier="FEEDBACK" identifier="feedbackok" showHide="show">{$question->feedbackok}</modalFeedback>
! {/if} {if $question->feedbackmissed != ''} <modalFeedback
! 	outcomeIdentifier="FEEDBACK" identifier="feedbackmissed"
! 	showHide="hide">{$question->feedbackmissed}</modalFeedback> {/if} </assessmentItem>
diff -crB questionorg/format/qti_two/templates/notimplemented.tpl questionupd/format/qti_two/templates/notimplemented.tpl
*** questionorg/format/qti_two/templates/notimplemented.tpl	2012-04-13 12:31:11.526178256 +0500
--- questionupd/format/qti_two/templates/notimplemented.tpl	2012-04-13 09:42:54.000000000 +0500
***************
*** 1,20 ****
! {if $courselevelexport}<?xml version="1.0" encoding="UTF-8"?>{/if}
! <assessmentItem xmlns="http://www.imsglobal.org/xsd/imsqti_item_v2p0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.imsglobal.org/xsd/imsqti_item_v2p0 ./imsqti_item_v2p0.xsd" identifier="{$assessmentitemidentifier}" title="{$assessmentitemtitle}" adaptive="false" timeDependent="false">
! 	<responseDeclaration identifier="{$questionid}" cardinality="single" baseType="string"/>
! 	<outcomeDeclaration identifier="SCORE" cardinality="single" baseType="integer"/>
! 	<itemBody>
! 		<p>{$questionText}</p>
! 		<div class="interactive.textEntry">
! 			<textEntryInteraction responseIdentifier="{$questionid}" expectedLength="200"></textEntryInteraction>
! 		</div>
! 	{if $question_has_image == 1}
! 		<div class="media">
! 	    {if $hassize == 1}
! 			<object type="{$question->mediamimetype}" data="{$question->mediaurl}" width="{$question->mediax}" height="{$question->mediay}" />
! 		{else}
! 			<object type="{$question->mediamimetype}" data="{$question->mediaurl}" />
! 		{/if}
! 		</div>
  	{/if}
! 	</itemBody>
! </assessmentItem>
--- 1,25 ----
! {if $courselevelexport}
! <?xml version="1.0" encoding="UTF-8"?>
! {/if}
! <assessmentItem xmlns="http://www.imsglobal.org/xsd/imsqti_item_v2p0"
! 	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
! 	xsi:schemaLocation="http://www.imsglobal.org/xsd/imsqti_item_v2p0 ./imsqti_item_v2p0.xsd"
! 	identifier="{$assessmentitemidentifier}" title="{$assessmentitemtitle}"
! 	adaptive="false" timeDependent="false"> <responseDeclaration
! 	identifier="{$questionid}" cardinality="single" baseType="string" /> <outcomeDeclaration
! 	identifier="SCORE" cardinality="single" baseType="integer" /> <itemBody>
! <p>{$questionText}</p>
! <div class="interactive.textEntry">
! 	<textEntryInteraction responseIdentifier="{$questionid}"
! 		expectedLength="200"></textEntryInteraction>
! </div>
! {if $question_has_image == 1}
! <div class="media">
! 	{if $hassize == 1}
! 	<object type="{$question->mediamimetype}" data="{$question->mediaurl}"
! 		width="{$question->mediax}" height="{$question->mediay}" />
! 	{else}
! 	<object type="{$question->mediamimetype}" data="{$question->mediaurl}" />
  	{/if}
! </div>
! {/if} </itemBody> </assessmentItem>
diff -crB questionorg/format/qti_two/templates/numerical.tpl questionupd/format/qti_two/templates/numerical.tpl
*** questionorg/format/qti_two/templates/numerical.tpl	2012-04-13 12:31:11.385178256 +0500
--- questionupd/format/qti_two/templates/numerical.tpl	2012-04-13 09:42:54.000000000 +0500
***************
*** 1,65 ****
! {if $courselevelexport}<?xml version="1.0" encoding="UTF-8"?>{/if}
! <assessmentItem xmlns="http://www.imsglobal.org/xsd/imsqti_item_v2p0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.imsglobal.org/xsd/imsqti_item_v2p0 ./imsqti_item_v2p0.xsd" identifier="{$assessmentitemidentifier}" title="{$assessmentitemtitle}" adaptive="false" timeDependent="false">
! 	<responseDeclaration identifier="{$questionid}" cardinality="single" baseType="float">
! 		<correctResponse>
! 			<value>{$answer->answer}</value>
! 		</correctResponse>
! 		<mapping defaultValue="0">
! 			<mapEntry mapKey="{$answer->answer}" mappedValue="{$answer->fraction}" />
! 		</mapping>
! 	</responseDeclaration>
! 	<outcomeDeclaration identifier="SCORE" cardinality="single" baseType="float"/>
! 	<itemBody>
! 		<p>{$questionText}</p>
! 		<div class="interactive.textEntry">
!             <textEntryInteraction responseIdentifier="{$questionid}" expectedLength="10"/>
! 		</div>
! 	{if $question_has_image == 1}
! 		<div class="media">
! 	    {if $hassize == 1}
! 			<object type="{$question->mediamimetype}" data="{$question->mediaurl}" width="{$question->mediax}" height="{$question->mediay}" />
! 		{else}
! 			<object type="{$question->mediamimetype}" data="{$question->mediaurl}" />
! 		{/if}
! 		</div>
! 	{/if}
! 	</itemBody>
! 	<responseProcessing xmlns="http://www.imsglobal.org/xsd/imsqti_item_v2p0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.imsglobal.org/xsd/imsqti_item_v2p0 ../imsqti_item_v2p0.xsd">
! 		<responseCondition>
! 			<responseIf>
! 				<and>
! 				<not>
! 					<isNull>
! 						<variable identifier="{$questionid}" />
! 					</isNull>
! 				</not>
! 				<gte>
! 					<baseValue baseType="float">{$lowerbound}</baseValue>
! 					<variable identifier="{$questionid}" />
! 				</gte>
! 				<lte>
! 					<baseValue baseType="float">{$upperbound}</baseValue>
! 					<variable identifier="{$questionid}" />
! 				</lte>
! 				</and>
! 				<setOutcomeValue identifier="SCORE">
! 					<baseValue baseType="integer">1</baseValue>
! 				</setOutcomeValue>
! 			</responseIf>
! 			<responseElse>
! 				<setOutcomeValue identifier="SCORE">
! 					<baseValue baseType="integer">0</baseValue>
! 				</setOutcomeValue>
! 			</responseElse>
! 		</responseCondition>
!         <setOutcomeValue identifier="FEEDBACK">
!             <variable identifier="{$questionid}"/>
!         </setOutcomeValue>		
! 	</responseProcessing>
! {if $answer->feedback != ''}
! 	<modalFeedback outcomeIdentifier="FEEDBACK" identifier="{$answer->id}" showHide="show">{$answer->feedback}</modalFeedback>
! {/if}
! {if $answer->altfeedback != ''}
! 	<modalFeedback outcomeIdentifier="FEEDBACK" identifier="{$answer->id}" showHide="hide">{$answer->altfeedback}</modalFeedback>
  {/if}
! </assessmentItem>
--- 1,47 ----
! {if $courselevelexport}
! <?xml version="1.0" encoding="UTF-8"?>
  {/if}
! <assessmentItem xmlns="http://www.imsglobal.org/xsd/imsqti_item_v2p0"
! 	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
! 	xsi:schemaLocation="http://www.imsglobal.org/xsd/imsqti_item_v2p0 ./imsqti_item_v2p0.xsd"
! 	identifier="{$assessmentitemidentifier}" title="{$assessmentitemtitle}"
! 	adaptive="false" timeDependent="false"> <responseDeclaration
! 	identifier="{$questionid}" cardinality="single" baseType="float"> <correctResponse>
! <value>{$answer->answer}</value> </correctResponse> <mapping
! 	defaultValue="0"> <mapEntry mapKey="{$answer->answer}"
! 	mappedValue="{$answer->fraction}" /> </mapping> </responseDeclaration>
! <outcomeDeclaration identifier="SCORE" cardinality="single"
! 	baseType="float" /> <itemBody>
! <p>{$questionText}</p>
! <div class="interactive.textEntry">
! 	<textEntryInteraction responseIdentifier="{$questionid}"
! 		expectedLength="10" />
! </div>
! {if $question_has_image == 1}
! <div class="media">
! 	{if $hassize == 1}
! 	<object type="{$question->mediamimetype}" data="{$question->mediaurl}"
! 		width="{$question->mediax}" height="{$question->mediay}" />
! 	{else}
! 	<object type="{$question->mediamimetype}" data="{$question->mediaurl}" />
! 	{/if}
! </div>
! {/if} </itemBody> <responseProcessing
! 	xmlns="http://www.imsglobal.org/xsd/imsqti_item_v2p0"
! 	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
! 	xsi:schemaLocation="http://www.imsglobal.org/xsd/imsqti_item_v2p0 ../imsqti_item_v2p0.xsd">
! <responseCondition> <responseIf> <and> <not> <isNull> <variable
! 	identifier="{$questionid}" /> </isNull> </not> <gte> <baseValue
! 	baseType="float">{$lowerbound}</baseValue> <variable
! 	identifier="{$questionid}" /> </gte> <lte> <baseValue baseType="float">{$upperbound}</baseValue>
! <variable identifier="{$questionid}" /> </lte> </and> <setOutcomeValue
! 	identifier="SCORE"> <baseValue baseType="integer">1</baseValue> </setOutcomeValue>
! </responseIf> <responseElse> <setOutcomeValue identifier="SCORE"> <baseValue
! 	baseType="integer">0</baseValue> </setOutcomeValue> </responseElse> </responseCondition>
! <setOutcomeValue identifier="FEEDBACK"> <variable
! 	identifier="{$questionid}" /> </setOutcomeValue> </responseProcessing>
! {if $answer->feedback != ''} <modalFeedback outcomeIdentifier="FEEDBACK"
! 	identifier="{$answer->id}" showHide="show">{$answer->feedback}</modalFeedback>
! {/if} {if $answer->altfeedback != ''} <modalFeedback
! 	outcomeIdentifier="FEEDBACK" identifier="{$answer->id}" showHide="hide">{$answer->altfeedback}</modalFeedback>
! {/if} </assessmentItem>
diff -crB questionorg/format/qti_two/templates/textEntry.tpl questionupd/format/qti_two/templates/textEntry.tpl
*** questionorg/format/qti_two/templates/textEntry.tpl	2012-04-13 12:31:11.386178256 +0500
--- questionupd/format/qti_two/templates/textEntry.tpl	2012-04-13 09:42:55.000000000 +0500
***************
*** 1,50 ****
! {if $courselevelexport}<?xml version="1.0" encoding="UTF-8"?>{/if}
! <assessmentItem xmlns="http://www.imsglobal.org/xsd/imsqti_item_v2p0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.imsglobal.org/xsd/imsqti_item_v2p0 ./imsqti_item_v2p0.xsd" identifier="{$assessmentitemidentifier}" title="{$assessmentitemtitle}" adaptive="false" timeDependent="false">
! 	<responseDeclaration identifier="{$questionid}" cardinality="{$responsedeclarationcardinality}" baseType="string">
! 		<correctResponse>
! 		{section name=answer loop=$correctresponses}
! 			<value>{$correctresponses[answer].answer}</value>
! 		{/section}
! 		</correctResponse>
! 		<mapping lowerBound="0" upperBound="1" defaultValue="0">
! 		{section name=answer loop=$answers}
! 		    {if $answers[answer].fraction != 0}
! 			<mapEntry mapKey="{$answers[answer].answer}" mappedValue="{$answers[answer].fraction}" />
! 			{/if}
! 		{/section}
! 		</mapping>
! 	</responseDeclaration>
! 	<outcomeDeclaration identifier="SCORE" cardinality="single" baseType="float"/>
! 	<itemBody>
! 		<p>{$questionText}</p>
! 		<div class="interactive.textEntry">
!             <textEntryInteraction responseIdentifier="{$questionid}" expectedLength="15"/>
! 		</div>
! 	{if $question_has_image == 1}
! 		<div class="media">
! 	    {if $hassize == 1}
! 			<object type="{$question->mediamimetype}" data="{$question->mediaurl}" width="{$question->mediax}" height="{$question->mediay}" />
! 		{else}
! 			<object type="{$question->mediamimetype}" data="{$question->mediaurl}" />
! 		{/if}
! 		</div>
  	{/if}
! 	</itemBody>
! 	<responseProcessing xmlns="http://www.imsglobal.org/xsd/imsqti_item_v2p0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.imsglobal.org/xsd/imsqti_item_v2p0 ../imsqti_item_v2p0.xsd">
! 		<responseCondition>
! 			<responseIf>
! 				<isNull>
! 					<variable identifier="{$questionid}"/>
! 				</isNull>
! 				<setOutcomeValue identifier="SCORE">
! 					<baseValue baseType="integer">0</baseValue>
! 				</setOutcomeValue>
! 			</responseIf>
! 			<responseElse>
! 				<setOutcomeValue identifier="SCORE">
! 					<mapResponse identifier="{$questionid}"/>
! 				</setOutcomeValue>
! 			</responseElse>
! 		</responseCondition>
! 	</responseProcessing>
! </assessmentItem>
--- 1,42 ----
! {if $courselevelexport}
! <?xml version="1.0" encoding="UTF-8"?>
! {/if}
! <assessmentItem xmlns="http://www.imsglobal.org/xsd/imsqti_item_v2p0"
! 	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
! 	xsi:schemaLocation="http://www.imsglobal.org/xsd/imsqti_item_v2p0 ./imsqti_item_v2p0.xsd"
! 	identifier="{$assessmentitemidentifier}" title="{$assessmentitemtitle}"
! 	adaptive="false" timeDependent="false"> <responseDeclaration
! 	identifier="{$questionid}"
! 	cardinality="{$responsedeclarationcardinality}" baseType="string"> <correctResponse>
! {section name=answer loop=$correctresponses} <value>{$correctresponses[answer].answer}</value>
! {/section} </correctResponse> <mapping lowerBound="0" upperBound="1"
! 	defaultValue="0"> {section name=answer loop=$answers} {if
! $answers[answer].fraction != 0} <mapEntry
! 	mapKey="{$answers[answer].answer}"
! 	mappedValue="{$answers[answer].fraction}" /> {/if} {/section} </mapping>
! </responseDeclaration> <outcomeDeclaration identifier="SCORE"
! 	cardinality="single" baseType="float" /> <itemBody>
! <p>{$questionText}</p>
! <div class="interactive.textEntry">
! 	<textEntryInteraction responseIdentifier="{$questionid}"
! 		expectedLength="15" />
! </div>
! {if $question_has_image == 1}
! <div class="media">
! 	{if $hassize == 1}
! 	<object type="{$question->mediamimetype}" data="{$question->mediaurl}"
! 		width="{$question->mediax}" height="{$question->mediay}" />
! 	{else}
! 	<object type="{$question->mediamimetype}" data="{$question->mediaurl}" />
  	{/if}
! </div>
! {/if} </itemBody> <responseProcessing
! 	xmlns="http://www.imsglobal.org/xsd/imsqti_item_v2p0"
! 	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
! 	xsi:schemaLocation="http://www.imsglobal.org/xsd/imsqti_item_v2p0 ../imsqti_item_v2p0.xsd">
! <responseCondition> <responseIf> <isNull> <variable
! 	identifier="{$questionid}" /> </isNull> <setOutcomeValue
! 	identifier="SCORE"> <baseValue baseType="integer">0</baseValue> </setOutcomeValue>
! </responseIf> <responseElse> <setOutcomeValue identifier="SCORE"> <mapResponse
! 	identifier="{$questionid}" /> </setOutcomeValue> </responseElse> </responseCondition>
! </responseProcessing> </assessmentItem>
diff -crB questionorg/format/webct/format.php questionupd/format/webct/format.php
*** questionorg/format/webct/format.php	2012-04-13 12:31:11.199178252 +0500
--- questionupd/format/webct/format.php	2012-04-13 09:42:55.000000000 +0500
***************
*** 33,39 ****
   */
  
  function unhtmlentities($string){
!     $search = array ("'<script[?>]*?>.*?</script>'si",  // remove javascript
                   "'<[\/\!]*?[^<?>]*?>'si",  // remove HTML tags
                   "'([\r\n])[\s]+'",  // remove spaces
                   "'&(quot|#34);'i",  // remove HTML entites
--- 33,39 ----
   */
  
  function unhtmlentities($string){
! 	$search = array ("'<script[?>]*?>.*?</script>'si",  // remove javascript
                   "'<[\/\!]*?[^<?>]*?>'si",  // remove HTML tags
                   "'([\r\n])[\s]+'",  // remove spaces
                   "'&(quot|#34);'i",  // remove HTML entites
***************
*** 46,52 ****
                   "'&(pound|#163);'i",
                   "'&(copy|#169);'i",
                   "'&#(\d+);'e");  // Evaluate like PHP
!     $replace = array ("",
                    "",
                    "\\1",
                    "\"",
--- 46,52 ----
                   "'&(pound|#163);'i",
                   "'&(copy|#169);'i",
                   "'&#(\d+);'e");  // Evaluate like PHP
! 	$replace = array ("",
                    "",
                    "\\1",
                    "\"",
***************
*** 54,669 ****
                    "<",
                    "?>",
                    " ",
!                   chr(161),
!                   chr(162),
!                   chr(163),
!                   chr(169),
                    "chr(\\1)");
!     return preg_replace ($search, $replace, $string);
  }
  
  
  
  function qformat_webct_convert_formula($formula) {
  
!     // Remove empty space, as it would cause problems otherwise:
!     $formula = str_replace(' ', '', $formula);
  
!     // Remove paranthesis after e,E and *10**:
!     while (preg_match('~[0-9.](e|E|\\*10\\*\\*)\\([+-]?[0-9]+\\)~', $formula, $regs)) {
!         $formula = str_replace(
!                 $regs[0], preg_replace('/[)(]/', '', $regs[0]), $formula);
!     }
! 
!     // Replace *10** with e where possible
!     while (preg_match('~(^[+-]?|[^eE][+-]|[^0-9eE+-])[0-9.]+\\*10\\*\\*[+-]?[0-9]+([^0-9.eE]|$)~',
!             $formula, $regs)) {
!         $formula = str_replace(
!                 $regs[0], str_replace('*10**', 'e', $regs[0]), $formula);
!     }
! 
!     // Replace other 10** with 1e where possible
!     while (preg_match('~(^|[^0-9.eE])10\\*\\*[+-]?[0-9]+([^0-9.eE]|$)~', $formula, $regs)) {
!         $formula = str_replace(
!                 $regs[0], str_replace('10**', '1e', $regs[0]), $formula);
!     }
! 
!     // Replace all other base**exp with the PHP equivalent function pow(base,exp)
!     // (Pretty tricky to exchange an operator with a function)
!     while (2 == count($splits = explode('**', $formula, 2))) {
! 
!         // Find $base
!         if (preg_match('~^(.*[^0-9.eE])?(([0-9]+(\\.[0-9]*)?|\\.[0-9]+)([eE][+-]?[0-9]+)?|\\{[^}]*\\})$~',
!                 $splits[0], $regs)) {
!             // The simple cases
!             $base = $regs[2];
!             $splits[0] = $regs[1];
! 
!         } else if (preg_match('~\\)$~', $splits[0])) {
!             // Find the start of this parenthesis
!             $deep = 1;
!             for ($i = 1 ; $deep ; ++$i) {
!                 if (!preg_match('~^(.*[^[:alnum:]_])?([[:alnum:]_]*([)(])([^)(]*[)(]){'.$i.'})$~',
!                         $splits[0], $regs)) {
!                     print_error("parenthesisinproperstart", 'question', '', $splits[0]);
!                 }
!                 if ('(' == $regs[3]) {
!                     --$deep;
!                 } else if (')' == $regs[3]) {
!                     ++$deep;
!                 } else {
!                     print_error('impossiblechar', 'question', '', $regs[3]);
!                 }
!             }
!             $base = $regs[2];
!             $splits[0] = $regs[1];
! 
!         } else {
!             print_error('badbase', 'question', '', $splits[0]);
!         }
! 
!         // Find $exp (similar to above but a little easier)
!         if (preg_match('~^([+-]?(\\{[^}]\\}|([0-9]+(\\.[0-9]*)?|\\.[0-9]+)([eE][+-]?[0-9]+)?))(.*)~',
!                 $splits[1], $regs)) {
!             // The simple case
!             $exp = $regs[1];
!             $splits[1] = $regs[6];
! 
!         } else if (preg_match('~^[+-]?[[:alnum:]_]*\\(~', $splits[1])) {
!             // Find the end of the parenthesis
!             $deep = 1;
!             for ($i = 1 ; $deep ; ++$i) {
!                 if (!preg_match('~^([+-]?[[:alnum:]_]*([)(][^)(]*){'.$i.'}([)(]))(.*)~',
!                         $splits[1], $regs)) {
!                     print_error("parenthesisinproperclose", 'question', '', $splits[1]);
!                 }
!                 if (')' == $regs[3]) {
!                     --$deep;
!                 } else if ('(' == $regs[3]) {
!                     ++$deep;
!                 } else {
!                     print_error("impossiblechar", 'question');
!                 }
!             }
!             $exp = $regs[1];
!             $splits[1] = $regs[4];
!         }
! 
!         // Replace it!
!         $formula = "$splits[0]pow($base,$exp)$splits[1]";
!     }
  
!     // Nothing more is known to need to be converted
  
!     return $formula;
  }
  
  class qformat_webct extends qformat_default {
  
!     function provide_import() {
!       return true;
!     }
! 
!     function readquestions ($lines) {
!         global $QTYPES ;
!         //  $qtypecalculated = new qformat_webct_modified_calculated_qtype();
!         $webctnumberregex =
                  '[+-]?([0-9]+(\\.[0-9]*)?|\\.[0-9]+)((e|E|\\*10\\*\\*)([+-]?[0-9]+|\\([+-]?[0-9]+\\)))?';
  
!         $questions = array();
!         $errors = array();
!         $warnings = array();
!         $webct_options = array();
! 
!         $ignore_rest_of_question = FALSE;
! 
!         $nLineCounter = 0;
!         $nQuestionStartLine = 0;
!         $bIsHTMLText = FALSE;
!         $lines[] = ":EOF:";    // for an easiest processing of the last line
!     //    $question = $this->defaultquestion();
! 
!         foreach ($lines as $line) {
!             $nLineCounter++;
!             $line = iconv("Windows-1252","UTF-8",$line);
!             // Processing multiples lines strings
! 
!             if (isset($questiontext) and is_string($questiontext)) {
!                 if (preg_match("~^:~",$line)) {
!                     $question->questiontext = trim($questiontext);
!                     unset($questiontext);
!                 }
!                  else {
!                     $questiontext .= str_replace('\:', ':', $line);
!                     continue;
!                 }
!             }
! 
!             if (isset($answertext) and is_string($answertext)) {
!                 if (preg_match("~^:~",$line)) {
!                     $answertext = trim($answertext);
!                     $question->answer[$currentchoice] = $answertext;
!                     $question->subanswers[$currentchoice] = $answertext;
!                     unset($answertext);
!                 }
!                  else {
!                     $answertext .= str_replace('\:', ':', $line);
!                     continue;
!                 }
!             }
! 
!             if (isset($responsetext) and is_string($responsetext)) {
!                 if (preg_match("~^:~",$line)) {
!                     $question->subquestions[$currentchoice] = trim($responsetext);
!                     unset($responsetext);
!                 }
!                  else {
!                     $responsetext .= str_replace('\:', ':', $line);
!                     continue;
!                 }
!             }
! 
!             if (isset($feedbacktext) and is_string($feedbacktext)) {
!                 if (preg_match("~^:~",$line)) {
!                    $question->feedback[$currentchoice] = trim($feedbacktext);
!                     unset($feedbacktext);
!                 }
!                  else {
!                     $feedbacktext .= str_replace('\:', ':', $line);
!                     continue;
!                 }
!             }
! 
!             if (isset($generalfeedbacktext) and is_string($generalfeedbacktext)) {
!                 if (preg_match("~^:~",$line)) {
!                    $question->tempgeneralfeedback= trim($generalfeedbacktext);
!                     unset($generalfeedbacktext);
!                 }
!                  else {
!                     $generalfeedbacktext .= str_replace('\:', ':', $line);
!                     continue;
!                 }
!             }
! 
!             $line = trim($line);
! 
!             if (preg_match("~^:(TYPE|EOF):~i",$line)) {
!                 // New Question or End of File
!                 if (isset($question)) {            // if previous question exists, complete, check and save it
! 
!                     // Setup default value of missing fields
!                     if (!isset($question->name)) {
!                         $question->name = $question->questiontext;
!                     }
!                     if (strlen($question->name) > 255) {
!                         $question->name = substr($question->name,0,250)."...";
!                         $warnings[] = get_string("questionnametoolong", "quiz", $nQuestionStartLine);
!                     }
!                     if (!isset($question->defaultgrade)) {
!                         $question->defaultgrade = 1;
!                     }
!                     if (!isset($question->image)) {
!                         $question->image = "";
!                     }
! 
!                     // Perform sanity checks
!                     $QuestionOK = TRUE;
!                     if (strlen($question->questiontext) == 0) {
!                         $warnings[] = get_string("missingquestion", "quiz", $nQuestionStartLine);
!                         $QuestionOK = FALSE;
!                     }
!                     if (sizeof($question->answer) < 1) {  // a question must have at least 1 answer
!                        $errors[] = get_string("missinganswer", "quiz", $nQuestionStartLine);
!                        $QuestionOK = FALSE;
!                     }
!                     else {
!                         // Create empty feedback array
!                         foreach ($question->answer as $key => $dataanswer) {
!                             if(!isset( $question->feedback[$key])){
!                                 $question->feedback[$key] = '';
!                             }
!                         }
!                         // this tempgeneralfeedback allows the code to work with versions from 1.6 to 1.9
!                         // when question->generalfeedback is undefined, the webct feedback is added to each answer feedback
!                         if (isset($question->tempgeneralfeedback)){
!                             if (isset($question->generalfeedback)) {
!                                 $question->generalfeedback = $question->tempgeneralfeedback;
!                             } else {
!                                 foreach ($question->answer as $key => $dataanswer) {
!                                     if ($question->tempgeneralfeedback !=''){
!                                         $question->feedback[$key] = $question->tempgeneralfeedback.'<br/>'.$question->feedback[$key];
!                                     }
!                                 }
!                             }
!                             unset($question->tempgeneralfeedback);
!                         }
!                         $maxfraction = -1;
!                         $totalfraction = 0;
!                         foreach($question->fraction as $fraction) {
!                             if ($fraction > 0) {
!                                 $totalfraction += $fraction;
!                             }
!                             if ($fraction > $maxfraction) {
!                                 $maxfraction = $fraction;
!                             }
!                         }
!                         switch ($question->qtype) {
!                             case SHORTANSWER:
!                                 if ($maxfraction != 1) {
!                                     $maxfraction = $maxfraction * 100;
!                                     $errors[] = "'$question->name': ".get_string("wronggrade", "quiz", $nLineCounter).' '.get_string("fractionsnomax", "quiz", $maxfraction);
!                                     $QuestionOK = FALSE;
!                                 }
!                                 break;
! 
!                             case MULTICHOICE:
!                                 if ($question->single) {
!                                     if ($maxfraction != 1) {
!                                         $maxfraction = $maxfraction * 100;
!                                         $errors[] = "'$question->name': ".get_string("wronggrade", "quiz", $nLineCounter).' '.get_string("fractionsnomax", "quiz", $maxfraction);
!                                         $QuestionOK = FALSE;
!                                     }
!                                 } else {
!                                     $totalfraction = round($totalfraction,2);
!                                     if ($totalfraction != 1) {
!                                         $totalfraction = $totalfraction * 100;
!                                         $errors[] = "'$question->name': ".get_string("wronggrade", "quiz", $nLineCounter).' '.get_string("fractionsaddwrong", "quiz", $totalfraction);
!                                         $QuestionOK = FALSE;
!                                     }
!                                 }
!                                 break;
! 
!                             case CALCULATED:
!                                 foreach ($question->answers as $answer) {
!                                     if ($formulaerror =qtype_calculated_find_formula_errors($answer)) { //$QTYPES['calculated']->
!                                         $warnings[] = "'$question->name': ". $formulaerror;
!                                         $QuestionOK = FALSE;
!                                     }
!                                 }
!                                 foreach ($question->dataset as $dataset) {
!                                     $dataset->itemcount=count($dataset->datasetitem);
!                                 }
!                                 $question->import_process=TRUE ;
!                                 unset($question->answer); //not used in calculated question
!                                 break;
!                             case MATCH:
!                                 // MDL-10680:
!                                 // switch subquestions and subanswers
!                                 foreach ($question->subquestions as $id=>$subquestion) {
!                                     $temp = $question->subquestions[$id];
!                                     $question->subquestions[$id] = $question->subanswers[$id];
!                                     $question->subanswers[$id] = $temp;
!                                 }
!                                 if (count($question->answer) < 3){
!                                     // add a dummy missing question
!                                     $question->name = 'Dummy question added '.$question->name ;
!                                     $question->answer[] = 'dummy';
!                                     $question->subanswers[] = 'dummy';
!                                     $question->subquestions[] = 'dummy';
!                                     $question->fraction[] = '0.0';
!                                     $question->feedback[] = '';
!                                  }
!                                  break;
!                             default:
!                                 // No problemo
!                         }
!                     }
! 
!                     if ($QuestionOK) {
!                        // echo "<pre>"; print_r ($question);
!                         $questions[] = $question;    // store it
!                         unset($question);            // and prepare a new one
!                         $question = $this->defaultquestion();
!                     }
!                 }
!                 $nQuestionStartLine = $nLineCounter;
!             }
! 
!             // Processing Question Header
! 
!             if (preg_match("~^:TYPE:MC:1(.*)~i",$line,$webct_options)) {
!                 // Multiple Choice Question with only one good answer
!                 $question = $this->defaultquestion();
!                 $question->feedback = array();
!                 $question->qtype = MULTICHOICE;
!                 $question->single = 1;        // Only one answer is allowed
!                 $ignore_rest_of_question = FALSE;
!                 continue;
!             }
! 
!             if (preg_match("~^:TYPE:MC:N(.*)~i",$line,$webct_options)) {
!                 // Multiple Choice Question with several good answers
!                 $question = $this->defaultquestion();
!                 $question->feedback = array();
!                 $question->qtype = MULTICHOICE;
!                 $question->single = 0;        // Many answers allowed
!                 $ignore_rest_of_question = FALSE;
!                 continue;
!             }
! 
!             if (preg_match("~^:TYPE:S~i",$line)) {
!                 // Short Answer Question
!                 $question = $this->defaultquestion();
!                 $question->feedback = array();
!                 $question->qtype = SHORTANSWER;
!                 $question->usecase = 0;       // Ignore case
!                 $ignore_rest_of_question = FALSE;
!                 continue;
!             }
! 
!             if (preg_match("~^:TYPE:C~i",$line)) {
!                 // Calculated Question
!            /*     $warnings[] = get_string("calculatedquestion", "quiz", $nLineCounter);
!                 unset($question);
!                 $ignore_rest_of_question = TRUE;         // Question Type not handled by Moodle
!              */
!                 $question = $this->defaultquestion();
!                 $question->qtype = CALCULATED;
!                 $question->answers = array(); // No problem as they go as :FORMULA: from webct
!                 $question->units = array();
!                 $question->dataset = array();
! 
!                 // To make us pass the end-of-question sanity checks
!                 $question->answer = array('dummy');
!                 $question->fraction = array('1.0');
!                 $question->feedback = array();
! 
!                 $currentchoice = -1;
!                 $ignore_rest_of_question = FALSE;
!                 continue;
!             }
! 
!             if (preg_match("~^:TYPE:M~i",$line)) {
!                 // Match Question
!                 $question = $this->defaultquestion();
!                 $question->qtype = MATCH;
!                 $question->feedback = array();
!                 $ignore_rest_of_question = FALSE;         // match question processing is not debugged
!                 continue;
!             }
! 
!             if (preg_match("~^:TYPE:P~i",$line)) {
!                 // Paragraph Question
!                 $warnings[] = get_string("paragraphquestion", "quiz", $nLineCounter);
!                 unset($question);
!                 $ignore_rest_of_question = TRUE;         // Question Type not handled by Moodle
!                 continue;
!             }
! 
!             if (preg_match("~^:TYPE:~i",$line)) {
!                 // Unknow Question
!                 $warnings[] = get_string("unknowntype", "quiz", $nLineCounter);
!                 unset($question);
!                 $ignore_rest_of_question = TRUE;         // Question Type not handled by Moodle
!                 continue;
!             }
! 
!             if ($ignore_rest_of_question) {
!                 continue;
!             }
! 
!             if (preg_match("~^:TITLE:(.*)~i",$line,$webct_options)) {
!                 $name = trim($webct_options[1]);
!                 if (strlen($name) > 255) {
!                     $name = substr($name,0,250)."...";
!                     $warnings[] = get_string("questionnametoolong", "quiz", $nLineCounter);
!                 }
!                 $question->name = $name;
!                 continue;
!             }
! 
!             if (preg_match("~^:IMAGE:(.*)~i",$line,$webct_options)) {
!                 $filename = trim($webct_options[1]);
!                 if (preg_match("~^http://~i",$filename)) {
!                     $question->image = $filename;
!                 }
!                 continue;
!             }
! 
!             // Need to put the parsing of calculated items here to avoid ambitiuosness:
!             // if question isn't defined yet there is nothing to do here (avoid notices)
!             if (!isset($question)) {
!                 continue;
!             }
!             if (isset($question->qtype ) && CALCULATED == $question->qtype && preg_match(
                      "~^:([[:lower:]].*|::.*)-(MIN|MAX|DEC|VAL([0-9]+))::?:?($webctnumberregex)~", $line, $webct_options)) {
!                 $datasetname = preg_replace('/^::/', '', $webct_options[1]);
!                 $datasetvalue = qformat_webct_convert_formula($webct_options[4]);
!                 switch ($webct_options[2]) {
!                     case 'MIN':
!                         $question->dataset[$datasetname]->min = $datasetvalue;
!                         break;
!                     case 'MAX':
!                         $question->dataset[$datasetname]->max = $datasetvalue;
!                         break;
!                     case 'DEC':
!                         $datasetvalue = floor($datasetvalue); // int only!
!                         $question->dataset[$datasetname]->length = max(0, $datasetvalue);
!                         break;
!                     default:
!                         // The VAL case:
!                         $question->dataset[$datasetname]->datasetitem[$webct_options[3]] = new stdClass();
!                         $question->dataset[$datasetname]->datasetitem[$webct_options[3]]->itemnumber = $webct_options[3];
!                         $question->dataset[$datasetname]->datasetitem[$webct_options[3]]->value  = $datasetvalue;
!                         break;
!                 }
!                 continue;
!             }
! 
! 
!             $bIsHTMLText = preg_match("~:H$~i",$line);  // True if next lines are coded in HTML
!             if (preg_match("~^:QUESTION~i",$line)) {
!                 $questiontext="";               // Start gathering next lines
!                 continue;
!             }
! 
!             if (preg_match("~^:ANSWER([0-9]+):([^:]+):([0-9\.\-]+):(.*)~i",$line,$webct_options)) {      /// SHORTANSWER
!                 $currentchoice=$webct_options[1];
!                 $answertext=$webct_options[2];            // Start gathering next lines
!                 $question->fraction[$currentchoice]=($webct_options[3]/100);
!                 continue;
!             }
! 
!             if (preg_match("~^:ANSWER([0-9]+):([0-9\.\-]+)~i",$line,$webct_options)) {
!                 $answertext="";                 // Start gathering next lines
!                 $currentchoice=$webct_options[1];
!                 $question->fraction[$currentchoice]=($webct_options[2]/100);
!                 continue;
!             }
! 
!             if (preg_match('~^:FORMULA:(.*)~i', $line, $webct_options)) {
!                 // Answer for a CALCULATED question
!                 ++$currentchoice;
!                 $question->answers[$currentchoice] =
!                         qformat_webct_convert_formula($webct_options[1]);
! 
!                 // Default settings:
!                 $question->fraction[$currentchoice] = 1.0;
!                 $question->tolerance[$currentchoice] = 0.0;
!                 $question->tolerancetype[$currentchoice] = 2; // nominal (units in webct)
!                 $question->feedback[$currentchoice] = '';
!                 $question->correctanswerlength[$currentchoice] = 4;
! 
!                 $datasetnames = $QTYPES[CALCULATED]->find_dataset_names($webct_options[1]);
!                 foreach ($datasetnames as $datasetname) {
!                     $question->dataset[$datasetname] = new stdClass();
!                     $question->dataset[$datasetname]->datasetitem = array();
!                     $question->dataset[$datasetname]->name = $datasetname ;
!                     $question->dataset[$datasetname]->distribution = 'uniform';
!                     $question->dataset[$datasetname]->status ='private';
!                 }
!                 continue;
!             }
! 
!             if (preg_match("~^:L([0-9]+)~i",$line,$webct_options)) {
!                 $answertext="";                 // Start gathering next lines
!                 $currentchoice=$webct_options[1];
!                 $question->fraction[$currentchoice]=1;
!                 continue;
!             }
! 
!             if (preg_match("~^:R([0-9]+)~i",$line,$webct_options)) {
!                 $responsetext="";                // Start gathering next lines
!                 $currentchoice=$webct_options[1];
!                 continue;
!             }
! 
!             if (preg_match("~^:REASON([0-9]+):?~i",$line,$webct_options)) {
!                 $feedbacktext="";               // Start gathering next lines
!                 $currentchoice=$webct_options[1];
!                 continue;
!             }
!             if (preg_match("~^:FEEDBACK([0-9]+):?~i",$line,$webct_options)) {
!                 $generalfeedbacktext="";               // Start gathering next lines
!                 $currentchoice=$webct_options[1];
!                 continue;
!             }
!             if (preg_match('~^:FEEDBACK:(.*)~i',$line,$webct_options)) {
!                 $generalfeedbacktext="";               // Start gathering next lines
!                 continue;
!             }
!             if (preg_match('~^:LAYOUT:(.*)~i',$line,$webct_options)) {
!             //    ignore  since layout in question_multichoice  is no more used in moodle
!             //    $webct_options[1] contains either vertical or horizontal ;
!                 continue;
!             }
! 
!             if (isset($question->qtype ) && CALCULATED == $question->qtype && preg_match('~^:ANS-DEC:([1-9][0-9]*)~i', $line, $webct_options)) {
!                 // We can but hope that this always appear before the ANSTYPE property
!                 $question->correctanswerlength[$currentchoice] = $webct_options[1];
!                 continue;
!             }
! 
!             if (isset($question->qtype )&& CALCULATED == $question->qtype && preg_match("~^:TOL:($webctnumberregex)~i", $line, $webct_options)) {
!                 // We can but hope that this always appear before the TOL property
!                 $question->tolerance[$currentchoice] =
!                         qformat_webct_convert_formula($webct_options[1]);
!                 continue;
!             }
! 
!             if (isset($question->qtype )&& CALCULATED == $question->qtype && preg_match('~^:TOLTYPE:percent~i', $line)) {
!                 // Percentage case is handled as relative in Moodle:
!                 $question->tolerance[$currentchoice]  /= 100;
!                 $question->tolerancetype[$currentchoice] = 1; // Relative
!                 continue;
!             }
  
!             if (preg_match('~^:UNITS:(.+)~i', $line, $webct_options)
                      and $webctunits = trim($webct_options[1])) {
!                 // This is a guess - I really do not know how different webct units are separated...
!                 $webctunits = explode(':', $webctunits);
!                 $unitrec->multiplier = 1.0; // Webct does not seem to support this
!                 foreach ($webctunits as $webctunit) {
!                     $unitrec->unit = trim($webctunit);
!                     $question->units[] = $unitrec;
!                 }
!                 continue;
!             }
  
!             if (!empty($question->units) && preg_match('~^:UNITREQ:(.*)~i', $line, $webct_options)
                      && !$webct_options[1]) {
!                 // There are units but units are not required so add the no unit alternative
!                 // We can but hope that the UNITS property always appear before this property
!                 $unitrec->unit = '';
!                 $unitrec->multiplier = 1.0;
!                 $question->units[] = $unitrec;
!                 continue;
!             }
! 
!             if (!empty($question->units) && preg_match('~^:UNITCASE:~i', $line)) {
!                 // This could be important but I was not able to figure out how
!                 // it works so I ignore it for now
!                 continue;
!             }
! 
!             if (isset($question->qtype )&& CALCULATED == $question->qtype && preg_match('~^:ANSTYPE:dec~i', $line)) {
!                 $question->correctanswerformat[$currentchoice]='1';
!                 continue;
!             }
!             if (isset($question->qtype )&& CALCULATED == $question->qtype && preg_match('~^:ANSTYPE:sig~i', $line)) {
!                 $question->correctanswerformat[$currentchoice]='2';
!                 continue;
!             }
!         }
! 
!         if (sizeof($errors) > 0) {
!             echo "<p>".get_string("errorsdetected", "quiz", sizeof($errors))."</p><ul>";
!             foreach($errors as $error) {
!                 echo "<li>$error</li>";
!             }
!             echo "</ul>";
!             unset($questions);     // no questions imported
!         }
! 
!         if (sizeof($warnings) > 0) {
!             echo "<p>".get_string("warningsdetected", "quiz", sizeof($warnings))."</p><ul>";
!             foreach($warnings as $warning) {
!                 echo "<li>$warning</li>";
!             }
!             echo "</ul>";
!         }
!         return $questions;
!     }
  }
  
  ?>
--- 54,669 ----
                    "<",
                    "?>",
                    " ",
! 	chr(161),
! 	chr(162),
! 	chr(163),
! 	chr(169),
                    "chr(\\1)");
! 	return preg_replace ($search, $replace, $string);
  }
  
  
  
  function qformat_webct_convert_formula($formula) {
  
! 	// Remove empty space, as it would cause problems otherwise:
! 	$formula = str_replace(' ', '', $formula);
  
! 	// Remove paranthesis after e,E and *10**:
! 	while (preg_match('~[0-9.](e|E|\\*10\\*\\*)\\([+-]?[0-9]+\\)~', $formula, $regs)) {
! 		$formula = str_replace(
! 		$regs[0], preg_replace('/[)(]/', '', $regs[0]), $formula);
! 	}
! 
! 	// Replace *10** with e where possible
! 	while (preg_match('~(^[+-]?|[^eE][+-]|[^0-9eE+-])[0-9.]+\\*10\\*\\*[+-]?[0-9]+([^0-9.eE]|$)~',
! 	$formula, $regs)) {
! 		$formula = str_replace(
! 		$regs[0], str_replace('*10**', 'e', $regs[0]), $formula);
! 	}
! 
! 	// Replace other 10** with 1e where possible
! 	while (preg_match('~(^|[^0-9.eE])10\\*\\*[+-]?[0-9]+([^0-9.eE]|$)~', $formula, $regs)) {
! 		$formula = str_replace(
! 		$regs[0], str_replace('10**', '1e', $regs[0]), $formula);
! 	}
! 
! 	// Replace all other base**exp with the PHP equivalent function pow(base,exp)
! 	// (Pretty tricky to exchange an operator with a function)
! 	while (2 == count($splits = explode('**', $formula, 2))) {
! 
! 		// Find $base
! 		if (preg_match('~^(.*[^0-9.eE])?(([0-9]+(\\.[0-9]*)?|\\.[0-9]+)([eE][+-]?[0-9]+)?|\\{[^}]*\\})$~',
! 		$splits[0], $regs)) {
! 			// The simple cases
! 			$base = $regs[2];
! 			$splits[0] = $regs[1];
! 
! 		} else if (preg_match('~\\)$~', $splits[0])) {
! 			// Find the start of this parenthesis
! 			$deep = 1;
! 			for ($i = 1 ; $deep ; ++$i) {
! 				if (!preg_match('~^(.*[^[:alnum:]_])?([[:alnum:]_]*([)(])([^)(]*[)(]){'.$i.'})$~',
! 				$splits[0], $regs)) {
! 					print_error("parenthesisinproperstart", 'question', '', $splits[0]);
! 				}
! 				if ('(' == $regs[3]) {
! 					--$deep;
! 				} else if (')' == $regs[3]) {
! 					++$deep;
! 				} else {
! 					print_error('impossiblechar', 'question', '', $regs[3]);
! 				}
! 			}
! 			$base = $regs[2];
! 			$splits[0] = $regs[1];
! 
! 		} else {
! 			print_error('badbase', 'question', '', $splits[0]);
! 		}
! 
! 		// Find $exp (similar to above but a little easier)
! 		if (preg_match('~^([+-]?(\\{[^}]\\}|([0-9]+(\\.[0-9]*)?|\\.[0-9]+)([eE][+-]?[0-9]+)?))(.*)~',
! 		$splits[1], $regs)) {
! 			// The simple case
! 			$exp = $regs[1];
! 			$splits[1] = $regs[6];
! 
! 		} else if (preg_match('~^[+-]?[[:alnum:]_]*\\(~', $splits[1])) {
! 			// Find the end of the parenthesis
! 			$deep = 1;
! 			for ($i = 1 ; $deep ; ++$i) {
! 				if (!preg_match('~^([+-]?[[:alnum:]_]*([)(][^)(]*){'.$i.'}([)(]))(.*)~',
! 				$splits[1], $regs)) {
! 					print_error("parenthesisinproperclose", 'question', '', $splits[1]);
! 				}
! 				if (')' == $regs[3]) {
! 					--$deep;
! 				} else if ('(' == $regs[3]) {
! 					++$deep;
! 				} else {
! 					print_error("impossiblechar", 'question');
! 				}
! 			}
! 			$exp = $regs[1];
! 			$splits[1] = $regs[4];
! 		}
! 
! 		// Replace it!
! 		$formula = "$splits[0]pow($base,$exp)$splits[1]";
! 	}
  
! 	// Nothing more is known to need to be converted
  
! 	return $formula;
  }
  
  class qformat_webct extends qformat_default {
  
! 	function provide_import() {
! 		return true;
! 	}
! 
! 	function readquestions ($lines) {
! 		global $QTYPES ;
! 		//  $qtypecalculated = new qformat_webct_modified_calculated_qtype();
! 		$webctnumberregex =
                  '[+-]?([0-9]+(\\.[0-9]*)?|\\.[0-9]+)((e|E|\\*10\\*\\*)([+-]?[0-9]+|\\([+-]?[0-9]+\\)))?';
  
! 		$questions = array();
! 		$errors = array();
! 		$warnings = array();
! 		$webct_options = array();
! 
! 		$ignore_rest_of_question = FALSE;
! 
! 		$nLineCounter = 0;
! 		$nQuestionStartLine = 0;
! 		$bIsHTMLText = FALSE;
! 		$lines[] = ":EOF:";    // for an easiest processing of the last line
! 		//    $question = $this->defaultquestion();
! 
! 		foreach ($lines as $line) {
! 			$nLineCounter++;
! 			$line = iconv("Windows-1252","UTF-8",$line);
! 			// Processing multiples lines strings
! 
! 			if (isset($questiontext) and is_string($questiontext)) {
! 				if (preg_match("~^:~",$line)) {
! 					$question->questiontext = trim($questiontext);
! 					unset($questiontext);
! 				}
! 				else {
! 					$questiontext .= str_replace('\:', ':', $line);
! 					continue;
! 				}
! 			}
! 
! 			if (isset($answertext) and is_string($answertext)) {
! 				if (preg_match("~^:~",$line)) {
! 					$answertext = trim($answertext);
! 					$question->answer[$currentchoice] = $answertext;
! 					$question->subanswers[$currentchoice] = $answertext;
! 					unset($answertext);
! 				}
! 				else {
! 					$answertext .= str_replace('\:', ':', $line);
! 					continue;
! 				}
! 			}
! 
! 			if (isset($responsetext) and is_string($responsetext)) {
! 				if (preg_match("~^:~",$line)) {
! 					$question->subquestions[$currentchoice] = trim($responsetext);
! 					unset($responsetext);
! 				}
! 				else {
! 					$responsetext .= str_replace('\:', ':', $line);
! 					continue;
! 				}
! 			}
! 
! 			if (isset($feedbacktext) and is_string($feedbacktext)) {
! 				if (preg_match("~^:~",$line)) {
! 					$question->feedback[$currentchoice] = trim($feedbacktext);
! 					unset($feedbacktext);
! 				}
! 				else {
! 					$feedbacktext .= str_replace('\:', ':', $line);
! 					continue;
! 				}
! 			}
! 
! 			if (isset($generalfeedbacktext) and is_string($generalfeedbacktext)) {
! 				if (preg_match("~^:~",$line)) {
! 					$question->tempgeneralfeedback= trim($generalfeedbacktext);
! 					unset($generalfeedbacktext);
! 				}
! 				else {
! 					$generalfeedbacktext .= str_replace('\:', ':', $line);
! 					continue;
! 				}
! 			}
! 
! 			$line = trim($line);
! 
! 			if (preg_match("~^:(TYPE|EOF):~i",$line)) {
! 				// New Question or End of File
! 				if (isset($question)) {            // if previous question exists, complete, check and save it
! 
! 					// Setup default value of missing fields
! 					if (!isset($question->name)) {
! 						$question->name = $question->questiontext;
! 					}
! 					if (strlen($question->name) > 255) {
! 						$question->name = substr($question->name,0,250)."...";
! 						$warnings[] = get_string("questionnametoolong", "quiz", $nQuestionStartLine);
! 					}
! 					if (!isset($question->defaultgrade)) {
! 						$question->defaultgrade = 1;
! 					}
! 					if (!isset($question->image)) {
! 						$question->image = "";
! 					}
! 
! 					// Perform sanity checks
! 					$QuestionOK = TRUE;
! 					if (strlen($question->questiontext) == 0) {
! 						$warnings[] = get_string("missingquestion", "quiz", $nQuestionStartLine);
! 						$QuestionOK = FALSE;
! 					}
! 					if (sizeof($question->answer) < 1) {  // a question must have at least 1 answer
! 						$errors[] = get_string("missinganswer", "quiz", $nQuestionStartLine);
! 						$QuestionOK = FALSE;
! 					}
! 					else {
! 						// Create empty feedback array
! 						foreach ($question->answer as $key => $dataanswer) {
! 							if(!isset( $question->feedback[$key])){
! 								$question->feedback[$key] = '';
! 							}
! 						}
! 						// this tempgeneralfeedback allows the code to work with versions from 1.6 to 1.9
! 						// when question->generalfeedback is undefined, the webct feedback is added to each answer feedback
! 						if (isset($question->tempgeneralfeedback)){
! 							if (isset($question->generalfeedback)) {
! 								$question->generalfeedback = $question->tempgeneralfeedback;
! 							} else {
! 								foreach ($question->answer as $key => $dataanswer) {
! 									if ($question->tempgeneralfeedback !=''){
! 										$question->feedback[$key] = $question->tempgeneralfeedback.'<br/>'.$question->feedback[$key];
! 									}
! 								}
! 							}
! 							unset($question->tempgeneralfeedback);
! 						}
! 						$maxfraction = -1;
! 						$totalfraction = 0;
! 						foreach($question->fraction as $fraction) {
! 							if ($fraction > 0) {
! 								$totalfraction += $fraction;
! 							}
! 							if ($fraction > $maxfraction) {
! 								$maxfraction = $fraction;
! 							}
! 						}
! 						switch ($question->qtype) {
! 							case SHORTANSWER:
! 								if ($maxfraction != 1) {
! 									$maxfraction = $maxfraction * 100;
! 									$errors[] = "'$question->name': ".get_string("wronggrade", "quiz", $nLineCounter).' '.get_string("fractionsnomax", "quiz", $maxfraction);
! 									$QuestionOK = FALSE;
! 								}
! 								break;
! 
! 							case MULTICHOICE:
! 								if ($question->single) {
! 									if ($maxfraction != 1) {
! 										$maxfraction = $maxfraction * 100;
! 										$errors[] = "'$question->name': ".get_string("wronggrade", "quiz", $nLineCounter).' '.get_string("fractionsnomax", "quiz", $maxfraction);
! 										$QuestionOK = FALSE;
! 									}
! 								} else {
! 									$totalfraction = round($totalfraction,2);
! 									if ($totalfraction != 1) {
! 										$totalfraction = $totalfraction * 100;
! 										$errors[] = "'$question->name': ".get_string("wronggrade", "quiz", $nLineCounter).' '.get_string("fractionsaddwrong", "quiz", $totalfraction);
! 										$QuestionOK = FALSE;
! 									}
! 								}
! 								break;
! 
! 							case CALCULATED:
! 								foreach ($question->answers as $answer) {
! 									if ($formulaerror =qtype_calculated_find_formula_errors($answer)) { //$QTYPES['calculated']->
! 										$warnings[] = "'$question->name': ". $formulaerror;
! 										$QuestionOK = FALSE;
! 									}
! 								}
! 								foreach ($question->dataset as $dataset) {
! 									$dataset->itemcount=count($dataset->datasetitem);
! 								}
! 								$question->import_process=TRUE ;
! 								unset($question->answer); //not used in calculated question
! 								break;
! 							case MATCH:
! 								// MDL-10680:
! 								// switch subquestions and subanswers
! 								foreach ($question->subquestions as $id=>$subquestion) {
! 									$temp = $question->subquestions[$id];
! 									$question->subquestions[$id] = $question->subanswers[$id];
! 									$question->subanswers[$id] = $temp;
! 								}
! 								if (count($question->answer) < 3){
! 									// add a dummy missing question
! 									$question->name = 'Dummy question added '.$question->name ;
! 									$question->answer[] = 'dummy';
! 									$question->subanswers[] = 'dummy';
! 									$question->subquestions[] = 'dummy';
! 									$question->fraction[] = '0.0';
! 									$question->feedback[] = '';
! 								}
! 								break;
! 							default:
! 								// No problemo
! 						}
! 					}
! 
! 					if ($QuestionOK) {
! 						// echo "<pre>"; print_r ($question);
! 						$questions[] = $question;    // store it
! 						unset($question);            // and prepare a new one
! 						$question = $this->defaultquestion();
! 					}
! 				}
! 				$nQuestionStartLine = $nLineCounter;
! 			}
! 
! 			// Processing Question Header
! 
! 			if (preg_match("~^:TYPE:MC:1(.*)~i",$line,$webct_options)) {
! 				// Multiple Choice Question with only one good answer
! 				$question = $this->defaultquestion();
! 				$question->feedback = array();
! 				$question->qtype = MULTICHOICE;
! 				$question->single = 1;        // Only one answer is allowed
! 				$ignore_rest_of_question = FALSE;
! 				continue;
! 			}
! 
! 			if (preg_match("~^:TYPE:MC:N(.*)~i",$line,$webct_options)) {
! 				// Multiple Choice Question with several good answers
! 				$question = $this->defaultquestion();
! 				$question->feedback = array();
! 				$question->qtype = MULTICHOICE;
! 				$question->single = 0;        // Many answers allowed
! 				$ignore_rest_of_question = FALSE;
! 				continue;
! 			}
! 
! 			if (preg_match("~^:TYPE:S~i",$line)) {
! 				// Short Answer Question
! 				$question = $this->defaultquestion();
! 				$question->feedback = array();
! 				$question->qtype = SHORTANSWER;
! 				$question->usecase = 0;       // Ignore case
! 				$ignore_rest_of_question = FALSE;
! 				continue;
! 			}
! 
! 			if (preg_match("~^:TYPE:C~i",$line)) {
! 				// Calculated Question
! 				/*     $warnings[] = get_string("calculatedquestion", "quiz", $nLineCounter);
! 				unset($question);
! 				$ignore_rest_of_question = TRUE;         // Question Type not handled by Moodle
! 				*/
! 				$question = $this->defaultquestion();
! 				$question->qtype = CALCULATED;
! 				$question->answers = array(); // No problem as they go as :FORMULA: from webct
! 				$question->units = array();
! 				$question->dataset = array();
! 
! 				// To make us pass the end-of-question sanity checks
! 				$question->answer = array('dummy');
! 				$question->fraction = array('1.0');
! 				$question->feedback = array();
! 
! 				$currentchoice = -1;
! 				$ignore_rest_of_question = FALSE;
! 				continue;
! 			}
! 
! 			if (preg_match("~^:TYPE:M~i",$line)) {
! 				// Match Question
! 				$question = $this->defaultquestion();
! 				$question->qtype = MATCH;
! 				$question->feedback = array();
! 				$ignore_rest_of_question = FALSE;         // match question processing is not debugged
! 				continue;
! 			}
! 
! 			if (preg_match("~^:TYPE:P~i",$line)) {
! 				// Paragraph Question
! 				$warnings[] = get_string("paragraphquestion", "quiz", $nLineCounter);
! 				unset($question);
! 				$ignore_rest_of_question = TRUE;         // Question Type not handled by Moodle
! 				continue;
! 			}
! 
! 			if (preg_match("~^:TYPE:~i",$line)) {
! 				// Unknow Question
! 				$warnings[] = get_string("unknowntype", "quiz", $nLineCounter);
! 				unset($question);
! 				$ignore_rest_of_question = TRUE;         // Question Type not handled by Moodle
! 				continue;
! 			}
! 
! 			if ($ignore_rest_of_question) {
! 				continue;
! 			}
! 
! 			if (preg_match("~^:TITLE:(.*)~i",$line,$webct_options)) {
! 				$name = trim($webct_options[1]);
! 				if (strlen($name) > 255) {
! 					$name = substr($name,0,250)."...";
! 					$warnings[] = get_string("questionnametoolong", "quiz", $nLineCounter);
! 				}
! 				$question->name = $name;
! 				continue;
! 			}
! 
! 			if (preg_match("~^:IMAGE:(.*)~i",$line,$webct_options)) {
! 				$filename = trim($webct_options[1]);
! 				if (preg_match("~^http://~i",$filename)) {
! 					$question->image = $filename;
! 				}
! 				continue;
! 			}
! 
! 			// Need to put the parsing of calculated items here to avoid ambitiuosness:
! 			// if question isn't defined yet there is nothing to do here (avoid notices)
! 			if (!isset($question)) {
! 				continue;
! 			}
! 			if (isset($question->qtype ) && CALCULATED == $question->qtype && preg_match(
                      "~^:([[:lower:]].*|::.*)-(MIN|MAX|DEC|VAL([0-9]+))::?:?($webctnumberregex)~", $line, $webct_options)) {
! 			$datasetname = preg_replace('/^::/', '', $webct_options[1]);
! 			$datasetvalue = qformat_webct_convert_formula($webct_options[4]);
! 			switch ($webct_options[2]) {
! 				case 'MIN':
! 					$question->dataset[$datasetname]->min = $datasetvalue;
! 					break;
! 				case 'MAX':
! 					$question->dataset[$datasetname]->max = $datasetvalue;
! 					break;
! 				case 'DEC':
! 					$datasetvalue = floor($datasetvalue); // int only!
! 					$question->dataset[$datasetname]->length = max(0, $datasetvalue);
! 					break;
! 				default:
! 					// The VAL case:
! 					$question->dataset[$datasetname]->datasetitem[$webct_options[3]] = new stdClass();
! 					$question->dataset[$datasetname]->datasetitem[$webct_options[3]]->itemnumber = $webct_options[3];
! 					$question->dataset[$datasetname]->datasetitem[$webct_options[3]]->value  = $datasetvalue;
! 					break;
! 			}
! 			continue;
!                     }
! 
  
!                     $bIsHTMLText = preg_match("~:H$~i",$line);  // True if next lines are coded in HTML
!                     if (preg_match("~^:QUESTION~i",$line)) {
!                     	$questiontext="";               // Start gathering next lines
!                     	continue;
!                     }
! 
!                     if (preg_match("~^:ANSWER([0-9]+):([^:]+):([0-9\.\-]+):(.*)~i",$line,$webct_options)) {      /// SHORTANSWER
!                     	$currentchoice=$webct_options[1];
!                     	$answertext=$webct_options[2];            // Start gathering next lines
!                     	$question->fraction[$currentchoice]=($webct_options[3]/100);
!                     	continue;
!                     }
! 
!                     if (preg_match("~^:ANSWER([0-9]+):([0-9\.\-]+)~i",$line,$webct_options)) {
!                     	$answertext="";                 // Start gathering next lines
!                     	$currentchoice=$webct_options[1];
!                     	$question->fraction[$currentchoice]=($webct_options[2]/100);
!                     	continue;
!                     }
! 
!                     if (preg_match('~^:FORMULA:(.*)~i', $line, $webct_options)) {
!                     	// Answer for a CALCULATED question
!                     	++$currentchoice;
!                     	$question->answers[$currentchoice] =
!                     	qformat_webct_convert_formula($webct_options[1]);
! 
!                     	// Default settings:
!                     	$question->fraction[$currentchoice] = 1.0;
!                     	$question->tolerance[$currentchoice] = 0.0;
!                     	$question->tolerancetype[$currentchoice] = 2; // nominal (units in webct)
!                     	$question->feedback[$currentchoice] = '';
!                     	$question->correctanswerlength[$currentchoice] = 4;
! 
!                     	$datasetnames = $QTYPES[CALCULATED]->find_dataset_names($webct_options[1]);
!                     	foreach ($datasetnames as $datasetname) {
!                     		$question->dataset[$datasetname] = new stdClass();
!                     		$question->dataset[$datasetname]->datasetitem = array();
!                     		$question->dataset[$datasetname]->name = $datasetname ;
!                     		$question->dataset[$datasetname]->distribution = 'uniform';
!                     		$question->dataset[$datasetname]->status ='private';
!                     	}
!                     	continue;
!                     }
! 
!                     if (preg_match("~^:L([0-9]+)~i",$line,$webct_options)) {
!                     	$answertext="";                 // Start gathering next lines
!                     	$currentchoice=$webct_options[1];
!                     	$question->fraction[$currentchoice]=1;
!                     	continue;
!                     }
! 
!                     if (preg_match("~^:R([0-9]+)~i",$line,$webct_options)) {
!                     	$responsetext="";                // Start gathering next lines
!                     	$currentchoice=$webct_options[1];
!                     	continue;
!                     }
! 
!                     if (preg_match("~^:REASON([0-9]+):?~i",$line,$webct_options)) {
!                     	$feedbacktext="";               // Start gathering next lines
!                     	$currentchoice=$webct_options[1];
!                     	continue;
!                     }
!                     if (preg_match("~^:FEEDBACK([0-9]+):?~i",$line,$webct_options)) {
!                     	$generalfeedbacktext="";               // Start gathering next lines
!                     	$currentchoice=$webct_options[1];
!                     	continue;
!                     }
!                     if (preg_match('~^:FEEDBACK:(.*)~i',$line,$webct_options)) {
!                     	$generalfeedbacktext="";               // Start gathering next lines
!                     	continue;
!                     }
!                     if (preg_match('~^:LAYOUT:(.*)~i',$line,$webct_options)) {
!                     	//    ignore  since layout in question_multichoice  is no more used in moodle
!                     	//    $webct_options[1] contains either vertical or horizontal ;
!                     	continue;
!                     }
! 
!                     if (isset($question->qtype ) && CALCULATED == $question->qtype && preg_match('~^:ANS-DEC:([1-9][0-9]*)~i', $line, $webct_options)) {
!                     	// We can but hope that this always appear before the ANSTYPE property
!                     	$question->correctanswerlength[$currentchoice] = $webct_options[1];
!                     	continue;
!                     }
! 
!                     if (isset($question->qtype )&& CALCULATED == $question->qtype && preg_match("~^:TOL:($webctnumberregex)~i", $line, $webct_options)) {
!                     	// We can but hope that this always appear before the TOL property
!                     	$question->tolerance[$currentchoice] =
!                     	qformat_webct_convert_formula($webct_options[1]);
!                     	continue;
!                     }
! 
!                     if (isset($question->qtype )&& CALCULATED == $question->qtype && preg_match('~^:TOLTYPE:percent~i', $line)) {
!                     	// Percentage case is handled as relative in Moodle:
!                     	$question->tolerance[$currentchoice]  /= 100;
!                     	$question->tolerancetype[$currentchoice] = 1; // Relative
!                     	continue;
!                     }
! 
!                     if (preg_match('~^:UNITS:(.+)~i', $line, $webct_options)
                      and $webctunits = trim($webct_options[1])) {
!                     	// This is a guess - I really do not know how different webct units are separated...
!                     	$webctunits = explode(':', $webctunits);
!                     	$unitrec->multiplier = 1.0; // Webct does not seem to support this
!                     	foreach ($webctunits as $webctunit) {
!                     		$unitrec->unit = trim($webctunit);
!                     		$question->units[] = $unitrec;
!                     	}
!                     	continue;
!                     }
  
!                     if (!empty($question->units) && preg_match('~^:UNITREQ:(.*)~i', $line, $webct_options)
                      && !$webct_options[1]) {
!                     	// There are units but units are not required so add the no unit alternative
!                     	// We can but hope that the UNITS property always appear before this property
!                     	$unitrec->unit = '';
!                     	$unitrec->multiplier = 1.0;
!                     	$question->units[] = $unitrec;
!                     	continue;
!                     }
! 
!                     if (!empty($question->units) && preg_match('~^:UNITCASE:~i', $line)) {
!                     	// This could be important but I was not able to figure out how
!                     	// it works so I ignore it for now
!                     	continue;
!                     }
! 
!                     if (isset($question->qtype )&& CALCULATED == $question->qtype && preg_match('~^:ANSTYPE:dec~i', $line)) {
!                     	$question->correctanswerformat[$currentchoice]='1';
!                     	continue;
!                     }
!                     if (isset($question->qtype )&& CALCULATED == $question->qtype && preg_match('~^:ANSTYPE:sig~i', $line)) {
!                     	$question->correctanswerformat[$currentchoice]='2';
!                     	continue;
!                     }
! 		}
! 
! 		if (sizeof($errors) > 0) {
! 			echo "<p>".get_string("errorsdetected", "quiz", sizeof($errors))."</p><ul>";
! 			foreach($errors as $error) {
! 				echo "<li>$error</li>";
! 			}
! 			echo "</ul>";
! 			unset($questions);     // no questions imported
! 		}
! 
! 		if (sizeof($warnings) > 0) {
! 			echo "<p>".get_string("warningsdetected", "quiz", sizeof($warnings))."</p><ul>";
! 			foreach($warnings as $warning) {
! 				echo "<li>$warning</li>";
! 			}
! 			echo "</ul>";
! 		}
! 		return $questions;
! 	}
  }
  
  ?>
diff -crB questionorg/format/xhtml/format.php questionupd/format/xhtml/format.php
*** questionorg/format/xhtml/format.php	2012-04-13 12:31:10.752178247 +0500
--- questionupd/format/xhtml/format.php	2012-04-13 09:42:55.000000000 +0500
***************
*** 6,151 ****
   */
  class qformat_xhtml extends qformat_default {
  
!     function provide_export() {
!       return true;
!     }
! 
! function repchar($text) {
!     return $text;
! }
! 
! function writequestion($question) {
!     global $OUTPUT;
!     // turns question into string
!     // question reflects database fields for general question and specific to type
! 
!     // if a category switch, just ignore
!     if ($question->qtype=='category') {
!         return '';
!     }
! 
!     // initial string;
!     $expout = "";
!     $id = $question->id;
! 
!     // add comment and div tags
!     $expout .= "<!-- question: $id  name: $question->name -->\n";
!     $expout .= "<div class=\"question\">\n";
! 
!     // add header
!     $expout .= "<h3>$question->name</h3>\n";
! 
!     // format and add question text
!     $questiontext = $question->questiontext;
!     $format = $question->questiontextformat;
!     $formatted_text = format_text($questiontext, $format);
!     $expout .= "<p class=\"questiontext\">$formatted_text</p>\n";
! 
!     // selection depends on question type
!     switch($question->qtype) {
!     case TRUEFALSE:
!         $st_true = get_string( 'true','quiz' );
!         $st_false = get_string( 'false','quiz' );
!         $expout .= "<ul class=\"truefalse\">\n";
!         $expout .= "  <li><input name=\"quest_$id\" type=\"radio\" value=\"$st_true\" />$st_true</li>\n";
!         $expout .= "  <li><input name=\"quest_$id\" type=\"radio\" value=\"$st_false\" />$st_false</li>\n";
!         $expout .= "</ul>\n";
!         break;
!     case MULTICHOICE:
!         $expout .= "<ul class=\"multichoice\">\n";
!         foreach($question->options->answers as $answer) {
!             $ans_text = $this->repchar( $answer->answer );
!             if ($question->options->single) {
!                 $expout .= "  <li><input name=\"quest_$id\" type=\"radio\" value=\"" . s($ans_text) . "\" />$ans_text</li>\n";
!             }
!             else {
!                 $expout .= "  <li><input name=\"quest_$id\" type=\"checkbox\" value=\"" . s($ans_text) . "\" />$ans_text</li>\n";
!             }
!         }
!         $expout .= "</ul>\n";
!         break;
!     case SHORTANSWER:
!         $expout .= "<ul class=\"shortanswer\">\n";
!         $expout .= "  <li><input name=\"quest_$id\" type=\"text\" /></li>\n";
!         $expout .= "</ul>\n";
!         break;
!     case NUMERICAL:
!         $expout .= "<ul class=\"numerical\">\n";
!         $expout .= "  <li><input name=\"quest_$id\" type=\"text\" /></li>\n";
!         $expout .= "</ul>\n";
!         break;
!     case MATCH:
!         $expout .= "<ul class=\"match\">\n";
! 
!         // build answer list
!         $ans_list = array();
!         foreach($question->options->subquestions as $subquestion) {
!            $ans_list[] = $this->repchar( $subquestion->answertext );
!         }
!         shuffle( $ans_list ); // random display order
! 
!         // build drop down for answers
!         $dropdown = "<select name=\"quest_$id\">\n";
!         foreach($ans_list as $ans) {
!             $dropdown .= "<option value=\"" . s($ans) . "\">" . s($ans) . "</option>\n";
!         }
!         $dropdown .= "</select>\n";
! 
!         // finally display
!         foreach($question->options->subquestions as $subquestion) {
!           $quest_text = $this->repchar( $subquestion->questiontext );
!           $expout .= "  <li>$quest_text</li>\n";
!           $expout .= $dropdown;
!         }
!         $expout .= "</ul>\n";
!         break;
!     case DESCRIPTION:
!         break;
!     case MULTIANSWER:
!         $expout .= "<!-- CLOZE type is not supported  -->\n";
!         break;
!     default:
!         echo $OUTPUT->notification("No handler for qtype $question->qtype for GIFT export" );
!     }
!     // close off div
!     $expout .= "</div>\n\n\n";
!     return $expout;
! }
! 
! 
! function presave_process( $content ) {
!   // override method to allow us to add xhtml headers and footers
! 
!   global $CFG;
! 
!   // get css bit
!   $css_lines = file( "$CFG->dirroot/question/format/xhtml/xhtml.css" );
!   $css = implode( ' ',$css_lines );
! 
!   $xp =  "<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\"\n";
!   $xp .= "  \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\">\n";
!   $xp .= "<html xmlns=\"http://www.w3.org/1999/xhtml\">\n";
!   $xp .= "<head>\n";
!   $xp .= "<meta http-equiv=\"content-type\" content=\"text/html; charset=UTF-8\" />\n";
!   $xp .= "<title>Moodle Quiz XHTML Export</title>\n";
!   $xp .= $css;
!   $xp .= "</head>\n";
!   $xp .= "<body>\n";
!   $xp .= "<form action=\"...REPLACE ME...\" method=\"post\">\n\n";
!   $xp .= $content;
!   $xp .= "<p class=\"submit\">\n";
!   $xp .= "  <input type=\"submit\" />\n";
!   $xp .= "</p>\n";
!   $xp .= "</form>\n";
!   $xp .= "</body>\n";
!   $xp .= "</html>\n";
! 
!   return $xp;
! }
! 
! function export_file_extension() {
!   return ".html";
! }
  
  }
  
--- 6,151 ----
   */
  class qformat_xhtml extends qformat_default {
  
! 	function provide_export() {
! 		return true;
! 	}
! 
! 	function repchar($text) {
! 		return $text;
! 	}
! 
! 	function writequestion($question) {
! 		global $OUTPUT;
! 		// turns question into string
! 		// question reflects database fields for general question and specific to type
! 
! 		// if a category switch, just ignore
! 		if ($question->qtype=='category') {
! 			return '';
! 		}
! 
! 		// initial string;
! 		$expout = "";
! 		$id = $question->id;
! 
! 		// add comment and div tags
! 		$expout .= "<!-- question: $id  name: $question->name -->\n";
! 		$expout .= "<div class=\"question\">\n";
! 
! 		// add header
! 		$expout .= "<h3>$question->name</h3>\n";
! 
! 		// format and add question text
! 		$questiontext = $question->questiontext;
! 		$format = $question->questiontextformat;
! 		$formatted_text = format_text($questiontext, $format);
! 		$expout .= "<p class=\"questiontext\">$formatted_text</p>\n";
! 
! 		// selection depends on question type
! 		switch($question->qtype) {
! 			case TRUEFALSE:
! 				$st_true = get_string( 'true','quiz' );
! 				$st_false = get_string( 'false','quiz' );
! 				$expout .= "<ul class=\"truefalse\">\n";
! 				$expout .= "  <li><input name=\"quest_$id\" type=\"radio\" value=\"$st_true\" />$st_true</li>\n";
! 				$expout .= "  <li><input name=\"quest_$id\" type=\"radio\" value=\"$st_false\" />$st_false</li>\n";
! 				$expout .= "</ul>\n";
! 				break;
! 			case MULTICHOICE:
! 				$expout .= "<ul class=\"multichoice\">\n";
! 				foreach($question->options->answers as $answer) {
! 					$ans_text = $this->repchar( $answer->answer );
! 					if ($question->options->single) {
! 						$expout .= "  <li><input name=\"quest_$id\" type=\"radio\" value=\"" . s($ans_text) . "\" />$ans_text</li>\n";
! 					}
! 					else {
! 						$expout .= "  <li><input name=\"quest_$id\" type=\"checkbox\" value=\"" . s($ans_text) . "\" />$ans_text</li>\n";
! 					}
! 				}
! 				$expout .= "</ul>\n";
! 				break;
! 			case SHORTANSWER:
! 				$expout .= "<ul class=\"shortanswer\">\n";
! 				$expout .= "  <li><input name=\"quest_$id\" type=\"text\" /></li>\n";
! 				$expout .= "</ul>\n";
! 				break;
! 			case NUMERICAL:
! 				$expout .= "<ul class=\"numerical\">\n";
! 				$expout .= "  <li><input name=\"quest_$id\" type=\"text\" /></li>\n";
! 				$expout .= "</ul>\n";
! 				break;
! 			case MATCH:
! 				$expout .= "<ul class=\"match\">\n";
! 
! 				// build answer list
! 				$ans_list = array();
! 				foreach($question->options->subquestions as $subquestion) {
! 					$ans_list[] = $this->repchar( $subquestion->answertext );
! 				}
! 				shuffle( $ans_list ); // random display order
! 
! 				// build drop down for answers
! 				$dropdown = "<select name=\"quest_$id\">\n";
! 				foreach($ans_list as $ans) {
! 					$dropdown .= "<option value=\"" . s($ans) . "\">" . s($ans) . "</option>\n";
! 				}
! 				$dropdown .= "</select>\n";
! 
! 				// finally display
! 				foreach($question->options->subquestions as $subquestion) {
! 					$quest_text = $this->repchar( $subquestion->questiontext );
! 					$expout .= "  <li>$quest_text</li>\n";
! 					$expout .= $dropdown;
! 				}
! 				$expout .= "</ul>\n";
! 				break;
! 			case DESCRIPTION:
! 				break;
! 			case MULTIANSWER:
! 				$expout .= "<!-- CLOZE type is not supported  -->\n";
! 				break;
! 			default:
! 				echo $OUTPUT->notification("No handler for qtype $question->qtype for GIFT export" );
! 		}
! 		// close off div
! 		$expout .= "</div>\n\n\n";
! 		return $expout;
! 	}
! 
! 
! 	function presave_process( $content ) {
! 		// override method to allow us to add xhtml headers and footers
! 
! 		global $CFG;
! 
! 		// get css bit
! 		$css_lines = file( "$CFG->dirroot/question/format/xhtml/xhtml.css" );
! 		$css = implode( ' ',$css_lines );
! 
! 		$xp =  "<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\"\n";
! 		$xp .= "  \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\">\n";
! 		$xp .= "<html xmlns=\"http://www.w3.org/1999/xhtml\">\n";
! 		$xp .= "<head>\n";
! 		$xp .= "<meta http-equiv=\"content-type\" content=\"text/html; charset=UTF-8\" />\n";
! 		$xp .= "<title>Moodle Quiz XHTML Export</title>\n";
! 		$xp .= $css;
! 		$xp .= "</head>\n";
! 		$xp .= "<body>\n";
! 		$xp .= "<form action=\"...REPLACE ME...\" method=\"post\">\n\n";
! 		$xp .= $content;
! 		$xp .= "<p class=\"submit\">\n";
! 		$xp .= "  <input type=\"submit\" />\n";
! 		$xp .= "</p>\n";
! 		$xp .= "</form>\n";
! 		$xp .= "</body>\n";
! 		$xp .= "</html>\n";
! 
! 		return $xp;
! 	}
! 
! 	function export_file_extension() {
! 		return ".html";
! 	}
  
  }
  
diff -crB questionorg/format/xhtml/xhtml.css questionupd/format/xhtml/xhtml.css
*** questionorg/format/xhtml/xhtml.css	2012-04-13 12:31:10.796178243 +0500
--- questionupd/format/xhtml/xhtml.css	2012-04-13 09:42:55.000000000 +0500
***************
*** 1,24 ****
! <style>
!   body {
!     font-family: Verdana, Helvetica, Sans-Serif;
!     background-color: #fff;
!     color: #000;
!   }
  
!   .question {
!     border: 1px solid #ddd;
!     margin: 5px;
!     padding: 3px;
!     }
  
!   .question h3 {
!     font-weight: normal;
!     font-size: 125%;
!   }
! 
!   .question ul {
!     list-style-type: none;
!   }
! 
! </style>
  
--- 1,24 ----
! <
! style>body {
! 	font-family: Verdana, Helvetica, Sans-Serif;
! 	background-color: #fff;
! 	color: #000;
! }
  
! .question {
! 	border: 1px solid #ddd;
! 	margin: 5px;
! 	padding: 3px;
! }
  
! .question h3 {
! 	font-weight: normal;
! 	font-size: 125%;
! }
  
+ .question ul {
+ 	list-style-type: none;
+ }
+ </
+ style
+ >
\ No newline at end of file
diff -crB questionorg/format/xml/format.php questionupd/format/xml/format.php
*** questionorg/format/xml/format.php	2012-04-13 12:31:11.020178249 +0500
--- questionupd/format/xml/format.php	2012-04-13 09:42:55.000000000 +0500
***************
*** 37,1430 ****
  
  class qformat_xml extends qformat_default {
  
!     function provide_import() {
!         return true;
!     }
! 
!     function provide_export() {
!         return true;
!     }
! 
!     function mime_type() {
!         return 'application/xml';
!     }
! 
!     // IMPORT FUNCTIONS START HERE
! 
!     /**
!      * Translate human readable format name
!      * into internal Moodle code number
!      * @param string name format name from xml file
!      * @return int Moodle format code
!      */
!     function trans_format($name) {
!         $name = trim($name);
! 
!         if ($name == 'moodle_auto_format') {
!             $id = 0;
!         } else if ($name == 'html') {
!             $id = 1;
!         } else if ($name == 'plain_text') {
!             $id = 2;
!         } else if ($name == 'wiki_like') {
!             $id = 3;
!         } else if ($name == 'markdown') {
!             $id = 4;
!         } else {
!             $id = 0; // or maybe warning required
!         }
!         return $id;
!     }
! 
!     /**
!      * Translate human readable single answer option
!      * to internal code number
!      * @param string name true/false
!      * @return int internal code number
!      */
!     function trans_single( $name ) {
!         $name = trim($name);
!         if ($name == "false" || !$name) {
!             return 0;
!         } else {
!             return 1;
!         }
!     }
! 
!     /**
!      * process text string from xml file
!      * @param array $text bit of xml tree after ['text']
!      * @return string processed text
!      */
!     function import_text( $text ) {
!         // quick sanity check
!         if (empty($text)) {
!             return '';
!         }
!         $data = $text[0]['#'];
!         return trim($data);
!     }
! 
!     /**
!      * return the value of a node, given a path to the node
!      * if it doesn't exist return the default value
!      * @param array xml data to read
!      * @param array path path to node expressed as array
!      * @param mixed default
!      * @param bool istext process as text
!      * @param string error if set value must exist, return false and issue message if not
!      * @return mixed value
!      */
!     function getpath($xml, $path, $default, $istext=false, $error='') {
!         foreach ($path as $index) {
!             if (!isset($xml[$index])) {
!                 if (!empty($error)) {
!                     $this->error( $error );
!                     return false;
!                 } else {
!                     return $default;
!                 }
!             }
!             else $xml = $xml[$index];
!         }
!         if ($istext) {
!             if (!is_string($xml)) {
!                 $this->error( get_string('invalidxml','qformat_xml') );
!             }
!             $xml = trim($xml);
!         }
! 
!         return $xml;
!     }
! 
! 
!     /**
!      * import parts of question common to all types
!      * @param $question array question question array from xml tree
!      * @return object question object
!      */
!     function import_headers($question) {
!         global $CFG;
! 
!         // get some error strings
!         $error_noname = get_string('xmlimportnoname','quiz');
!         $error_noquestion = get_string('xmlimportnoquestion','quiz');
! 
!         // this routine initialises the question object
!         $qo = $this->defaultquestion();
! 
!         // question name
!         $qo->name = $this->getpath( $question, array('#','name',0,'#','text',0,'#'), '', true, $error_noname );
!         $qo->questiontext       = $this->getpath($question, array('#','questiontext',0,'#','text',0,'#'), '', true );
!         $qo->questiontextformat = $this->trans_format(
!                 $this->getpath($question, array('#','questiontext',0,'@','format'), 'moodle_auto_format'));
! 
!         $qo->questiontextfiles = array();
! 
!         // restore files in questiontext
!         $files = $this->getpath($question, array('#', 'questiontext', 0, '#','file'), array(), false);
!         foreach ($files as $file) {
!             $data = new stdclass;
!             $data->content = $file['#'];
!             $data->encoding = $file['@']['encoding'];
!             $data->name = $file['@']['name'];
!             $qo->questiontextfiles[] = $data;
!         }
! 
!         // Backwards compatibility, deal with the old image tag.
!         $filedata = $this->getpath($question, array('#', 'image_base64', '0', '#'), null, false);
!         $filename = $this->getpath($question, array('#', 'image', '0', '#'), null, false);
!         if ($filedata && $filename) {
!             $data = new stdclass;
!             $data->content = $filedata;
!             $data->encoding = 'base64';
!             $data->name = $filename;
!             $qo->questiontextfiles[] = $data;
!             $qo->questiontext .= ' <img src="@@PLUGINFILE@@/' . $filename . '" />';
!         }
! 
!         // restore files in generalfeedback
!         $qo->generalfeedback = $this->getpath($question, array('#','generalfeedback',0,'#','text',0,'#'), $qo->generalfeedback, true);
!         $qo->generalfeedbackfiles = array();
!         $qo->generalfeedbackformat = $this->trans_format(
!                 $this->getpath($question, array('#', 'generalfeedback', 0, '@', 'format'), 'moodle_auto_format'));
!         $files = $this->getpath($question, array('#', 'generalfeedback', 0, '#', 'file'), array(), false);
!         foreach ($files as $file) {
!             $data = new stdclass;
!             $data->content = $file['#'];
!             $data->encoding = $file['@']['encoding'];
!             $data->name = $file['@']['name'];
!             $qo->generalfeedbackfiles[] = $data;
!         }
! 
!         $qo->defaultgrade = $this->getpath( $question, array('#','defaultgrade',0,'#'), $qo->defaultgrade );
!         $qo->penalty = $this->getpath( $question, array('#','penalty',0,'#'), $qo->penalty );
! 
!         // Read the question tags.
!         if (!empty($CFG->usetags) && array_key_exists('tags', $question['#'])
!                 && !empty($question['#']['tags'][0]['#']['tag'])) {
!             require_once($CFG->dirroot.'/tag/lib.php');
!             $qo->tags = array();
!             foreach ($question['#']['tags'][0]['#']['tag'] as $tagdata) {
!                 $qo->tags[] = $this->getpath($tagdata, array('#', 'text', 0, '#'), '', true);
!             }
!         }
! 
!         return $qo;
!     }
! 
!     /**
!      * import the common parts of a single answer
!      * @param array answer xml tree for single answer
!      * @return object answer object
!      */
!     function import_answer($answer) {
!         $fraction = $this->getpath($answer, array('@', 'fraction'), 0);
!         $answertext = $this->getpath($answer, array('#', 'text', 0, '#'), '', true);
!         $answerformat = $this->trans_format($this->getpath($answer,
!                 array('#', 'text', 0, '#'), 'moodle_auto_format'));
!         $answerfiles = array();
!         $files = $this->getpath($answer, array('#', 'answer', 0, '#', 'file'), array());
!         foreach ($files as $file) {
!             $data = new stdclass;
!             $data->content = $file['#'];
!             $data->name = $file['@']['name'];
!             $data->encoding = $file['@']['encoding'];
!             $answerfiles[] = $data;
!         }
! 
!         $feedbacktext = $this->getpath($answer, array('#', 'feedback', 0, '#', 'text', 0, '#'), '', true);
!         $feedbackformat = $this->trans_format($this->getpath($answer,
!                 array('#', 'feedback', 0, '@', 'format'), 'moodle_auto_format'));
!         $feedbackfiles = array();
!         $files = $this->getpath($answer, array('#', 'feedback', 0, '#', 'file'), array());
!         foreach ($files as $file) {
!             $data = new stdclass;
!             $data->content = $file['#'];
!             $data->name = $file['@']['name'];
!             $data->encoding = $file['@']['encoding'];
!             $feedbackfiles[] = $data;
!         }
! 
!         $ans = new stdclass;
! 
!         $ans->answer = array();
!         $ans->answer['text']   = $answertext;
!         $ans->answer['format'] = $answerformat;
!         $ans->answer['files']  = $answerfiles;
! 
!         $ans->feedback = array();
!         $ans->feedback['text']   = $feedbacktext;
!         $ans->feedback['format'] = $feedbackformat;
!         $ans->feedback['files']  = $feedbackfiles;
! 
!         $ans->fraction = $fraction / 100;
!         return $ans;
!     }
! 
!     /**
!      * import multiple choice question
!      * @param array question question array from xml tree
!      * @return object question object
!      */
!     function import_multichoice($question) {
!         // get common parts
!         $qo = $this->import_headers($question);
! 
!         // 'header' parts particular to multichoice
!         $qo->qtype = MULTICHOICE;
!         $single = $this->getpath( $question, array('#','single',0,'#'), 'true' );
!         $qo->single = $this->trans_single( $single );
!         $shuffleanswers = $this->getpath( $question, array('#','shuffleanswers',0,'#'), 'false' );
!         $qo->answernumbering = $this->getpath( $question, array('#','answernumbering',0,'#'), 'abc' );
!         $qo->shuffleanswers = $this->trans_single($shuffleanswers);
! 
!         $qo->correctfeedback = array();
!         $qo->correctfeedback['text'] = $this->getpath($question, array('#', 'correctfeedback', 0, '#', 'text', 0, '#'), '', true);
!         $qo->correctfeedback['format'] = $this->trans_format(
!                 $this->getpath($question, array('#', 'correctfeedback', 0, '@', 'format'), 'moodle_auto_format'));
!         $qo->correctfeedback['files'] = array();
!         // restore files in correctfeedback
!         $files = $this->getpath($question, array('#', 'correctfeedback', 0, '#','file'), array(), false);
!         foreach ($files as $file) {
!             $data = new stdclass;
!             $data->content = $file['#'];
!             $data->encoding = $file['@']['encoding'];
!             $data->name = $file['@']['name'];
!             $qo->correctfeedback['files'][] = $data;
!         }
! 
!         $qo->partiallycorrectfeedback = array();
!         $qo->partiallycorrectfeedback['text'] = $this->getpath( $question, array('#','partiallycorrectfeedback',0,'#','text',0,'#'), '', true );
!         $qo->partiallycorrectfeedback['format'] = $this->trans_format(
!                 $this->getpath($question, array('#', 'partiallycorrectfeedback', 0, '@', 'format'), 'moodle_auto_format'));
!         $qo->partiallycorrectfeedback['files'] = array();
!         // restore files in partiallycorrectfeedback
!         $files = $this->getpath($question, array('#', 'partiallycorrectfeedback', 0, '#','file'), array(), false);
!         foreach ($files as $file) {
!             $data = new stdclass;
!             $data->content = $file['#'];
!             $data->encoding = $file['@']['encoding'];
!             $data->name = $file['@']['name'];
!             $qo->partiallycorrectfeedback['files'][] = $data;
!         }
! 
!         $qo->incorrectfeedback = array();
!         $qo->incorrectfeedback['text'] = $this->getpath( $question, array('#','incorrectfeedback',0,'#','text',0,'#'), '', true );
!         $qo->incorrectfeedback['format'] = $this->trans_format(
!                 $this->getpath($question, array('#', 'incorrectfeedback', 0, '@', 'format'), 'moodle_auto_format'));
!         $qo->incorrectfeedback['files'] = array();
!         // restore files in incorrectfeedback
!         $files = $this->getpath($question, array('#', 'incorrectfeedback', 0, '#','file'), array(), false);
!         foreach ($files as $file) {
!             $data = new stdclass;
!             $data->content = $file['#'];
!             $data->encoding = $file['@']['encoding'];
!             $data->name = $file['@']['name'];
!             $qo->incorrectfeedback['files'][] = $data;
!         }
! 
!         // There was a time on the 1.8 branch when it could output an empty answernumbering tag, so fix up any found.
!         if (empty($qo->answernumbering)) {
!             $qo->answernumbering = 'abc';
!         }
! 
!         // run through the answers
!         $answers = $question['#']['answer'];
!         $a_count = 0;
!         foreach ($answers as $answer) {
!             $ans = $this->import_answer($answer);
!             $qo->answer[$a_count] = $ans->answer;
!             $qo->fraction[$a_count] = $ans->fraction;
!             $qo->feedback[$a_count] = $ans->feedback;
!             ++$a_count;
!         }
! 
!         return $qo;
!     }
! 
!     /**
!      * import cloze type question
!      * @param array question question array from xml tree
!      * @return object question object
!      */
!     function import_multianswer( $questions ) {
!         $questiontext = array();
!         $questiontext['text'] = $this->import_text($questions['#']['questiontext'][0]['#']['text']);
!         $questiontext['format'] = '1';
!         $questiontext['itemid'] = ''; 
!         $qo = qtype_multianswer_extract_question($questiontext);
! 
!         // 'header' parts particular to multianswer
!         $qo->qtype = MULTIANSWER;
!         $qo->course = $this->course;
!         $qo->generalfeedback = '' ;
!         // restore files in generalfeedback
!         $qo->generalfeedback = $this->getpath($questions, array('#','generalfeedback',0,'#','text',0,'#'), $qo->generalfeedback, true);
!         $qo->generalfeedbackfiles = array();
!         $qo->generalfeedbackformat = $this->trans_format(
!                 $this->getpath($questions, array('#', 'generalfeedback', 0, '@', 'format'), 'moodle_auto_format'));
!         $files = $this->getpath($questions, array('#', 'generalfeedback', 0, '#', 'file'), array(), false);
!         foreach ($files as $file) {
!             $data = new stdclass;
!             $data->content = $file['#'];
!             $data->encoding = $file['@']['encoding'];
!             $data->name = $file['@']['name'];
!             $qo->generalfeedbackfiles[] = $data;
!         }
!         if (!empty($questions)) {
!             $qo->name = $this->import_text( $questions['#']['name'][0]['#']['text'] );
!         }
!         $qo->questiontext =  $qo->questiontext['text'] ;
!         $qo->questiontextformat = '' ;
! 
!         return $qo;
!     }
! 
!     /**
!      * import true/false type question
!      * @param array question question array from xml tree
!      * @return object question object
!      */
!     function import_truefalse( $question ) {
!         // get common parts
!         global $OUTPUT;
!         $qo = $this->import_headers( $question );
! 
!         // 'header' parts particular to true/false
!         $qo->qtype = TRUEFALSE;
! 
!         // get answer info
!         //
!         // In the past, it used to be assumed that the two answers were in the file
!         // true first, then false. Howevever that was not always true. Now, we
!         // try to match on the answer text, but in old exports, this will be a localised
!         // string, so if we don't find true or false, we fall back to the old system.
!         $first = true;
!         $warning = false;
!         foreach ($question['#']['answer'] as $answer) {
!             $answertext = $this->getpath( $answer, array('#','text',0,'#'), '', true);
!             $feedback = $this->getpath($answer, array('#','feedback',0,'#','text',0,'#'), '', true);
!             $feedbackformat = $this->getpath($answer, array('#','feedback',0, '@', 'format'), 'moodle_auto_format');
!             $feedbackfiles = $this->getpath($answer, array('#', 'feedback', 0, '#', 'file'), array());
!             $files = array();
!             foreach ($feedbackfiles as $file) {
!                 $data = new stdclass;
!                 $data->content = $file['#'];
!                 $data->encoding = $file['@']['encoding'];
!                 $data->name = $file['@']['name'];
!                 $files[] = $data;
!             }
!             if ($answertext != 'true' && $answertext != 'false') {
!                 $warning = true;
!                 $answertext = $first ? 'true' : 'false'; // Old style file, assume order is true/false.
!             }
!             if ($answertext == 'true') {
!                 $qo->answer = ($answer['@']['fraction'] == 100);
!                 $qo->correctanswer = $qo->answer;
!                 $qo->feedbacktrue = array();
!                 $qo->feedbacktrue['text'] = $feedback;
!                 $qo->feedbacktrue['format'] = $this->trans_format($feedbackformat);
!                 $qo->feedbacktrue['itemid'] = null;
!                 $qo->feedbacktruefiles = $files;
!             } else {
!                 $qo->answer = ($answer['@']['fraction'] != 100);
!                 $qo->correctanswer = $qo->answer;
!                 $qo->feedbackfalse = array();
!                 $qo->feedbackfalse['text'] = $feedback;
!                 $qo->feedbackfalse['format'] = $this->trans_format($feedbackformat);
!                 $qo->feedbackfalse['itemid'] = null;
!                 $qo->feedbackfalsefiles = $files;
!             }
!             $first = false;
!         }
! 
!         if ($warning) {
!             $a = new stdClass;
!             $a->questiontext = $qo->questiontext;
!             $a->answer = get_string($qo->answer ? 'true' : 'false', 'quiz');
!             echo $OUTPUT->notification(get_string('truefalseimporterror', 'quiz', $a));
!         }
!         return $qo;
!     }
! 
!     /**
!      * import short answer type question
!      * @param array question question array from xml tree
!      * @return object question object
!      */
!     function import_shortanswer( $question ) {
!         // get common parts
!         $qo = $this->import_headers( $question );
! 
!         // header parts particular to shortanswer
!         $qo->qtype = SHORTANSWER;
! 
!         // get usecase
!         $qo->usecase = $this->getpath($question, array('#','usecase',0,'#'), $qo->usecase );
! 
!         // run through the answers
!         $answers = $question['#']['answer'];
!         $a_count = 0;
!         foreach ($answers as $answer) {
!             $ans = $this->import_answer($answer);
!             $qo->answer[$a_count] = $ans->answer['text'];
!             $qo->fraction[$a_count] = $ans->fraction;
!             $qo->feedback[$a_count] = $ans->feedback;
!             ++$a_count;
!         }
! 
!         return $qo;
!     }
! 
!     /**
!      * import description type question
!      * @param array question question array from xml tree
!      * @return object question object
!      */
!     function import_description( $question ) {
!         // get common parts
!         $qo = $this->import_headers( $question );
!         // header parts particular to shortanswer
!         $qo->qtype = DESCRIPTION;
!         $qo->defaultgrade = 0;
!         $qo->length = 0;
!         return $qo;
!     }
! 
!     /**
!      * import numerical type question
!      * @param array question question array from xml tree
!      * @return object question object
!      */
!     function import_numerical($question) {
!         // get common parts
!         $qo = $this->import_headers($question);
! 
!         // header parts particular to numerical
!         $qo->qtype = NUMERICAL;
! 
!         // get answers array
!         $answers = $question['#']['answer'];
!         $qo->answer = array();
!         $qo->feedback = array();
!         $qo->fraction = array();
!         $qo->tolerance = array();
!         foreach ($answers as $answer) {
!             // answer outside of <text> is deprecated
!             $obj = $this->import_answer($answer);
!             $qo->answer[] = $obj->answer['text'];
!             if (empty($qo->answer)) {
!                 $qo->answer = '*';
!             }
!             $qo->feedback[]  = $obj->feedback;
!             $qo->tolerance[] = $this->getpath($answer, array('#', 'tolerance', 0, '#'), 0);
! 
!             // fraction as a tag is deprecated
!             $fraction = $this->getpath($answer, array('@', 'fraction'), 0) / 100;
!             $qo->fraction[] = $this->getpath($answer, array('#', 'fraction', 0, '#'), $fraction); // deprecated
!         }
! 
!         // get units array
!         $qo->unit = array();
!         $units = $this->getpath( $question, array('#','units',0,'#','unit'), array() );
!         if (!empty($units)) {
!             $qo->multiplier = array();
!             foreach ($units as $unit) {
!                 $qo->multiplier[] = $this->getpath( $unit, array('#','multiplier',0,'#'), 1 );
!                 $qo->unit[] = $this->getpath( $unit, array('#','unit_name',0,'#'), '', true );
!             }
!         }
!         $qo->unitgradingtype = $this->getpath( $question, array('#','unitgradingtype',0,'#'), 0 );
!         $qo->unitpenalty = $this->getpath( $question, array('#','unitpenalty',0,'#'), 0 );
!         $qo->showunits = $this->getpath( $question, array('#','showunits',0,'#'), 0 );
!         $qo->unitsleft = $this->getpath( $question, array('#','unitsleft',0,'#'), 0 );
!         $qo->instructions['text'] = '';
!         $qo->instructions['format'] = FORMAT_HTML;
!         $instructions = $this->getpath($question, array('#', 'instructions'), array());
!         if (!empty($instructions)) {
!             $qo->instructions = array();
!             $qo->instructions['text'] = $this->getpath($instructions,
!                     array('0', '#', 'text', '0', '#'), '', true);
!             $qo->instructions['format'] = $this->trans_format($this->getpath($instructions,
!                     array('0', '@', 'format'), 'moodle_auto_format'));
!             $files = $this->getpath($instructions, array('0', '#', 'file'), array());
!             $qo->instructions['files'] = array();
!             foreach ($files as $file) {
!                 $data = new stdclass;
!                 $data->content = $file['#'];
!                 $data->encoding = $file['@']['encoding'];
!                 $data->name = $file['@']['name'];
!                 $qo->instructions['files'][]= $data;
!             }
!         }
!         return $qo;
!     }
! 
!     /**
!      * import matching type question
!      * @param array question question array from xml tree
!      * @return object question object
!      */
!     function import_matching($question) {
!         // get common parts
!         $qo = $this->import_headers($question);
! 
!         // header parts particular to matching
!         $qo->qtype = MATCH;
!         $qo->shuffleanswers = $this->getpath($question, array('#', 'shuffleanswers', 0, '#'), 1);
! 
!         // get subquestions
!         $subquestions = $question['#']['subquestion'];
!         $qo->subquestions = array();
!         $qo->subanswers = array();
! 
!         // run through subquestions
!         foreach ($subquestions as $subquestion) {
!             $question = array();
!             $question['text'] = $this->getpath($subquestion, array('#', 'text', 0, '#'), '', true);
!             $question['format'] = $this->trans_format(
!                     $this->getpath($subquestion, array('@', 'format'), 'moodle_auto_format'));
!             $question['files'] = array();
! 
!             $files = $this->getpath($subquestion, array('#', 'file'), array());
!             foreach ($files as $file) {
!                 $data = new stdclass();
!                 $data->content = $file['#'];
!                 $data->encoding = $file['@']['encoding'];
!                 $data->name = $file['@']['name'];
!                 $question['files'][] = $data;
!             }
!             $qo->subquestions[] = $question;
!             $answers = $this->getpath($subquestion, array('#', 'answer'), array());
!             $qo->subanswers[] = $this->getpath($subquestion, array('#','answer',0,'#','text',0,'#'), '', true);
!         }
!         return $qo;
!     }
! 
!     /**
!      * import  essay type question
!      * @param array question question array from xml tree
!      * @return object question object
!      */
!     function import_essay( $question ) {
!         // get common parts
!         $qo = $this->import_headers( $question );
! 
!         // header parts particular to essay
!         $qo->qtype = ESSAY;
! 
!         $answers = $this->getpath($question, array('#', 'answer'), null);
!         if ($answers) {
!             $answer = array_pop($answers);
!             $answer = $this->import_answer($answer);
!             // get feedback
!             $qo->feedback = $answer->feedback;
!         } else {
!             $qo->feedback = array('text' => '', 'format' => FORMAT_MOODLE, 'files' => array());
!         }
! 
!         // get fraction - <fraction> tag is deprecated
!         $qo->fraction = $this->getpath($question, array('@','fraction'), 0 ) / 100;
!         $q0->fraction = $this->getpath($question, array('#','fraction',0,'#'), $qo->fraction );
! 
!         return $qo;
!     }
! 
!     function import_calculated($question,$qtype) {
!     // import calculated question
! 
!         // get common parts
!         $qo = $this->import_headers( $question );
! 
!         // header parts particular to calculated
!         $qo->qtype = CALCULATED ;//CALCULATED;
!         $qo->synchronize = $this->getpath( $question, array( '#','synchronize',0,'#' ), 0 );
!         $single = $this->getpath( $question, array('#','single',0,'#'), 'true' );
!         $qo->single = $this->trans_single( $single );
!         $shuffleanswers = $this->getpath( $question, array('#','shuffleanswers',0,'#'), 'false' );
!         $qo->answernumbering = $this->getpath( $question, array('#','answernumbering',0,'#'), 'abc' );
!         $qo->shuffleanswers = $this->trans_single($shuffleanswers);
! 
!         $qo->correctfeedback = array();
!         $qo->correctfeedback['text'] = $this->getpath($question, array('#','correctfeedback',0,'#','text',0,'#'), '', true );
!         $qo->correctfeedback['format'] = $this->trans_format($this->getpath(
!                 $question, array('#', 'correctfeedback', 0, '@', 'formath'), 'moodle_auto_format'));
!         $qo->correctfeedback['files'] = array();
! 
!         $files = $this->getpath($question, array('#', 'correctfeedback', '0', '#', 'file'), array());
!         foreach ($files as $file) {
!             $data = new stdclass();
!             $data->content = $file['#'];
!             $data->name = $file['@']['name'];
!             $data->encoding = $file['@']['encoding'];
!             $qo->correctfeedback['files'][] = $data;
!         }
! 
!         $qo->partiallycorrectfeedback = array();
!         $qo->partiallycorrectfeedback['text'] = $this->getpath( $question, array('#','partiallycorrectfeedback',0,'#','text',0,'#'), '', true );
!         $qo->partiallycorrectfeedback['format'] = $this->trans_format(
!                 $this->getpath($question, array('#','partiallycorrectfeedback', 0, '@','format'), 'moodle_auto_format'));
!         $qo->partiallycorrectfeedback['files'] = array();
! 
!         $files = $this->getpath($question, array('#', 'partiallycorrectfeedback', '0', '#', 'file'), array());
!         foreach ($files as $file) {
!             $data = new stdclass();
!             $data->content = $file['#'];
!             $data->name = $file['@']['name'];
!             $data->encoding = $file['@']['encoding'];
!             $qo->partiallycorrectfeedback['files'][] = $data;
!         }
! 
!         $qo->incorrectfeedback = array();
!         $qo->incorrectfeedback['text'] = $this->getpath( $question, array('#','incorrectfeedback',0,'#','text',0,'#'), '', true );
!         $qo->incorrectfeedback['format'] = $this->trans_format($this->getpath(
!                 $question, array('#','incorrectfeedback', 0, '@','format'), 'moodle_auto_format'));
!         $qo->incorrectfeedback['files'] = array();
! 
!         $files = $this->getpath($question, array('#', 'incorrectfeedback', '0', '#', 'file'), array());
!         foreach ($files as $file) {
!             $data = new stdclass();
!             $data->content = $file['#'];
!             $data->name = $file['@']['name'];
!             $data->encoding = $file['@']['encoding'];
!             $qo->incorrectfeedback['files'][] = $data;
!         }
! 
!         $qo->unitgradingtype = $this->getpath($question, array('#','unitgradingtype',0,'#'), 0 );
!         $qo->unitpenalty = $this->getpath($question, array('#','unitpenalty',0,'#'), 0 );
!         $qo->showunits = $this->getpath($question, array('#','showunits',0,'#'), 0 );
!         $qo->unitsleft = $this->getpath($question, array('#','unitsleft',0,'#'), 0 );
!         $qo->instructions = $this->getpath( $question, array('#','instructions',0,'#','text',0,'#'), '', true );
!         if (!empty($instructions)) {
!             $qo->instructions = array();
!             $qo->instructions['text'] = $this->getpath($instructions,
!                     array('0', '#', 'text', '0', '#'), '', true);
!             $qo->instructions['format'] = $this->trans_format($this->getpath($instructions,
!                     array('0', '@', 'format'), 'moodle_auto_format'));
!             $files = $this->getpath($instructions,
!                     array('0', '#', 'file'), array());
!             $qo->instructions['files'] = array();
!             foreach ($files as $file) {
!                 $data = new stdclass;
!                 $data->content = $file['#'];
!                 $data->encoding = $file['@']['encoding'];
!                 $data->name = $file['@']['name'];
!                 $qo->instructions['files'][]= $data;
!             }
!         }
! 
!         $files = $this->getpath($question, array('#', 'instructions', 0, '#', 'file', 0, '@'), '', false);
! 
!         // get answers array
!         $answers = $question['#']['answer'];
!         $qo->answers = array();
!         $qo->feedback = array();
!         $qo->fraction = array();
!         $qo->tolerance = array();
!         $qo->tolerancetype = array();
!         $qo->correctanswerformat = array();
!         $qo->correctanswerlength = array();
!         $qo->feedback = array();
!         foreach ($answers as $answer) {
!             $ans = $this->import_answer($answer);
!             // answer outside of <text> is deprecated
!             if (empty($ans->answer['text'])) {
!                 $ans->answer['text'] = '*';
!             }
!             $qo->answers[] = $ans->answer;
!             $qo->feedback[] = $ans->feedback;
!             $qo->tolerance[] = $answer['#']['tolerance'][0]['#'];
!             // fraction as a tag is deprecated
!             if (!empty($answer['#']['fraction'][0]['#'])) {
!                 $qo->fraction[] = $answer['#']['fraction'][0]['#'];
!             } else {
!                 $qo->fraction[] = $answer['@']['fraction'] / 100;
!             }
!             $qo->tolerancetype[] = $answer['#']['tolerancetype'][0]['#'];
!             $qo->correctanswerformat[] = $answer['#']['correctanswerformat'][0]['#'];
!             $qo->correctanswerlength[] = $answer['#']['correctanswerlength'][0]['#'];
!         }
!         // get units array
!         $qo->unit = array();
!         if (isset($question['#']['units'][0]['#']['unit'])) {
!             $units = $question['#']['units'][0]['#']['unit'];
!             $qo->multiplier = array();
!             foreach ($units as $unit) {
!                 $qo->multiplier[] = $unit['#']['multiplier'][0]['#'];
!                 $qo->unit[] = $unit['#']['unit_name'][0]['#'];
!             }
!         }
!         $instructions = $this->getpath($question, array('#', 'instructions'), array());
!         if (!empty($instructions)) {
!             $qo->instructions = array();
!             $qo->instructions['text'] = $this->getpath($instructions,
!                     array('0', '#', 'text', '0', '#'), '', true);
!             $qo->instructions['format'] = $this->trans_format($this->getpath($instructions,
!                     array('0', '@', 'format'), 'moodle_auto_format'));
!             $files = $this->getpath($instructions,
!                     array('0', '#', 'file'), array());
!             $qo->instructions['files'] = array();
!             foreach ($files as $file) {
!                 $data = new stdclass;
!                 $data->content = $file['#'];
!                 $data->encoding = $file['@']['encoding'];
!                 $data->name = $file['@']['name'];
!                 $qo->instructions['files'][]= $data;
!             }
!         }
!         $datasets = $question['#']['dataset_definitions'][0]['#']['dataset_definition'];
!         $qo->dataset = array();
!         $qo->datasetindex= 0 ;
!         foreach ($datasets as $dataset) {
!             $qo->datasetindex++;
!             $qo->dataset[$qo->datasetindex] = new stdClass();
!             $qo->dataset[$qo->datasetindex]->status = $this->import_text( $dataset['#']['status'][0]['#']['text']);
!             $qo->dataset[$qo->datasetindex]->name = $this->import_text( $dataset['#']['name'][0]['#']['text']);
!             $qo->dataset[$qo->datasetindex]->type =  $dataset['#']['type'][0]['#'];
!             $qo->dataset[$qo->datasetindex]->distribution = $this->import_text( $dataset['#']['distribution'][0]['#']['text']);
!             $qo->dataset[$qo->datasetindex]->max = $this->import_text( $dataset['#']['maximum'][0]['#']['text']);
!             $qo->dataset[$qo->datasetindex]->min = $this->import_text( $dataset['#']['minimum'][0]['#']['text']);
!             $qo->dataset[$qo->datasetindex]->length = $this->import_text( $dataset['#']['decimals'][0]['#']['text']);
!             $qo->dataset[$qo->datasetindex]->distribution = $this->import_text( $dataset['#']['distribution'][0]['#']['text']);
!             $qo->dataset[$qo->datasetindex]->itemcount = $dataset['#']['itemcount'][0]['#'];
!             $qo->dataset[$qo->datasetindex]->datasetitem = array();
!             $qo->dataset[$qo->datasetindex]->itemindex = 0;
!             $qo->dataset[$qo->datasetindex]->number_of_items=$dataset['#']['number_of_items'][0]['#'];
!             $datasetitems = $dataset['#']['dataset_items'][0]['#']['dataset_item'];
!             foreach ($datasetitems as $datasetitem) {
!                 $qo->dataset[$qo->datasetindex]->itemindex++;
!                 $qo->dataset[$qo->datasetindex]->datasetitem[$qo->dataset[$qo->datasetindex]->itemindex] = new stdClass();
!                 $qo->dataset[$qo->datasetindex]->datasetitem[$qo->dataset[$qo->datasetindex]->itemindex]->itemnumber =  $datasetitem['#']['number'][0]['#']; //[0]['#']['number'][0]['#'] ; // [0]['numberitems'] ;//['#']['number'][0]['#'];// $datasetitems['#']['number'][0]['#'];
!                 $qo->dataset[$qo->datasetindex]->datasetitem[$qo->dataset[$qo->datasetindex]->itemindex]->value = $datasetitem['#']['value'][0]['#'] ;//$datasetitem['#']['value'][0]['#'];
!             }
!         }
! 
!         // echo "<pre>loaded qo";print_r($qo);echo "</pre>";
!         return $qo;
!     }
! 
!     /**
!      * this is not a real question type. It's a dummy type used
!      * to specify the import category
!      * format is:
!      * <question type="category">
!      *     <category>tom/dick/harry</category>
!      * </question>
!      */
!     function import_category( $question ) {
!         $qo = new stdClass;
!         $qo->qtype = 'category';
!         $qo->category = $this->import_text($question['#']['category'][0]['#']['text']);
!         return $qo;
!     }
! 
!     /**
!      * parse the array of lines into an array of questions
!      * this *could* burn memory - but it won't happen that much
!      * so fingers crossed!
!      * @param array lines array of lines from the input file
!      * @return array (of objects) question objects
!      */
!     function readquestions($lines) {
!         // we just need it as one big string
!         $text = implode($lines, " ");
!         unset($lines);
! 
!         // this converts xml to big nasty data structure
!         // the 0 means keep white space as it is (important for markdown format)
!         // print_r it if you want to see what it looks like!
!         $xml = xmlize($text, 0);
! 
!         // set up array to hold all our questions
!         $questions = array();
! 
!         // iterate through questions
!         foreach ($xml['quiz']['#']['question'] as $question) {
!             $question_type = $question['@']['type'];
!             $questiontype = get_string( 'questiontype','quiz',$question_type );
! 
!             if ($question_type=='multichoice') {
!                 $qo = $this->import_multichoice( $question );
!             }
!             elseif ($question_type=='truefalse') {
!                 $qo = $this->import_truefalse( $question );
!             }
!             elseif ($question_type=='shortanswer') {
!                 $qo = $this->import_shortanswer( $question );
!             }
!             elseif ($question_type=='numerical') {
!                 $qo = $this->import_numerical( $question );
!             }
!             elseif ($question_type=='description') {
!                 $qo = $this->import_description( $question );
!             }
!             elseif ($question_type=='matching') {
!                 $qo = $this->import_matching( $question );
!             }
!             elseif ($question_type=='cloze') {
!                 $qo = $this->import_multianswer( $question );
!             }
!             elseif ($question_type=='essay') {
!                 $qo = $this->import_essay( $question );
!             }
!             elseif ($question_type=='calculated') {
!                 $qo = $this->import_calculated( $question,CALCULATED  );
!             }
!             elseif ($question_type=='calculatedsimple') {
!                 $qo = $this->import_calculated( $question,CALCULATEDMULTI  );
!                 $qo->qtype = CALCULATEDSIMPLE ;
!             }
!             elseif ($question_type=='calculatedmulti') {
!                 $qo = $this->import_calculated( $question,CALCULATEDMULTI );
!                 $qo->qtype = CALCULATEDMULTI ;
!             }
!             elseif ($question_type=='category') {
!                 $qo = $this->import_category( $question );
!             }
!             else {
!                 // try for plugin support
!                 // no default question, as the plugin can call
!                 // import_headers() itself if it wants to
!                 if (!$qo = $this->try_importing_using_qtypes( $question, null, null, $question_type)) {
!                     $notsupported = get_string( 'xmltypeunsupported','quiz',$question_type );
!                     $this->error( $notsupported );
!                     $qo = null;
!                 }
!             }
! 
!             // stick the result in the $questions array
!             if ($qo) {
!                 $questions[] = $qo;
!             }
!         }
!         return $questions;
!     }
! 
!     // EXPORT FUNCTIONS START HERE
! 
!     function export_file_extension() {
!         return '.xml';
!     }
! 
!     /**
!      * Turn the internal question code into a human readable form
!      * (The code used to be numeric, but this remains as some of
!      * the names don't match the new internal format)
!      * @param mixed type_id Internal code
!      * @return string question type string
!      */
!     function get_qtype( $type_id ) {
!         switch( $type_id ) {
!         case TRUEFALSE:
!             $name = 'truefalse';
!             break;
!         case MULTICHOICE:
!             $name = 'multichoice';
!             break;
!         case SHORTANSWER:
!             $name = 'shortanswer';
!             break;
!         case NUMERICAL:
!             $name = 'numerical';
!             break;
!         case MATCH:
!             $name = 'matching';
!             break;
!         case DESCRIPTION:
!             $name = 'description';
!             break;
!         case MULTIANSWER:
!             $name = 'cloze';
!             break;
!         case ESSAY:
!             $name = 'essay';
!             break;
!         case CALCULATED:
!             $name = 'calculated';
!             break;
!         case CALCULATEDSIMPLE:
!             $name = 'calculatedsimple';
!             break;
!         case CALCULATEDMULTI:
!             $name = 'calculatedmulti';
!             break;
!         default:
!             $name = false;
!         }
!         return $name;
!     }
! 
!     /**
!      * Convert internal Moodle text format code into
!      * human readable form
!      * @param int id internal code
!      * @return string format text
!      */
!     function get_format( $id ) {
!         switch( $id ) {
!         case 0:
!             $name = "moodle_auto_format";
!             break;
!         case 1:
!             $name = "html";
!             break;
!         case 2:
!             $name = "plain_text";
!             break;
!         case 3:
!             $name = "wiki_like";
!             break;
!         case 4:
!             $name = "markdown";
!             break;
!         default:
!             $name = "unknown";
!         }
!         return $name;
!     }
! 
!     /**
!      * Convert internal single question code into
!      * human readable form
!      * @param int id single question code
!      * @return string single question string
!      */
!     function get_single( $id ) {
!         switch( $id ) {
!         case 0:
!             $name = "false";
!             break;
!         case 1:
!             $name = "true";
!             break;
!         default:
!             $name = "unknown";
!         }
!         return $name;
!     }
! 
!     /**
!      * generates <text></text> tags, processing raw text therein
!      * @param int ilev the current indent level
!      * @param boolean short stick it on one line
!      * @return string formatted text
!      */
!     function writetext($raw, $ilev = 0, $short = true) {
!         $indent = str_repeat('  ', $ilev);
! 
!         // if required add CDATA tags
!         if (!empty($raw) and (htmlspecialchars($raw) != $raw)) {
!             $raw = "<![CDATA[$raw]]>";
!         }
! 
!         if ($short) {
!             $xml = "$indent<text>$raw</text>";
!         } else {
!             $xml = "$indent<text>\n$raw\n$indent</text>\n";
!         }
  
!         return $xml;
!     }
  
!     function presave_process( $content ) {
!     // override method to allow us to add xml headers and footers
  
!         // add the xml headers and footers
!         $content = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n" .
                         "<quiz>\n" .
!                        $content . "\n" .
                         "</quiz>";
!         return $content;
!     }
  
!     /**
!      * Turns question into an xml segment
!      * @param object question object
!      * @param int context id
!      * @return string xml segment
!      */
!     function writequestion($question) {
!         global $CFG, $QTYPES, $OUTPUT;
! 
!         $fs = get_file_storage();
!         $contextid = $question->contextid;
!         // initial string;
!         $expout = "";
! 
!         // add comment
!         $expout .= "\n\n<!-- question: $question->id  -->\n";
! 
!         // check question type
!         if (!$question_type = $this->get_qtype( $question->qtype )) {
!             // must be a plugin then, so just accept the name supplied
!             $question_type = $question->qtype;
!         }
! 
!         // add opening tag
!         // generates specific header for Cloze and category type question
!         if ($question->qtype == 'category') {
!             $categorypath = $this->writetext( $question->category );
!             $expout .= "  <question type=\"category\">\n";
!             $expout .= "    <category>\n";
!             $expout .= "        $categorypath\n";
!             $expout .= "    </category>\n";
!             $expout .= "  </question>\n";
!             return $expout;
!         } elseif ($question->qtype != MULTIANSWER) {
!             // for all question types except Close
!             $name_text = $this->writetext($question->name);
!             $qtformat = $this->get_format($question->questiontextformat);
!             $generalfeedbackformat = $this->get_format($question->generalfeedbackformat);
! 
!             $question_text = $this->writetext($question->questiontext);
!             $question_text_files = $this->writefiles($question->questiontextfiles);
! 
!             $generalfeedback = $this->writetext($question->generalfeedback);
!             $generalfeedback_files = $this->writefiles($question->generalfeedbackfiles);
! 
!             $expout .= "  <question type=\"$question_type\">\n";
!             $expout .= "    <name>$name_text</name>\n";
!             $expout .= "    <questiontext format=\"$qtformat\">\n";
!             $expout .= $question_text;
!             $expout .= $question_text_files;
!             $expout .= "    </questiontext>\n";
!             $expout .= "    <generalfeedback format=\"$generalfeedbackformat\">\n";
!             $expout .= $generalfeedback;
!             $expout .= $generalfeedback_files;
!             $expout .= "    </generalfeedback>\n";
!             $expout .= "    <defaultgrade>{$question->defaultgrade}</defaultgrade>\n";
!             $expout .= "    <penalty>{$question->penalty}</penalty>\n";
!             $expout .= "    <hidden>{$question->hidden}</hidden>\n";
!         } else {
!             // for Cloze type only
!             $name_text = $this->writetext( $question->name );
!             $question_text = $this->writetext( $question->questiontext );
!             $generalfeedback = $this->writetext( $question->generalfeedback );
!             $expout .= "  <question type=\"$question_type\">\n";
!             $expout .= "    <name>$name_text</name>\n";
!             $expout .= "    <questiontext>\n";
!             $expout .= $question_text;
!             $expout .= "    </questiontext>\n";
!             $expout .= "    <generalfeedback>\n";
!             $expout .= $generalfeedback;
!             $expout .= "    </generalfeedback>\n";
!         }
! 
!         if (!empty($question->options->shuffleanswers)) {
!             $expout .= "    <shuffleanswers>{$question->options->shuffleanswers}</shuffleanswers>\n";
!         }
!         else {
!             $expout .= "    <shuffleanswers>0</shuffleanswers>\n";
!         }
! 
!         // output depends on question type
!         switch($question->qtype) {
!         case 'category':
!             // not a qtype really - dummy used for category switching
!             break;
!         case TRUEFALSE:
!             foreach ($question->options->answers as $answer) {
!                 $fraction_pc = round( $answer->fraction * 100 );
!                 if ($answer->id == $question->options->trueanswer) {
!                     $answertext = 'true';
!                 } else {
!                     $answertext = 'false';
!                 }
!                 $expout .= "    <answer fraction=\"$fraction_pc\">\n";
!                 $expout .= $this->writetext($answertext, 3) . "\n";
!                 $feedbackformat = $this->get_format($answer->feedbackformat);
!                 $expout .= "      <feedback format=\"$feedbackformat\">\n";
!                 $expout .= $this->writetext($answer->feedback,4,false);
!                 $expout .= $this->writefiles($answer->feedbackfiles);
!                 $expout .= "      </feedback>\n";
!                 $expout .= "    </answer>\n";
!             }
!             break;
!         case MULTICHOICE:
!             $expout .= "    <single>".$this->get_single($question->options->single)."</single>\n";
!             $expout .= "    <shuffleanswers>".$this->get_single($question->options->shuffleanswers)."</shuffleanswers>\n";
! 
!             $textformat = $this->get_format($question->options->correctfeedbackformat);
!             $files = $fs->get_area_files($contextid, 'qtype_multichoice', 'correctfeedback', $question->id);
!             $expout .= "    <correctfeedback format=\"$textformat\">\n";
!             $expout .= $this->writetext($question->options->correctfeedback, 3);
!             $expout .= $this->writefiles($files);
!             $expout .= "    </correctfeedback>\n";
! 
!             $textformat = $this->get_format($question->options->partiallycorrectfeedbackformat);
!             $files = $fs->get_area_files($contextid, 'qtype_multichoice', 'partiallycorrectfeedback', $question->id);
!             $expout .= "    <partiallycorrectfeedback format=\"$textformat\">\n";
!             $expout .= $this->writetext($question->options->partiallycorrectfeedback, 3);
!             $expout .= $this->writefiles($files);
!             $expout .= "    </partiallycorrectfeedback>\n";
! 
!             $textformat = $this->get_format($question->options->incorrectfeedbackformat);
!             $files = $fs->get_area_files($contextid, 'qtype_multichoice', 'incorrectfeedback', $question->id);
!             $expout .= "    <incorrectfeedback format=\"$textformat\">\n";
!             $expout .= $this->writetext($question->options->incorrectfeedback, 3);
!             $expout .= $this->writefiles($files);
!             $expout .= "    </incorrectfeedback>\n";
! 
!             $expout .= "    <answernumbering>{$question->options->answernumbering}</answernumbering>\n";
!             foreach($question->options->answers as $answer) {
!                 $percent = $answer->fraction * 100;
!                 $expout .= "      <answer fraction=\"$percent\">\n";
!                 $expout .= $this->writetext($answer->answer,4,false);
!                 $feedbackformat = $this->get_format($answer->feedbackformat);
!                 $expout .= "      <feedback format=\"$feedbackformat\">\n";
!                 $expout .= $this->writetext($answer->feedback,5,false);
!                 $expout .= $this->writefiles($answer->feedbackfiles);
!                 $expout .= "      </feedback>\n";
!                 $expout .= "    </answer>\n";
!                 }
!             break;
!         case SHORTANSWER:
!             $expout .= "    <usecase>{$question->options->usecase}</usecase>\n ";
!             foreach($question->options->answers as $answer) {
!                 $percent = 100 * $answer->fraction;
!                 $expout .= "    <answer fraction=\"$percent\">\n";
!                 $expout .= $this->writetext( $answer->answer,3,false );
!                 $feedbackformat = $this->get_format($answer->feedbackformat);
!                 $expout .= "      <feedback format=\"$feedbackformat\">\n";
!                 $expout .= $this->writetext($answer->feedback);
!                 $expout .= $this->writefiles($answer->feedbackfiles);
!                 $expout .= "      </feedback>\n";
!                 $expout .= "    </answer>\n";
!             }
!             break;
!         case NUMERICAL:
!             foreach ($question->options->answers as $answer) {
!                 $tolerance = $answer->tolerance;
!                 $percent = 100 * $answer->fraction;
!                 $expout .= "<answer fraction=\"$percent\">\n";
!                 // <text> tags are an added feature, old filed won't have them
!                 $expout .= "    <text>{$answer->answer}</text>\n";
!                 $expout .= "    <tolerance>$tolerance</tolerance>\n";
!                 $feedbackformat = $this->get_format($answer->feedbackformat);
!                 $expout .= "    <feedback format=\"$feedbackformat\">\n";
!                 $expout .= $this->writetext($answer->feedback);
!                 $expout .= $this->writefiles($answer->feedbackfiles);
!                 $expout .= "    </feedback>\n";
!                 // fraction tag is deprecated
!                 // $expout .= "    <fraction>{$answer->fraction}</fraction>\n";
!                 $expout .= "</answer>\n";
!             }
! 
!             $units = $question->options->units;
!             if (count($units)) {
!                 $expout .= "<units>\n";
!                 foreach ($units as $unit) {
!                     $expout .= "  <unit>\n";
!                     $expout .= "    <multiplier>{$unit->multiplier}</multiplier>\n";
!                     $expout .= "    <unit_name>{$unit->unit}</unit_name>\n";
!                     $expout .= "  </unit>\n";
!                 }
!                 $expout .= "</units>\n";
!             }
!             if (isset($question->options->unitgradingtype)) {
!                 $expout .= "    <unitgradingtype>{$question->options->unitgradingtype}</unitgradingtype>\n";
!             }
!             if (isset($question->options->unitpenalty)) {
!                 $expout .= "    <unitpenalty>{$question->options->unitpenalty}</unitpenalty>\n";
!             }
!             if (isset($question->options->showunits)) {
!                 $expout .= "    <showunits>{$question->options->showunits}</showunits>\n";
!             }
!             if (isset($question->options->unitsleft)) {
!                 $expout .= "    <unitsleft>{$question->options->unitsleft}</unitsleft>\n";
!             }
!             if (!empty($question->options->instructionsformat)) {
!                 $textformat = $this->get_format($question->options->instructionsformat);
!                 $files = $fs->get_area_files($contextid, 'qtype_numerical', 'instruction', $question->id);
!                 $expout .= "    <instructions format=\"$textformat\">\n";
!                 $expout .= $this->writetext($question->options->instructions, 3);
!                 $expout .= $this->writefiles($files);
!                 $expout .= "    </instructions>\n";
!             }
!             break;
!         case MATCH:
!             foreach($question->options->subquestions as $subquestion) {
!                 $files = $fs->get_area_files($contextid, 'qtype_match', 'subquestion', $subquestion->id);
!                 $textformat = $this->get_format($subquestion->questiontextformat);
!                 $expout .= "<subquestion format=\"$textformat\">\n";
!                 $expout .= $this->writetext($subquestion->questiontext);
!                 $expout .= $this->writefiles($files);
!                 $expout .= "<answer>";
!                 $expout .= $this->writetext($subquestion->answertext);
!                 $expout .= "</answer>\n";
!                 $expout .= "</subquestion>\n";
!             }
!             break;
!         case DESCRIPTION:
!             // nothing more to do for this type
!             break;
!         case MULTIANSWER:
!             $a_count=1;
!             foreach($question->options->questions as $question) {
!                 $thispattern = preg_quote("{#".$a_count."}"); //TODO: is this really necessary?
!                 $thisreplace = $question->questiontext;
!                 $expout=preg_replace("~$thispattern~", $thisreplace, $expout );
!                 $a_count++;
!             }
!         break;
!         case ESSAY:
!             if (!empty($question->options->answers)) {
!                 foreach ($question->options->answers as $answer) {
!                     $percent = 100 * $answer->fraction;
!                     $expout .= "<answer fraction=\"$percent\">\n";
!                     $feedbackformat = $this->get_format($answer->feedbackformat);
!                     $expout .= "    <feedback format=\"$feedbackformat\">\n";
!                     $expout .= $this->writetext($answer->feedback);
!                     $expout .= $this->writefiles($answer->feedbackfiles);
!                     $expout .= "    </feedback>\n";
!                     // fraction tag is deprecated
!                     // $expout .= "    <fraction>{$answer->fraction}</fraction>\n";
!                     $expout .= "</answer>\n";
!                 }
!             }
!             break;
!         case CALCULATED:
!         case CALCULATEDSIMPLE:
!         case CALCULATEDMULTI:
!             $expout .= "    <synchronize>{$question->options->synchronize}</synchronize>\n";
!             $expout .= "    <single>{$question->options->single}</single>\n";
!             $expout .= "    <answernumbering>{$question->options->answernumbering}</answernumbering>\n";
!             $expout .= "    <shuffleanswers>".$this->writetext($question->options->shuffleanswers, 3)."</shuffleanswers>\n";
! 
!             $component = 'qtype_' . $question->qtype;
!             $files = $fs->get_area_files($contextid, $component, 'correctfeedback', $question->id);
!             $expout .= "    <correctfeedback>\n";
!             $expout .= $this->writetext($question->options->correctfeedback, 3);
!             $expout .= $this->writefiles($files);
!             $expout .= "    </correctfeedback>\n";
! 
!             $files = $fs->get_area_files($contextid, $component, 'partiallycorrectfeedback', $question->id);
!             $expout .= "    <partiallycorrectfeedback>\n";
!             $expout .= $this->writetext($question->options->partiallycorrectfeedback, 3);
!             $expout .= $this->writefiles($files);
!             $expout .= "    </partiallycorrectfeedback>\n";
! 
!             $files = $fs->get_area_files($contextid, $component, 'incorrectfeedback', $question->id);
!             $expout .= "    <incorrectfeedback>\n";
!             $expout .= $this->writetext($question->options->incorrectfeedback, 3);
!             $expout .= $this->writefiles($files);
!             $expout .= "    </incorrectfeedback>\n";
! 
!             foreach ($question->options->answers as $answer) {
!                 $tolerance = $answer->tolerance;
!                 $tolerancetype = $answer->tolerancetype;
!                 $correctanswerlength= $answer->correctanswerlength ;
!                 $correctanswerformat= $answer->correctanswerformat;
!                 $percent = 100 * $answer->fraction;
!                 $expout .= "<answer fraction=\"$percent\">\n";
!                 // "<text/>" tags are an added feature, old files won't have them
!                 $expout .= "    <text>{$answer->answer}</text>\n";
!                 $expout .= "    <tolerance>$tolerance</tolerance>\n";
!                 $expout .= "    <tolerancetype>$tolerancetype</tolerancetype>\n";
!                 $expout .= "    <correctanswerformat>$correctanswerformat</correctanswerformat>\n";
!                 $expout .= "    <correctanswerlength>$correctanswerlength</correctanswerlength>\n";
!                 $feedbackformat = $this->get_format($answer->feedbackformat);
!                 $expout .= "    <feedback format=\"$feedbackformat\">\n";
!                 $expout .= $this->writetext($answer->feedback);
!                 $expout .= $this->writefiles($answer->feedbackfiles);
!                 $expout .= "    </feedback>\n";
!                 $expout .= "</answer>\n";
!             }
!             if (isset($question->options->unitgradingtype)) {
!                 $expout .= "    <unitgradingtype>{$question->options->unitgradingtype}</unitgradingtype>\n";
!             }
!             if (isset($question->options->unitpenalty)) {
!                 $expout .= "    <unitpenalty>{$question->options->unitpenalty}</unitpenalty>\n";
!             }
!             if (isset($question->options->showunits)) {
!                 $expout .= "    <showunits>{$question->options->showunits}</showunits>\n";
!             }
!             if (isset($question->options->unitsleft)) {
!                 $expout .= "    <unitsleft>{$question->options->unitsleft}</unitsleft>\n";
!             }
! 
!             if (isset($question->options->instructionsformat)) {
!                 $textformat = $this->get_format($question->options->instructionsformat);
!                 $files = $fs->get_area_files($contextid, $component, 'instruction', $question->id);
!                 $expout .= "    <instructions format=\"$textformat\">\n";
!                 $expout .= $this->writetext($question->options->instructions, 3);
!                 $expout .= $this->writefiles($files);
!                 $expout .= "    </instructions>\n";
!             }
! 
!             if (isset($question->options->units)) {
!                 $units = $question->options->units;
!                 if (count($units)) {
!                     $expout .= "<units>\n";
!                     foreach ($units as $unit) {
!                         $expout .= "  <unit>\n";
!                         $expout .= "    <multiplier>{$unit->multiplier}</multiplier>\n";
!                         $expout .= "    <unit_name>{$unit->unit}</unit_name>\n";
!                         $expout .= "  </unit>\n";
!                     }
!                     $expout .= "</units>\n";
!                 }
!             }
!             //The tag $question->export_process has been set so we get all the data items in the database
!             //   from the function $QTYPES['calculated']->get_question_options(&$question);
!             //  calculatedsimple defaults to calculated
!             if( isset($question->options->datasets)&&count($question->options->datasets)){// there should be
!                 $expout .= "<dataset_definitions>\n";
!                 foreach ($question->options->datasets as $def) {
!                     $expout .= "<dataset_definition>\n";
!                     $expout .= "    <status>".$this->writetext($def->status)."</status>\n";
!                     $expout .= "    <name>".$this->writetext($def->name)."</name>\n";
!                     if ( $question->qtype == CALCULATED){
!                         $expout .= "    <type>calculated</type>\n";
!                     }else {
!                         $expout .= "    <type>calculatedsimple</type>\n";
!                     }
!                     $expout .= "    <distribution>".$this->writetext($def->distribution)."</distribution>\n";
!                     $expout .= "    <minimum>".$this->writetext($def->minimum)."</minimum>\n";
!                     $expout .= "    <maximum>".$this->writetext($def->maximum)."</maximum>\n";
!                     $expout .= "    <decimals>".$this->writetext($def->decimals)."</decimals>\n";
!                     $expout .= "    <itemcount>$def->itemcount</itemcount>\n";
!                     if ($def->itemcount > 0 ) {
!                         $expout .= "    <dataset_items>\n";
!                         foreach ($def->items as $item ){
!                               $expout .= "        <dataset_item>\n";
!                               $expout .= "           <number>".$item->itemnumber."</number>\n";
!                               $expout .= "           <value>".$item->value."</value>\n";
!                               $expout .= "        </dataset_item>\n";
!                         }
!                         $expout .= "    </dataset_items>\n";
!                         $expout .= "    <number_of_items>".$def-> number_of_items."</number_of_items>\n";
!                      }
!                     $expout .= "</dataset_definition>\n";
!                 }
!                 $expout .= "</dataset_definitions>\n";
!             }
!             break;
!         default:
!             // try support by optional plugin
!             if (!$data = $this->try_exporting_using_qtypes( $question->qtype, $question )) {
!                 echo $OUTPUT->notification( get_string( 'unsupportedexport','qformat_xml',$QTYPES[$question->qtype]->local_name() ) );
!             }
!             $expout .= $data;
!         }
! 
!         // Write the question tags.
!         if (!empty($CFG->usetags)) {
!             require_once($CFG->dirroot.'/tag/lib.php');
!             $tags = tag_get_tags_array('question', $question->id);
!             if (!empty($tags)) {
!                 $expout .= "    <tags>\n";
!                 foreach ($tags as $tag) {
!                     $expout .= "      <tag>" . $this->writetext($tag, 0, true) . "</tag>\n";
!                 }
!                 $expout .= "    </tags>\n";
!             }
!         }
  
!         // close the question tag
!         $expout .= "</question>\n";
  
!         return $expout;
!     }
  }
--- 37,1430 ----
  
  class qformat_xml extends qformat_default {
  
! 	function provide_import() {
! 		return true;
! 	}
! 
! 	function provide_export() {
! 		return true;
! 	}
! 
! 	function mime_type() {
! 		return 'application/xml';
! 	}
! 
! 	// IMPORT FUNCTIONS START HERE
! 
! 	/**
! 	 * Translate human readable format name
! 	 * into internal Moodle code number
! 	 * @param string name format name from xml file
! 	 * @return int Moodle format code
! 	 */
! 	function trans_format($name) {
! 		$name = trim($name);
! 
! 		if ($name == 'moodle_auto_format') {
! 			$id = 0;
! 		} else if ($name == 'html') {
! 			$id = 1;
! 		} else if ($name == 'plain_text') {
! 			$id = 2;
! 		} else if ($name == 'wiki_like') {
! 			$id = 3;
! 		} else if ($name == 'markdown') {
! 			$id = 4;
! 		} else {
! 			$id = 0; // or maybe warning required
! 		}
! 		return $id;
! 	}
! 
! 	/**
! 	 * Translate human readable single answer option
! 	 * to internal code number
! 	 * @param string name true/false
! 	 * @return int internal code number
! 	 */
! 	function trans_single( $name ) {
! 		$name = trim($name);
! 		if ($name == "false" || !$name) {
! 			return 0;
! 		} else {
! 			return 1;
! 		}
! 	}
! 
! 	/**
! 	 * process text string from xml file
! 	 * @param array $text bit of xml tree after ['text']
! 	 * @return string processed text
! 	 */
! 	function import_text( $text ) {
! 		// quick sanity check
! 		if (empty($text)) {
! 			return '';
! 		}
! 		$data = $text[0]['#'];
! 		return trim($data);
! 	}
! 
! 	/**
! 	 * return the value of a node, given a path to the node
! 	 * if it doesn't exist return the default value
! 	 * @param array xml data to read
! 	 * @param array path path to node expressed as array
! 	 * @param mixed default
! 	 * @param bool istext process as text
! 	 * @param string error if set value must exist, return false and issue message if not
! 	 * @return mixed value
! 	 */
! 	function getpath($xml, $path, $default, $istext=false, $error='') {
! 		foreach ($path as $index) {
! 			if (!isset($xml[$index])) {
! 				if (!empty($error)) {
! 					$this->error( $error );
! 					return false;
! 				} else {
! 					return $default;
! 				}
! 			}
! 			else $xml = $xml[$index];
! 		}
! 		if ($istext) {
! 			if (!is_string($xml)) {
! 				$this->error( get_string('invalidxml','qformat_xml') );
! 			}
! 			$xml = trim($xml);
! 		}
! 
! 		return $xml;
! 	}
! 
! 
! 	/**
! 	 * import parts of question common to all types
! 	 * @param $question array question question array from xml tree
! 	 * @return object question object
! 	 */
! 	function import_headers($question) {
! 		global $CFG;
! 
! 		// get some error strings
! 		$error_noname = get_string('xmlimportnoname','quiz');
! 		$error_noquestion = get_string('xmlimportnoquestion','quiz');
! 
! 		// this routine initialises the question object
! 		$qo = $this->defaultquestion();
! 
! 		// question name
! 		$qo->name = $this->getpath( $question, array('#','name',0,'#','text',0,'#'), '', true, $error_noname );
! 		$qo->questiontext       = $this->getpath($question, array('#','questiontext',0,'#','text',0,'#'), '', true );
! 		$qo->questiontextformat = $this->trans_format(
! 		$this->getpath($question, array('#','questiontext',0,'@','format'), 'moodle_auto_format'));
! 
! 		$qo->questiontextfiles = array();
! 
! 		// restore files in questiontext
! 		$files = $this->getpath($question, array('#', 'questiontext', 0, '#','file'), array(), false);
! 		foreach ($files as $file) {
! 			$data = new stdclass;
! 			$data->content = $file['#'];
! 			$data->encoding = $file['@']['encoding'];
! 			$data->name = $file['@']['name'];
! 			$qo->questiontextfiles[] = $data;
! 		}
! 
! 		// Backwards compatibility, deal with the old image tag.
! 		$filedata = $this->getpath($question, array('#', 'image_base64', '0', '#'), null, false);
! 		$filename = $this->getpath($question, array('#', 'image', '0', '#'), null, false);
! 		if ($filedata && $filename) {
! 			$data = new stdclass;
! 			$data->content = $filedata;
! 			$data->encoding = 'base64';
! 			$data->name = $filename;
! 			$qo->questiontextfiles[] = $data;
! 			$qo->questiontext .= ' <img src="@@PLUGINFILE@@/' . $filename . '" />';
! 		}
! 
! 		// restore files in generalfeedback
! 		$qo->generalfeedback = $this->getpath($question, array('#','generalfeedback',0,'#','text',0,'#'), $qo->generalfeedback, true);
! 		$qo->generalfeedbackfiles = array();
! 		$qo->generalfeedbackformat = $this->trans_format(
! 		$this->getpath($question, array('#', 'generalfeedback', 0, '@', 'format'), 'moodle_auto_format'));
! 		$files = $this->getpath($question, array('#', 'generalfeedback', 0, '#', 'file'), array(), false);
! 		foreach ($files as $file) {
! 			$data = new stdclass;
! 			$data->content = $file['#'];
! 			$data->encoding = $file['@']['encoding'];
! 			$data->name = $file['@']['name'];
! 			$qo->generalfeedbackfiles[] = $data;
! 		}
! 
! 		$qo->defaultgrade = $this->getpath( $question, array('#','defaultgrade',0,'#'), $qo->defaultgrade );
! 		$qo->penalty = $this->getpath( $question, array('#','penalty',0,'#'), $qo->penalty );
! 
! 		// Read the question tags.
! 		if (!empty($CFG->usetags) && array_key_exists('tags', $question['#'])
! 		&& !empty($question['#']['tags'][0]['#']['tag'])) {
! 			require_once($CFG->dirroot.'/tag/lib.php');
! 			$qo->tags = array();
! 			foreach ($question['#']['tags'][0]['#']['tag'] as $tagdata) {
! 				$qo->tags[] = $this->getpath($tagdata, array('#', 'text', 0, '#'), '', true);
! 			}
! 		}
! 
! 		return $qo;
! 	}
! 
! 	/**
! 	 * import the common parts of a single answer
! 	 * @param array answer xml tree for single answer
! 	 * @return object answer object
! 	 */
! 	function import_answer($answer) {
! 		$fraction = $this->getpath($answer, array('@', 'fraction'), 0);
! 		$answertext = $this->getpath($answer, array('#', 'text', 0, '#'), '', true);
! 		$answerformat = $this->trans_format($this->getpath($answer,
! 		array('#', 'text', 0, '#'), 'moodle_auto_format'));
! 		$answerfiles = array();
! 		$files = $this->getpath($answer, array('#', 'answer', 0, '#', 'file'), array());
! 		foreach ($files as $file) {
! 			$data = new stdclass;
! 			$data->content = $file['#'];
! 			$data->name = $file['@']['name'];
! 			$data->encoding = $file['@']['encoding'];
! 			$answerfiles[] = $data;
! 		}
! 
! 		$feedbacktext = $this->getpath($answer, array('#', 'feedback', 0, '#', 'text', 0, '#'), '', true);
! 		$feedbackformat = $this->trans_format($this->getpath($answer,
! 		array('#', 'feedback', 0, '@', 'format'), 'moodle_auto_format'));
! 		$feedbackfiles = array();
! 		$files = $this->getpath($answer, array('#', 'feedback', 0, '#', 'file'), array());
! 		foreach ($files as $file) {
! 			$data = new stdclass;
! 			$data->content = $file['#'];
! 			$data->name = $file['@']['name'];
! 			$data->encoding = $file['@']['encoding'];
! 			$feedbackfiles[] = $data;
! 		}
! 
! 		$ans = new stdclass;
! 
! 		$ans->answer = array();
! 		$ans->answer['text']   = $answertext;
! 		$ans->answer['format'] = $answerformat;
! 		$ans->answer['files']  = $answerfiles;
! 
! 		$ans->feedback = array();
! 		$ans->feedback['text']   = $feedbacktext;
! 		$ans->feedback['format'] = $feedbackformat;
! 		$ans->feedback['files']  = $feedbackfiles;
! 
! 		$ans->fraction = $fraction / 100;
! 		return $ans;
! 	}
! 
! 	/**
! 	 * import multiple choice question
! 	 * @param array question question array from xml tree
! 	 * @return object question object
! 	 */
! 	function import_multichoice($question) {
! 		// get common parts
! 		$qo = $this->import_headers($question);
! 
! 		// 'header' parts particular to multichoice
! 		$qo->qtype = MULTICHOICE;
! 		$single = $this->getpath( $question, array('#','single',0,'#'), 'true' );
! 		$qo->single = $this->trans_single( $single );
! 		$shuffleanswers = $this->getpath( $question, array('#','shuffleanswers',0,'#'), 'false' );
! 		$qo->answernumbering = $this->getpath( $question, array('#','answernumbering',0,'#'), 'abc' );
! 		$qo->shuffleanswers = $this->trans_single($shuffleanswers);
! 
! 		$qo->correctfeedback = array();
! 		$qo->correctfeedback['text'] = $this->getpath($question, array('#', 'correctfeedback', 0, '#', 'text', 0, '#'), '', true);
! 		$qo->correctfeedback['format'] = $this->trans_format(
! 		$this->getpath($question, array('#', 'correctfeedback', 0, '@', 'format'), 'moodle_auto_format'));
! 		$qo->correctfeedback['files'] = array();
! 		// restore files in correctfeedback
! 		$files = $this->getpath($question, array('#', 'correctfeedback', 0, '#','file'), array(), false);
! 		foreach ($files as $file) {
! 			$data = new stdclass;
! 			$data->content = $file['#'];
! 			$data->encoding = $file['@']['encoding'];
! 			$data->name = $file['@']['name'];
! 			$qo->correctfeedback['files'][] = $data;
! 		}
! 
! 		$qo->partiallycorrectfeedback = array();
! 		$qo->partiallycorrectfeedback['text'] = $this->getpath( $question, array('#','partiallycorrectfeedback',0,'#','text',0,'#'), '', true );
! 		$qo->partiallycorrectfeedback['format'] = $this->trans_format(
! 		$this->getpath($question, array('#', 'partiallycorrectfeedback', 0, '@', 'format'), 'moodle_auto_format'));
! 		$qo->partiallycorrectfeedback['files'] = array();
! 		// restore files in partiallycorrectfeedback
! 		$files = $this->getpath($question, array('#', 'partiallycorrectfeedback', 0, '#','file'), array(), false);
! 		foreach ($files as $file) {
! 			$data = new stdclass;
! 			$data->content = $file['#'];
! 			$data->encoding = $file['@']['encoding'];
! 			$data->name = $file['@']['name'];
! 			$qo->partiallycorrectfeedback['files'][] = $data;
! 		}
! 
! 		$qo->incorrectfeedback = array();
! 		$qo->incorrectfeedback['text'] = $this->getpath( $question, array('#','incorrectfeedback',0,'#','text',0,'#'), '', true );
! 		$qo->incorrectfeedback['format'] = $this->trans_format(
! 		$this->getpath($question, array('#', 'incorrectfeedback', 0, '@', 'format'), 'moodle_auto_format'));
! 		$qo->incorrectfeedback['files'] = array();
! 		// restore files in incorrectfeedback
! 		$files = $this->getpath($question, array('#', 'incorrectfeedback', 0, '#','file'), array(), false);
! 		foreach ($files as $file) {
! 			$data = new stdclass;
! 			$data->content = $file['#'];
! 			$data->encoding = $file['@']['encoding'];
! 			$data->name = $file['@']['name'];
! 			$qo->incorrectfeedback['files'][] = $data;
! 		}
! 
! 		// There was a time on the 1.8 branch when it could output an empty answernumbering tag, so fix up any found.
! 		if (empty($qo->answernumbering)) {
! 			$qo->answernumbering = 'abc';
! 		}
! 
! 		// run through the answers
! 		$answers = $question['#']['answer'];
! 		$a_count = 0;
! 		foreach ($answers as $answer) {
! 			$ans = $this->import_answer($answer);
! 			$qo->answer[$a_count] = $ans->answer;
! 			$qo->fraction[$a_count] = $ans->fraction;
! 			$qo->feedback[$a_count] = $ans->feedback;
! 			++$a_count;
! 		}
! 
! 		return $qo;
! 	}
! 
! 	/**
! 	 * import cloze type question
! 	 * @param array question question array from xml tree
! 	 * @return object question object
! 	 */
! 	function import_multianswer( $questions ) {
! 		$questiontext = array();
! 		$questiontext['text'] = $this->import_text($questions['#']['questiontext'][0]['#']['text']);
! 		$questiontext['format'] = '1';
! 		$questiontext['itemid'] = '';
! 		$qo = qtype_multianswer_extract_question($questiontext);
! 
! 		// 'header' parts particular to multianswer
! 		$qo->qtype = MULTIANSWER;
! 		$qo->course = $this->course;
! 		$qo->generalfeedback = '' ;
! 		// restore files in generalfeedback
! 		$qo->generalfeedback = $this->getpath($questions, array('#','generalfeedback',0,'#','text',0,'#'), $qo->generalfeedback, true);
! 		$qo->generalfeedbackfiles = array();
! 		$qo->generalfeedbackformat = $this->trans_format(
! 		$this->getpath($questions, array('#', 'generalfeedback', 0, '@', 'format'), 'moodle_auto_format'));
! 		$files = $this->getpath($questions, array('#', 'generalfeedback', 0, '#', 'file'), array(), false);
! 		foreach ($files as $file) {
! 			$data = new stdclass;
! 			$data->content = $file['#'];
! 			$data->encoding = $file['@']['encoding'];
! 			$data->name = $file['@']['name'];
! 			$qo->generalfeedbackfiles[] = $data;
! 		}
! 		if (!empty($questions)) {
! 			$qo->name = $this->import_text( $questions['#']['name'][0]['#']['text'] );
! 		}
! 		$qo->questiontext =  $qo->questiontext['text'] ;
! 		$qo->questiontextformat = '' ;
! 
! 		return $qo;
! 	}
! 
! 	/**
! 	 * import true/false type question
! 	 * @param array question question array from xml tree
! 	 * @return object question object
! 	 */
! 	function import_truefalse( $question ) {
! 		// get common parts
! 		global $OUTPUT;
! 		$qo = $this->import_headers( $question );
! 
! 		// 'header' parts particular to true/false
! 		$qo->qtype = TRUEFALSE;
! 
! 		// get answer info
! 		//
! 		// In the past, it used to be assumed that the two answers were in the file
! 		// true first, then false. Howevever that was not always true. Now, we
! 		// try to match on the answer text, but in old exports, this will be a localised
! 		// string, so if we don't find true or false, we fall back to the old system.
! 		$first = true;
! 		$warning = false;
! 		foreach ($question['#']['answer'] as $answer) {
! 			$answertext = $this->getpath( $answer, array('#','text',0,'#'), '', true);
! 			$feedback = $this->getpath($answer, array('#','feedback',0,'#','text',0,'#'), '', true);
! 			$feedbackformat = $this->getpath($answer, array('#','feedback',0, '@', 'format'), 'moodle_auto_format');
! 			$feedbackfiles = $this->getpath($answer, array('#', 'feedback', 0, '#', 'file'), array());
! 			$files = array();
! 			foreach ($feedbackfiles as $file) {
! 				$data = new stdclass;
! 				$data->content = $file['#'];
! 				$data->encoding = $file['@']['encoding'];
! 				$data->name = $file['@']['name'];
! 				$files[] = $data;
! 			}
! 			if ($answertext != 'true' && $answertext != 'false') {
! 				$warning = true;
! 				$answertext = $first ? 'true' : 'false'; // Old style file, assume order is true/false.
! 			}
! 			if ($answertext == 'true') {
! 				$qo->answer = ($answer['@']['fraction'] == 100);
! 				$qo->correctanswer = $qo->answer;
! 				$qo->feedbacktrue = array();
! 				$qo->feedbacktrue['text'] = $feedback;
! 				$qo->feedbacktrue['format'] = $this->trans_format($feedbackformat);
! 				$qo->feedbacktrue['itemid'] = null;
! 				$qo->feedbacktruefiles = $files;
! 			} else {
! 				$qo->answer = ($answer['@']['fraction'] != 100);
! 				$qo->correctanswer = $qo->answer;
! 				$qo->feedbackfalse = array();
! 				$qo->feedbackfalse['text'] = $feedback;
! 				$qo->feedbackfalse['format'] = $this->trans_format($feedbackformat);
! 				$qo->feedbackfalse['itemid'] = null;
! 				$qo->feedbackfalsefiles = $files;
! 			}
! 			$first = false;
! 		}
! 
! 		if ($warning) {
! 			$a = new stdClass;
! 			$a->questiontext = $qo->questiontext;
! 			$a->answer = get_string($qo->answer ? 'true' : 'false', 'quiz');
! 			echo $OUTPUT->notification(get_string('truefalseimporterror', 'quiz', $a));
! 		}
! 		return $qo;
! 	}
! 
! 	/**
! 	 * import short answer type question
! 	 * @param array question question array from xml tree
! 	 * @return object question object
! 	 */
! 	function import_shortanswer( $question ) {
! 		// get common parts
! 		$qo = $this->import_headers( $question );
! 
! 		// header parts particular to shortanswer
! 		$qo->qtype = SHORTANSWER;
! 
! 		// get usecase
! 		$qo->usecase = $this->getpath($question, array('#','usecase',0,'#'), $qo->usecase );
! 
! 		// run through the answers
! 		$answers = $question['#']['answer'];
! 		$a_count = 0;
! 		foreach ($answers as $answer) {
! 			$ans = $this->import_answer($answer);
! 			$qo->answer[$a_count] = $ans->answer['text'];
! 			$qo->fraction[$a_count] = $ans->fraction;
! 			$qo->feedback[$a_count] = $ans->feedback;
! 			++$a_count;
! 		}
! 
! 		return $qo;
! 	}
! 
! 	/**
! 	 * import description type question
! 	 * @param array question question array from xml tree
! 	 * @return object question object
! 	 */
! 	function import_description( $question ) {
! 		// get common parts
! 		$qo = $this->import_headers( $question );
! 		// header parts particular to shortanswer
! 		$qo->qtype = DESCRIPTION;
! 		$qo->defaultgrade = 0;
! 		$qo->length = 0;
! 		return $qo;
! 	}
! 
! 	/**
! 	 * import numerical type question
! 	 * @param array question question array from xml tree
! 	 * @return object question object
! 	 */
! 	function import_numerical($question) {
! 		// get common parts
! 		$qo = $this->import_headers($question);
! 
! 		// header parts particular to numerical
! 		$qo->qtype = NUMERICAL;
! 
! 		// get answers array
! 		$answers = $question['#']['answer'];
! 		$qo->answer = array();
! 		$qo->feedback = array();
! 		$qo->fraction = array();
! 		$qo->tolerance = array();
! 		foreach ($answers as $answer) {
! 			// answer outside of <text> is deprecated
! 			$obj = $this->import_answer($answer);
! 			$qo->answer[] = $obj->answer['text'];
! 			if (empty($qo->answer)) {
! 				$qo->answer = '*';
! 			}
! 			$qo->feedback[]  = $obj->feedback;
! 			$qo->tolerance[] = $this->getpath($answer, array('#', 'tolerance', 0, '#'), 0);
! 
! 			// fraction as a tag is deprecated
! 			$fraction = $this->getpath($answer, array('@', 'fraction'), 0) / 100;
! 			$qo->fraction[] = $this->getpath($answer, array('#', 'fraction', 0, '#'), $fraction); // deprecated
! 		}
! 
! 		// get units array
! 		$qo->unit = array();
! 		$units = $this->getpath( $question, array('#','units',0,'#','unit'), array() );
! 		if (!empty($units)) {
! 			$qo->multiplier = array();
! 			foreach ($units as $unit) {
! 				$qo->multiplier[] = $this->getpath( $unit, array('#','multiplier',0,'#'), 1 );
! 				$qo->unit[] = $this->getpath( $unit, array('#','unit_name',0,'#'), '', true );
! 			}
! 		}
! 		$qo->unitgradingtype = $this->getpath( $question, array('#','unitgradingtype',0,'#'), 0 );
! 		$qo->unitpenalty = $this->getpath( $question, array('#','unitpenalty',0,'#'), 0 );
! 		$qo->showunits = $this->getpath( $question, array('#','showunits',0,'#'), 0 );
! 		$qo->unitsleft = $this->getpath( $question, array('#','unitsleft',0,'#'), 0 );
! 		$qo->instructions['text'] = '';
! 		$qo->instructions['format'] = FORMAT_HTML;
! 		$instructions = $this->getpath($question, array('#', 'instructions'), array());
! 		if (!empty($instructions)) {
! 			$qo->instructions = array();
! 			$qo->instructions['text'] = $this->getpath($instructions,
! 			array('0', '#', 'text', '0', '#'), '', true);
! 			$qo->instructions['format'] = $this->trans_format($this->getpath($instructions,
! 			array('0', '@', 'format'), 'moodle_auto_format'));
! 			$files = $this->getpath($instructions, array('0', '#', 'file'), array());
! 			$qo->instructions['files'] = array();
! 			foreach ($files as $file) {
! 				$data = new stdclass;
! 				$data->content = $file['#'];
! 				$data->encoding = $file['@']['encoding'];
! 				$data->name = $file['@']['name'];
! 				$qo->instructions['files'][]= $data;
! 			}
! 		}
! 		return $qo;
! 	}
! 
! 	/**
! 	 * import matching type question
! 	 * @param array question question array from xml tree
! 	 * @return object question object
! 	 */
! 	function import_matching($question) {
! 		// get common parts
! 		$qo = $this->import_headers($question);
! 
! 		// header parts particular to matching
! 		$qo->qtype = MATCH;
! 		$qo->shuffleanswers = $this->getpath($question, array('#', 'shuffleanswers', 0, '#'), 1);
! 
! 		// get subquestions
! 		$subquestions = $question['#']['subquestion'];
! 		$qo->subquestions = array();
! 		$qo->subanswers = array();
! 
! 		// run through subquestions
! 		foreach ($subquestions as $subquestion) {
! 			$question = array();
! 			$question['text'] = $this->getpath($subquestion, array('#', 'text', 0, '#'), '', true);
! 			$question['format'] = $this->trans_format(
! 			$this->getpath($subquestion, array('@', 'format'), 'moodle_auto_format'));
! 			$question['files'] = array();
! 
! 			$files = $this->getpath($subquestion, array('#', 'file'), array());
! 			foreach ($files as $file) {
! 				$data = new stdclass();
! 				$data->content = $file['#'];
! 				$data->encoding = $file['@']['encoding'];
! 				$data->name = $file['@']['name'];
! 				$question['files'][] = $data;
! 			}
! 			$qo->subquestions[] = $question;
! 			$answers = $this->getpath($subquestion, array('#', 'answer'), array());
! 			$qo->subanswers[] = $this->getpath($subquestion, array('#','answer',0,'#','text',0,'#'), '', true);
! 		}
! 		return $qo;
! 	}
! 
! 	/**
! 	 * import  essay type question
! 	 * @param array question question array from xml tree
! 	 * @return object question object
! 	 */
! 	function import_essay( $question ) {
! 		// get common parts
! 		$qo = $this->import_headers( $question );
! 
! 		// header parts particular to essay
! 		$qo->qtype = ESSAY;
! 
! 		$answers = $this->getpath($question, array('#', 'answer'), null);
! 		if ($answers) {
! 			$answer = array_pop($answers);
! 			$answer = $this->import_answer($answer);
! 			// get feedback
! 			$qo->feedback = $answer->feedback;
! 		} else {
! 			$qo->feedback = array('text' => '', 'format' => FORMAT_MOODLE, 'files' => array());
! 		}
! 
! 		// get fraction - <fraction> tag is deprecated
! 		$qo->fraction = $this->getpath($question, array('@','fraction'), 0 ) / 100;
! 		$q0->fraction = $this->getpath($question, array('#','fraction',0,'#'), $qo->fraction );
! 
! 		return $qo;
! 	}
! 
! 	function import_calculated($question,$qtype) {
! 		// import calculated question
! 
! 		// get common parts
! 		$qo = $this->import_headers( $question );
! 
! 		// header parts particular to calculated
! 		$qo->qtype = CALCULATED ;//CALCULATED;
! 		$qo->synchronize = $this->getpath( $question, array( '#','synchronize',0,'#' ), 0 );
! 		$single = $this->getpath( $question, array('#','single',0,'#'), 'true' );
! 		$qo->single = $this->trans_single( $single );
! 		$shuffleanswers = $this->getpath( $question, array('#','shuffleanswers',0,'#'), 'false' );
! 		$qo->answernumbering = $this->getpath( $question, array('#','answernumbering',0,'#'), 'abc' );
! 		$qo->shuffleanswers = $this->trans_single($shuffleanswers);
! 
! 		$qo->correctfeedback = array();
! 		$qo->correctfeedback['text'] = $this->getpath($question, array('#','correctfeedback',0,'#','text',0,'#'), '', true );
! 		$qo->correctfeedback['format'] = $this->trans_format($this->getpath(
! 		$question, array('#', 'correctfeedback', 0, '@', 'formath'), 'moodle_auto_format'));
! 		$qo->correctfeedback['files'] = array();
! 
! 		$files = $this->getpath($question, array('#', 'correctfeedback', '0', '#', 'file'), array());
! 		foreach ($files as $file) {
! 			$data = new stdclass();
! 			$data->content = $file['#'];
! 			$data->name = $file['@']['name'];
! 			$data->encoding = $file['@']['encoding'];
! 			$qo->correctfeedback['files'][] = $data;
! 		}
! 
! 		$qo->partiallycorrectfeedback = array();
! 		$qo->partiallycorrectfeedback['text'] = $this->getpath( $question, array('#','partiallycorrectfeedback',0,'#','text',0,'#'), '', true );
! 		$qo->partiallycorrectfeedback['format'] = $this->trans_format(
! 		$this->getpath($question, array('#','partiallycorrectfeedback', 0, '@','format'), 'moodle_auto_format'));
! 		$qo->partiallycorrectfeedback['files'] = array();
! 
! 		$files = $this->getpath($question, array('#', 'partiallycorrectfeedback', '0', '#', 'file'), array());
! 		foreach ($files as $file) {
! 			$data = new stdclass();
! 			$data->content = $file['#'];
! 			$data->name = $file['@']['name'];
! 			$data->encoding = $file['@']['encoding'];
! 			$qo->partiallycorrectfeedback['files'][] = $data;
! 		}
! 
! 		$qo->incorrectfeedback = array();
! 		$qo->incorrectfeedback['text'] = $this->getpath( $question, array('#','incorrectfeedback',0,'#','text',0,'#'), '', true );
! 		$qo->incorrectfeedback['format'] = $this->trans_format($this->getpath(
! 		$question, array('#','incorrectfeedback', 0, '@','format'), 'moodle_auto_format'));
! 		$qo->incorrectfeedback['files'] = array();
! 
! 		$files = $this->getpath($question, array('#', 'incorrectfeedback', '0', '#', 'file'), array());
! 		foreach ($files as $file) {
! 			$data = new stdclass();
! 			$data->content = $file['#'];
! 			$data->name = $file['@']['name'];
! 			$data->encoding = $file['@']['encoding'];
! 			$qo->incorrectfeedback['files'][] = $data;
! 		}
! 
! 		$qo->unitgradingtype = $this->getpath($question, array('#','unitgradingtype',0,'#'), 0 );
! 		$qo->unitpenalty = $this->getpath($question, array('#','unitpenalty',0,'#'), 0 );
! 		$qo->showunits = $this->getpath($question, array('#','showunits',0,'#'), 0 );
! 		$qo->unitsleft = $this->getpath($question, array('#','unitsleft',0,'#'), 0 );
! 		$qo->instructions = $this->getpath( $question, array('#','instructions',0,'#','text',0,'#'), '', true );
! 		if (!empty($instructions)) {
! 			$qo->instructions = array();
! 			$qo->instructions['text'] = $this->getpath($instructions,
! 			array('0', '#', 'text', '0', '#'), '', true);
! 			$qo->instructions['format'] = $this->trans_format($this->getpath($instructions,
! 			array('0', '@', 'format'), 'moodle_auto_format'));
! 			$files = $this->getpath($instructions,
! 			array('0', '#', 'file'), array());
! 			$qo->instructions['files'] = array();
! 			foreach ($files as $file) {
! 				$data = new stdclass;
! 				$data->content = $file['#'];
! 				$data->encoding = $file['@']['encoding'];
! 				$data->name = $file['@']['name'];
! 				$qo->instructions['files'][]= $data;
! 			}
! 		}
! 
! 		$files = $this->getpath($question, array('#', 'instructions', 0, '#', 'file', 0, '@'), '', false);
! 
! 		// get answers array
! 		$answers = $question['#']['answer'];
! 		$qo->answers = array();
! 		$qo->feedback = array();
! 		$qo->fraction = array();
! 		$qo->tolerance = array();
! 		$qo->tolerancetype = array();
! 		$qo->correctanswerformat = array();
! 		$qo->correctanswerlength = array();
! 		$qo->feedback = array();
! 		foreach ($answers as $answer) {
! 			$ans = $this->import_answer($answer);
! 			// answer outside of <text> is deprecated
! 			if (empty($ans->answer['text'])) {
! 				$ans->answer['text'] = '*';
! 			}
! 			$qo->answers[] = $ans->answer;
! 			$qo->feedback[] = $ans->feedback;
! 			$qo->tolerance[] = $answer['#']['tolerance'][0]['#'];
! 			// fraction as a tag is deprecated
! 			if (!empty($answer['#']['fraction'][0]['#'])) {
! 				$qo->fraction[] = $answer['#']['fraction'][0]['#'];
! 			} else {
! 				$qo->fraction[] = $answer['@']['fraction'] / 100;
! 			}
! 			$qo->tolerancetype[] = $answer['#']['tolerancetype'][0]['#'];
! 			$qo->correctanswerformat[] = $answer['#']['correctanswerformat'][0]['#'];
! 			$qo->correctanswerlength[] = $answer['#']['correctanswerlength'][0]['#'];
! 		}
! 		// get units array
! 		$qo->unit = array();
! 		if (isset($question['#']['units'][0]['#']['unit'])) {
! 			$units = $question['#']['units'][0]['#']['unit'];
! 			$qo->multiplier = array();
! 			foreach ($units as $unit) {
! 				$qo->multiplier[] = $unit['#']['multiplier'][0]['#'];
! 				$qo->unit[] = $unit['#']['unit_name'][0]['#'];
! 			}
! 		}
! 		$instructions = $this->getpath($question, array('#', 'instructions'), array());
! 		if (!empty($instructions)) {
! 			$qo->instructions = array();
! 			$qo->instructions['text'] = $this->getpath($instructions,
! 			array('0', '#', 'text', '0', '#'), '', true);
! 			$qo->instructions['format'] = $this->trans_format($this->getpath($instructions,
! 			array('0', '@', 'format'), 'moodle_auto_format'));
! 			$files = $this->getpath($instructions,
! 			array('0', '#', 'file'), array());
! 			$qo->instructions['files'] = array();
! 			foreach ($files as $file) {
! 				$data = new stdclass;
! 				$data->content = $file['#'];
! 				$data->encoding = $file['@']['encoding'];
! 				$data->name = $file['@']['name'];
! 				$qo->instructions['files'][]= $data;
! 			}
! 		}
! 		$datasets = $question['#']['dataset_definitions'][0]['#']['dataset_definition'];
! 		$qo->dataset = array();
! 		$qo->datasetindex= 0 ;
! 		foreach ($datasets as $dataset) {
! 			$qo->datasetindex++;
! 			$qo->dataset[$qo->datasetindex] = new stdClass();
! 			$qo->dataset[$qo->datasetindex]->status = $this->import_text( $dataset['#']['status'][0]['#']['text']);
! 			$qo->dataset[$qo->datasetindex]->name = $this->import_text( $dataset['#']['name'][0]['#']['text']);
! 			$qo->dataset[$qo->datasetindex]->type =  $dataset['#']['type'][0]['#'];
! 			$qo->dataset[$qo->datasetindex]->distribution = $this->import_text( $dataset['#']['distribution'][0]['#']['text']);
! 			$qo->dataset[$qo->datasetindex]->max = $this->import_text( $dataset['#']['maximum'][0]['#']['text']);
! 			$qo->dataset[$qo->datasetindex]->min = $this->import_text( $dataset['#']['minimum'][0]['#']['text']);
! 			$qo->dataset[$qo->datasetindex]->length = $this->import_text( $dataset['#']['decimals'][0]['#']['text']);
! 			$qo->dataset[$qo->datasetindex]->distribution = $this->import_text( $dataset['#']['distribution'][0]['#']['text']);
! 			$qo->dataset[$qo->datasetindex]->itemcount = $dataset['#']['itemcount'][0]['#'];
! 			$qo->dataset[$qo->datasetindex]->datasetitem = array();
! 			$qo->dataset[$qo->datasetindex]->itemindex = 0;
! 			$qo->dataset[$qo->datasetindex]->number_of_items=$dataset['#']['number_of_items'][0]['#'];
! 			$datasetitems = $dataset['#']['dataset_items'][0]['#']['dataset_item'];
! 			foreach ($datasetitems as $datasetitem) {
! 				$qo->dataset[$qo->datasetindex]->itemindex++;
! 				$qo->dataset[$qo->datasetindex]->datasetitem[$qo->dataset[$qo->datasetindex]->itemindex] = new stdClass();
! 				$qo->dataset[$qo->datasetindex]->datasetitem[$qo->dataset[$qo->datasetindex]->itemindex]->itemnumber =  $datasetitem['#']['number'][0]['#']; //[0]['#']['number'][0]['#'] ; // [0]['numberitems'] ;//['#']['number'][0]['#'];// $datasetitems['#']['number'][0]['#'];
! 				$qo->dataset[$qo->datasetindex]->datasetitem[$qo->dataset[$qo->datasetindex]->itemindex]->value = $datasetitem['#']['value'][0]['#'] ;//$datasetitem['#']['value'][0]['#'];
! 			}
! 		}
! 
! 		// echo "<pre>loaded qo";print_r($qo);echo "</pre>";
! 		return $qo;
! 	}
! 
! 	/**
! 	 * this is not a real question type. It's a dummy type used
! 	 * to specify the import category
! 	 * format is:
! 	 * <question type="category">
! 	 *     <category>tom/dick/harry</category>
! 	 * </question>
! 	 */
! 	function import_category( $question ) {
! 		$qo = new stdClass;
! 		$qo->qtype = 'category';
! 		$qo->category = $this->import_text($question['#']['category'][0]['#']['text']);
! 		return $qo;
! 	}
! 
! 	/**
! 	 * parse the array of lines into an array of questions
! 	 * this *could* burn memory - but it won't happen that much
! 	 * so fingers crossed!
! 	 * @param array lines array of lines from the input file
! 	 * @return array (of objects) question objects
! 	 */
! 	function readquestions($lines) {
! 		// we just need it as one big string
! 		$text = implode($lines, " ");
! 		unset($lines);
! 
! 		// this converts xml to big nasty data structure
! 		// the 0 means keep white space as it is (important for markdown format)
! 		// print_r it if you want to see what it looks like!
! 		$xml = xmlize($text, 0);
! 
! 		// set up array to hold all our questions
! 		$questions = array();
! 
! 		// iterate through questions
! 		foreach ($xml['quiz']['#']['question'] as $question) {
! 			$question_type = $question['@']['type'];
! 			$questiontype = get_string( 'questiontype','quiz',$question_type );
! 
! 			if ($question_type=='multichoice') {
! 				$qo = $this->import_multichoice( $question );
! 			}
! 			elseif ($question_type=='truefalse') {
! 				$qo = $this->import_truefalse( $question );
! 			}
! 			elseif ($question_type=='shortanswer') {
! 				$qo = $this->import_shortanswer( $question );
! 			}
! 			elseif ($question_type=='numerical') {
! 				$qo = $this->import_numerical( $question );
! 			}
! 			elseif ($question_type=='description') {
! 				$qo = $this->import_description( $question );
! 			}
! 			elseif ($question_type=='matching') {
! 				$qo = $this->import_matching( $question );
! 			}
! 			elseif ($question_type=='cloze') {
! 				$qo = $this->import_multianswer( $question );
! 			}
! 			elseif ($question_type=='essay') {
! 				$qo = $this->import_essay( $question );
! 			}
! 			elseif ($question_type=='calculated') {
! 				$qo = $this->import_calculated( $question,CALCULATED  );
! 			}
! 			elseif ($question_type=='calculatedsimple') {
! 				$qo = $this->import_calculated( $question,CALCULATEDMULTI  );
! 				$qo->qtype = CALCULATEDSIMPLE ;
! 			}
! 			elseif ($question_type=='calculatedmulti') {
! 				$qo = $this->import_calculated( $question,CALCULATEDMULTI );
! 				$qo->qtype = CALCULATEDMULTI ;
! 			}
! 			elseif ($question_type=='category') {
! 				$qo = $this->import_category( $question );
! 			}
! 			else {
! 				// try for plugin support
! 				// no default question, as the plugin can call
! 				// import_headers() itself if it wants to
! 				if (!$qo = $this->try_importing_using_qtypes( $question, null, null, $question_type)) {
! 					$notsupported = get_string( 'xmltypeunsupported','quiz',$question_type );
! 					$this->error( $notsupported );
! 					$qo = null;
! 				}
! 			}
! 
! 			// stick the result in the $questions array
! 			if ($qo) {
! 				$questions[] = $qo;
! 			}
! 		}
! 		return $questions;
! 	}
! 
! 	// EXPORT FUNCTIONS START HERE
! 
! 	function export_file_extension() {
! 		return '.xml';
! 	}
! 
! 	/**
! 	 * Turn the internal question code into a human readable form
! 	 * (The code used to be numeric, but this remains as some of
! 	 * the names don't match the new internal format)
! 	 * @param mixed type_id Internal code
! 	 * @return string question type string
! 	 */
! 	function get_qtype( $type_id ) {
! 		switch( $type_id ) {
! 			case TRUEFALSE:
! 				$name = 'truefalse';
! 				break;
! 			case MULTICHOICE:
! 				$name = 'multichoice';
! 				break;
! 			case SHORTANSWER:
! 				$name = 'shortanswer';
! 				break;
! 			case NUMERICAL:
! 				$name = 'numerical';
! 				break;
! 			case MATCH:
! 				$name = 'matching';
! 				break;
! 			case DESCRIPTION:
! 				$name = 'description';
! 				break;
! 			case MULTIANSWER:
! 				$name = 'cloze';
! 				break;
! 			case ESSAY:
! 				$name = 'essay';
! 				break;
! 			case CALCULATED:
! 				$name = 'calculated';
! 				break;
! 			case CALCULATEDSIMPLE:
! 				$name = 'calculatedsimple';
! 				break;
! 			case CALCULATEDMULTI:
! 				$name = 'calculatedmulti';
! 				break;
! 			default:
! 				$name = false;
! 		}
! 		return $name;
! 	}
! 
! 	/**
! 	 * Convert internal Moodle text format code into
! 	 * human readable form
! 	 * @param int id internal code
! 	 * @return string format text
! 	 */
! 	function get_format( $id ) {
! 		switch( $id ) {
! 			case 0:
! 				$name = "moodle_auto_format";
! 				break;
! 			case 1:
! 				$name = "html";
! 				break;
! 			case 2:
! 				$name = "plain_text";
! 				break;
! 			case 3:
! 				$name = "wiki_like";
! 				break;
! 			case 4:
! 				$name = "markdown";
! 				break;
! 			default:
! 				$name = "unknown";
! 		}
! 		return $name;
! 	}
! 
! 	/**
! 	 * Convert internal single question code into
! 	 * human readable form
! 	 * @param int id single question code
! 	 * @return string single question string
! 	 */
! 	function get_single( $id ) {
! 		switch( $id ) {
! 			case 0:
! 				$name = "false";
! 				break;
! 			case 1:
! 				$name = "true";
! 				break;
! 			default:
! 				$name = "unknown";
! 		}
! 		return $name;
! 	}
! 
! 	/**
! 	 * generates <text></text> tags, processing raw text therein
! 	 * @param int ilev the current indent level
! 	 * @param boolean short stick it on one line
! 	 * @return string formatted text
! 	 */
! 	function writetext($raw, $ilev = 0, $short = true) {
! 		$indent = str_repeat('  ', $ilev);
! 
! 		// if required add CDATA tags
! 		if (!empty($raw) and (htmlspecialchars($raw) != $raw)) {
! 			$raw = "<![CDATA[$raw]]>";
! 		}
! 
! 		if ($short) {
! 			$xml = "$indent<text>$raw</text>";
! 		} else {
! 			$xml = "$indent<text>\n$raw\n$indent</text>\n";
! 		}
  
! 		return $xml;
! 	}
  
! 	function presave_process( $content ) {
! 		// override method to allow us to add xml headers and footers
  
! 		// add the xml headers and footers
! 		$content = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n" .
                         "<quiz>\n" .
! 		$content . "\n" .
                         "</quiz>";
! 		return $content;
! 	}
  
! 	/**
! 	 * Turns question into an xml segment
! 	 * @param object question object
! 	 * @param int context id
! 	 * @return string xml segment
! 	 */
! 	function writequestion($question) {
! 		global $CFG, $QTYPES, $OUTPUT;
! 
! 		$fs = get_file_storage();
! 		$contextid = $question->contextid;
! 		// initial string;
! 		$expout = "";
! 
! 		// add comment
! 		$expout .= "\n\n<!-- question: $question->id  -->\n";
! 
! 		// check question type
! 		if (!$question_type = $this->get_qtype( $question->qtype )) {
! 			// must be a plugin then, so just accept the name supplied
! 			$question_type = $question->qtype;
! 		}
! 
! 		// add opening tag
! 		// generates specific header for Cloze and category type question
! 		if ($question->qtype == 'category') {
! 			$categorypath = $this->writetext( $question->category );
! 			$expout .= "  <question type=\"category\">\n";
! 			$expout .= "    <category>\n";
! 			$expout .= "        $categorypath\n";
! 			$expout .= "    </category>\n";
! 			$expout .= "  </question>\n";
! 			return $expout;
! 		} elseif ($question->qtype != MULTIANSWER) {
! 			// for all question types except Close
! 			$name_text = $this->writetext($question->name);
! 			$qtformat = $this->get_format($question->questiontextformat);
! 			$generalfeedbackformat = $this->get_format($question->generalfeedbackformat);
! 
! 			$question_text = $this->writetext($question->questiontext);
! 			$question_text_files = $this->writefiles($question->questiontextfiles);
! 
! 			$generalfeedback = $this->writetext($question->generalfeedback);
! 			$generalfeedback_files = $this->writefiles($question->generalfeedbackfiles);
! 
! 			$expout .= "  <question type=\"$question_type\">\n";
! 			$expout .= "    <name>$name_text</name>\n";
! 			$expout .= "    <questiontext format=\"$qtformat\">\n";
! 			$expout .= $question_text;
! 			$expout .= $question_text_files;
! 			$expout .= "    </questiontext>\n";
! 			$expout .= "    <generalfeedback format=\"$generalfeedbackformat\">\n";
! 			$expout .= $generalfeedback;
! 			$expout .= $generalfeedback_files;
! 			$expout .= "    </generalfeedback>\n";
! 			$expout .= "    <defaultgrade>{$question->defaultgrade}</defaultgrade>\n";
! 			$expout .= "    <penalty>{$question->penalty}</penalty>\n";
! 			$expout .= "    <hidden>{$question->hidden}</hidden>\n";
! 		} else {
! 			// for Cloze type only
! 			$name_text = $this->writetext( $question->name );
! 			$question_text = $this->writetext( $question->questiontext );
! 			$generalfeedback = $this->writetext( $question->generalfeedback );
! 			$expout .= "  <question type=\"$question_type\">\n";
! 			$expout .= "    <name>$name_text</name>\n";
! 			$expout .= "    <questiontext>\n";
! 			$expout .= $question_text;
! 			$expout .= "    </questiontext>\n";
! 			$expout .= "    <generalfeedback>\n";
! 			$expout .= $generalfeedback;
! 			$expout .= "    </generalfeedback>\n";
! 		}
! 
! 		if (!empty($question->options->shuffleanswers)) {
! 			$expout .= "    <shuffleanswers>{$question->options->shuffleanswers}</shuffleanswers>\n";
! 		}
! 		else {
! 			$expout .= "    <shuffleanswers>0</shuffleanswers>\n";
! 		}
! 
! 		// output depends on question type
! 		switch($question->qtype) {
! 			case 'category':
! 				// not a qtype really - dummy used for category switching
! 				break;
! 			case TRUEFALSE:
! 				foreach ($question->options->answers as $answer) {
! 					$fraction_pc = round( $answer->fraction * 100 );
! 					if ($answer->id == $question->options->trueanswer) {
! 						$answertext = 'true';
! 					} else {
! 						$answertext = 'false';
! 					}
! 					$expout .= "    <answer fraction=\"$fraction_pc\">\n";
! 					$expout .= $this->writetext($answertext, 3) . "\n";
! 					$feedbackformat = $this->get_format($answer->feedbackformat);
! 					$expout .= "      <feedback format=\"$feedbackformat\">\n";
! 					$expout .= $this->writetext($answer->feedback,4,false);
! 					$expout .= $this->writefiles($answer->feedbackfiles);
! 					$expout .= "      </feedback>\n";
! 					$expout .= "    </answer>\n";
! 				}
! 				break;
! 			case MULTICHOICE:
! 				$expout .= "    <single>".$this->get_single($question->options->single)."</single>\n";
! 				$expout .= "    <shuffleanswers>".$this->get_single($question->options->shuffleanswers)."</shuffleanswers>\n";
! 
! 				$textformat = $this->get_format($question->options->correctfeedbackformat);
! 				$files = $fs->get_area_files($contextid, 'qtype_multichoice', 'correctfeedback', $question->id);
! 				$expout .= "    <correctfeedback format=\"$textformat\">\n";
! 				$expout .= $this->writetext($question->options->correctfeedback, 3);
! 				$expout .= $this->writefiles($files);
! 				$expout .= "    </correctfeedback>\n";
! 
! 				$textformat = $this->get_format($question->options->partiallycorrectfeedbackformat);
! 				$files = $fs->get_area_files($contextid, 'qtype_multichoice', 'partiallycorrectfeedback', $question->id);
! 				$expout .= "    <partiallycorrectfeedback format=\"$textformat\">\n";
! 				$expout .= $this->writetext($question->options->partiallycorrectfeedback, 3);
! 				$expout .= $this->writefiles($files);
! 				$expout .= "    </partiallycorrectfeedback>\n";
! 
! 				$textformat = $this->get_format($question->options->incorrectfeedbackformat);
! 				$files = $fs->get_area_files($contextid, 'qtype_multichoice', 'incorrectfeedback', $question->id);
! 				$expout .= "    <incorrectfeedback format=\"$textformat\">\n";
! 				$expout .= $this->writetext($question->options->incorrectfeedback, 3);
! 				$expout .= $this->writefiles($files);
! 				$expout .= "    </incorrectfeedback>\n";
! 
! 				$expout .= "    <answernumbering>{$question->options->answernumbering}</answernumbering>\n";
! 				foreach($question->options->answers as $answer) {
! 					$percent = $answer->fraction * 100;
! 					$expout .= "      <answer fraction=\"$percent\">\n";
! 					$expout .= $this->writetext($answer->answer,4,false);
! 					$feedbackformat = $this->get_format($answer->feedbackformat);
! 					$expout .= "      <feedback format=\"$feedbackformat\">\n";
! 					$expout .= $this->writetext($answer->feedback,5,false);
! 					$expout .= $this->writefiles($answer->feedbackfiles);
! 					$expout .= "      </feedback>\n";
! 					$expout .= "    </answer>\n";
! 				}
! 				break;
! 			case SHORTANSWER:
! 				$expout .= "    <usecase>{$question->options->usecase}</usecase>\n ";
! 				foreach($question->options->answers as $answer) {
! 					$percent = 100 * $answer->fraction;
! 					$expout .= "    <answer fraction=\"$percent\">\n";
! 					$expout .= $this->writetext( $answer->answer,3,false );
! 					$feedbackformat = $this->get_format($answer->feedbackformat);
! 					$expout .= "      <feedback format=\"$feedbackformat\">\n";
! 					$expout .= $this->writetext($answer->feedback);
! 					$expout .= $this->writefiles($answer->feedbackfiles);
! 					$expout .= "      </feedback>\n";
! 					$expout .= "    </answer>\n";
! 				}
! 				break;
! 			case NUMERICAL:
! 				foreach ($question->options->answers as $answer) {
! 					$tolerance = $answer->tolerance;
! 					$percent = 100 * $answer->fraction;
! 					$expout .= "<answer fraction=\"$percent\">\n";
! 					// <text> tags are an added feature, old filed won't have them
! 					$expout .= "    <text>{$answer->answer}</text>\n";
! 					$expout .= "    <tolerance>$tolerance</tolerance>\n";
! 					$feedbackformat = $this->get_format($answer->feedbackformat);
! 					$expout .= "    <feedback format=\"$feedbackformat\">\n";
! 					$expout .= $this->writetext($answer->feedback);
! 					$expout .= $this->writefiles($answer->feedbackfiles);
! 					$expout .= "    </feedback>\n";
! 					// fraction tag is deprecated
! 					// $expout .= "    <fraction>{$answer->fraction}</fraction>\n";
! 					$expout .= "</answer>\n";
! 				}
! 
! 				$units = $question->options->units;
! 				if (count($units)) {
! 					$expout .= "<units>\n";
! 					foreach ($units as $unit) {
! 						$expout .= "  <unit>\n";
! 						$expout .= "    <multiplier>{$unit->multiplier}</multiplier>\n";
! 						$expout .= "    <unit_name>{$unit->unit}</unit_name>\n";
! 						$expout .= "  </unit>\n";
! 					}
! 					$expout .= "</units>\n";
! 				}
! 				if (isset($question->options->unitgradingtype)) {
! 					$expout .= "    <unitgradingtype>{$question->options->unitgradingtype}</unitgradingtype>\n";
! 				}
! 				if (isset($question->options->unitpenalty)) {
! 					$expout .= "    <unitpenalty>{$question->options->unitpenalty}</unitpenalty>\n";
! 				}
! 				if (isset($question->options->showunits)) {
! 					$expout .= "    <showunits>{$question->options->showunits}</showunits>\n";
! 				}
! 				if (isset($question->options->unitsleft)) {
! 					$expout .= "    <unitsleft>{$question->options->unitsleft}</unitsleft>\n";
! 				}
! 				if (!empty($question->options->instructionsformat)) {
! 					$textformat = $this->get_format($question->options->instructionsformat);
! 					$files = $fs->get_area_files($contextid, 'qtype_numerical', 'instruction', $question->id);
! 					$expout .= "    <instructions format=\"$textformat\">\n";
! 					$expout .= $this->writetext($question->options->instructions, 3);
! 					$expout .= $this->writefiles($files);
! 					$expout .= "    </instructions>\n";
! 				}
! 				break;
! 			case MATCH:
! 				foreach($question->options->subquestions as $subquestion) {
! 					$files = $fs->get_area_files($contextid, 'qtype_match', 'subquestion', $subquestion->id);
! 					$textformat = $this->get_format($subquestion->questiontextformat);
! 					$expout .= "<subquestion format=\"$textformat\">\n";
! 					$expout .= $this->writetext($subquestion->questiontext);
! 					$expout .= $this->writefiles($files);
! 					$expout .= "<answer>";
! 					$expout .= $this->writetext($subquestion->answertext);
! 					$expout .= "</answer>\n";
! 					$expout .= "</subquestion>\n";
! 				}
! 				break;
! 			case DESCRIPTION:
! 				// nothing more to do for this type
! 				break;
! 			case MULTIANSWER:
! 				$a_count=1;
! 				foreach($question->options->questions as $question) {
! 					$thispattern = preg_quote("{#".$a_count."}"); //TODO: is this really necessary?
! 					$thisreplace = $question->questiontext;
! 					$expout=preg_replace("~$thispattern~", $thisreplace, $expout );
! 					$a_count++;
! 				}
! 				break;
! 			case ESSAY:
! 				if (!empty($question->options->answers)) {
! 					foreach ($question->options->answers as $answer) {
! 						$percent = 100 * $answer->fraction;
! 						$expout .= "<answer fraction=\"$percent\">\n";
! 						$feedbackformat = $this->get_format($answer->feedbackformat);
! 						$expout .= "    <feedback format=\"$feedbackformat\">\n";
! 						$expout .= $this->writetext($answer->feedback);
! 						$expout .= $this->writefiles($answer->feedbackfiles);
! 						$expout .= "    </feedback>\n";
! 						// fraction tag is deprecated
! 						// $expout .= "    <fraction>{$answer->fraction}</fraction>\n";
! 						$expout .= "</answer>\n";
! 					}
! 				}
! 				break;
! 			case CALCULATED:
! 			case CALCULATEDSIMPLE:
! 			case CALCULATEDMULTI:
! 				$expout .= "    <synchronize>{$question->options->synchronize}</synchronize>\n";
! 				$expout .= "    <single>{$question->options->single}</single>\n";
! 				$expout .= "    <answernumbering>{$question->options->answernumbering}</answernumbering>\n";
! 				$expout .= "    <shuffleanswers>".$this->writetext($question->options->shuffleanswers, 3)."</shuffleanswers>\n";
! 
! 				$component = 'qtype_' . $question->qtype;
! 				$files = $fs->get_area_files($contextid, $component, 'correctfeedback', $question->id);
! 				$expout .= "    <correctfeedback>\n";
! 				$expout .= $this->writetext($question->options->correctfeedback, 3);
! 				$expout .= $this->writefiles($files);
! 				$expout .= "    </correctfeedback>\n";
! 
! 				$files = $fs->get_area_files($contextid, $component, 'partiallycorrectfeedback', $question->id);
! 				$expout .= "    <partiallycorrectfeedback>\n";
! 				$expout .= $this->writetext($question->options->partiallycorrectfeedback, 3);
! 				$expout .= $this->writefiles($files);
! 				$expout .= "    </partiallycorrectfeedback>\n";
! 
! 				$files = $fs->get_area_files($contextid, $component, 'incorrectfeedback', $question->id);
! 				$expout .= "    <incorrectfeedback>\n";
! 				$expout .= $this->writetext($question->options->incorrectfeedback, 3);
! 				$expout .= $this->writefiles($files);
! 				$expout .= "    </incorrectfeedback>\n";
! 
! 				foreach ($question->options->answers as $answer) {
! 					$tolerance = $answer->tolerance;
! 					$tolerancetype = $answer->tolerancetype;
! 					$correctanswerlength= $answer->correctanswerlength ;
! 					$correctanswerformat= $answer->correctanswerformat;
! 					$percent = 100 * $answer->fraction;
! 					$expout .= "<answer fraction=\"$percent\">\n";
! 					// "<text/>" tags are an added feature, old files won't have them
! 					$expout .= "    <text>{$answer->answer}</text>\n";
! 					$expout .= "    <tolerance>$tolerance</tolerance>\n";
! 					$expout .= "    <tolerancetype>$tolerancetype</tolerancetype>\n";
! 					$expout .= "    <correctanswerformat>$correctanswerformat</correctanswerformat>\n";
! 					$expout .= "    <correctanswerlength>$correctanswerlength</correctanswerlength>\n";
! 					$feedbackformat = $this->get_format($answer->feedbackformat);
! 					$expout .= "    <feedback format=\"$feedbackformat\">\n";
! 					$expout .= $this->writetext($answer->feedback);
! 					$expout .= $this->writefiles($answer->feedbackfiles);
! 					$expout .= "    </feedback>\n";
! 					$expout .= "</answer>\n";
! 				}
! 				if (isset($question->options->unitgradingtype)) {
! 					$expout .= "    <unitgradingtype>{$question->options->unitgradingtype}</unitgradingtype>\n";
! 				}
! 				if (isset($question->options->unitpenalty)) {
! 					$expout .= "    <unitpenalty>{$question->options->unitpenalty}</unitpenalty>\n";
! 				}
! 				if (isset($question->options->showunits)) {
! 					$expout .= "    <showunits>{$question->options->showunits}</showunits>\n";
! 				}
! 				if (isset($question->options->unitsleft)) {
! 					$expout .= "    <unitsleft>{$question->options->unitsleft}</unitsleft>\n";
! 				}
! 
! 				if (isset($question->options->instructionsformat)) {
! 					$textformat = $this->get_format($question->options->instructionsformat);
! 					$files = $fs->get_area_files($contextid, $component, 'instruction', $question->id);
! 					$expout .= "    <instructions format=\"$textformat\">\n";
! 					$expout .= $this->writetext($question->options->instructions, 3);
! 					$expout .= $this->writefiles($files);
! 					$expout .= "    </instructions>\n";
! 				}
! 
! 				if (isset($question->options->units)) {
! 					$units = $question->options->units;
! 					if (count($units)) {
! 						$expout .= "<units>\n";
! 						foreach ($units as $unit) {
! 							$expout .= "  <unit>\n";
! 							$expout .= "    <multiplier>{$unit->multiplier}</multiplier>\n";
! 							$expout .= "    <unit_name>{$unit->unit}</unit_name>\n";
! 							$expout .= "  </unit>\n";
! 						}
! 						$expout .= "</units>\n";
! 					}
! 				}
! 				//The tag $question->export_process has been set so we get all the data items in the database
! 				//   from the function $QTYPES['calculated']->get_question_options(&$question);
! 				//  calculatedsimple defaults to calculated
! 				if( isset($question->options->datasets)&&count($question->options->datasets)){// there should be
! 					$expout .= "<dataset_definitions>\n";
! 					foreach ($question->options->datasets as $def) {
! 						$expout .= "<dataset_definition>\n";
! 						$expout .= "    <status>".$this->writetext($def->status)."</status>\n";
! 						$expout .= "    <name>".$this->writetext($def->name)."</name>\n";
! 						if ( $question->qtype == CALCULATED){
! 							$expout .= "    <type>calculated</type>\n";
! 						}else {
! 							$expout .= "    <type>calculatedsimple</type>\n";
! 						}
! 						$expout .= "    <distribution>".$this->writetext($def->distribution)."</distribution>\n";
! 						$expout .= "    <minimum>".$this->writetext($def->minimum)."</minimum>\n";
! 						$expout .= "    <maximum>".$this->writetext($def->maximum)."</maximum>\n";
! 						$expout .= "    <decimals>".$this->writetext($def->decimals)."</decimals>\n";
! 						$expout .= "    <itemcount>$def->itemcount</itemcount>\n";
! 						if ($def->itemcount > 0 ) {
! 							$expout .= "    <dataset_items>\n";
! 							foreach ($def->items as $item ){
! 								$expout .= "        <dataset_item>\n";
! 								$expout .= "           <number>".$item->itemnumber."</number>\n";
! 								$expout .= "           <value>".$item->value."</value>\n";
! 								$expout .= "        </dataset_item>\n";
! 							}
! 							$expout .= "    </dataset_items>\n";
! 							$expout .= "    <number_of_items>".$def-> number_of_items."</number_of_items>\n";
! 						}
! 						$expout .= "</dataset_definition>\n";
! 					}
! 					$expout .= "</dataset_definitions>\n";
! 				}
! 				break;
! 			default:
! 				// try support by optional plugin
! 				if (!$data = $this->try_exporting_using_qtypes( $question->qtype, $question )) {
! 					echo $OUTPUT->notification( get_string( 'unsupportedexport','qformat_xml',$QTYPES[$question->qtype]->local_name() ) );
! 				}
! 				$expout .= $data;
! 		}
! 
! 		// Write the question tags.
! 		if (!empty($CFG->usetags)) {
! 			require_once($CFG->dirroot.'/tag/lib.php');
! 			$tags = tag_get_tags_array('question', $question->id);
! 			if (!empty($tags)) {
! 				$expout .= "    <tags>\n";
! 				foreach ($tags as $tag) {
! 					$expout .= "      <tag>" . $this->writetext($tag, 0, true) . "</tag>\n";
! 				}
! 				$expout .= "    </tags>\n";
! 			}
! 		}
  
! 		// close the question tag
! 		$expout .= "</question>\n";
  
! 		return $expout;
! 	}
  }
diff -crB questionorg/format.php questionupd/format.php
*** questionorg/format.php	2012-04-13 12:31:10.707178244 +0500
--- questionupd/format.php	2012-04-13 09:42:55.000000000 +0500
***************
*** 10,889 ****
   */
  class qformat_default {
  
!     public $displayerrors = true;
!     public $category = NULL;
!     public $questions = array();
!     public $course = NULL;
!     public $filename = '';
!     public $realfilename = '';
!     public $matchgrades = 'error';
!     public $catfromfile = 0;
!     public $contextfromfile = 0;
!     public $cattofile = 0;
!     public $contexttofile = 0;
!     public $questionids = array();
!     public $importerrors = 0;
!     public $stoponerror = true;
!     public $translator = null;
!     public $canaccessbackupdata = true;
! 
!     protected $importcontext = null;
! 
! // functions to indicate import/export functionality
! // override to return true if implemented
! 
!     /** @return boolean whether this plugin provides import functionality. */
!     function provide_import() {
!         return false;
!     }
! 
!     /** @return boolean whether this plugin provides export functionality. */
!     function provide_export() {
!         return false;
!     }
! 
!     /** The string mime-type of the files that this plugin reads or writes. */
!     function mime_type() {
!         return mimeinfo('type', $this->export_file_extension());
!     }
! 
!     /**
!      * @return string the file extension (including .) that is normally used for
!      * files handled by this plugin.
!      */
!     function export_file_extension() {
!         return '.txt';
!     }
! 
! // Accessor methods
! 
!     /**
!      * set the category
!      * @param object category the category object
!      */
!     function setCategory($category) {
!         if (count($this->questions)) {
!             debugging('You shouldn\'t call setCategory after setQuestions');
!         }
!         $this->category = $category;
!     }
! 
!     /**
!      * Set the specific questions to export. Should not include questions with
!      * parents (sub questions of cloze question type).
!      * Only used for question export.
!      * @param array of question objects
!      */
!     function setQuestions($questions) {
!         if ($this->category !== null) {
!             debugging('You shouldn\'t call setQuestions after setCategory');
!         }
!         $this->questions = $questions;
!     }
! 
!     /**
!      * set the course class variable
!      * @param course object Moodle course variable
!      */
!     function setCourse($course) {
!         $this->course = $course;
!     }
! 
!     /**
!      * set an array of contexts.
!      * @param array $contexts Moodle course variable
!      */
!     function setContexts($contexts) {
!         $this->contexts = $contexts;
!         $this->translator = new context_to_string_translator($this->contexts);
!     }
! 
!     /**
!      * set the filename
!      * @param string filename name of file to import/export
!      */
!     function setFilename($filename) {
!         $this->filename = $filename;
!     }
! 
!     /**
!      * set the "real" filename
!      * (this is what the user typed, regardless of wha happened next)
!      * @param string realfilename name of file as typed by user
!      */
!     function setRealfilename($realfilename) {
!         $this->realfilename = $realfilename;
!     }
! 
!     /**
!      * set matchgrades
!      * @param string matchgrades error or nearest for grades
!      */
!     function setMatchgrades($matchgrades) {
!         $this->matchgrades = $matchgrades;
!     }
! 
!     /**
!      * set catfromfile
!      * @param bool catfromfile allow categories embedded in import file
!      */
!     function setCatfromfile($catfromfile) {
!         $this->catfromfile = $catfromfile;
!     }
! 
!     /**
!      * set contextfromfile
!      * @param bool $contextfromfile allow contexts embedded in import file
!      */
!     function setContextfromfile($contextfromfile) {
!         $this->contextfromfile = $contextfromfile;
!     }
! 
!     /**
!      * set cattofile
!      * @param bool cattofile exports categories within export file
!      */
!     function setCattofile($cattofile) {
!         $this->cattofile = $cattofile;
!     }
! 
!     /**
!      * set contexttofile
!      * @param bool cattofile exports categories within export file
!      */
!     function setContexttofile($contexttofile) {
!         $this->contexttofile = $contexttofile;
!     }
! 
!     /**
!      * set stoponerror
!      * @param bool stoponerror stops database write if any errors reported
!      */
!     function setStoponerror($stoponerror) {
!         $this->stoponerror = $stoponerror;
!     }
! 
!     /**
!      * @param boolean $canaccess Whether the current use can access the backup data folder. Determines
!      * where export files are saved.
!      */
!     function set_can_access_backupdata($canaccess) {
!         $this->canaccessbackupdata = $canaccess;
!     }
! 
! /***********************
!  * IMPORTING FUNCTIONS
!  ***********************/
! 
!     /**
!      * Handle parsing error
!      */
!     function error($message, $text='', $questionname='') {
!         $importerrorquestion = get_string('importerrorquestion','quiz');
! 
!         echo "<div class=\"importerror\">\n";
!         echo "<strong>$importerrorquestion $questionname</strong>";
!         if (!empty($text)) {
!             $text = s($text);
!             echo "<blockquote>$text</blockquote>\n";
!         }
!         echo "<strong>$message</strong>\n";
!         echo "</div>";
! 
!          $this->importerrors++;
!     }
! 
!     /**
!      * Import for questiontype plugins
!      * Do not override.
!      * @param data mixed The segment of data containing the question
!      * @param question object processed (so far) by standard import code if appropriate
!      * @param extra mixed any additional format specific data that may be passed by the format
!      * @param qtypehint hint about a question type from format
!      * @return object question object suitable for save_options() or false if cannot handle
!      */
!     function try_importing_using_qtypes($data, $question=null, $extra=null, $qtypehint='') {
!         global $QTYPES;
! 
!         // work out what format we are using
!         $formatname = substr(get_class($this), strlen('qformat_'));
!         $methodname = "import_from_$formatname";
! 
!         //first try importing using a hint from format
!         if (!empty($qtypehint)) {
!             $qtype = $QTYPES[$qtypehint];
!             if (is_object($qtype) && method_exists($qtype, $methodname)) {
!                 $question = $qtype->$methodname($data, $question, $this, $extra);
!                 if ($question) {
!                     return $question;
!                 }
!             }
!         }
! 
!         // loop through installed questiontypes checking for
!         // function to handle this question
!         foreach ($QTYPES as $qtype) {
!             if (method_exists($qtype, $methodname)) {
!                 if ($question = $qtype->$methodname($data, $question, $this, $extra)) {
!                     return $question;
!                 }
!             }
!         }
!         return false;
!     }
! 
!     /**
!      * Perform any required pre-processing
!      * @return boolean success
!      */
!     function importpreprocess() {
!         return true;
!     }
! 
!     /**
!      * Process the file
!      * This method should not normally be overidden
!      * @param object $context
!      * @return boolean success
!      */
!     function importprocess($category) {
!         global $USER, $CFG, $DB, $OUTPUT, $QTYPES;
! 
!         $context = $category->context;
!         $this->importcontext = $context;
! 
!         // reset the timer in case file upload was slow
!         set_time_limit(0);
! 
!         // STAGE 1: Parse the file
!         echo $OUTPUT->notification(get_string('parsingquestions','quiz'));
! 
!         if (! $lines = $this->readdata($this->filename)) {
!             echo $OUTPUT->notification(get_string('cannotread','quiz'));
!             return false;
!         }
! 
!         if (!$questions = $this->readquestions($lines, $context)) {   // Extract all the questions
!             echo $OUTPUT->notification(get_string('noquestionsinfile','quiz'));
!             return false;
!         }
! 
!         // STAGE 2: Write data to database
!         echo $OUTPUT->notification(get_string('importingquestions','quiz',$this->count_questions($questions)));
! 
!         // check for errors before we continue
!         if ($this->stoponerror and ($this->importerrors>0)) {
!             echo $OUTPUT->notification(get_string('importparseerror','quiz'));
!             return true;
!         }
! 
!         // get list of valid answer grades
!         $grades = get_grade_options();
!         $gradeoptionsfull = $grades->gradeoptionsfull;
! 
!         // check answer grades are valid
!         // (now need to do this here because of 'stop on error': MDL-10689)
!         $gradeerrors = 0;
!         $goodquestions = array();
!         foreach ($questions as $question) {
! 
!             if (!empty($question->fraction) and (is_array($question->fraction))) {
!                 $fractions = $question->fraction;
!                 $answersvalid = true; // in case they are!
!                 foreach ($fractions as $key => $fraction) {
!                     $newfraction = match_grade_options($gradeoptionsfull, $fraction, $this->matchgrades);
!                     if ($newfraction===false) {
!                         $answersvalid = false;
!                     }
!                     else {
!                         $fractions[$key] = $newfraction;
!                     }
!                 }
!                 if (!$answersvalid) {
!                     echo $OUTPUT->notification(get_string('matcherror', 'quiz'));
!                     ++$gradeerrors;
!                     continue;
!                 }
!                 else {
!                     $question->fraction = $fractions;
!                 }
!             }
!             $goodquestions[] = $question;
!         }
!         $questions = $goodquestions;
! 
!         // check for errors before we continue
!         if ($this->stoponerror and ($gradeerrors>0)) {
!             return false;
!         }
! 
!         // count number of questions processed
!         $count = 0;
! 
!         foreach ($questions as $question) {   // Process and store each question
! 
!             // reset the php timeout
!             @set_time_limit(0);
! 
!             // check for category modifiers
!             if ($question->qtype == 'category') {
!                 if ($this->catfromfile) {
!                     // find/create category object
!                     $catpath = $question->category;
!                     $newcategory = $this->create_category_path($catpath);
!                     if (!empty($newcategory)) {
!                         $this->category = $newcategory;
!                     }
!                 }
!                 continue;
!             }
!             $question->context = $context;
! 
!             $count++;
! 
!             echo "<hr /><p><b>$count</b>. ".$this->format_question_text($question)."</p>";
! 
!             $question->category = $this->category->id;
!             $question->stamp = make_unique_id_code();  // Set the unique code (not to be changed)
! 
!             $question->createdby = $USER->id;
!             $question->timecreated = time();
! 
!             $question->id = $DB->insert_record('question', $question);
!             if (isset($question->questiontextfiles)) {
!                 foreach ($question->questiontextfiles as $file) {
!                     $QTYPES[$question->qtype]->import_file($context, 'question', 'questiontext', $question->id, $file);
!                 }
!             }
!             if (isset($question->generalfeedbackfiles)) {
!                 foreach ($question->generalfeedbackfiles as $file) {
!                     $QTYPES[$question->qtype]->import_file($context, 'question', 'generalfeedback', $question->id, $file);
!                 }
!             }
! 
!             $this->questionids[] = $question->id;
! 
!             // Now to save all the answers and type-specific options
! 
!             $result = $QTYPES[$question->qtype]->save_question_options($question);
! 
!             if (!empty($CFG->usetags) && isset($question->tags)) {
!                 require_once($CFG->dirroot . '/tag/lib.php');
!                 tag_set('question', $question->id, $question->tags);
!             }
! 
!             if (!empty($result->error)) {
!                 echo $OUTPUT->notification($result->error);
!                 return false;
!             }
! 
!             if (!empty($result->notice)) {
!                 echo $OUTPUT->notification($result->notice);
!                 return true;
!             }
! 
!             // Give the question a unique version stamp determined by question_hash()
!             $DB->set_field('question', 'version', question_hash($question), array('id'=>$question->id));
!         }
!         return true;
!     }
! 
!     /**
!      * Count all non-category questions in the questions array.
!      *
!      * @param array questions An array of question objects.
!      * @return int The count.
!      *
!      */
!     function count_questions($questions) {
!         $count = 0;
!         if (!is_array($questions)) {
!             return $count;
!         }
!         foreach ($questions as $question) {
!             if (!is_object($question) || !isset($question->qtype) || ($question->qtype == 'category')) {
!                 continue;
!             }
!             $count++;
!         }
!         return $count;
!     }
! 
!     /**
!      * find and/or create the category described by a delimited list
!      * e.g. $course$/tom/dick/harry or tom/dick/harry
!      *
!      * removes any context string no matter whether $getcontext is set
!      * but if $getcontext is set then ignore the context and use selected category context.
!      *
!      * @param string catpath delimited category path
!      * @param int courseid course to search for categories
!      * @return mixed category object or null if fails
!      */
!     function create_category_path($catpath) {
!         global $DB;
!         $catnames = $this->split_category_path($catpath);
!         $parent = 0;
!         $category = null;
! 
!         // check for context id in path, it might not be there in pre 1.9 exports
!         $matchcount = preg_match('/^\$([a-z]+)\$$/', $catnames[0], $matches);
!         if ($matchcount==1) {
!             $contextid = $this->translator->string_to_context($matches[1]);
!             array_shift($catnames);
!         } else {
!             $contextid = false;
!         }
! 
!         if ($this->contextfromfile && $contextid !== false) {
!             $context = get_context_instance_by_id($contextid);
!             require_capability('moodle/question:add', $context);
!         } else {
!             $context = get_context_instance_by_id($this->category->contextid);
!         }
! 
!         // Now create any categories that need to be created.
!         foreach ($catnames as $catname) {
!             if ($category = $DB->get_record('question_categories', array('name' => $catname, 'contextid' => $context->id, 'parent' => $parent))) {
!                 $parent = $category->id;
!             } else {
!                 require_capability('moodle/question:managecategory', $context);
!                 // create the new category
!                 $category = new stdClass();
!                 $category->contextid = $context->id;
!                 $category->name = $catname;
!                 $category->info = '';
!                 $category->parent = $parent;
!                 $category->sortorder = 999;
!                 $category->stamp = make_unique_id_code();
!                 $id = $DB->insert_record('question_categories', $category);
!                 $category->id = $id;
!                 $parent = $id;
!             }
!         }
!         return $category;
!     }
! 
!     /**
!      * Return complete file within an array, one item per line
!      * @param string filename name of file
!      * @return mixed contents array or false on failure
!      */
!     function readdata($filename) {
!         if (is_readable($filename)) {
!             $filearray = file($filename);
! 
!             /// Check for Macintosh OS line returns (ie file on one line), and fix
!             if (preg_match("~\r~", $filearray[0]) AND !preg_match("~\n~", $filearray[0])) {
!                 return explode("\r", $filearray[0]);
!             } else {
!                 return $filearray;
!             }
!         }
!         return false;
!     }
! 
!     /**
!      * Parses an array of lines into an array of questions,
!      * where each item is a question object as defined by
!      * readquestion().   Questions are defined as anything
!      * between blank lines.
!      *
!      * If your format does not use blank lines as a delimiter
!      * then you will need to override this method. Even then
!      * try to use readquestion for each question
!      * @param array lines array of lines from readdata
!      * @param object $context
!      * @return array array of question objects
!      */
!     function readquestions($lines, $context) {
! 
!         $questions = array();
!         $currentquestion = array();
! 
!         foreach ($lines as $line) {
!             $line = trim($line);
!             if (empty($line)) {
!                 if (!empty($currentquestion)) {
!                     if ($question = $this->readquestion($currentquestion)) {
!                         $questions[] = $question;
!                     }
!                     $currentquestion = array();
!                 }
!             } else {
!                 $currentquestion[] = $line;
!             }
!         }
! 
!         if (!empty($currentquestion)) {  // There may be a final question
!             if ($question = $this->readquestion($currentquestion, $context)) {
!                 $questions[] = $question;
!             }
!         }
! 
!         return $questions;
!     }
! 
!     /**
!      * return an "empty" question
!      * Somewhere to specify question parameters that are not handled
!      * by import but are required db fields.
!      * This should not be overridden.
!      * @return object default question
!      */
!     function defaultquestion() {
!         global $CFG;
!         static $defaultshuffleanswers = null;
!         if (is_null($defaultshuffleanswers)) {
!             $defaultshuffleanswers = get_config('quiz', 'shuffleanswers');
!         }
! 
!         $question = new stdClass();
!         $question->shuffleanswers = $defaultshuffleanswers;
!         $question->defaultgrade = 1;
!         $question->image = "";
!         $question->usecase = 0;
!         $question->multiplier = array();
!         $question->generalfeedback = '';
!         $question->correctfeedback = '';
!         $question->partiallycorrectfeedback = '';
!         $question->incorrectfeedback = '';
!         $question->answernumbering = 'abc';
!         $question->penalty = 0.1;
!         $question->length = 1;
! 
!         // this option in case the questiontypes class wants
!         // to know where the data came from
!         $question->export_process = true;
!         $question->import_process = true;
! 
!         return $question;
!     }
! 
!     /**
!      * Given the data known to define a question in
!      * this format, this function converts it into a question
!      * object suitable for processing and insertion into Moodle.
!      *
!      * If your format does not use blank lines to delimit questions
!      * (e.g. an XML format) you must override 'readquestions' too
!      * @param $lines mixed data that represents question
!      * @return object question object
!      */
!     function readquestion($lines) {
! 
!         $formatnotimplemented = get_string('formatnotimplemented','quiz');
!         echo "<p>$formatnotimplemented</p>";
! 
!         return NULL;
!     }
! 
!     /**
!      * Override if any post-processing is required
!      * @return boolean success
!      */
!     function importpostprocess() {
!         return true;
!     }
! 
! 
! /*******************
!  * EXPORT FUNCTIONS
!  *******************/
! 
!     /**
!      * Provide export functionality for plugin questiontypes
!      * Do not override
!      * @param name questiontype name
!      * @param question object data to export
!      * @param extra mixed any addition format specific data needed
!      * @return string the data to append to export or false if error (or unhandled)
!      */
!     function try_exporting_using_qtypes($name, $question, $extra=null) {
!         global $QTYPES;
! 
!         // work out the name of format in use
!         $formatname = substr(get_class($this), strlen('qformat_'));
!         $methodname = "export_to_$formatname";
! 
!         if (array_key_exists($name, $QTYPES)) {
!             $qtype = $QTYPES[ $name ];
!             if (method_exists($qtype, $methodname)) {
!                 if ($data = $qtype->$methodname($question, $this, $extra)) {
!                     return $data;
!                 }
!             }
!         }
!         return false;
!     }
! 
!     /**
!      * Do any pre-processing that may be required
!      * @param boolean success
!      */
!     function exportpreprocess() {
!         return true;
!     }
! 
!     /**
!      * Enable any processing to be done on the content
!      * just prior to the file being saved
!      * default is to do nothing
!      * @param string output text
!      * @param string processed output text
!      */
!     function presave_process($content) {
!         return $content;
!     }
! 
!     /**
!      * Do the export
!      * For most types this should not need to be overrided
!      * @return stored_file
!      */
!     function exportprocess() {
!         global $CFG, $OUTPUT, $DB, $USER;
! 
!         // get the questions (from database) in this category
!         // only get q's with no parents (no cloze subquestions specifically)
!         if ($this->category) {
!             $questions = get_questions_category($this->category, true);
!         } else {
!             $questions = $this->questions;
!         }
! 
!         //echo $OUTPUT->notification(get_string('exportingquestions','quiz'));
!         $count = 0;
! 
!         // results are first written into string (and then to a file)
!         // so create/initialize the string here
!         $expout = "";
! 
!         // track which category questions are in
!         // if it changes we will record the category change in the output
!         // file if selected. 0 means that it will get printed before the 1st question
!         $trackcategory = 0;
! 
!         $fs = get_file_storage();
! 
!         // iterate through questions
!         foreach($questions as $question) {
!             // used by file api
!             $contextid = $DB->get_field('question_categories', 'contextid', array('id'=>$question->category));
!             $question->contextid = $contextid;
! 
!             // do not export hidden questions
!             if (!empty($question->hidden)) {
!                 continue;
!             }
! 
!             // do not export random questions
!             if ($question->qtype==RANDOM) {
!                 continue;
!             }
! 
!             // check if we need to record category change
!             if ($this->cattofile) {
!                 if ($question->category != $trackcategory) {
!                     $trackcategory = $question->category;
!                     $categoryname = $this->get_category_path($trackcategory, $this->contexttofile);
! 
!                     // create 'dummy' question for category export
!                     $dummyquestion = new stdClass();
!                     $dummyquestion->qtype = 'category';
!                     $dummyquestion->category = $categoryname;
!                     $dummyquestion->name = 'Switch category to ' . $categoryname;
!                     $dummyquestion->id = 0;
!                     $dummyquestion->questiontextformat = '';
!                     $dummyquestion->contextid = 0;
!                     $expout .= $this->writequestion($dummyquestion) . "\n";
!                 }
!             }
! 
!             // export the question displaying message
!             $count++;
! 
!             if (question_has_capability_on($question, 'view', $question->category)) {
!                 // files used by questiontext
!                 $files = $fs->get_area_files($contextid, 'question', 'questiontext', $question->id);
!                 $question->questiontextfiles = $files;
!                 // files used by generalfeedback
!                 $files = $fs->get_area_files($contextid, 'question', 'generalfeedback', $question->id);
!                 $question->generalfeedbackfiles = $files;
!                 if (!empty($question->options->answers)) {
!                     foreach ($question->options->answers as $answer) {
!                         $files = $fs->get_area_files($contextid, 'question', 'answerfeedback', $answer->id);
!                         $answer->feedbackfiles = $files;
!                     }
!                 }
! 
!                 $expout .= $this->writequestion($question, $contextid) . "\n";
!             }
!         }
! 
!         // continue path for following error checks
!         $course = $this->course;
!         $continuepath = "$CFG->wwwroot/question/export.php?courseid=$course->id";
! 
!         // did we actually process anything
!         if ($count==0) {
!             print_error('noquestions','quiz',$continuepath);
!         }
! 
!         // final pre-process on exported data
!         $expout = $this->presave_process($expout);
!         return $expout;
!     }
! 
!     /**
!      * get the category as a path (e.g., tom/dick/harry)
!      * @param int id the id of the most nested catgory
!      * @return string the path
!      */
!     function get_category_path($id, $includecontext = true) {
!         global $DB;
! 
!         if (!$category = $DB->get_record('question_categories',array('id' =>$id))) {
!             print_error('cannotfindcategory', 'error', '', $id);
!         }
!         $contextstring = $this->translator->context_to_string($category->contextid);
! 
!         $pathsections = array();
!         do {
!             $pathsections[] = $category->name;
!             $id = $category->parent;
!         } while ($category = $DB->get_record('question_categories', array('id' => $id)));
! 
!         if ($includecontext) {
!             $pathsections[] = '$' . $contextstring . '$';
!         }
! 
!         $path = $this->assemble_category_path(array_reverse($pathsections));
! 
!         return $path;
!     }
! 
!     /**
!      * Convert a list of category names, possibly preceeded by one of the
!      * context tokens like $course$, into a string representation of the
!      * category path.
!      *
!      * Names are separated by / delimiters. And /s in the name are replaced by //.
!      *
!      * To reverse the process and split the paths into names, use
!      * {@link split_category_path()}.
!      *
!      * @param array $names
!      * @return string
!      */
!     protected function assemble_category_path($names) {
!         $escapednames = array();
!         foreach ($names as $name) {
!             $escapedname = str_replace('/', '//', $name);
!             if (substr($escapedname, 0, 1) == '/') {
!                 $escapedname = ' ' . $escapedname;
!             }
!             if (substr($escapedname, -1) == '/') {
!                 $escapedname = $escapedname . ' ';
!             }
!             $escapednames[] = $escapedname;
!         }
!         return implode('/', $escapednames);
!     }
! 
!     /**
!      * Convert a string, as returned by {@link assemble_category_path()},
!      * back into an array of category names.
!      *
!      * Each category name is cleaned by a call to clean_param(, PARAM_MULTILANG),
!      * which matches the cleaning in question/category_form.php.
!      *
!      * @param string $path
!      * @return array of category names.
!      */
!     protected function split_category_path($path) {
!         $rawnames = preg_split('~(?<!/)/(?!/)~', $path);
!         $names = array();
!         foreach ($rawnames as $rawname) {
!             $names[] = clean_param(trim(str_replace('//', '/', $rawname)), PARAM_MULTILANG);
!         }
!         return $names;
!     }
! 
!     /**
!      * Do an post-processing that may be required
!      * @return boolean success
!      */
!     function exportpostprocess() {
!         return true;
!     }
! 
!     /**
!      * convert a single question object into text output in the given
!      * format.
!      * This must be overriden
!      * @param object question question object
!      * @return mixed question export text or null if not implemented
!      */
!     function writequestion($question) {
!         // if not overidden, then this is an error.
!         $formatnotimplemented = get_string('formatnotimplemented','quiz');
!         echo "<p>$formatnotimplemented</p>";
!         return NULL;
!     }
! 
!     /**
!      * get directory into which export is going
!      * @return string file path
!      */
!     function question_get_export_dir() {
!         global $USER;
!         if ($this->canaccessbackupdata) {
!             $dirname = get_string("exportfilename","quiz");
!             $path = $this->course->id.'/backupdata/'.$dirname; // backupdata is protected directory
!         } else {
!             $path = 'temp/questionexport/' . $USER->id;
!         }
!         return $path;
!     }
! 
!     /**
!      * Convert the question text to plain text, so it can safely be displayed
!      * during import to let the user see roughly what is going on.
!      */
!     function format_question_text($question) {
!         global $DB;
!         $formatoptions = new stdClass;
!         $formatoptions->noclean = true;
!         $formatoptions->para = false;
!         if (empty($question->questiontextformat)) {
!             $format = FORMAT_MOODLE;
!         } else {
!             $format = $question->questiontextformat;
!         }
!         $text = $question->questiontext;
!         return format_text(html_to_text($text, 0, false), $format, $formatoptions);
!     }
! 
!     /**
!      * convert files into text output in the given format.
!      * @param array
!      * @param string encoding method
!      * @return string $string
!      */
!     function writefiles($files, $encoding='base64') {
!         if (empty($files)) {
!             return '';
!         }
!         $string = '';
!         foreach ($files as $file) {
!             if ($file->is_directory()) {
!                 continue;
!             }
!             $string .= '<file name="' . $file->get_filename() . '" encoding="' . $encoding . '">';
!             $string .= base64_encode($file->get_content());
!             $string .= '</file>';
!         }
!         return $string;
!     }
  }
--- 10,889 ----
   */
  class qformat_default {
  
! 	public $displayerrors = true;
! 	public $category = NULL;
! 	public $questions = array();
! 	public $course = NULL;
! 	public $filename = '';
! 	public $realfilename = '';
! 	public $matchgrades = 'error';
! 	public $catfromfile = 0;
! 	public $contextfromfile = 0;
! 	public $cattofile = 0;
! 	public $contexttofile = 0;
! 	public $questionids = array();
! 	public $importerrors = 0;
! 	public $stoponerror = true;
! 	public $translator = null;
! 	public $canaccessbackupdata = true;
! 
! 	protected $importcontext = null;
! 
! 	// functions to indicate import/export functionality
! 	// override to return true if implemented
! 
! 	/** @return boolean whether this plugin provides import functionality. */
! 	function provide_import() {
! 		return false;
! 	}
! 
! 	/** @return boolean whether this plugin provides export functionality. */
! 	function provide_export() {
! 		return false;
! 	}
! 
! 	/** The string mime-type of the files that this plugin reads or writes. */
! 	function mime_type() {
! 		return mimeinfo('type', $this->export_file_extension());
! 	}
! 
! 	/**
! 	 * @return string the file extension (including .) that is normally used for
! 	 * files handled by this plugin.
! 	 */
! 	function export_file_extension() {
! 		return '.txt';
! 	}
! 
! 	// Accessor methods
! 
! 	/**
! 	 * set the category
! 	 * @param object category the category object
! 	 */
! 	function setCategory($category) {
! 		if (count($this->questions)) {
! 			debugging('You shouldn\'t call setCategory after setQuestions');
! 		}
! 		$this->category = $category;
! 	}
! 
! 	/**
! 	 * Set the specific questions to export. Should not include questions with
! 	 * parents (sub questions of cloze question type).
! 	 * Only used for question export.
! 	 * @param array of question objects
! 	 */
! 	function setQuestions($questions) {
! 		if ($this->category !== null) {
! 			debugging('You shouldn\'t call setQuestions after setCategory');
! 		}
! 		$this->questions = $questions;
! 	}
! 
! 	/**
! 	 * set the course class variable
! 	 * @param course object Moodle course variable
! 	 */
! 	function setCourse($course) {
! 		$this->course = $course;
! 	}
! 
! 	/**
! 	 * set an array of contexts.
! 	 * @param array $contexts Moodle course variable
! 	 */
! 	function setContexts($contexts) {
! 		$this->contexts = $contexts;
! 		$this->translator = new context_to_string_translator($this->contexts);
! 	}
! 
! 	/**
! 	 * set the filename
! 	 * @param string filename name of file to import/export
! 	 */
! 	function setFilename($filename) {
! 		$this->filename = $filename;
! 	}
! 
! 	/**
! 	 * set the "real" filename
! 	 * (this is what the user typed, regardless of wha happened next)
! 	 * @param string realfilename name of file as typed by user
! 	 */
! 	function setRealfilename($realfilename) {
! 		$this->realfilename = $realfilename;
! 	}
! 
! 	/**
! 	 * set matchgrades
! 	 * @param string matchgrades error or nearest for grades
! 	 */
! 	function setMatchgrades($matchgrades) {
! 		$this->matchgrades = $matchgrades;
! 	}
! 
! 	/**
! 	 * set catfromfile
! 	 * @param bool catfromfile allow categories embedded in import file
! 	 */
! 	function setCatfromfile($catfromfile) {
! 		$this->catfromfile = $catfromfile;
! 	}
! 
! 	/**
! 	 * set contextfromfile
! 	 * @param bool $contextfromfile allow contexts embedded in import file
! 	 */
! 	function setContextfromfile($contextfromfile) {
! 		$this->contextfromfile = $contextfromfile;
! 	}
! 
! 	/**
! 	 * set cattofile
! 	 * @param bool cattofile exports categories within export file
! 	 */
! 	function setCattofile($cattofile) {
! 		$this->cattofile = $cattofile;
! 	}
! 
! 	/**
! 	 * set contexttofile
! 	 * @param bool cattofile exports categories within export file
! 	 */
! 	function setContexttofile($contexttofile) {
! 		$this->contexttofile = $contexttofile;
! 	}
! 
! 	/**
! 	 * set stoponerror
! 	 * @param bool stoponerror stops database write if any errors reported
! 	 */
! 	function setStoponerror($stoponerror) {
! 		$this->stoponerror = $stoponerror;
! 	}
! 
! 	/**
! 	 * @param boolean $canaccess Whether the current use can access the backup data folder. Determines
! 	 * where export files are saved.
! 	 */
! 	function set_can_access_backupdata($canaccess) {
! 		$this->canaccessbackupdata = $canaccess;
! 	}
! 
! 	/***********************
! 	 * IMPORTING FUNCTIONS
! 	 ***********************/
! 
! 	/**
! 	 * Handle parsing error
! 	 */
! 	function error($message, $text='', $questionname='') {
! 		$importerrorquestion = get_string('importerrorquestion','quiz');
! 
! 		echo "<div class=\"importerror\">\n";
! 		echo "<strong>$importerrorquestion $questionname</strong>";
! 		if (!empty($text)) {
! 			$text = s($text);
! 			echo "<blockquote>$text</blockquote>\n";
! 		}
! 		echo "<strong>$message</strong>\n";
! 		echo "</div>";
! 
! 		$this->importerrors++;
! 	}
! 
! 	/**
! 	 * Import for questiontype plugins
! 	 * Do not override.
! 	 * @param data mixed The segment of data containing the question
! 	 * @param question object processed (so far) by standard import code if appropriate
! 	 * @param extra mixed any additional format specific data that may be passed by the format
! 	 * @param qtypehint hint about a question type from format
! 	 * @return object question object suitable for save_options() or false if cannot handle
! 	 */
! 	function try_importing_using_qtypes($data, $question=null, $extra=null, $qtypehint='') {
! 		global $QTYPES;
! 
! 		// work out what format we are using
! 		$formatname = substr(get_class($this), strlen('qformat_'));
! 		$methodname = "import_from_$formatname";
! 
! 		//first try importing using a hint from format
! 		if (!empty($qtypehint)) {
! 			$qtype = $QTYPES[$qtypehint];
! 			if (is_object($qtype) && method_exists($qtype, $methodname)) {
! 				$question = $qtype->$methodname($data, $question, $this, $extra);
! 				if ($question) {
! 					return $question;
! 				}
! 			}
! 		}
! 
! 		// loop through installed questiontypes checking for
! 		// function to handle this question
! 		foreach ($QTYPES as $qtype) {
! 			if (method_exists($qtype, $methodname)) {
! 				if ($question = $qtype->$methodname($data, $question, $this, $extra)) {
! 					return $question;
! 				}
! 			}
! 		}
! 		return false;
! 	}
! 
! 	/**
! 	 * Perform any required pre-processing
! 	 * @return boolean success
! 	 */
! 	function importpreprocess() {
! 		return true;
! 	}
! 
! 	/**
! 	 * Process the file
! 	 * This method should not normally be overidden
! 	 * @param object $context
! 	 * @return boolean success
! 	 */
! 	function importprocess($category) {
! 		global $USER, $CFG, $DB, $OUTPUT, $QTYPES;
! 
! 		$context = $category->context;
! 		$this->importcontext = $context;
! 
! 		// reset the timer in case file upload was slow
! 		set_time_limit(0);
! 
! 		// STAGE 1: Parse the file
! 		echo $OUTPUT->notification(get_string('parsingquestions','quiz'));
! 
! 		if (! $lines = $this->readdata($this->filename)) {
! 			echo $OUTPUT->notification(get_string('cannotread','quiz'));
! 			return false;
! 		}
! 
! 		if (!$questions = $this->readquestions($lines, $context)) {   // Extract all the questions
! 			echo $OUTPUT->notification(get_string('noquestionsinfile','quiz'));
! 			return false;
! 		}
! 
! 		// STAGE 2: Write data to database
! 		echo $OUTPUT->notification(get_string('importingquestions','quiz',$this->count_questions($questions)));
! 
! 		// check for errors before we continue
! 		if ($this->stoponerror and ($this->importerrors>0)) {
! 			echo $OUTPUT->notification(get_string('importparseerror','quiz'));
! 			return true;
! 		}
! 
! 		// get list of valid answer grades
! 		$grades = get_grade_options();
! 		$gradeoptionsfull = $grades->gradeoptionsfull;
! 
! 		// check answer grades are valid
! 		// (now need to do this here because of 'stop on error': MDL-10689)
! 		$gradeerrors = 0;
! 		$goodquestions = array();
! 		foreach ($questions as $question) {
! 
! 			if (!empty($question->fraction) and (is_array($question->fraction))) {
! 				$fractions = $question->fraction;
! 				$answersvalid = true; // in case they are!
! 				foreach ($fractions as $key => $fraction) {
! 					$newfraction = match_grade_options($gradeoptionsfull, $fraction, $this->matchgrades);
! 					if ($newfraction===false) {
! 						$answersvalid = false;
! 					}
! 					else {
! 						$fractions[$key] = $newfraction;
! 					}
! 				}
! 				if (!$answersvalid) {
! 					echo $OUTPUT->notification(get_string('matcherror', 'quiz'));
! 					++$gradeerrors;
! 					continue;
! 				}
! 				else {
! 					$question->fraction = $fractions;
! 				}
! 			}
! 			$goodquestions[] = $question;
! 		}
! 		$questions = $goodquestions;
! 
! 		// check for errors before we continue
! 		if ($this->stoponerror and ($gradeerrors>0)) {
! 			return false;
! 		}
! 
! 		// count number of questions processed
! 		$count = 0;
! 
! 		foreach ($questions as $question) {   // Process and store each question
! 
! 			// reset the php timeout
! 			@set_time_limit(0);
! 
! 			// check for category modifiers
! 			if ($question->qtype == 'category') {
! 				if ($this->catfromfile) {
! 					// find/create category object
! 					$catpath = $question->category;
! 					$newcategory = $this->create_category_path($catpath);
! 					if (!empty($newcategory)) {
! 						$this->category = $newcategory;
! 					}
! 				}
! 				continue;
! 			}
! 			$question->context = $context;
! 
! 			$count++;
! 
! 			echo "<hr /><p><b>$count</b>. ".$this->format_question_text($question)."</p>";
! 
! 			$question->category = $this->category->id;
! 			$question->stamp = make_unique_id_code();  // Set the unique code (not to be changed)
! 
! 			$question->createdby = $USER->id;
! 			$question->timecreated = time();
! 
! 			$question->id = $DB->insert_record('question', $question);
! 			if (isset($question->questiontextfiles)) {
! 				foreach ($question->questiontextfiles as $file) {
! 					$QTYPES[$question->qtype]->import_file($context, 'question', 'questiontext', $question->id, $file);
! 				}
! 			}
! 			if (isset($question->generalfeedbackfiles)) {
! 				foreach ($question->generalfeedbackfiles as $file) {
! 					$QTYPES[$question->qtype]->import_file($context, 'question', 'generalfeedback', $question->id, $file);
! 				}
! 			}
! 
! 			$this->questionids[] = $question->id;
! 
! 			// Now to save all the answers and type-specific options
! 
! 			$result = $QTYPES[$question->qtype]->save_question_options($question);
! 
! 			if (!empty($CFG->usetags) && isset($question->tags)) {
! 				require_once($CFG->dirroot . '/tag/lib.php');
! 				tag_set('question', $question->id, $question->tags);
! 			}
! 
! 			if (!empty($result->error)) {
! 				echo $OUTPUT->notification($result->error);
! 				return false;
! 			}
! 
! 			if (!empty($result->notice)) {
! 				echo $OUTPUT->notification($result->notice);
! 				return true;
! 			}
! 
! 			// Give the question a unique version stamp determined by question_hash()
! 			$DB->set_field('question', 'version', question_hash($question), array('id'=>$question->id));
! 		}
! 		return true;
! 	}
! 
! 	/**
! 	 * Count all non-category questions in the questions array.
! 	 *
! 	 * @param array questions An array of question objects.
! 	 * @return int The count.
! 	 *
! 	 */
! 	function count_questions($questions) {
! 		$count = 0;
! 		if (!is_array($questions)) {
! 			return $count;
! 		}
! 		foreach ($questions as $question) {
! 			if (!is_object($question) || !isset($question->qtype) || ($question->qtype == 'category')) {
! 				continue;
! 			}
! 			$count++;
! 		}
! 		return $count;
! 	}
! 
! 	/**
! 	 * find and/or create the category described by a delimited list
! 	 * e.g. $course$/tom/dick/harry or tom/dick/harry
! 	 *
! 	 * removes any context string no matter whether $getcontext is set
! 	 * but if $getcontext is set then ignore the context and use selected category context.
! 	 *
! 	 * @param string catpath delimited category path
! 	 * @param int courseid course to search for categories
! 	 * @return mixed category object or null if fails
! 	 */
! 	function create_category_path($catpath) {
! 		global $DB;
! 		$catnames = $this->split_category_path($catpath);
! 		$parent = 0;
! 		$category = null;
! 
! 		// check for context id in path, it might not be there in pre 1.9 exports
! 		$matchcount = preg_match('/^\$([a-z]+)\$$/', $catnames[0], $matches);
! 		if ($matchcount==1) {
! 			$contextid = $this->translator->string_to_context($matches[1]);
! 			array_shift($catnames);
! 		} else {
! 			$contextid = false;
! 		}
! 
! 		if ($this->contextfromfile && $contextid !== false) {
! 			$context = get_context_instance_by_id($contextid);
! 			require_capability('moodle/question:add', $context);
! 		} else {
! 			$context = get_context_instance_by_id($this->category->contextid);
! 		}
! 
! 		// Now create any categories that need to be created.
! 		foreach ($catnames as $catname) {
! 			if ($category = $DB->get_record('question_categories', array('name' => $catname, 'contextid' => $context->id, 'parent' => $parent))) {
! 				$parent = $category->id;
! 			} else {
! 				require_capability('moodle/question:managecategory', $context);
! 				// create the new category
! 				$category = new stdClass();
! 				$category->contextid = $context->id;
! 				$category->name = $catname;
! 				$category->info = '';
! 				$category->parent = $parent;
! 				$category->sortorder = 999;
! 				$category->stamp = make_unique_id_code();
! 				$id = $DB->insert_record('question_categories', $category);
! 				$category->id = $id;
! 				$parent = $id;
! 			}
! 		}
! 		return $category;
! 	}
! 
! 	/**
! 	 * Return complete file within an array, one item per line
! 	 * @param string filename name of file
! 	 * @return mixed contents array or false on failure
! 	 */
! 	function readdata($filename) {
! 		if (is_readable($filename)) {
! 			$filearray = file($filename);
! 
! 			/// Check for Macintosh OS line returns (ie file on one line), and fix
! 			if (preg_match("~\r~", $filearray[0]) AND !preg_match("~\n~", $filearray[0])) {
! 				return explode("\r", $filearray[0]);
! 			} else {
! 				return $filearray;
! 			}
! 		}
! 		return false;
! 	}
! 
! 	/**
! 	 * Parses an array of lines into an array of questions,
! 	 * where each item is a question object as defined by
! 	 * readquestion().   Questions are defined as anything
! 	 * between blank lines.
! 	 *
! 	 * If your format does not use blank lines as a delimiter
! 	 * then you will need to override this method. Even then
! 	 * try to use readquestion for each question
! 	 * @param array lines array of lines from readdata
! 	 * @param object $context
! 	 * @return array array of question objects
! 	 */
! 	function readquestions($lines, $context) {
! 
! 		$questions = array();
! 		$currentquestion = array();
! 
! 		foreach ($lines as $line) {
! 			$line = trim($line);
! 			if (empty($line)) {
! 				if (!empty($currentquestion)) {
! 					if ($question = $this->readquestion($currentquestion)) {
! 						$questions[] = $question;
! 					}
! 					$currentquestion = array();
! 				}
! 			} else {
! 				$currentquestion[] = $line;
! 			}
! 		}
! 
! 		if (!empty($currentquestion)) {  // There may be a final question
! 			if ($question = $this->readquestion($currentquestion, $context)) {
! 				$questions[] = $question;
! 			}
! 		}
! 
! 		return $questions;
! 	}
! 
! 	/**
! 	 * return an "empty" question
! 	 * Somewhere to specify question parameters that are not handled
! 	 * by import but are required db fields.
! 	 * This should not be overridden.
! 	 * @return object default question
! 	 */
! 	function defaultquestion() {
! 		global $CFG;
! 		static $defaultshuffleanswers = null;
! 		if (is_null($defaultshuffleanswers)) {
! 			$defaultshuffleanswers = get_config('quiz', 'shuffleanswers');
! 		}
! 
! 		$question = new stdClass();
! 		$question->shuffleanswers = $defaultshuffleanswers;
! 		$question->defaultgrade = 1;
! 		$question->image = "";
! 		$question->usecase = 0;
! 		$question->multiplier = array();
! 		$question->generalfeedback = '';
! 		$question->correctfeedback = '';
! 		$question->partiallycorrectfeedback = '';
! 		$question->incorrectfeedback = '';
! 		$question->answernumbering = 'abc';
! 		$question->penalty = 0.1;
! 		$question->length = 1;
! 
! 		// this option in case the questiontypes class wants
! 		// to know where the data came from
! 		$question->export_process = true;
! 		$question->import_process = true;
! 
! 		return $question;
! 	}
! 
! 	/**
! 	 * Given the data known to define a question in
! 	 * this format, this function converts it into a question
! 	 * object suitable for processing and insertion into Moodle.
! 	 *
! 	 * If your format does not use blank lines to delimit questions
! 	 * (e.g. an XML format) you must override 'readquestions' too
! 	 * @param $lines mixed data that represents question
! 	 * @return object question object
! 	 */
! 	function readquestion($lines) {
! 
! 		$formatnotimplemented = get_string('formatnotimplemented','quiz');
! 		echo "<p>$formatnotimplemented</p>";
! 
! 		return NULL;
! 	}
! 
! 	/**
! 	 * Override if any post-processing is required
! 	 * @return boolean success
! 	 */
! 	function importpostprocess() {
! 		return true;
! 	}
! 
! 
! 	/*******************
! 	 * EXPORT FUNCTIONS
! 	 *******************/
! 
! 	/**
! 	 * Provide export functionality for plugin questiontypes
! 	 * Do not override
! 	 * @param name questiontype name
! 	 * @param question object data to export
! 	 * @param extra mixed any addition format specific data needed
! 	 * @return string the data to append to export or false if error (or unhandled)
! 	 */
! 	function try_exporting_using_qtypes($name, $question, $extra=null) {
! 		global $QTYPES;
! 
! 		// work out the name of format in use
! 		$formatname = substr(get_class($this), strlen('qformat_'));
! 		$methodname = "export_to_$formatname";
! 
! 		if (array_key_exists($name, $QTYPES)) {
! 			$qtype = $QTYPES[ $name ];
! 			if (method_exists($qtype, $methodname)) {
! 				if ($data = $qtype->$methodname($question, $this, $extra)) {
! 					return $data;
! 				}
! 			}
! 		}
! 		return false;
! 	}
! 
! 	/**
! 	 * Do any pre-processing that may be required
! 	 * @param boolean success
! 	 */
! 	function exportpreprocess() {
! 		return true;
! 	}
! 
! 	/**
! 	 * Enable any processing to be done on the content
! 	 * just prior to the file being saved
! 	 * default is to do nothing
! 	 * @param string output text
! 	 * @param string processed output text
! 	 */
! 	function presave_process($content) {
! 		return $content;
! 	}
! 
! 	/**
! 	 * Do the export
! 	 * For most types this should not need to be overrided
! 	 * @return stored_file
! 	 */
! 	function exportprocess() {
! 		global $CFG, $OUTPUT, $DB, $USER;
! 
! 		// get the questions (from database) in this category
! 		// only get q's with no parents (no cloze subquestions specifically)
! 		if ($this->category) {
! 			$questions = get_questions_category($this->category, true);
! 		} else {
! 			$questions = $this->questions;
! 		}
! 
! 		//echo $OUTPUT->notification(get_string('exportingquestions','quiz'));
! 		$count = 0;
! 
! 		// results are first written into string (and then to a file)
! 		// so create/initialize the string here
! 		$expout = "";
! 
! 		// track which category questions are in
! 		// if it changes we will record the category change in the output
! 		// file if selected. 0 means that it will get printed before the 1st question
! 		$trackcategory = 0;
! 
! 		$fs = get_file_storage();
! 
! 		// iterate through questions
! 		foreach($questions as $question) {
! 			// used by file api
! 			$contextid = $DB->get_field('question_categories', 'contextid', array('id'=>$question->category));
! 			$question->contextid = $contextid;
! 
! 			// do not export hidden questions
! 			if (!empty($question->hidden)) {
! 				continue;
! 			}
! 
! 			// do not export random questions
! 			if ($question->qtype==RANDOM) {
! 				continue;
! 			}
! 
! 			// check if we need to record category change
! 			if ($this->cattofile) {
! 				if ($question->category != $trackcategory) {
! 					$trackcategory = $question->category;
! 					$categoryname = $this->get_category_path($trackcategory, $this->contexttofile);
! 
! 					// create 'dummy' question for category export
! 					$dummyquestion = new stdClass();
! 					$dummyquestion->qtype = 'category';
! 					$dummyquestion->category = $categoryname;
! 					$dummyquestion->name = 'Switch category to ' . $categoryname;
! 					$dummyquestion->id = 0;
! 					$dummyquestion->questiontextformat = '';
! 					$dummyquestion->contextid = 0;
! 					$expout .= $this->writequestion($dummyquestion) . "\n";
! 				}
! 			}
! 
! 			// export the question displaying message
! 			$count++;
! 
! 			if (question_has_capability_on($question, 'view', $question->category)) {
! 				// files used by questiontext
! 				$files = $fs->get_area_files($contextid, 'question', 'questiontext', $question->id);
! 				$question->questiontextfiles = $files;
! 				// files used by generalfeedback
! 				$files = $fs->get_area_files($contextid, 'question', 'generalfeedback', $question->id);
! 				$question->generalfeedbackfiles = $files;
! 				if (!empty($question->options->answers)) {
! 					foreach ($question->options->answers as $answer) {
! 						$files = $fs->get_area_files($contextid, 'question', 'answerfeedback', $answer->id);
! 						$answer->feedbackfiles = $files;
! 					}
! 				}
! 
! 				$expout .= $this->writequestion($question, $contextid) . "\n";
! 			}
! 		}
! 
! 		// continue path for following error checks
! 		$course = $this->course;
! 		$continuepath = "$CFG->wwwroot/question/export.php?courseid=$course->id";
! 
! 		// did we actually process anything
! 		if ($count==0) {
! 			print_error('noquestions','quiz',$continuepath);
! 		}
! 
! 		// final pre-process on exported data
! 		$expout = $this->presave_process($expout);
! 		return $expout;
! 	}
! 
! 	/**
! 	 * get the category as a path (e.g., tom/dick/harry)
! 	 * @param int id the id of the most nested catgory
! 	 * @return string the path
! 	 */
! 	function get_category_path($id, $includecontext = true) {
! 		global $DB;
! 
! 		if (!$category = $DB->get_record('question_categories',array('id' =>$id))) {
! 			print_error('cannotfindcategory', 'error', '', $id);
! 		}
! 		$contextstring = $this->translator->context_to_string($category->contextid);
! 
! 		$pathsections = array();
! 		do {
! 			$pathsections[] = $category->name;
! 			$id = $category->parent;
! 		} while ($category = $DB->get_record('question_categories', array('id' => $id)));
! 
! 		if ($includecontext) {
! 			$pathsections[] = '$' . $contextstring . '$';
! 		}
! 
! 		$path = $this->assemble_category_path(array_reverse($pathsections));
! 
! 		return $path;
! 	}
! 
! 	/**
! 	 * Convert a list of category names, possibly preceeded by one of the
! 	 * context tokens like $course$, into a string representation of the
! 	 * category path.
! 	 *
! 	 * Names are separated by / delimiters. And /s in the name are replaced by //.
! 	 *
! 	 * To reverse the process and split the paths into names, use
! 	 * {@link split_category_path()}.
! 	 *
! 	 * @param array $names
! 	 * @return string
! 	 */
! 	protected function assemble_category_path($names) {
! 		$escapednames = array();
! 		foreach ($names as $name) {
! 			$escapedname = str_replace('/', '//', $name);
! 			if (substr($escapedname, 0, 1) == '/') {
! 				$escapedname = ' ' . $escapedname;
! 			}
! 			if (substr($escapedname, -1) == '/') {
! 				$escapedname = $escapedname . ' ';
! 			}
! 			$escapednames[] = $escapedname;
! 		}
! 		return implode('/', $escapednames);
! 	}
! 
! 	/**
! 	 * Convert a string, as returned by {@link assemble_category_path()},
! 	 * back into an array of category names.
! 	 *
! 	 * Each category name is cleaned by a call to clean_param(, PARAM_MULTILANG),
! 	 * which matches the cleaning in question/category_form.php.
! 	 *
! 	 * @param string $path
! 	 * @return array of category names.
! 	 */
! 	protected function split_category_path($path) {
! 		$rawnames = preg_split('~(?<!/)/(?!/)~', $path);
! 		$names = array();
! 		foreach ($rawnames as $rawname) {
! 			$names[] = clean_param(trim(str_replace('//', '/', $rawname)), PARAM_MULTILANG);
! 		}
! 		return $names;
! 	}
! 
! 	/**
! 	 * Do an post-processing that may be required
! 	 * @return boolean success
! 	 */
! 	function exportpostprocess() {
! 		return true;
! 	}
! 
! 	/**
! 	 * convert a single question object into text output in the given
! 	 * format.
! 	 * This must be overriden
! 	 * @param object question question object
! 	 * @return mixed question export text or null if not implemented
! 	 */
! 	function writequestion($question) {
! 		// if not overidden, then this is an error.
! 		$formatnotimplemented = get_string('formatnotimplemented','quiz');
! 		echo "<p>$formatnotimplemented</p>";
! 		return NULL;
! 	}
! 
! 	/**
! 	 * get directory into which export is going
! 	 * @return string file path
! 	 */
! 	function question_get_export_dir() {
! 		global $USER;
! 		if ($this->canaccessbackupdata) {
! 			$dirname = get_string("exportfilename","quiz");
! 			$path = $this->course->id.'/backupdata/'.$dirname; // backupdata is protected directory
! 		} else {
! 			$path = 'temp/questionexport/' . $USER->id;
! 		}
! 		return $path;
! 	}
! 
! 	/**
! 	 * Convert the question text to plain text, so it can safely be displayed
! 	 * during import to let the user see roughly what is going on.
! 	 */
! 	function format_question_text($question) {
! 		global $DB;
! 		$formatoptions = new stdClass;
! 		$formatoptions->noclean = true;
! 		$formatoptions->para = false;
! 		if (empty($question->questiontextformat)) {
! 			$format = FORMAT_MOODLE;
! 		} else {
! 			$format = $question->questiontextformat;
! 		}
! 		$text = $question->questiontext;
! 		return format_text(html_to_text($text, 0, false), $format, $formatoptions);
! 	}
! 
! 	/**
! 	 * convert files into text output in the given format.
! 	 * @param array
! 	 * @param string encoding method
! 	 * @return string $string
! 	 */
! 	function writefiles($files, $encoding='base64') {
! 		if (empty($files)) {
! 			return '';
! 		}
! 		$string = '';
! 		foreach ($files as $file) {
! 			if ($file->is_directory()) {
! 				continue;
! 			}
! 			$string .= '<file name="' . $file->get_filename() . '" encoding="' . $encoding . '">';
! 			$string .= base64_encode($file->get_content());
! 			$string .= '</file>';
! 		}
! 		return $string;
! 	}
  }
diff -crB questionorg/import_form.php questionupd/import_form.php
*** questionorg/import_form.php	2012-04-13 12:31:10.703178242 +0500
--- questionupd/import_form.php	2012-04-13 09:42:55.000000000 +0500
***************
*** 1,82 ****
  <?php
  
  if (!defined('MOODLE_INTERNAL')) {
!     die('Direct access to this script is forbidden.');    ///  It must be included from a Moodle page
  }
  
  require_once($CFG->libdir.'/formslib.php');
  
  class question_import_form extends moodleform {
  
!     function definition() {
!         global $COURSE;
!         $mform    =& $this->_form;
! 
!         $defaultcategory   = $this->_customdata['defaultcategory'];
!         $contexts   = $this->_customdata['contexts'];
! 
! //--------------------------------------------------------------------------------
!         $mform->addElement('header','fileformat', get_string('fileformat','quiz'));
!         $fileformatnames = get_import_export_formats('import');
!         $i = 0 ;
!         foreach ($fileformatnames as $shortname => $fileformatname) {
!             $currentgrp1 = array();
!             $currentgrp1[] = &$mform->createElement('radio','format','',$fileformatname,$shortname);
!             $mform->addGroup($currentgrp1,"formathelp[$i]",'',array('<br />'),false);
!             $mform->addHelpButton("formathelp[$i]", $shortname, 'qformat_'.$shortname);
!             $i++ ;
!         }
!         $mform->addRule("formathelp[0]", null, 'required', null, 'client' );
! //--------------------------------------------------------------------------------
!         $mform->addElement('header','general', get_string('general', 'form'));
! 
!         $mform->addElement('questioncategory', 'category', get_string('importcategory', 'question'), compact('contexts'));
!         $mform->setDefault('category', $defaultcategory);
!         $mform->addHelpButton('category', 'importcategory', 'question');
! 
!         $categorygroup = array();
!         $categorygroup[] =& $mform->createElement('checkbox', 'catfromfile', '', get_string('getcategoryfromfile', 'question'));
!         $categorygroup[] =& $mform->createElement('checkbox', 'contextfromfile', '', get_string('getcontextfromfile', 'question'));
!         $mform->addGroup($categorygroup, 'categorygroup', '', '', false);
!         $mform->disabledIf('categorygroup', 'catfromfile', 'notchecked');
!         $mform->setDefault('catfromfile', 1);
!         $mform->setDefault('contextfromfile', 1);
! 
! 
!         $matchgrades = array();
!         $matchgrades['error'] = get_string('matchgradeserror','quiz');
!         $matchgrades['nearest'] = get_string('matchgradesnearest','quiz');
!         $mform->addElement('select', 'matchgrades', get_string('matchgrades', 'question'), $matchgrades);
!         $mform->addHelpButton('matchgrades', 'matchgrades', 'question');
!         $mform->setDefault('matchgrades', 'error');
! 
!         $mform->addElement('selectyesno', 'stoponerror', get_string('stoponerror', 'question'));
!         $mform->setDefault('stoponerror', 1);
!         $mform->addHelpButton('stoponerror', 'stoponerror', 'question');
! 
! //--------------------------------------------------------------------------------
!         $mform->addElement('header', 'importfileupload', get_string('importfromthisfile','quiz'));
! 
!         $mform->addElement('filepicker', 'newfile', get_string('import', 'quiz'));
! //--------------------------------------------------------------------------------
!         $mform->addElement('submit', 'submitbutton', get_string('import', 'quiz'));
! 
! //--------------------------------------------------------------------------------
!         //if (has_capability('moodle/course:managefiles', get_context_instance(CONTEXT_COURSE, $COURSE->id))){
!             //$mform->addElement('header', 'importfilearea', get_string('importfilearea','quiz'));
!             //TODO: MDL-16094
!             //$mform->addElement('choosecoursefile', 'choosefile', get_string('choosefile','quiz'));
! //--------------------------------------------------------------------------------
!             //$mform->addElement('submit', 'submitbutton', get_string('importfromthisfile','quiz'));
!         //}
! //--------------------------------------------------------------------------------
!         $mform->addElement('static', 'dummy', '');
!         $mform->closeHeaderBefore('dummy');
! 
!         // set a template for the format select elements
!         $renderer =& $mform->defaultRenderer();
!         $template = "{help} {element}\n";
!         $renderer->setGroupElementTemplate($template, 'format');
!     }
  }
  
--- 1,82 ----
  <?php
  
  if (!defined('MOODLE_INTERNAL')) {
! 	die('Direct access to this script is forbidden.');    ///  It must be included from a Moodle page
  }
  
  require_once($CFG->libdir.'/formslib.php');
  
  class question_import_form extends moodleform {
  
! 	function definition() {
! 		global $COURSE;
! 		$mform    =& $this->_form;
! 
! 		$defaultcategory   = $this->_customdata['defaultcategory'];
! 		$contexts   = $this->_customdata['contexts'];
! 
! 		//--------------------------------------------------------------------------------
! 		$mform->addElement('header','fileformat', get_string('fileformat','quiz'));
! 		$fileformatnames = get_import_export_formats('import');
! 		$i = 0 ;
! 		foreach ($fileformatnames as $shortname => $fileformatname) {
! 			$currentgrp1 = array();
! 			$currentgrp1[] = &$mform->createElement('radio','format','',$fileformatname,$shortname);
! 			$mform->addGroup($currentgrp1,"formathelp[$i]",'',array('<br />'),false);
! 			$mform->addHelpButton("formathelp[$i]", $shortname, 'qformat_'.$shortname);
! 			$i++ ;
! 		}
! 		$mform->addRule("formathelp[0]", null, 'required', null, 'client' );
! 		//--------------------------------------------------------------------------------
! 		$mform->addElement('header','general', get_string('general', 'form'));
! 
! 		$mform->addElement('questioncategory', 'category', get_string('importcategory', 'question'), compact('contexts'));
! 		$mform->setDefault('category', $defaultcategory);
! 		$mform->addHelpButton('category', 'importcategory', 'question');
! 
! 		$categorygroup = array();
! 		$categorygroup[] =& $mform->createElement('checkbox', 'catfromfile', '', get_string('getcategoryfromfile', 'question'));
! 		$categorygroup[] =& $mform->createElement('checkbox', 'contextfromfile', '', get_string('getcontextfromfile', 'question'));
! 		$mform->addGroup($categorygroup, 'categorygroup', '', '', false);
! 		$mform->disabledIf('categorygroup', 'catfromfile', 'notchecked');
! 		$mform->setDefault('catfromfile', 1);
! 		$mform->setDefault('contextfromfile', 1);
! 
! 
! 		$matchgrades = array();
! 		$matchgrades['error'] = get_string('matchgradeserror','quiz');
! 		$matchgrades['nearest'] = get_string('matchgradesnearest','quiz');
! 		$mform->addElement('select', 'matchgrades', get_string('matchgrades', 'question'), $matchgrades);
! 		$mform->addHelpButton('matchgrades', 'matchgrades', 'question');
! 		$mform->setDefault('matchgrades', 'error');
! 
! 		$mform->addElement('selectyesno', 'stoponerror', get_string('stoponerror', 'question'));
! 		$mform->setDefault('stoponerror', 1);
! 		$mform->addHelpButton('stoponerror', 'stoponerror', 'question');
! 
! 		//--------------------------------------------------------------------------------
! 		$mform->addElement('header', 'importfileupload', get_string('importfromthisfile','quiz'));
! 
! 		$mform->addElement('filepicker', 'newfile', get_string('import', 'quiz'));
! 		//--------------------------------------------------------------------------------
! 		$mform->addElement('submit', 'submitbutton', get_string('import', 'quiz'));
! 
! 		//--------------------------------------------------------------------------------
! 		//if (has_capability('moodle/course:managefiles', get_context_instance(CONTEXT_COURSE, $COURSE->id))){
! 		//$mform->addElement('header', 'importfilearea', get_string('importfilearea','quiz'));
! 			//TODO: MDL-16094
! 			//$mform->addElement('choosecoursefile', 'choosefile', get_string('choosefile','quiz'));
! 			//--------------------------------------------------------------------------------
! 			//$mform->addElement('submit', 'submitbutton', get_string('importfromthisfile','quiz'));
! 			//}
! 			//--------------------------------------------------------------------------------
! 			$mform->addElement('static', 'dummy', '');
! 			$mform->closeHeaderBefore('dummy');
! 
! 			// set a template for the format select elements
! 			$renderer =& $mform->defaultRenderer();
! 			$template = "{help} {element}\n";
! 			$renderer->setGroupElementTemplate($template, 'format');
! 	}
  }
  
diff -crB questionorg/import.php questionupd/import.php
*** questionorg/import.php	2012-04-13 12:31:14.530178304 +0500
--- questionupd/import.php	2012-04-13 09:42:55.000000000 +0500
***************
*** 14,20 ****
  require_once("import_form.php");
  
  list($thispageurl, $contexts, $cmid, $cm, $module, $pagevars) =
!         question_edit_setup('import', '/question/import.php', false, false);
  
  // get display strings
  $txt = new stdClass();
--- 14,20 ----
  require_once("import_form.php");
  
  list($thispageurl, $contexts, $cmid, $cm, $module, $pagevars) =
! question_edit_setup('import', '/question/import.php', false, false);
  
  // get display strings
  $txt = new stdClass();
***************
*** 23,29 ****
  
  list($catid, $catcontext) = explode(',', $pagevars['cat']);
  if (!$category = $DB->get_record("question_categories", array("id" => $catid))) {
!     print_error('nocategory','quiz');
  }
  
  $PAGE->set_pagelayout('standard');
--- 23,29 ----
  
  list($catid, $catcontext) = explode(',', $pagevars['cat']);
  if (!$category = $DB->get_record("question_categories", array("id" => $catid))) {
! 	print_error('nocategory','quiz');
  }
  
  $PAGE->set_pagelayout('standard');
***************
*** 33,47 ****
  //this page can be called without courseid or cmid in which case
  //we get the context from the category object.
  if ($contexts === null) { // need to get the course from the chosen category
!     $contexts = new question_edit_contexts($categorycontext);
!     $thiscontext = $contexts->lowest();
!     if ($thiscontext->contextlevel == CONTEXT_COURSE){
!         require_login($thiscontext->instanceid, false);
!     } elseif ($thiscontext->contextlevel == CONTEXT_MODULE){
!         list($module, $cm) = get_module_from_cmid($thiscontext->instanceid);
!         require_login($cm->course, false, $cm);
!     }
!     $contexts->require_one_edit_tab_cap($edittab);
  }
  
  $PAGE->set_url($thispageurl->out());
--- 33,47 ----
  //this page can be called without courseid or cmid in which case
  //we get the context from the category object.
  if ($contexts === null) { // need to get the course from the chosen category
! 	$contexts = new question_edit_contexts($categorycontext);
! 	$thiscontext = $contexts->lowest();
! 	if ($thiscontext->contextlevel == CONTEXT_COURSE){
! 		require_login($thiscontext->instanceid, false);
! 	} elseif ($thiscontext->contextlevel == CONTEXT_MODULE){
! 		list($module, $cm) = get_module_from_cmid($thiscontext->instanceid);
! 		require_login($cm->course, false, $cm);
! 	}
! 	$contexts->require_one_edit_tab_cap($edittab);
  }
  
  $PAGE->set_url($thispageurl->out());
***************
*** 50,56 ****
                                                      'defaultcategory'=>$pagevars['cat']));
  
  if ($import_form->is_cancelled()){
!     redirect($thispageurl);
  }
  //==========
  // PAGE HEADER
--- 50,56 ----
                                                      'defaultcategory'=>$pagevars['cat']));
  
  if ($import_form->is_cancelled()){
! 	redirect($thispageurl);
  }
  //==========
  // PAGE HEADER
***************
*** 62,130 ****
  // file upload form sumitted
  if ($form = $import_form->get_data()) {
  
!     // file checks out ok
!     $fileisgood = false;
  
!     // work out if this is an uploaded file
!     // or one from the filesarea.
!     $realfilename = $import_form->get_new_filename('newfile');
! 
!     $importfile = "{$CFG->dataroot}/temp/questionimport/{$realfilename}";
!     make_upload_directory('temp/questionimport');
!     if (!$result = $import_form->save_file('newfile', $importfile, true)) {
!         print_error('uploadproblem', 'moodle');
!     }else {
!         $fileisgood = true;
!     }
! 
!     // process if we are happy file is ok
!     if ($fileisgood) {
! 
!         if (! is_readable("format/$form->format/format.php")) {
!             print_error('formatnotfound','quiz', $form->format);
!         }
! 
!         require_once("format.php");  // Parent class
!         require_once("format/$form->format/format.php");
! 
!         $classname = "qformat_$form->format";
!         $qformat = new $classname();
! 
!         // load data into class
!         $qformat->setCategory($category);
!         $qformat->setContexts($contexts->having_one_edit_tab_cap('import'));
!         $qformat->setCourse($COURSE);
!         $qformat->setFilename($importfile);
!         $qformat->setRealfilename($realfilename);
!         $qformat->setMatchgrades($form->matchgrades);
!         $qformat->setCatfromfile(!empty($form->catfromfile));
!         $qformat->setContextfromfile(!empty($form->contextfromfile));
!         $qformat->setStoponerror($form->stoponerror);
! 
!         // Do anything before that we need to
!         if (! $qformat->importpreprocess()) {
!             //TODO: need more detailed error info
!             print_error('cannotimport', '', $thispageurl->out());
!         }
! 
!         // Process the uploaded file
!         if (! $qformat->importprocess($category)) {
!             //TODO: need more detailed error info
!             print_error('cannotimport', '', $thispageurl->out());
!         }
! 
!         // In case anything needs to be done after
!         if (! $qformat->importpostprocess()) {
!             //TODO: need more detailed error info
!             print_error('cannotimport', '', $thispageurl->out());
!         }
! 
!         echo '<hr />';
!         $params = $thispageurl->params() + array('category'=>"{$qformat->category->id},{$qformat->category->contextid}");
!         echo $OUTPUT->continue_button(new moodle_url('edit.php', $params));
!         echo $OUTPUT->footer();
!         exit;
!     }
  }
  
  echo $OUTPUT->heading_with_help($txt->importquestions, 'importquestions', 'question');
--- 62,130 ----
  // file upload form sumitted
  if ($form = $import_form->get_data()) {
  
! 	// file checks out ok
! 	$fileisgood = false;
  
! 	// work out if this is an uploaded file
! 	// or one from the filesarea.
! 	$realfilename = $import_form->get_new_filename('newfile');
! 
! 	$importfile = "{$CFG->dataroot}/temp/questionimport/{$realfilename}";
! 	make_upload_directory('temp/questionimport');
! 	if (!$result = $import_form->save_file('newfile', $importfile, true)) {
! 		print_error('uploadproblem', 'moodle');
! 	}else {
! 		$fileisgood = true;
! 	}
! 
! 	// process if we are happy file is ok
! 	if ($fileisgood) {
! 
! 		if (! is_readable("format/$form->format/format.php")) {
! 			print_error('formatnotfound','quiz', $form->format);
! 		}
! 
! 		require_once("format.php");  // Parent class
! 		require_once("format/$form->format/format.php");
! 
! 		$classname = "qformat_$form->format";
! 		$qformat = new $classname();
! 
! 		// load data into class
! 		$qformat->setCategory($category);
! 		$qformat->setContexts($contexts->having_one_edit_tab_cap('import'));
! 		$qformat->setCourse($COURSE);
! 		$qformat->setFilename($importfile);
! 		$qformat->setRealfilename($realfilename);
! 		$qformat->setMatchgrades($form->matchgrades);
! 		$qformat->setCatfromfile(!empty($form->catfromfile));
! 		$qformat->setContextfromfile(!empty($form->contextfromfile));
! 		$qformat->setStoponerror($form->stoponerror);
! 
! 		// Do anything before that we need to
! 		if (! $qformat->importpreprocess()) {
! 			//TODO: need more detailed error info
! 			print_error('cannotimport', '', $thispageurl->out());
! 		}
! 
! 		// Process the uploaded file
! 		if (! $qformat->importprocess($category)) {
! 			//TODO: need more detailed error info
! 			print_error('cannotimport', '', $thispageurl->out());
! 		}
! 
! 		// In case anything needs to be done after
! 		if (! $qformat->importpostprocess()) {
! 			//TODO: need more detailed error info
! 			print_error('cannotimport', '', $thispageurl->out());
! 		}
! 
! 		echo '<hr />';
! 		$params = $thispageurl->params() + array('category'=>"{$qformat->category->id},{$qformat->category->contextid}");
! 		echo $OUTPUT->continue_button(new moodle_url('edit.php', $params));
! 		echo $OUTPUT->footer();
! 		exit;
! 	}
  }
  
  echo $OUTPUT->heading_with_help($txt->importquestions, 'importquestions', 'question');
diff -crB questionorg/move_form.php questionupd/move_form.php
*** questionorg/move_form.php	2012-04-13 12:31:14.597178306 +0500
--- questionupd/move_form.php	2012-04-13 09:42:55.000000000 +0500
***************
*** 1,28 ****
  <?php
  
  if (!defined('MOODLE_INTERNAL')) {
!     die('Direct access to this script is forbidden.');    ///  It must be included from a Moodle page
  }
  
  require_once($CFG->libdir.'/formslib.php');
  
  class question_move_form extends moodleform {
  
!     function definition() {
!         $mform    =& $this->_form;
  
!         $currentcat   = $this->_customdata['currentcat'];
!         $contexts   = $this->_customdata['contexts'];
! //--------------------------------------------------------------------------------
! 
!         $mform->addElement('questioncategory', 'category', get_string('category','quiz'), compact('contexts', 'currentcat'));
! 
! 
! //--------------------------------------------------------------------------------
!         $this->add_action_buttons(true, get_string('categorymoveto', 'quiz'));
! //--------------------------------------------------------------------------------
!         $mform->addElement('hidden', 'delete', $currentcat);
!         $mform->setType('delete', PARAM_INT);
!     }
  }
  
--- 1,28 ----
  <?php
  
  if (!defined('MOODLE_INTERNAL')) {
! 	die('Direct access to this script is forbidden.');    ///  It must be included from a Moodle page
  }
  
  require_once($CFG->libdir.'/formslib.php');
  
  class question_move_form extends moodleform {
  
! 	function definition() {
! 		$mform    =& $this->_form;
  
! 		$currentcat   = $this->_customdata['currentcat'];
! 		$contexts   = $this->_customdata['contexts'];
! 		//--------------------------------------------------------------------------------
! 
! 		$mform->addElement('questioncategory', 'category', get_string('category','quiz'), compact('contexts', 'currentcat'));
! 
! 
! 		//--------------------------------------------------------------------------------
! 		$this->add_action_buttons(true, get_string('categorymoveto', 'quiz'));
! 		//--------------------------------------------------------------------------------
! 		$mform->addElement('hidden', 'delete', $currentcat);
! 		$mform->setType('delete', PARAM_INT);
! 	}
  }
  
diff -crB questionorg/previewlib.php questionupd/previewlib.php
*** questionorg/previewlib.php	2012-04-13 12:31:14.535178307 +0500
--- questionupd/previewlib.php	2012-04-13 09:42:55.000000000 +0500
***************
*** 37,108 ****
   * @return bool false if file not found, does not return if found - justsend the file
   */
  function question_preview_question_pluginfile($course, $context, $component,
!         $filearea, $attemptid, $questionid, $args, $forcedownload) {
!     global $USER, $SESSION, $DB, $CFG;
!     require_once($CFG->dirroot . '/mod/quiz/locallib.php');
! 
!     if (!$question = $DB->get_record('question', array('id' => $questionid))) {
!         return send_file_not_found();
!     }
! 
!     if (!question_has_capability_on($question, 'use', $question->category)) {
!         send_file_not_found();
!     }
! 
!     if (!isset($SESSION->quizpreview->states) || $SESSION->quizpreview->questionid != $questionid) {
!         send_file_not_found();
!     }
! 
!     $states = end($SESSION->quizpreview->states);
!     if (!array_key_exists($question->id, $states)) {
!         send_file_not_found();
!     }
!     $state = $states[$question->id];
! 
!     // Build fake cmoptions
!     $quiz = new cmoptions;
!     $quiz->id = 0;
!     $quiz->review = get_config('quiz', 'review');
!     if (empty($course->id)) {
!         $quiz->course = SITEID;
!     } else {
!         $quiz->course = $course->id;
!     }
!     $quiz->decimalpoints = get_config('quiz', 'decimalpoints');
! 
!     $questions[$question->id] = $question;
!     get_question_options($questions);
! 
!     // Build fake attempt
!     $timenow = time();
!     $attempt = new stdClass();
!     $attempt->quiz = $quiz->id;
!     $attempt->userid = $USER->id;
!     $attempt->attempt = 0;
!     $attempt->sumgrades = 0;
!     $attempt->timestart = $timenow;
!     $attempt->timefinish = 0;
!     $attempt->timemodified = $timenow;
!     $attempt->uniqueid = 0;
!     $attempt->id = 0;
!     $attempt->layout = $question->id;
! 
!     $options = quiz_get_renderoptions($quiz, $attempt, $context, $state);
!     $options->noeditlink = true;
!     // XXX: mulitichoice type needs quiz id to get maxgrade
!     $options->quizid = 0;
! 
!     if (!question_check_file_access($question, $state, $options, $context->id, $component,
!             $filearea, $args, $forcedownload)) {
!         send_file_not_found();
!     }
! 
!     $fs = get_file_storage();
!     $relativepath = implode('/', $args);
!     $fullpath = "/$context->id/$component/$filearea/$relativepath";
!     if (!$file = $fs->get_file_by_hash(sha1($fullpath)) or $file->is_directory()) {
!         send_file_not_found();
!     }
  
!     send_stored_file($file, 0, 0, $forcedownload);
  }
--- 37,108 ----
   * @return bool false if file not found, does not return if found - justsend the file
   */
  function question_preview_question_pluginfile($course, $context, $component,
! $filearea, $attemptid, $questionid, $args, $forcedownload) {
! 	global $USER, $SESSION, $DB, $CFG;
! 	require_once($CFG->dirroot . '/mod/quiz/locallib.php');
! 
! 	if (!$question = $DB->get_record('question', array('id' => $questionid))) {
! 		return send_file_not_found();
! 	}
! 
! 	if (!question_has_capability_on($question, 'use', $question->category)) {
! 		send_file_not_found();
! 	}
! 
! 	if (!isset($SESSION->quizpreview->states) || $SESSION->quizpreview->questionid != $questionid) {
! 		send_file_not_found();
! 	}
! 
! 	$states = end($SESSION->quizpreview->states);
! 	if (!array_key_exists($question->id, $states)) {
! 		send_file_not_found();
! 	}
! 	$state = $states[$question->id];
! 
! 	// Build fake cmoptions
! 	$quiz = new cmoptions;
! 	$quiz->id = 0;
! 	$quiz->review = get_config('quiz', 'review');
! 	if (empty($course->id)) {
! 		$quiz->course = SITEID;
! 	} else {
! 		$quiz->course = $course->id;
! 	}
! 	$quiz->decimalpoints = get_config('quiz', 'decimalpoints');
! 
! 	$questions[$question->id] = $question;
! 	get_question_options($questions);
! 
! 	// Build fake attempt
! 	$timenow = time();
! 	$attempt = new stdClass();
! 	$attempt->quiz = $quiz->id;
! 	$attempt->userid = $USER->id;
! 	$attempt->attempt = 0;
! 	$attempt->sumgrades = 0;
! 	$attempt->timestart = $timenow;
! 	$attempt->timefinish = 0;
! 	$attempt->timemodified = $timenow;
! 	$attempt->uniqueid = 0;
! 	$attempt->id = 0;
! 	$attempt->layout = $question->id;
! 
! 	$options = quiz_get_renderoptions($quiz, $attempt, $context, $state);
! 	$options->noeditlink = true;
! 	// XXX: mulitichoice type needs quiz id to get maxgrade
! 	$options->quizid = 0;
! 
! 	if (!question_check_file_access($question, $state, $options, $context->id, $component,
! 	$filearea, $args, $forcedownload)) {
! 		send_file_not_found();
! 	}
! 
! 	$fs = get_file_storage();
! 	$relativepath = implode('/', $args);
! 	$fullpath = "/$context->id/$component/$filearea/$relativepath";
! 	if (!$file = $fs->get_file_by_hash(sha1($fullpath)) or $file->is_directory()) {
! 		send_file_not_found();
! 	}
  
! 	send_stored_file($file, 0, 0, $forcedownload);
  }
diff -crB questionorg/preview.php questionupd/preview.php
*** questionorg/preview.php	2012-04-13 12:31:14.593178307 +0500
--- questionupd/preview.php	2012-04-13 09:42:55.000000000 +0500
***************
*** 15,255 ****
   * @package questionbank
   */
  
!     require_once("../config.php");
!     require_once($CFG->libdir.'/questionlib.php');
!     require_once($CFG->dirroot.'/mod/quiz/locallib.php'); // We really want to get rid of this
! 
!     $id = required_param('id', PARAM_INT);        // question id
!     // if no quiz id is specified then a dummy quiz with default options is used
!     $quizid = optional_param('quizid', 0, PARAM_INT);
!     // if no quiz id is specified then tell us the course
! 
!     $pageurl = new moodle_url('/question/preview.php', array('id' => $id, 'continue' => 1));
!     if (empty($quizid)) {
!         $courseid = required_param('courseid', PARAM_INT);
!         $pageurl->param('courseid', $courseid);
!     } else {
!         $pageurl->param('quizid', $quizid);
!     }
!     $PAGE->set_url($pageurl);
!     $PAGE->set_pagelayout('popup');
! 
!     // Test if we are continuing an attempt at a question
!     $continue = optional_param('continue', 0, PARAM_BOOL);
!     // Check for any of the submit buttons
!     $fillcorrect = optional_param('fillcorrect', 0, PARAM_BOOL);
!     $markall = optional_param('markall', 0, PARAM_BOOL);
!     $finishattempt = optional_param('finishattempt', 0, PARAM_BOOL);
!     $back = optional_param('back', 0, PARAM_BOOL);
!     $startagain = optional_param('startagain', 0, PARAM_BOOL);
!     // We are always continuing an attempt if a submit button was pressed with the
!     // exception of the start again button
!     if ($fillcorrect || $markall || $finishattempt || $back) {
!         $continue = true;
!     } else if ($startagain) {
!         $continue = false;
!     }
! 
!     $url = new moodle_url('/question/preview.php');
!     $url->param('id', $id);
!     if ($quizid) {
!         $url->param('quizid', $quizid);
!     } else {
!         $url->param('courseid', $courseid);
!     }
!     $url->param('continue', 1);
!     if (!$continue) {
!         // Start a new attempt; delete the old session
!         unset($SESSION->quizpreview);
!         // Redirect to ourselves but with continue=1; prevents refreshing the page
!         // from restarting an attempt (needed so that random questions don't change)
!         redirect($url);
!     }
!     // Load the question information
!     if (!$questions = $DB->get_records('question', array('id' =>  $id))) {
!         print_error('cannotloadquestion', 'question');
!     }
!     if (empty($quizid)) {
!         $quiz = new cmoptions;
!         $quiz->id = 0;
!         $quiz->review = get_config('quiz', 'review');
!         require_login($courseid, false);
!         $quiz->course = $courseid;
!         $quiz->decimalpoints = get_config('quiz', 'decimalpoints');
!         $context = get_context_instance(CONTEXT_COURSE, $courseid);
!     } else if (!$quiz = $DB->get_record('quiz', array('id' => $quizid))) {
!         print_error('invalidquizid', 'quiz', '', $quizid);
!     } else {
!         $cm = get_coursemodule_from_instance('quiz', $quizid, $quiz->course);
!         require_login($quiz->course, false, $cm);
!         $context = get_context_instance(CONTEXT_MODULE, $cm->id);
!     }
! 
!     if ($maxgrade = $DB->get_field('quiz_question_instances', 'grade', array('quiz' => $quiz->id, 'question' => $id))) {
!         $questions[$id]->maxgrade = $maxgrade;
!     } else {
!         $questions[$id]->maxgrade = $questions[$id]->defaultgrade;
!     }
! 
!     $quiz->id = 0; // just for safety
!     $quiz->questions = $id;
! 
!     if (!$category = $DB->get_record("question_categories", array("id" => $questions[$id]->category))) {
!         print_error('invalidquestionid', 'quiz');
!     }
! 
!     if (!question_has_capability_on($questions[$id], 'use', $questions[$id]->category)){
!         print_error('cannotpreview', 'question');
!     }
!     if (isset($COURSE)){
!         $quiz->course = $COURSE->id;
!     }
! 
!     // Load the question type specific information
!     if (!get_question_options($questions)) {
!         print_error('newattemptfail', 'quiz');
!     }
! 
!     // Create a dummy quiz attempt
!     // TODO: find out what of the following we really need. What is $attempt
!     //       really used for?
!     $timenow = time();
!     $attempt->quiz = $quiz->id;
!     $attempt->userid = $USER->id;
!     $attempt->attempt = 0;
!     $attempt->sumgrades = 0;
!     $attempt->timestart = $timenow;
!     $attempt->timefinish = 0;
!     $attempt->timemodified = $timenow;
!     $attempt->uniqueid = 0;
!     $attempt->id = 0;
!     $attempt->layout = $id;
! 
!     // Restore the history of question sessions from the moodle session or create
!     // new sessions. Make $states a reference to the states array in the moodle
!     // session.
!     if (isset($SESSION->quizpreview->states) and $SESSION->quizpreview->questionid == $id) {
!         // Reload the question session history from the moodle session
!         $states =& $SESSION->quizpreview->states;
!         $historylength = count($states) - 1;
!         if ($back && $historylength > 0) {
!             // Go back one step in the history
!             unset($states[$historylength]);
!             $historylength--;
!         }
!     } else {
!         // Record the question id in the moodle session
!         $SESSION->quizpreview->questionid = $id;
!         // Create an empty session for the question
!         if (!$newstates = get_question_states($questions, $quiz, $attempt)) {
!             print_error('newattemptfail', 'quiz');
!         }
!         $newstates[$id]->questionsessionid = 0;
!         $SESSION->quizpreview->states = array($newstates);
!         $states =& $SESSION->quizpreview->states;
!         $historylength = 0;
!     }
! 
!     if (!$fillcorrect && !$back && ($form = data_submitted())) {
!         $form = (array)$form;
!         $submitted = true;
! 
!         // Create a new item in the history of question states (don't simplify!)
!         $states[$historylength + 1] = array();
!         $states[$historylength + 1][$id] = clone($states[$historylength][$id]);
!         $historylength++;
!         $curstate =& $states[$historylength][$id];
!         $curstate->changed = false;
! 
!         // Process the responses
!         unset($form['id']);
!         unset($form['quizid']);
!         unset($form['continue']);
!         unset($form['markall']);
!         unset($form['finishattempt']);
!         unset($form['back']);
!         unset($form['startagain']);
! 
!         if ($finishattempt) {
!             $event = QUESTION_EVENTCLOSE;
!         } else if ($markall) {
!             $event = QUESTION_EVENTSUBMIT;
!         } else {
!             $event = QUESTION_EVENTSAVE;
!         }
!         if ($actions = question_extract_responses($questions, $form, $event)) {
!             $actions[$id]->timestamp = 0; // We do not care about timelimits here
!             if (!question_process_responses($questions[$id], $curstate, $actions[$id], $quiz, $attempt)) {
!                 unset($SESSION->quizpreview);
!                 print_error('errorprocessingresponses', 'question', $url->out());
!             }
!             if (!$curstate->changed) {
!                 // Update the current state rather than creating a new one
!                 $historylength--;
!                 unset($states[$historylength]);
!                 $states = array_values($states);
!                 $curstate =& $states[$historylength][$id];
!             }
!         }
!     } else {
!         $submitted = false;
!         $curstate =& $states[$historylength][$id];
!     }
! 
!     // TODO: should not use quiz-specific function here
!     $options = quiz_get_renderoptions($quiz, $attempt, $context, $curstate);
!     $options->noeditlink = true;
! 
!     // Fill in the correct responses (unless the question is in readonly mode)
!     if ($fillcorrect && !$options->readonly) {
!         $curstate->responses = $QTYPES[$questions[$id]->qtype]->get_correct_responses($questions[$id], $curstate);
!     }
! 
!     $strpreview = get_string('preview', 'quiz').' '.format_string($questions[$id]->name);
!     $questionlist = array($id);
!     question_get_html_head_contributions($questionlist, $questions, $states[$historylength]);
!     $PAGE->set_title($strpreview);
!     $PAGE->set_heading($COURSE->fullname);
!     echo $OUTPUT->header();
! 
!     if (!empty($quizid)) {
!         echo '<p class="quemodname">'.get_string('modulename', 'quiz') . ': ';
!         p(format_string($quiz->name));
!         echo "</p>\n";
!     }
!     $number = 1;
!     echo '<form method="post" action="'.$url->out_omit_querystring().'" enctype="multipart/form-data" id="responseform">', "\n";
!     $PAGE->requires->js_init_call('M.core_question_engine.init_form', array('#responseform'));
  
!     print_question($questions[$id], $curstate, $number, $quiz, $options, $context);
  
!     echo '<div class="controls">';
!     echo html_writer::input_hidden_params($url);
  
!     // Print the mark and finish attempt buttons
!     echo '<input name="markall" type="submit" value="' . get_string('markall',
       'quiz') . "\" />\n";
!     echo '<input name="finishattempt" type="submit" value="' .
!      get_string('submitallandfinish', 'quiz') . "\" />\n";
!     echo '<br />';
!     echo '<br />';
!     // Print the fill correct button (unless the question is in readonly mode)
!     if (!$options->readonly) {
!         echo '<input name="fillcorrect" type="submit" value="' .
!          get_string('fillcorrect', 'quiz') . "\" />\n";
!     }
!     // Print the navigation buttons
!     if ($historylength > 0) {
!         echo '<input name="back" type="submit" value="' . get_string('previous',
           'quiz') . "\" />\n";
!     }
!     // Print the start again button
!     echo '<input name="startagain" type="submit" value="' .
!      get_string('startagain', 'quiz') . "\" />\n";
!     // Print the close window button
!     echo '<input type="button" onclick="window.close()" value="' .
!      get_string('closepreview', 'quiz') . "\" />";
!     echo '</div>';
!     echo '</form>';
!     echo $OUTPUT->footer();
  
--- 15,255 ----
   * @package questionbank
   */
  
! require_once("../config.php");
! require_once($CFG->libdir.'/questionlib.php');
! require_once($CFG->dirroot.'/mod/quiz/locallib.php'); // We really want to get rid of this
! 
! $id = required_param('id', PARAM_INT);        // question id
! // if no quiz id is specified then a dummy quiz with default options is used
! $quizid = optional_param('quizid', 0, PARAM_INT);
! // if no quiz id is specified then tell us the course
! 
! $pageurl = new moodle_url('/question/preview.php', array('id' => $id, 'continue' => 1));
! if (empty($quizid)) {
! 	$courseid = required_param('courseid', PARAM_INT);
! 	$pageurl->param('courseid', $courseid);
! } else {
! 	$pageurl->param('quizid', $quizid);
! }
! $PAGE->set_url($pageurl);
! $PAGE->set_pagelayout('popup');
! 
! // Test if we are continuing an attempt at a question
! $continue = optional_param('continue', 0, PARAM_BOOL);
! // Check for any of the submit buttons
! $fillcorrect = optional_param('fillcorrect', 0, PARAM_BOOL);
! $markall = optional_param('markall', 0, PARAM_BOOL);
! $finishattempt = optional_param('finishattempt', 0, PARAM_BOOL);
! $back = optional_param('back', 0, PARAM_BOOL);
! $startagain = optional_param('startagain', 0, PARAM_BOOL);
! // We are always continuing an attempt if a submit button was pressed with the
! // exception of the start again button
! if ($fillcorrect || $markall || $finishattempt || $back) {
! 	$continue = true;
! } else if ($startagain) {
! 	$continue = false;
! }
! 
! $url = new moodle_url('/question/preview.php');
! $url->param('id', $id);
! if ($quizid) {
! 	$url->param('quizid', $quizid);
! } else {
! 	$url->param('courseid', $courseid);
! }
! $url->param('continue', 1);
! if (!$continue) {
! 	// Start a new attempt; delete the old session
! 	unset($SESSION->quizpreview);
! 	// Redirect to ourselves but with continue=1; prevents refreshing the page
! 	// from restarting an attempt (needed so that random questions don't change)
! 	redirect($url);
! }
! // Load the question information
! if (!$questions = $DB->get_records('question', array('id' =>  $id))) {
! 	print_error('cannotloadquestion', 'question');
! }
! if (empty($quizid)) {
! 	$quiz = new cmoptions;
! 	$quiz->id = 0;
! 	$quiz->review = get_config('quiz', 'review');
! 	require_login($courseid, false);
! 	$quiz->course = $courseid;
! 	$quiz->decimalpoints = get_config('quiz', 'decimalpoints');
! 	$context = get_context_instance(CONTEXT_COURSE, $courseid);
! } else if (!$quiz = $DB->get_record('quiz', array('id' => $quizid))) {
! 	print_error('invalidquizid', 'quiz', '', $quizid);
! } else {
! 	$cm = get_coursemodule_from_instance('quiz', $quizid, $quiz->course);
! 	require_login($quiz->course, false, $cm);
! 	$context = get_context_instance(CONTEXT_MODULE, $cm->id);
! }
! 
! if ($maxgrade = $DB->get_field('quiz_question_instances', 'grade', array('quiz' => $quiz->id, 'question' => $id))) {
! 	$questions[$id]->maxgrade = $maxgrade;
! } else {
! 	$questions[$id]->maxgrade = $questions[$id]->defaultgrade;
! }
! 
! $quiz->id = 0; // just for safety
! $quiz->questions = $id;
! 
! if (!$category = $DB->get_record("question_categories", array("id" => $questions[$id]->category))) {
! 	print_error('invalidquestionid', 'quiz');
! }
! 
! if (!question_has_capability_on($questions[$id], 'use', $questions[$id]->category)){
! 	print_error('cannotpreview', 'question');
! }
! if (isset($COURSE)){
! 	$quiz->course = $COURSE->id;
! }
! 
! // Load the question type specific information
! if (!get_question_options($questions)) {
! 	print_error('newattemptfail', 'quiz');
! }
! 
! // Create a dummy quiz attempt
! // TODO: find out what of the following we really need. What is $attempt
! //       really used for?
! $timenow = time();
! $attempt->quiz = $quiz->id;
! $attempt->userid = $USER->id;
! $attempt->attempt = 0;
! $attempt->sumgrades = 0;
! $attempt->timestart = $timenow;
! $attempt->timefinish = 0;
! $attempt->timemodified = $timenow;
! $attempt->uniqueid = 0;
! $attempt->id = 0;
! $attempt->layout = $id;
! 
! // Restore the history of question sessions from the moodle session or create
! // new sessions. Make $states a reference to the states array in the moodle
! // session.
! if (isset($SESSION->quizpreview->states) and $SESSION->quizpreview->questionid == $id) {
! 	// Reload the question session history from the moodle session
! 	$states =& $SESSION->quizpreview->states;
! 	$historylength = count($states) - 1;
! 	if ($back && $historylength > 0) {
! 		// Go back one step in the history
! 		unset($states[$historylength]);
! 		$historylength--;
! 	}
! } else {
! 	// Record the question id in the moodle session
! 	$SESSION->quizpreview->questionid = $id;
! 	// Create an empty session for the question
! 	if (!$newstates = get_question_states($questions, $quiz, $attempt)) {
! 		print_error('newattemptfail', 'quiz');
! 	}
! 	$newstates[$id]->questionsessionid = 0;
! 	$SESSION->quizpreview->states = array($newstates);
! 	$states =& $SESSION->quizpreview->states;
! 	$historylength = 0;
! }
! 
! if (!$fillcorrect && !$back && ($form = data_submitted())) {
! 	$form = (array)$form;
! 	$submitted = true;
! 
! 	// Create a new item in the history of question states (don't simplify!)
! 	$states[$historylength + 1] = array();
! 	$states[$historylength + 1][$id] = clone($states[$historylength][$id]);
! 	$historylength++;
! 	$curstate =& $states[$historylength][$id];
! 	$curstate->changed = false;
! 
! 	// Process the responses
! 	unset($form['id']);
! 	unset($form['quizid']);
! 	unset($form['continue']);
! 	unset($form['markall']);
! 	unset($form['finishattempt']);
! 	unset($form['back']);
! 	unset($form['startagain']);
! 
! 	if ($finishattempt) {
! 		$event = QUESTION_EVENTCLOSE;
! 	} else if ($markall) {
! 		$event = QUESTION_EVENTSUBMIT;
! 	} else {
! 		$event = QUESTION_EVENTSAVE;
! 	}
! 	if ($actions = question_extract_responses($questions, $form, $event)) {
! 		$actions[$id]->timestamp = 0; // We do not care about timelimits here
! 		if (!question_process_responses($questions[$id], $curstate, $actions[$id], $quiz, $attempt)) {
! 			unset($SESSION->quizpreview);
! 			print_error('errorprocessingresponses', 'question', $url->out());
! 		}
! 		if (!$curstate->changed) {
! 			// Update the current state rather than creating a new one
! 			$historylength--;
! 			unset($states[$historylength]);
! 			$states = array_values($states);
! 			$curstate =& $states[$historylength][$id];
! 		}
! 	}
! } else {
! 	$submitted = false;
! 	$curstate =& $states[$historylength][$id];
! }
! 
! // TODO: should not use quiz-specific function here
! $options = quiz_get_renderoptions($quiz, $attempt, $context, $curstate);
! $options->noeditlink = true;
! 
! // Fill in the correct responses (unless the question is in readonly mode)
! if ($fillcorrect && !$options->readonly) {
! 	$curstate->responses = $QTYPES[$questions[$id]->qtype]->get_correct_responses($questions[$id], $curstate);
! }
! 
! $strpreview = get_string('preview', 'quiz').' '.format_string($questions[$id]->name);
! $questionlist = array($id);
! question_get_html_head_contributions($questionlist, $questions, $states[$historylength]);
! $PAGE->set_title($strpreview);
! $PAGE->set_heading($COURSE->fullname);
! echo $OUTPUT->header();
! 
! if (!empty($quizid)) {
! 	echo '<p class="quemodname">'.get_string('modulename', 'quiz') . ': ';
! 	p(format_string($quiz->name));
! 	echo "</p>\n";
! }
! $number = 1;
! echo '<form method="post" action="'.$url->out_omit_querystring().'" enctype="multipart/form-data" id="responseform">', "\n";
! $PAGE->requires->js_init_call('M.core_question_engine.init_form', array('#responseform'));
  
! print_question($questions[$id], $curstate, $number, $quiz, $options, $context);
  
! echo '<div class="controls">';
! echo html_writer::input_hidden_params($url);
  
! // Print the mark and finish attempt buttons
! echo '<input name="markall" type="submit" value="' . get_string('markall',
       'quiz') . "\" />\n";
! echo '<input name="finishattempt" type="submit" value="' .
! get_string('submitallandfinish', 'quiz') . "\" />\n";
! echo '<br />';
! echo '<br />';
! // Print the fill correct button (unless the question is in readonly mode)
! if (!$options->readonly) {
! 	echo '<input name="fillcorrect" type="submit" value="' .
! 	get_string('fillcorrect', 'quiz') . "\" />\n";
! }
! // Print the navigation buttons
! if ($historylength > 0) {
! 	echo '<input name="back" type="submit" value="' . get_string('previous',
           'quiz') . "\" />\n";
! }
! // Print the start again button
! echo '<input name="startagain" type="submit" value="' .
! get_string('startagain', 'quiz') . "\" />\n";
! // Print the close window button
! echo '<input type="button" onclick="window.close()" value="' .
! get_string('closepreview', 'quiz') . "\" />";
! echo '</div>';
! echo '</form>';
! echo $OUTPUT->footer();
  
diff -crB questionorg/question.php questionupd/question.php
*** questionorg/question.php	2012-04-13 12:31:14.545178306 +0500
--- questionupd/question.php	2012-04-13 09:42:55.000000000 +0500
***************
*** 21,129 ****
  $courseid = optional_param('courseid', 0, PARAM_INT);
  $wizardnow = optional_param('wizardnow', '', PARAM_ALPHA);
  $movecontext = optional_param('movecontext', 0, PARAM_BOOL); // Switch to make
!         // question uneditable - form is displayed to edit category only
  $originalreturnurl = optional_param('returnurl', 0, PARAM_LOCALURL);
  $appendqnumstring = optional_param('appendqnumstring', '', PARAM_ALPHA);
  $inpopup = optional_param('inpopup', 0, PARAM_BOOL);
  
  $url = new moodle_url('/question/question.php');
  if ($id !== 0) {
!     $url->param('id', $id);
  }
  if ($qtype !== '') {
!     $url->param('qtype', $qtype);
  }
  if ($categoryid !== 0) {
!     $url->param('category', $categoryid);
  }
  if ($cmid !== 0) {
!     $url->param('cmid', $cmid);
  }
  if ($courseid !== 0) {
!     $url->param('courseid', $courseid);
  }
  if ($wizardnow !== '') {
!     $url->param('wizardnow', $wizardnow);
  }
  if ($movecontext !== 0) {
!     $url->param('movecontext', $movecontext);
  }
  if ($originalreturnurl !== 0) {
!     $url->param('returnurl', $originalreturnurl);
  }
  if ($appendqnumstring !== '') {
!     $url->param('appendqnumstring', $appendqnumstring);
  }
  if ($inpopup !== 0) {
!     $url->param('inpopup', $inpopup);
  }
  $PAGE->set_url($url);
  
  if ($originalreturnurl) {
!     if (strpos($originalreturnurl, '/') !== 0) {
!         throw new coding_exception("returnurl must be a local URL starting with '/'. $originalreturnurl was given.");
!     }
!     $returnurl = new moodle_url($originalreturnurl);
  } else if ($cmid) {
!     $returnurl = new moodle_url('/question/edit.php', array('cmid' => $cmid));
  } else {
!     $returnurl = new moodle_url('/question/edit.php', array('courseid' => $courseid));
  }
  
  if ($movecontext && !$id){
!     print_error('questiondoesnotexist', 'question', $returnurl);
  }
  
  if ($cmid){
!     list($module, $cm) = get_module_from_cmid($cmid);
!     require_login($cm->course, false, $cm);
!     $thiscontext = get_context_instance(CONTEXT_MODULE, $cmid);
  } elseif ($courseid) {
!     require_login($courseid, false);
!     $PAGE->set_pagelayout('course');
!     $thiscontext = get_context_instance(CONTEXT_COURSE, $courseid);
!     $module = null;
!     $cm = null;
  } else {
!     print_error('missingcourseorcmid', 'question');
  }
  $contexts = new question_edit_contexts($thiscontext);
  
  if (optional_param('addcancel', false, PARAM_BOOL)) {
!     redirect($returnurl);
  }
  
  if ($id) {
!     if (!$question = $DB->get_record('question', array('id' => $id))) {
!         print_error('questiondoesnotexist', 'question', $returnurl);
!     }
!     get_question_options($question, true);
  
  } else if ($categoryid && $qtype) { // only for creating new questions
!     $question = new stdClass;
!     $question->category = $categoryid;
!     $question->qtype = $qtype;
! 
!     // Check that users are allowed to create this question type at the moment.
!     $allowedtypes = question_type_menu();
!     if (!isset($allowedtypes[$qtype])) {
!         print_error('cannotenable', 'question', $returnurl, $qtype);
!     }
  
  } else if ($categoryid) {
!     // Category, but no qtype. They probably came from the addquestion.php
!     // script without choosing a question type. Send them back.
!     $addurl = new moodle_url('/question/addquestion.php', $url->params());
!     $addurl->param('validationerror', 1);
!     redirect($addurl);
  
  } else {
!     print_error('notenoughdatatoeditaquestion', 'question', $returnurl);
  }
  
  // Validate the question category.
  if (!$category = $DB->get_record('question_categories', array('id' => $question->category))) {
!     print_error('categorydoesnotexist', 'question', $returnurl);
  }
  
  // Check permissions
--- 21,129 ----
  $courseid = optional_param('courseid', 0, PARAM_INT);
  $wizardnow = optional_param('wizardnow', '', PARAM_ALPHA);
  $movecontext = optional_param('movecontext', 0, PARAM_BOOL); // Switch to make
! // question uneditable - form is displayed to edit category only
  $originalreturnurl = optional_param('returnurl', 0, PARAM_LOCALURL);
  $appendqnumstring = optional_param('appendqnumstring', '', PARAM_ALPHA);
  $inpopup = optional_param('inpopup', 0, PARAM_BOOL);
  
  $url = new moodle_url('/question/question.php');
  if ($id !== 0) {
! 	$url->param('id', $id);
  }
  if ($qtype !== '') {
! 	$url->param('qtype', $qtype);
  }
  if ($categoryid !== 0) {
! 	$url->param('category', $categoryid);
  }
  if ($cmid !== 0) {
! 	$url->param('cmid', $cmid);
  }
  if ($courseid !== 0) {
! 	$url->param('courseid', $courseid);
  }
  if ($wizardnow !== '') {
! 	$url->param('wizardnow', $wizardnow);
  }
  if ($movecontext !== 0) {
! 	$url->param('movecontext', $movecontext);
  }
  if ($originalreturnurl !== 0) {
! 	$url->param('returnurl', $originalreturnurl);
  }
  if ($appendqnumstring !== '') {
! 	$url->param('appendqnumstring', $appendqnumstring);
  }
  if ($inpopup !== 0) {
! 	$url->param('inpopup', $inpopup);
  }
  $PAGE->set_url($url);
  
  if ($originalreturnurl) {
! 	if (strpos($originalreturnurl, '/') !== 0) {
! 		throw new coding_exception("returnurl must be a local URL starting with '/'. $originalreturnurl was given.");
! 	}
! 	$returnurl = new moodle_url($originalreturnurl);
  } else if ($cmid) {
! 	$returnurl = new moodle_url('/question/edit.php', array('cmid' => $cmid));
  } else {
! 	$returnurl = new moodle_url('/question/edit.php', array('courseid' => $courseid));
  }
  
  if ($movecontext && !$id){
! 	print_error('questiondoesnotexist', 'question', $returnurl);
  }
  
  if ($cmid){
! 	list($module, $cm) = get_module_from_cmid($cmid);
! 	require_login($cm->course, false, $cm);
! 	$thiscontext = get_context_instance(CONTEXT_MODULE, $cmid);
  } elseif ($courseid) {
! 	require_login($courseid, false);
! 	$PAGE->set_pagelayout('course');
! 	$thiscontext = get_context_instance(CONTEXT_COURSE, $courseid);
! 	$module = null;
! 	$cm = null;
  } else {
! 	print_error('missingcourseorcmid', 'question');
  }
  $contexts = new question_edit_contexts($thiscontext);
  
  if (optional_param('addcancel', false, PARAM_BOOL)) {
! 	redirect($returnurl);
  }
  
  if ($id) {
! 	if (!$question = $DB->get_record('question', array('id' => $id))) {
! 		print_error('questiondoesnotexist', 'question', $returnurl);
! 	}
! 	get_question_options($question, true);
  
  } else if ($categoryid && $qtype) { // only for creating new questions
! 	$question = new stdClass;
! 	$question->category = $categoryid;
! 	$question->qtype = $qtype;
! 
! 	// Check that users are allowed to create this question type at the moment.
! 	$allowedtypes = question_type_menu();
! 	if (!isset($allowedtypes[$qtype])) {
! 		print_error('cannotenable', 'question', $returnurl, $qtype);
! 	}
  
  } else if ($categoryid) {
! 	// Category, but no qtype. They probably came from the addquestion.php
! 	// script without choosing a question type. Send them back.
! 	$addurl = new moodle_url('/question/addquestion.php', $url->params());
! 	$addurl->param('validationerror', 1);
! 	redirect($addurl);
  
  } else {
! 	print_error('notenoughdatatoeditaquestion', 'question', $returnurl);
  }
  
  // Validate the question category.
  if (!$category = $DB->get_record('question_categories', array('id' => $question->category))) {
! 	print_error('categorydoesnotexist', 'question', $returnurl);
  }
  
  // Check permissions
***************
*** 133,201 ****
  $addpermission = has_capability('moodle/question:add', $categorycontext);
  
  if ($id) {
!     $canview = question_has_capability_on($question, 'view');
!     if ($movecontext){
!         $question->formoptions->canedit = false;
!         $question->formoptions->canmove = (question_has_capability_on($question, 'move') && $contexts->have_cap('moodle/question:add'));
!         $question->formoptions->cansaveasnew = false;
!         $question->formoptions->repeatelements = false;
!         $question->formoptions->movecontext = true;
!         $formeditable = true;
!         question_require_capability_on($question, 'view');
!     } else {
!         $question->formoptions->canedit = question_has_capability_on($question, 'edit');
!         $question->formoptions->canmove = (question_has_capability_on($question, 'move') && $addpermission);
!         $question->formoptions->cansaveasnew = (($canview ||question_has_capability_on($question, 'edit')) && $addpermission);
!         $question->formoptions->repeatelements = ($question->formoptions->canedit || $question->formoptions->cansaveasnew);
!         $formeditable =  $question->formoptions->canedit || $question->formoptions->cansaveasnew || $question->formoptions->canmove;
!         $question->formoptions->movecontext = false;
!         if (!$formeditable){
!             question_require_capability_on($question, 'view');
!         }
!     }
  
  } else  { // creating a new question
!     require_capability('moodle/question:add', $categorycontext);
!     $formeditable = true;
!     $question->formoptions->canedit = question_has_capability_on($question, 'edit');
!     $question->formoptions->canmove = (question_has_capability_on($question, 'move') && $addpermission);
!     $question->formoptions->repeatelements = true;
!     $question->formoptions->movecontext = false;
  }
  
  // Validate the question type.
  if (!isset($QTYPES[$question->qtype])) {
!     print_error('unknownquestiontype', 'question', $returnurl, $question->qtype);
  }
  $PAGE->set_pagetype('question-type-' . $question->qtype);
  
  // Create the question editing form.
  if ($wizardnow!=='' && !$movecontext){
!     if (!method_exists($QTYPES[$question->qtype], 'next_wizard_form')){
!         print_error('missingimportantcode', 'question', $returnurl, 'wizard form definition');
!     } else {
!         $mform = $QTYPES[$question->qtype]->next_wizard_form('question.php', $question, $wizardnow, $formeditable);
!     }
  } else {
!     $mform = $QTYPES[$question->qtype]->create_editing_form('question.php', $question, $category, $contexts, $formeditable);
  }
  if ($mform === null) {
!     print_error('missingimportantcode', 'question', $returnurl, 'question editing form definition for "'.$question->qtype.'"');
  }
  $toform = fullclone($question); // send the question object and a few more parameters to the form
  $toform->category = "$category->id,$category->contextid";
  if ($formeditable && $id){
!     $toform->categorymoveto = $toform->category;
  }
  
  $toform->appendqnumstring = $appendqnumstring;
  $toform->returnurl = $originalreturnurl;
  $toform->movecontext = $movecontext;
  if ($cm !== null){
!     $toform->cmid = $cm->id;
!     $toform->courseid = $cm->course;
  } else {
!     $toform->courseid = $COURSE->id;
  }
  
  $toform->inpopup = $inpopup;
--- 133,201 ----
  $addpermission = has_capability('moodle/question:add', $categorycontext);
  
  if ($id) {
! 	$canview = question_has_capability_on($question, 'view');
! 	if ($movecontext){
! 		$question->formoptions->canedit = false;
! 		$question->formoptions->canmove = (question_has_capability_on($question, 'move') && $contexts->have_cap('moodle/question:add'));
! 		$question->formoptions->cansaveasnew = false;
! 		$question->formoptions->repeatelements = false;
! 		$question->formoptions->movecontext = true;
! 		$formeditable = true;
! 		question_require_capability_on($question, 'view');
! 	} else {
! 		$question->formoptions->canedit = question_has_capability_on($question, 'edit');
! 		$question->formoptions->canmove = (question_has_capability_on($question, 'move') && $addpermission);
! 		$question->formoptions->cansaveasnew = (($canview ||question_has_capability_on($question, 'edit')) && $addpermission);
! 		$question->formoptions->repeatelements = ($question->formoptions->canedit || $question->formoptions->cansaveasnew);
! 		$formeditable =  $question->formoptions->canedit || $question->formoptions->cansaveasnew || $question->formoptions->canmove;
! 		$question->formoptions->movecontext = false;
! 		if (!$formeditable){
! 			question_require_capability_on($question, 'view');
! 		}
! 	}
  
  } else  { // creating a new question
! 	require_capability('moodle/question:add', $categorycontext);
! 	$formeditable = true;
! 	$question->formoptions->canedit = question_has_capability_on($question, 'edit');
! 	$question->formoptions->canmove = (question_has_capability_on($question, 'move') && $addpermission);
! 	$question->formoptions->repeatelements = true;
! 	$question->formoptions->movecontext = false;
  }
  
  // Validate the question type.
  if (!isset($QTYPES[$question->qtype])) {
! 	print_error('unknownquestiontype', 'question', $returnurl, $question->qtype);
  }
  $PAGE->set_pagetype('question-type-' . $question->qtype);
  
  // Create the question editing form.
  if ($wizardnow!=='' && !$movecontext){
! 	if (!method_exists($QTYPES[$question->qtype], 'next_wizard_form')){
! 		print_error('missingimportantcode', 'question', $returnurl, 'wizard form definition');
! 	} else {
! 		$mform = $QTYPES[$question->qtype]->next_wizard_form('question.php', $question, $wizardnow, $formeditable);
! 	}
  } else {
! 	$mform = $QTYPES[$question->qtype]->create_editing_form('question.php', $question, $category, $contexts, $formeditable);
  }
  if ($mform === null) {
! 	print_error('missingimportantcode', 'question', $returnurl, 'question editing form definition for "'.$question->qtype.'"');
  }
  $toform = fullclone($question); // send the question object and a few more parameters to the form
  $toform->category = "$category->id,$category->contextid";
  if ($formeditable && $id){
! 	$toform->categorymoveto = $toform->category;
  }
  
  $toform->appendqnumstring = $appendqnumstring;
  $toform->returnurl = $originalreturnurl;
  $toform->movecontext = $movecontext;
  if ($cm !== null){
! 	$toform->cmid = $cm->id;
! 	$toform->courseid = $cm->course;
  } else {
! 	$toform->courseid = $COURSE->id;
  }
  
  $toform->inpopup = $inpopup;
***************
*** 203,321 ****
  $mform->set_data($toform);
  
  if ($mform->is_cancelled()){
!     if ($inpopup) {
!         close_window();
!     } else {
!         if (!empty($question->id)) {
!             $returnurl->param('lastchanged', $question->id);
!         }
!         redirect($returnurl->out(false));
!     }
  } else if ($fromform = $mform->get_data()) {
!     /// If we are saving as a copy, break the connection to the old question.
!     if (!empty($fromform->makecopy)) {
!         $question->id = 0;
!         $question->hidden = 0; // Copies should not be hidden
!     }
! 
!     /// Process the combination of usecurrentcat, categorymoveto and category form
!     /// fields, so the save_question method only has to consider $fromform->category
!     if (!empty($fromform->usecurrentcat)) {
!         // $fromform->category is the right category to save in.
!     } else {
!         if (!empty($fromform->categorymoveto)) {
!             $fromform->category = $fromform->categorymoveto;
!         } else {
!             // $fromform->category is the right category to save in.
!         }
!     }
! 
!     /// If we are moving a question, check we have permission to move it from
!     /// whence it came. (Where we are moving to is validated by the form.)
!     list($newcatid) = explode(',', $fromform->category);
!     if (!empty($question->id) && $newcatid != $question->category) {
!         question_require_capability_on($question, 'move');
!     }
! 
!     // Ensure we redirect back to the category the question is being saved into.
!     $returnurl->param('category', $fromform->category);
! 
!     if ($movecontext) {
!         // We are just moving the question to a different context.
!         list($tocatid, $tocontextid) = explode(',', $fromform->categorymoveto);
!         require_capability('moodle/question:add', get_context_instance_by_id($tocontextid));
!         question_move_questions_to_category(array($question->id), $tocatid);
! 
!     } else {
!         // We are acutally saving the question.
!         $question = $QTYPES[$question->qtype]->save_question($question, $fromform);
!         if (!empty($CFG->usetags) && isset($fromform->tags)) {
!             // A wizardpage from multipe pages questiontype like calculated may not
!             // allow editing the question tags, hence the isset($fromform->tags) test.
!             require_once($CFG->dirroot.'/tag/lib.php');
!             tag_set('question', $question->id, $fromform->tags);
!         }
!     }
! 
!     if (($QTYPES[$question->qtype]->finished_edit_wizard($fromform)) || $movecontext) {
!         if ($inpopup) {
!             echo $OUTPUT->notification(get_string('changessaved'), '');
!             close_window(3);
!         } else {
!             $returnurl->param('lastchanged', $question->id);
!             if ($appendqnumstring) {
!                 $returnurl->param($appendqnumstring, $question->id);
!                 $returnurl->param('sesskey', sesskey());
!                 $returnurl->param('cmid', $cmid);
!             }
!             redirect($returnurl);
!         }
  
!     } else {
!         $nexturlparams = array(
                  'returnurl' => $originalreturnurl,
                  'appendqnumstring' => $appendqnumstring);
!         if (isset($fromform->nextpageparam) && is_array($fromform->nextpageparam)){
!             //useful for passing data to the next page which is not saved in the database.
!             $nexturlparams += $fromform->nextpageparam;
!         }
!         $nexturlparams['id'] = $question->id;
!         $nexturlparams['wizardnow'] = $fromform->wizard;
!         $nexturl = new moodle_url('/question/question.php', $nexturlparams);
!         if ($cmid){
!             $nexturl->param('cmid', $cmid);
!         } else {
!             $nexturl->param('courseid', $COURSE->id);
!         }
!         redirect($nexturl);
!     }
  
  } else {
!     $streditingquestion = $QTYPES[$question->qtype]->get_heading();
!     $PAGE->set_title($streditingquestion);
!     $PAGE->set_heading($COURSE->fullname);
!     if ($cm !== null) {
!         $strmodule = get_string('modulename', $cm->modname);
!         $streditingmodule = get_string('editinga', 'moodle', $strmodule);
!         $PAGE->navbar->add(get_string('modulenameplural', $cm->modname), new moodle_url('/mod/'.$cm->modname.'/index.php', array('id'=>$cm->course)));
!         $PAGE->navbar->add(format_string($module->name), new moodle_url('/mod/'.$cm->modname.'/view.php', array('id'=>$cm->id)));
!         if (stripos($returnurl, "$CFG->wwwroot/mod/{$cm->modname}/view.php")!== 0){
!             //don't need this link if returnurl returns to view.php
!             $PAGE->navbar->add($streditingmodule, $returnurl);
!         }
!         $PAGE->navbar->add($streditingquestion);
!         echo $OUTPUT->header();
! 
!     } else {
!         $strediting = '<a href="edit.php?courseid='.$COURSE->id.'">'.get_string("editquestions", "quiz").'</a> -> '.$streditingquestion;
!         $PAGE->navbar->add(get_string('editquestions', 'quiz'), $returnurl);
!         $PAGE->navbar->add($streditingquestion);
!         echo $OUTPUT->header();
!     }
! 
!     // Display a heading, question editing form and possibly some extra content needed for
!     // for this question type.
!     $QTYPES[$question->qtype]->display_question_editing_page($mform, $question, $wizardnow);
!     echo $OUTPUT->footer();
  }
  
--- 203,321 ----
  $mform->set_data($toform);
  
  if ($mform->is_cancelled()){
! 	if ($inpopup) {
! 		close_window();
! 	} else {
! 		if (!empty($question->id)) {
! 			$returnurl->param('lastchanged', $question->id);
! 		}
! 		redirect($returnurl->out(false));
! 	}
  } else if ($fromform = $mform->get_data()) {
! 	/// If we are saving as a copy, break the connection to the old question.
! 	if (!empty($fromform->makecopy)) {
! 		$question->id = 0;
! 		$question->hidden = 0; // Copies should not be hidden
! 	}
! 
! 	/// Process the combination of usecurrentcat, categorymoveto and category form
! 	/// fields, so the save_question method only has to consider $fromform->category
! 	if (!empty($fromform->usecurrentcat)) {
! 		// $fromform->category is the right category to save in.
! 	} else {
! 		if (!empty($fromform->categorymoveto)) {
! 			$fromform->category = $fromform->categorymoveto;
! 		} else {
! 			// $fromform->category is the right category to save in.
! 		}
! 	}
! 
! 	/// If we are moving a question, check we have permission to move it from
! 	/// whence it came. (Where we are moving to is validated by the form.)
! 	list($newcatid) = explode(',', $fromform->category);
! 	if (!empty($question->id) && $newcatid != $question->category) {
! 		question_require_capability_on($question, 'move');
! 	}
! 
! 	// Ensure we redirect back to the category the question is being saved into.
! 	$returnurl->param('category', $fromform->category);
! 
! 	if ($movecontext) {
! 		// We are just moving the question to a different context.
! 		list($tocatid, $tocontextid) = explode(',', $fromform->categorymoveto);
! 		require_capability('moodle/question:add', get_context_instance_by_id($tocontextid));
! 		question_move_questions_to_category(array($question->id), $tocatid);
! 
! 	} else {
! 		// We are acutally saving the question.
! 		$question = $QTYPES[$question->qtype]->save_question($question, $fromform);
! 		if (!empty($CFG->usetags) && isset($fromform->tags)) {
! 			// A wizardpage from multipe pages questiontype like calculated may not
! 			// allow editing the question tags, hence the isset($fromform->tags) test.
! 			require_once($CFG->dirroot.'/tag/lib.php');
! 			tag_set('question', $question->id, $fromform->tags);
! 		}
! 	}
! 
! 	if (($QTYPES[$question->qtype]->finished_edit_wizard($fromform)) || $movecontext) {
! 		if ($inpopup) {
! 			echo $OUTPUT->notification(get_string('changessaved'), '');
! 			close_window(3);
! 		} else {
! 			$returnurl->param('lastchanged', $question->id);
! 			if ($appendqnumstring) {
! 				$returnurl->param($appendqnumstring, $question->id);
! 				$returnurl->param('sesskey', sesskey());
! 				$returnurl->param('cmid', $cmid);
! 			}
! 			redirect($returnurl);
! 		}
  
! 	} else {
! 		$nexturlparams = array(
                  'returnurl' => $originalreturnurl,
                  'appendqnumstring' => $appendqnumstring);
! 		if (isset($fromform->nextpageparam) && is_array($fromform->nextpageparam)){
! 			//useful for passing data to the next page which is not saved in the database.
! 			$nexturlparams += $fromform->nextpageparam;
! 		}
! 		$nexturlparams['id'] = $question->id;
! 		$nexturlparams['wizardnow'] = $fromform->wizard;
! 		$nexturl = new moodle_url('/question/question.php', $nexturlparams);
! 		if ($cmid){
! 			$nexturl->param('cmid', $cmid);
! 		} else {
! 			$nexturl->param('courseid', $COURSE->id);
! 		}
! 		redirect($nexturl);
! 	}
  
  } else {
! 	$streditingquestion = $QTYPES[$question->qtype]->get_heading();
! 	$PAGE->set_title($streditingquestion);
! 	$PAGE->set_heading($COURSE->fullname);
! 	if ($cm !== null) {
! 		$strmodule = get_string('modulename', $cm->modname);
! 		$streditingmodule = get_string('editinga', 'moodle', $strmodule);
! 		$PAGE->navbar->add(get_string('modulenameplural', $cm->modname), new moodle_url('/mod/'.$cm->modname.'/index.php', array('id'=>$cm->course)));
! 		$PAGE->navbar->add(format_string($module->name), new moodle_url('/mod/'.$cm->modname.'/view.php', array('id'=>$cm->id)));
! 		if (stripos($returnurl, "$CFG->wwwroot/mod/{$cm->modname}/view.php")!== 0){
! 			//don't need this link if returnurl returns to view.php
! 			$PAGE->navbar->add($streditingmodule, $returnurl);
! 		}
! 		$PAGE->navbar->add($streditingquestion);
! 		echo $OUTPUT->header();
! 
! 	} else {
! 		$strediting = '<a href="edit.php?courseid='.$COURSE->id.'">'.get_string("editquestions", "quiz").'</a> -> '.$streditingquestion;
! 		$PAGE->navbar->add(get_string('editquestions', 'quiz'), $returnurl);
! 		$PAGE->navbar->add($streditingquestion);
! 		echo $OUTPUT->header();
! 	}
! 
! 	// Display a heading, question editing form and possibly some extra content needed for
! 	// for this question type.
! 	$QTYPES[$question->qtype]->display_question_editing_page($mform, $question, $wizardnow);
! 	echo $OUTPUT->footer();
  }
  
diff -crB questionorg/simpletest/testimportexport.php questionupd/simpletest/testimportexport.php
*** questionorg/simpletest/testimportexport.php	2012-04-13 12:31:11.852178262 +0500
--- questionupd/simpletest/testimportexport.php	2012-04-13 09:42:56.000000000 +0500
***************
*** 36,48 ****
   * @license http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
   */
  class testable_qformat extends qformat_default {
!     public function assemble_category_path($names) {
!         return parent::assemble_category_path($names);
!     }
  
!     public function split_category_path($names) {
!         return parent::split_category_path($names);
!     }
  }
  
  
--- 36,48 ----
   * @license http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
   */
  class testable_qformat extends qformat_default {
! 	public function assemble_category_path($names) {
! 		return parent::assemble_category_path($names);
! 	}
  
! 	public function split_category_path($names) {
! 		return parent::split_category_path($names);
! 	}
  }
  
  
***************
*** 53,88 ****
   * @license http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
   */
  class qformat_default_test extends UnitTestCase {
!     public function test_assemble_category_path() {
!         $format = new testable_qformat();
!         $pathsections = array(
              '$course$',
              "Tim's questions",
              "Tricky things like / // and so on",
              'Category name ending in /',
              '/ and one that starts with one',
              '<span lang="en" class="multilang">Matematically</span> <span lang="sv" class="multilang">Matematiskt (svenska)</span>'
!         );
!         $this->assertEqual('$course$/Tim\'s questions/Tricky things like // //// and so on/Category name ending in // / // and one that starts with one/<span lang="en" class="multilang">Matematically<//span> <span lang="sv" class="multilang">Matematiskt (svenska)<//span>',
!                 $format->assemble_category_path($pathsections));
!     }
  
!     public function test_split_category_path() {
!         $format = new testable_qformat();
!         $path = '$course$/Tim\'s questions/Tricky things like // //// and so on/Category name ending in // / // and one that starts with one/<span lang="en" class="multilang">Matematically<//span> <span lang="sv" class="multilang">Matematiskt (svenska)<//span>';
!         $this->assertEqual(array(
                      '$course$',
                      "Tim's questions",
                      "Tricky things like / // and so on",
                      'Category name ending in /',
                      '/ and one that starts with one',
                      '<span lang="en" class="multilang">Matematically</span> <span lang="sv" class="multilang">Matematiskt (svenska)</span>'
!                 ), $format->split_category_path($path));
!     }
  
!     public function test_split_category_path_cleans() {
!         $format = new testable_qformat();
!         $path = '<evil>Nasty <virus //> thing<//evil>';
!         $this->assertEqual(array('Nasty  thing'), $format->split_category_path($path));
!     }
  }
--- 53,88 ----
   * @license http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
   */
  class qformat_default_test extends UnitTestCase {
! 	public function test_assemble_category_path() {
! 		$format = new testable_qformat();
! 		$pathsections = array(
              '$course$',
              "Tim's questions",
              "Tricky things like / // and so on",
              'Category name ending in /',
              '/ and one that starts with one',
              '<span lang="en" class="multilang">Matematically</span> <span lang="sv" class="multilang">Matematiskt (svenska)</span>'
!             );
!             $this->assertEqual('$course$/Tim\'s questions/Tricky things like // //// and so on/Category name ending in // / // and one that starts with one/<span lang="en" class="multilang">Matematically<//span> <span lang="sv" class="multilang">Matematiskt (svenska)<//span>',
!             $format->assemble_category_path($pathsections));
! 	}
  
! 	public function test_split_category_path() {
! 		$format = new testable_qformat();
! 		$path = '$course$/Tim\'s questions/Tricky things like // //// and so on/Category name ending in // / // and one that starts with one/<span lang="en" class="multilang">Matematically<//span> <span lang="sv" class="multilang">Matematiskt (svenska)<//span>';
! 		$this->assertEqual(array(
                      '$course$',
                      "Tim's questions",
                      "Tricky things like / // and so on",
                      'Category name ending in /',
                      '/ and one that starts with one',
                      '<span lang="en" class="multilang">Matematically</span> <span lang="sv" class="multilang">Matematiskt (svenska)</span>'
!                     ), $format->split_category_path($path));
! 	}
  
! 	public function test_split_category_path_cleans() {
! 		$format = new testable_qformat();
! 		$path = '<evil>Nasty <virus //> thing<//evil>';
! 		$this->assertEqual(array('Nasty  thing'), $format->split_category_path($path));
! 	}
  }
diff -crB questionorg/toggleflag.php questionupd/toggleflag.php
*** questionorg/toggleflag.php	2012-04-13 12:31:14.533178306 +0500
--- questionupd/toggleflag.php	2012-04-13 09:42:56.000000000 +0500
***************
*** 20,26 ****
  
  // Check the sesskey.
  if (!confirm_sesskey()) {
!     echo 'sesskey failure';
  }
  
  // Check the checksum - it is very hard to know who a question session belongs
--- 20,26 ----
  
  // Check the sesskey.
  if (!confirm_sesskey()) {
! 	echo 'sesskey failure';
  }
  
  // Check the checksum - it is very hard to know who a question session belongs
***************
*** 29,47 ****
  // probably makes it sufficiently difficult for malicious users to toggle
  // other users flags.
  if ($checksum != md5($attemptid . "_" . $USER->secret . "_" . $questionid . "_" . $sessionid)) {
!     echo 'checksum failure';
  }
  
  // Check that the requested session really exists
  $questionsession = $DB->get_record('question_sessions', array('id' => $sessionid,
          'attemptid' => $attemptid, 'questionid' => $questionid));
  if (!$questionsession) {
!     echo 'invalid ids';
  }
  
  // Now change state
  if (!question_update_flag($sessionid, $newstate)) {
!     echo 'update failed';
  }
  
  echo 'OK';
--- 29,47 ----
  // probably makes it sufficiently difficult for malicious users to toggle
  // other users flags.
  if ($checksum != md5($attemptid . "_" . $USER->secret . "_" . $questionid . "_" . $sessionid)) {
! 	echo 'checksum failure';
  }
  
  // Check that the requested session really exists
  $questionsession = $DB->get_record('question_sessions', array('id' => $sessionid,
          'attemptid' => $attemptid, 'questionid' => $questionid));
  if (!$questionsession) {
! 	echo 'invalid ids';
  }
  
  // Now change state
  if (!question_update_flag($sessionid, $newstate)) {
! 	echo 'update failed';
  }
  
  echo 'OK';
diff -crB questionorg/type/calculated/backup/moodle2/backup_qtype_calculated_plugin.class.php questionupd/type/calculated/backup/moodle2/backup_qtype_calculated_plugin.class.php
*** questionorg/type/calculated/backup/moodle2/backup_qtype_calculated_plugin.class.php	2012-04-13 12:31:11.942178264 +0500
--- questionupd/type/calculated/backup/moodle2/backup_qtype_calculated_plugin.class.php	2012-04-13 09:42:56.000000000 +0500
***************
*** 28,109 ****
   */
  class backup_qtype_calculated_plugin extends backup_qtype_plugin {
  
!     /**
!      * Returns the qtype information to attach to question element
!      */
!     protected function define_question_plugin_structure() {
! 
!         // Define the virtual plugin element with the condition to fulfill
!         // Note: we use $this->pluginname so for extended plugins this will work
!         // automatically: calculatedsimple and calculatedmulti
!         $plugin = $this->get_plugin_element(null, '../../qtype', $this->pluginname);
! 
!         // Create one standard named plugin element (the visible container)
!         $pluginwrapper = new backup_nested_element($this->get_recommended_name());
! 
!         // connect the visible container ASAP
!         $plugin->add_child($pluginwrapper);
! 
!         // This qtype uses standard question_answers, add them here
!         // to the tree before any other information that will use them
!         $this->add_question_question_answers($pluginwrapper);
! 
!         // This qtype uses standard numerical units, add them here
!         $this->add_question_numerical_units($pluginwrapper);
! 
!         // This qtype uses standard numerical options, add them here
!         $this->add_question_numerical_options($pluginwrapper);
! 
!         // This qtype uses standard datasets, add them here
!         $this->add_question_datasets($pluginwrapper);
! 
!         // Now create the qtype own structures
!         $calculatedrecords = new backup_nested_element('calculated_records');
!         $calculatedrecord = new backup_nested_element('calculated_record', array('id'), array(
              'answer', 'tolerance', 'tolerancetype', 'correctanswerlength',
              'correctanswerformat'));
  
!         $calculatedoptions = new backup_nested_element('calculated_options');
!         $calculatedoption = new backup_nested_element('calculated_option', array('id'), array(
              'synchronize', 'single', 'shuffleanswers', 'correctfeedback',
              'correctfeedbackformat', 'partiallycorrectfeedback', 'partiallycorrectfeedbackformat', 'incorrectfeedback',
              'incorrectfeedbackformat', 'answernumbering'));
  
!         // Now the own qtype tree
!         $pluginwrapper->add_child($calculatedrecords);
!         $calculatedrecords->add_child($calculatedrecord);
! 
!         $pluginwrapper->add_child($calculatedoptions);
!         $calculatedoptions->add_child($calculatedoption);
! 
!         // set source to populate the data
!         $calculatedrecord->set_source_table('question_calculated', array('question' => backup::VAR_PARENTID));
!         $calculatedoption->set_source_table('question_calculated_options', array('question' => backup::VAR_PARENTID));
! 
!         // don't need to annotate ids nor files
! 
!         return $plugin;
!     }
! 
!     /**
!      * Returns one array with filearea => mappingname elements for the qtype
!      *
!      * Used by {@link get_components_and_fileareas} to know about all the qtype
!      * files to be processed both in backup and restore.
!      */
!     public static function get_qtype_fileareas() {
!         // TODO: Discuss. Commented below are the "in theory" correct
!         // mappings for those fileareas. Instead we are using question for
!         // them, that will cause problems in the future if we want to change
!         // any of them to be 1..n (i.e. we should be always pointing to own id)
!         return array(
!             //'instruction' => 'question_numerical_option',
!             //'correctfeedback' => 'question_calculated_option',
!             //'partiallycorrectfeedback' => 'question_calculated_option',
!             //'incorrectfeedback' => 'question_calculated_option');
              'instruction' => 'question_created',
              'correctfeedback' => 'question_created',
              'partiallycorrectfeedback' => 'question_created',
              'incorrectfeedback' => 'question_created');
!     }
  }
--- 28,109 ----
   */
  class backup_qtype_calculated_plugin extends backup_qtype_plugin {
  
! 	/**
! 	 * Returns the qtype information to attach to question element
! 	 */
! 	protected function define_question_plugin_structure() {
! 
! 		// Define the virtual plugin element with the condition to fulfill
! 		// Note: we use $this->pluginname so for extended plugins this will work
! 		// automatically: calculatedsimple and calculatedmulti
! 		$plugin = $this->get_plugin_element(null, '../../qtype', $this->pluginname);
! 
! 		// Create one standard named plugin element (the visible container)
! 		$pluginwrapper = new backup_nested_element($this->get_recommended_name());
! 
! 		// connect the visible container ASAP
! 		$plugin->add_child($pluginwrapper);
! 
! 		// This qtype uses standard question_answers, add them here
! 		// to the tree before any other information that will use them
! 		$this->add_question_question_answers($pluginwrapper);
! 
! 		// This qtype uses standard numerical units, add them here
! 		$this->add_question_numerical_units($pluginwrapper);
! 
! 		// This qtype uses standard numerical options, add them here
! 		$this->add_question_numerical_options($pluginwrapper);
! 
! 		// This qtype uses standard datasets, add them here
! 		$this->add_question_datasets($pluginwrapper);
! 
! 		// Now create the qtype own structures
! 		$calculatedrecords = new backup_nested_element('calculated_records');
! 		$calculatedrecord = new backup_nested_element('calculated_record', array('id'), array(
              'answer', 'tolerance', 'tolerancetype', 'correctanswerlength',
              'correctanswerformat'));
  
! 		$calculatedoptions = new backup_nested_element('calculated_options');
! 		$calculatedoption = new backup_nested_element('calculated_option', array('id'), array(
              'synchronize', 'single', 'shuffleanswers', 'correctfeedback',
              'correctfeedbackformat', 'partiallycorrectfeedback', 'partiallycorrectfeedbackformat', 'incorrectfeedback',
              'incorrectfeedbackformat', 'answernumbering'));
  
! 		// Now the own qtype tree
! 		$pluginwrapper->add_child($calculatedrecords);
! 		$calculatedrecords->add_child($calculatedrecord);
! 
! 		$pluginwrapper->add_child($calculatedoptions);
! 		$calculatedoptions->add_child($calculatedoption);
! 
! 		// set source to populate the data
! 		$calculatedrecord->set_source_table('question_calculated', array('question' => backup::VAR_PARENTID));
! 		$calculatedoption->set_source_table('question_calculated_options', array('question' => backup::VAR_PARENTID));
! 
! 		// don't need to annotate ids nor files
! 
! 		return $plugin;
! 	}
! 
! 	/**
! 	 * Returns one array with filearea => mappingname elements for the qtype
! 	 *
! 	 * Used by {@link get_components_and_fileareas} to know about all the qtype
! 	 * files to be processed both in backup and restore.
! 	 */
! 	public static function get_qtype_fileareas() {
! 		// TODO: Discuss. Commented below are the "in theory" correct
! 		// mappings for those fileareas. Instead we are using question for
! 		// them, that will cause problems in the future if we want to change
! 		// any of them to be 1..n (i.e. we should be always pointing to own id)
! 		return array(
! 		//'instruction' => 'question_numerical_option',
! 		//'correctfeedback' => 'question_calculated_option',
! 		//'partiallycorrectfeedback' => 'question_calculated_option',
! 		//'incorrectfeedback' => 'question_calculated_option');
              'instruction' => 'question_created',
              'correctfeedback' => 'question_created',
              'partiallycorrectfeedback' => 'question_created',
              'incorrectfeedback' => 'question_created');
! 	}
  }
diff -crB questionorg/type/calculated/backup/moodle2/restore_qtype_calculated_plugin.class.php questionupd/type/calculated/backup/moodle2/restore_qtype_calculated_plugin.class.php
*** questionorg/type/calculated/backup/moodle2/restore_qtype_calculated_plugin.class.php	2012-04-13 12:31:11.900178263 +0500
--- questionupd/type/calculated/backup/moodle2/restore_qtype_calculated_plugin.class.php	2012-04-13 09:42:56.000000000 +0500
***************
*** 30,116 ****
   */
  class restore_qtype_calculated_plugin extends restore_qtype_plugin {
  
!     /**
!      * Returns the paths to be handled by the plugin at question level
!      */
!     protected function define_question_plugin_structure() {
! 
!         $paths = array();
! 
!         // This qtype uses question_answers, add them
!         $this->add_question_question_answers($paths);
! 
!         // This qtype uses question_numerical_options and question_numerical_units, add them
!         $this->add_question_numerical_options($paths);
!         $this->add_question_numerical_units($paths);
! 
!         // This qtype uses question datasets, add them
!         $this->add_question_datasets($paths);
! 
!         // Add own qtype stuff
!         $elename = 'calculated_record';
!         $elepath = $this->get_pathfor('/calculated_records/calculated_record'); // we used get_recommended_name() so this works
!         $paths[] = new restore_path_element($elename, $elepath);
! 
!         $elename = 'calculated_option';
!         $elepath = $this->get_pathfor('/calculated_options/calculated_option'); // we used get_recommended_name() so this works
!         $paths[] = new restore_path_element($elename, $elepath);
! 
!         return $paths; // And we return the interesting paths
!     }
! 
!     /**
!      * Process the qtype/calculated_record element
!      */
!     public function process_calculated_record($data) {
!         global $DB;
! 
!         $data = (object)$data;
!         $oldid = $data->id;
! 
!         // Detect if the question is created or mapped
!         $oldquestionid   = $this->get_old_parentid('question');
!         $newquestionid   = $this->get_new_parentid('question');
!         $questioncreated = $this->get_mappingid('question_created', $oldquestionid) ? true : false;
! 
!         // If the question has been created by restore, we need to create its question_calculated too
!         if ($questioncreated) {
!             // Adjust some columns
!             $data->question = $newquestionid;
!             $data->answer = $this->get_mappingid('question_answer', $data->answer);
!             // Insert record
!             $newitemid = $DB->insert_record('question_calculated', $data);
!             // Create mapping (not needed, no files nor childs nor states here)
!             //$this->set_mapping('question_calculated', $oldid, $newitemid);
!         } else {
!             // Nothing to remap if the question already existed
!         }
!     }
! 
!     /**
!      * Process the qtype/calculated_option element
!      */
!     public function process_calculated_option($data) {
!         global $DB;
! 
!         $data = (object)$data;
!         $oldid = $data->id;
! 
!         // Detect if the question is created or mapped
!         $oldquestionid   = $this->get_old_parentid('question');
!         $newquestionid   = $this->get_new_parentid('question');
!         $questioncreated = $this->get_mappingid('question_created', $oldquestionid) ? true : false;
! 
!         // If the question has been created by restore, we need to create its question_calculated too
!         if ($questioncreated) {
!             // Adjust some columns
!             $data->question = $newquestionid;
!             // Insert record
!             $newitemid = $DB->insert_record('question_calculated_options', $data);
!             // Create mapping (not needed, no files nor childs nor states here)
!             // $this->set_mapping('question_calculated_option', $oldid, $newitemid);
!         } else {
!             // Nothing to remap if the question already existed
!         }
!     }
  }
--- 30,116 ----
   */
  class restore_qtype_calculated_plugin extends restore_qtype_plugin {
  
! 	/**
! 	 * Returns the paths to be handled by the plugin at question level
! 	 */
! 	protected function define_question_plugin_structure() {
! 
! 		$paths = array();
! 
! 		// This qtype uses question_answers, add them
! 		$this->add_question_question_answers($paths);
! 
! 		// This qtype uses question_numerical_options and question_numerical_units, add them
! 		$this->add_question_numerical_options($paths);
! 		$this->add_question_numerical_units($paths);
! 
! 		// This qtype uses question datasets, add them
! 		$this->add_question_datasets($paths);
! 
! 		// Add own qtype stuff
! 		$elename = 'calculated_record';
! 		$elepath = $this->get_pathfor('/calculated_records/calculated_record'); // we used get_recommended_name() so this works
! 		$paths[] = new restore_path_element($elename, $elepath);
! 
! 		$elename = 'calculated_option';
! 		$elepath = $this->get_pathfor('/calculated_options/calculated_option'); // we used get_recommended_name() so this works
! 		$paths[] = new restore_path_element($elename, $elepath);
! 
! 		return $paths; // And we return the interesting paths
! 	}
! 
! 	/**
! 	 * Process the qtype/calculated_record element
! 	 */
! 	public function process_calculated_record($data) {
! 		global $DB;
! 
! 		$data = (object)$data;
! 		$oldid = $data->id;
! 
! 		// Detect if the question is created or mapped
! 		$oldquestionid   = $this->get_old_parentid('question');
! 		$newquestionid   = $this->get_new_parentid('question');
! 		$questioncreated = $this->get_mappingid('question_created', $oldquestionid) ? true : false;
! 
! 		// If the question has been created by restore, we need to create its question_calculated too
! 		if ($questioncreated) {
! 			// Adjust some columns
! 			$data->question = $newquestionid;
! 			$data->answer = $this->get_mappingid('question_answer', $data->answer);
! 			// Insert record
! 			$newitemid = $DB->insert_record('question_calculated', $data);
! 			// Create mapping (not needed, no files nor childs nor states here)
! 			//$this->set_mapping('question_calculated', $oldid, $newitemid);
! 		} else {
! 			// Nothing to remap if the question already existed
! 		}
! 	}
! 
! 	/**
! 	 * Process the qtype/calculated_option element
! 	 */
! 	public function process_calculated_option($data) {
! 		global $DB;
! 
! 		$data = (object)$data;
! 		$oldid = $data->id;
! 
! 		// Detect if the question is created or mapped
! 		$oldquestionid   = $this->get_old_parentid('question');
! 		$newquestionid   = $this->get_new_parentid('question');
! 		$questioncreated = $this->get_mappingid('question_created', $oldquestionid) ? true : false;
! 
! 		// If the question has been created by restore, we need to create its question_calculated too
! 		if ($questioncreated) {
! 			// Adjust some columns
! 			$data->question = $newquestionid;
! 			// Insert record
! 			$newitemid = $DB->insert_record('question_calculated_options', $data);
! 			// Create mapping (not needed, no files nor childs nor states here)
! 			// $this->set_mapping('question_calculated_option', $oldid, $newitemid);
! 		} else {
! 			// Nothing to remap if the question already existed
! 		}
! 	}
  }
diff -crB questionorg/type/calculated/datasetdefinitions_form.php questionupd/type/calculated/datasetdefinitions_form.php
*** questionorg/type/calculated/datasetdefinitions_form.php	2012-04-13 12:31:12.003178265 +0500
--- questionupd/type/calculated/datasetdefinitions_form.php	2012-04-13 09:42:56.000000000 +0500
***************
*** 5,160 ****
   */
  
  class question_dataset_dependent_definitions_form extends moodleform {
!     /**
!      * Question object with options and answers already loaded by get_question_options
!      * Be careful how you use this it is needed sometimes to set up the structure of the
!      * form in definition_inner but data is always loaded into the form with set_defaults.
!      *
!      * @var object
!      */
!     var $question;
!     /**
!      * Reference to question type object
!      *
!      * @var question_dataset_dependent_questiontype
!      */
!     var $qtypeobj;
!     /**
!      * Add question-type specific form fields.
!      *
!      * @param MoodleQuickForm $mform the form being built.
!      */
!     function question_dataset_dependent_definitions_form($submiturl, $question){
!         global $QTYPES, $DB;
!         $this->question = $question;
!         $this->qtypeobj =& $QTYPES[$this->question->qtype];
!         // Validate the question category.
!         if (!$category = $DB->get_record('question_categories', array('id' => $question->category))) {
!             print_error('categorydoesnotexist', 'question', $returnurl);
!         }
!         $this->category = $category;
!         $this->categorycontext = get_context_instance_by_id($category->contextid);
!         parent::moodleform($submiturl);
!     }
!     function definition() {
!         global $SESSION;
!         $mform =& $this->_form;
!         $possibledatasets = $this->qtypeobj->find_dataset_names($this->question->questiontext);
!         $mandatorydatasets = array();
!         if (isset($this->question->options->answers)){
!             foreach ($this->question->options->answers as $answer) {
!                 $mandatorydatasets += $this->qtypeobj->find_dataset_names($answer->answer);
!             }
!         }else{
!             foreach ($SESSION->calculated->questionform->answers as $answer){
!                 $mandatorydatasets += $this->qtypeobj->find_dataset_names($answer);
!             }
!         }
! 
!         $key = 0;
!         $datadefscat= array();
!         $datadefscat  = $this->qtypeobj->get_dataset_definitions_category($this->question);
!         $datasetmenus = array();
!         $label = "<div class='mdl-align'>".get_string('datasetrole', 'qtype_calculated')."</div>";
!         $mform->addElement('html', $label);// explaining the role of datasets so other strings can be shortened
!         $mform->addElement('header', 'mandatoryhdr', get_string('mandatoryhdr', 'qtype_calculated'));
!         $labelsharedwildcard = get_string('sharedwildcard', 'qtype_calculated');
! 
!         foreach ($mandatorydatasets as $datasetname) {
!             if (!isset($datasetmenus[$datasetname])) {
!                 list($options, $selected) =
!                         $this->qtypeobj->dataset_options($this->question, $datasetname);
!                 unset($options['0']); // Mandatory...
!                 $label = get_string("wildcard", "quiz"). " <strong>$datasetname</strong> ";
!                 $mform->addElement('select', "dataset[$key]", $label, $options);
!              if (isset($datadefscat[$datasetname])){
!                   $mform->addElement('static', "there is a category", get_string('sharedwildcard', 'qtype_calculated',$datasetname ), get_string('dataitemdefined','qtype_calculated', $datadefscat[$datasetname]));
!             }
!                 $mform->setDefault("dataset[$key]", $selected);
!                 $datasetmenus[$datasetname]='';
!                 $key++;
!             }
!         }
!                         $mform->addElement('header', 'possiblehdr', get_string('possiblehdr', 'qtype_calculated'));
! 
! 
!         foreach ($possibledatasets as $datasetname) {
!             if (!isset($datasetmenus[$datasetname])) {
!                 list($options, $selected) =
!                         $this->qtypeobj->dataset_options($this->question, $datasetname,false);
!                 $label = get_string("wildcard", "quiz"). " <strong>$datasetname</strong> ";
!                 $mform->addElement('select', "dataset[$key]", $label, $options);
!                  //       $mform->addRule("dataset[$key]", null, 'required', null, 'client');
!              if (isset($datadefscat[$datasetname])){
!                   $mform->addElement('static', "there is a category", get_string('sharedwildcard', 'qtype_calculated',$datasetname ), get_string('dataitemdefined',"qtype_calculated", $datadefscat[$datasetname]));
!             }
! 
!               //   $selected ="0";
!                 $mform->setDefault("dataset[$key]", $selected);
!                 $datasetmenus[$datasetname]='';
!                 $key++;
!             }
!         }
!         // temporary strings
!         // temporary strings
!         $mform->addElement('header', 'synchronizehdr', get_string('synchronize', 'qtype_calculated'));
!         $mform->addElement('radio', 'synchronize', '', get_string('synchronizeno', 'qtype_calculated'),0);
!         $mform->addElement('radio', 'synchronize', '', get_string('synchronizeyes', 'qtype_calculated'),1);
!         $mform->addElement('radio', 'synchronize', '', get_string('synchronizeyesdisplay', 'qtype_calculated'),2);
!         if (isset($this->question->options)&& isset($this->question->options->synchronize) ){
!             $mform->setDefault("synchronize", $this->question->options->synchronize);
!         } else {
!             $mform->setDefault("synchronize", 0 );
!         }
! 
!         $this->add_action_buttons(false, get_string('nextpage', 'qtype_calculated'));
! 
! 
!         //hidden elements
!         $mform->addElement('hidden', 'returnurl');
!         $mform->setType('returnurl', PARAM_LOCALURL);
!         $mform->setDefault('returnurl', 0);
!         $mform->addElement('hidden', 'id');
!         $mform->setType('id', PARAM_INT);
! 
!         $mform->addElement('hidden', 'category');
!         $mform->setType('category', PARAM_RAW);
!         $mform->setDefault('category', array('contexts' => array($this->categorycontext)));
! 
!         $mform->addElement('hidden', 'courseid');
!         $mform->setType('courseid', PARAM_INT);
!         $mform->setDefault('courseid', 0);
! 
!         $mform->addElement('hidden', 'cmid');
!         $mform->setType('cmid', PARAM_INT);
!         $mform->setDefault('cmid', 0);
! 
!         $mform->setType('id', PARAM_INT);
!         $mform->addElement('hidden', 'wizard', 'datasetitems');
!         $mform->setType('wizard', PARAM_ALPHA);
!     }
! /*    function set_data($question) {
!         $formdata = array();
!         $fromform = new stdClass();
!                   $default_values['synchronize'] = $question->options->synchronize ;
!         $question = (object)((array)$question + $default_values);
!     }*/
!     function validation($data, $files) {
!         $errors = parent::validation($data, $files);
!         $datasets = $data['dataset'];
!         $countvalid = 0 ;
!         foreach ($datasets as $key => $dataset){
!             if ($dataset !="0") {
!                 $countvalid++;
!             }
!         }
!         if (!$countvalid){
!             foreach ($datasets as $key => $dataset){
!                 $errors['dataset['.$key.']'] = get_string('atleastonerealdataset', 'qtype_calculated');
!             }
!        }
!         return $errors;
!     }
  
  }
  
--- 5,160 ----
   */
  
  class question_dataset_dependent_definitions_form extends moodleform {
! 	/**
! 	 * Question object with options and answers already loaded by get_question_options
! 	 * Be careful how you use this it is needed sometimes to set up the structure of the
! 	 * form in definition_inner but data is always loaded into the form with set_defaults.
! 	 *
! 	 * @var object
! 	 */
! 	var $question;
! 	/**
! 	 * Reference to question type object
! 	 *
! 	 * @var question_dataset_dependent_questiontype
! 	 */
! 	var $qtypeobj;
! 	/**
! 	 * Add question-type specific form fields.
! 	 *
! 	 * @param MoodleQuickForm $mform the form being built.
! 	 */
! 	function question_dataset_dependent_definitions_form($submiturl, $question){
! 		global $QTYPES, $DB;
! 		$this->question = $question;
! 		$this->qtypeobj =& $QTYPES[$this->question->qtype];
! 		// Validate the question category.
! 		if (!$category = $DB->get_record('question_categories', array('id' => $question->category))) {
! 			print_error('categorydoesnotexist', 'question', $returnurl);
! 		}
! 		$this->category = $category;
! 		$this->categorycontext = get_context_instance_by_id($category->contextid);
! 		parent::moodleform($submiturl);
! 	}
! 	function definition() {
! 		global $SESSION;
! 		$mform =& $this->_form;
! 		$possibledatasets = $this->qtypeobj->find_dataset_names($this->question->questiontext);
! 		$mandatorydatasets = array();
! 		if (isset($this->question->options->answers)){
! 			foreach ($this->question->options->answers as $answer) {
! 				$mandatorydatasets += $this->qtypeobj->find_dataset_names($answer->answer);
! 			}
! 		}else{
! 			foreach ($SESSION->calculated->questionform->answers as $answer){
! 				$mandatorydatasets += $this->qtypeobj->find_dataset_names($answer);
! 			}
! 		}
! 
! 		$key = 0;
! 		$datadefscat= array();
! 		$datadefscat  = $this->qtypeobj->get_dataset_definitions_category($this->question);
! 		$datasetmenus = array();
! 		$label = "<div class='mdl-align'>".get_string('datasetrole', 'qtype_calculated')."</div>";
! 		$mform->addElement('html', $label);// explaining the role of datasets so other strings can be shortened
! 		$mform->addElement('header', 'mandatoryhdr', get_string('mandatoryhdr', 'qtype_calculated'));
! 		$labelsharedwildcard = get_string('sharedwildcard', 'qtype_calculated');
! 
! 		foreach ($mandatorydatasets as $datasetname) {
! 			if (!isset($datasetmenus[$datasetname])) {
! 				list($options, $selected) =
! 				$this->qtypeobj->dataset_options($this->question, $datasetname);
! 				unset($options['0']); // Mandatory...
! 				$label = get_string("wildcard", "quiz"). " <strong>$datasetname</strong> ";
! 				$mform->addElement('select', "dataset[$key]", $label, $options);
! 				if (isset($datadefscat[$datasetname])){
! 					$mform->addElement('static', "there is a category", get_string('sharedwildcard', 'qtype_calculated',$datasetname ), get_string('dataitemdefined','qtype_calculated', $datadefscat[$datasetname]));
! 				}
! 				$mform->setDefault("dataset[$key]", $selected);
! 				$datasetmenus[$datasetname]='';
! 				$key++;
! 			}
! 		}
! 		$mform->addElement('header', 'possiblehdr', get_string('possiblehdr', 'qtype_calculated'));
! 
! 
! 		foreach ($possibledatasets as $datasetname) {
! 			if (!isset($datasetmenus[$datasetname])) {
! 				list($options, $selected) =
! 				$this->qtypeobj->dataset_options($this->question, $datasetname,false);
! 				$label = get_string("wildcard", "quiz"). " <strong>$datasetname</strong> ";
! 				$mform->addElement('select', "dataset[$key]", $label, $options);
! 				//       $mform->addRule("dataset[$key]", null, 'required', null, 'client');
! 				if (isset($datadefscat[$datasetname])){
! 					$mform->addElement('static', "there is a category", get_string('sharedwildcard', 'qtype_calculated',$datasetname ), get_string('dataitemdefined',"qtype_calculated", $datadefscat[$datasetname]));
! 				}
! 
! 				//   $selected ="0";
! 				$mform->setDefault("dataset[$key]", $selected);
! 				$datasetmenus[$datasetname]='';
! 				$key++;
! 			}
! 		}
! 		// temporary strings
! 		// temporary strings
! 		$mform->addElement('header', 'synchronizehdr', get_string('synchronize', 'qtype_calculated'));
! 		$mform->addElement('radio', 'synchronize', '', get_string('synchronizeno', 'qtype_calculated'),0);
! 		$mform->addElement('radio', 'synchronize', '', get_string('synchronizeyes', 'qtype_calculated'),1);
! 		$mform->addElement('radio', 'synchronize', '', get_string('synchronizeyesdisplay', 'qtype_calculated'),2);
! 		if (isset($this->question->options)&& isset($this->question->options->synchronize) ){
! 			$mform->setDefault("synchronize", $this->question->options->synchronize);
! 		} else {
! 			$mform->setDefault("synchronize", 0 );
! 		}
! 
! 		$this->add_action_buttons(false, get_string('nextpage', 'qtype_calculated'));
! 
! 
! 		//hidden elements
! 		$mform->addElement('hidden', 'returnurl');
! 		$mform->setType('returnurl', PARAM_LOCALURL);
! 		$mform->setDefault('returnurl', 0);
! 		$mform->addElement('hidden', 'id');
! 		$mform->setType('id', PARAM_INT);
! 
! 		$mform->addElement('hidden', 'category');
! 		$mform->setType('category', PARAM_RAW);
! 		$mform->setDefault('category', array('contexts' => array($this->categorycontext)));
! 
! 		$mform->addElement('hidden', 'courseid');
! 		$mform->setType('courseid', PARAM_INT);
! 		$mform->setDefault('courseid', 0);
! 
! 		$mform->addElement('hidden', 'cmid');
! 		$mform->setType('cmid', PARAM_INT);
! 		$mform->setDefault('cmid', 0);
! 
! 		$mform->setType('id', PARAM_INT);
! 		$mform->addElement('hidden', 'wizard', 'datasetitems');
! 		$mform->setType('wizard', PARAM_ALPHA);
! 	}
! 	/*    function set_data($question) {
! 	 $formdata = array();
! 	 $fromform = new stdClass();
! 	 $default_values['synchronize'] = $question->options->synchronize ;
! 	 $question = (object)((array)$question + $default_values);
! 	 }*/
! 	function validation($data, $files) {
! 		$errors = parent::validation($data, $files);
! 		$datasets = $data['dataset'];
! 		$countvalid = 0 ;
! 		foreach ($datasets as $key => $dataset){
! 			if ($dataset !="0") {
! 				$countvalid++;
! 			}
! 		}
! 		if (!$countvalid){
! 			foreach ($datasets as $key => $dataset){
! 				$errors['dataset['.$key.']'] = get_string('atleastonerealdataset', 'qtype_calculated');
! 			}
! 		}
! 		return $errors;
! 	}
  
  }
  
diff -crB questionorg/type/calculated/datasetitems_form.php questionupd/type/calculated/datasetitems_form.php
*** questionorg/type/calculated/datasetitems_form.php	2012-04-13 12:31:12.006178265 +0500
--- questionupd/type/calculated/datasetitems_form.php	2012-04-13 09:42:56.000000000 +0500
***************
*** 1,437 ****
  <?php
  class question_dataset_dependent_items_form extends moodleform {
!     /**
!      * Question object with options and answers already loaded by get_question_options
!      * Be careful how you use this it is needed sometimes to set up the structure of the
!      * form in definition_inner but data is always loaded into the form with set_defaults.
!      *
!      * @var object
!      */
!     public $question;
!     /**
!      * Reference to question type object
!      *
!      * @var question_dataset_dependent_questiontype
!      */
!     public $qtypeobj;
! 
!     public $datasetdefs;
! 
!     public $maxnumber = -1;
! 
!     public $regenerate;
! 
!     public $noofitems;
! 
!     public $outsidelimit = false ;
! 
!     public $commentanswers = array();
!     /**
!      * Add question-type specific form fields.
!      *
!      * @param MoodleQuickForm $mform the form being built.
!      */
!     function question_dataset_dependent_items_form($submiturl, $question, $regenerate){
!         global $QTYPES, $SESSION, $CFG, $DB;
!         $this->regenerate = $regenerate;
!         $this->question = $question;
!         $this->qtypeobj =& $QTYPES[$this->question->qtype];
!         // Validate the question category.
!         if (!$category = $DB->get_record('question_categories', array('id' => $question->category))) {
!             print_error('categorydoesnotexist', 'question', $returnurl);
!         }
!         $this->category = $category;
!         $this->categorycontext = get_context_instance_by_id($category->contextid);
!         //get the dataset defintions for this question
!         if (empty($question->id)) {
!             $this->datasetdefs = $this->qtypeobj->get_dataset_definitions($question->id, $SESSION->calculated->definitionform->dataset);
!         } else {
!             if (empty($question->options)) {
!                 $this->get_question_options($question);
!             }
!             $this->datasetdefs = $this->qtypeobj->get_dataset_definitions($question->id, array());
!         }
! 
!         foreach ($this->datasetdefs as $datasetdef) {
!             // Get maxnumber
!             if ($this->maxnumber == -1 || $datasetdef->itemcount < $this->maxnumber) {
!                 $this->maxnumber = $datasetdef->itemcount;
!             }
!         }
!         foreach ($this->datasetdefs as $defid => $datasetdef) {
!             if (isset($datasetdef->id)) {
!                 $this->datasetdefs[$defid]->items = $this->qtypeobj->get_database_dataset_items($datasetdef->id);
!             }
!         }
!         parent::moodleform($submiturl);
!     }
!     function definition() {
!                 $labelsharedwildcard = get_string("sharedwildcard", "qtype_calculated");
! 
!         $mform =& $this->_form;
!         $strquestionlabel = $this->qtypeobj->comment_header($this->question);
!         if ($this->maxnumber != -1){
!             $this->noofitems = $this->maxnumber;
!         } else {
!             $this->noofitems = 0;
!         }
!         $label = get_string("sharedwildcards", "qtype_calculated");
! //
!                 $html2 = $this->qtypeobj->print_dataset_definitions_category_shared($this->question,$this->datasetdefs);
!                 $mform->addElement('static','listcategory',$label,$html2);
! //------------------------------------------------------------------------------------------------------------------------------
!         $mform->addElement('submit', 'updatedatasets', get_string('updatedatasetparam', 'qtype_calculated'));
!         $mform->registerNoSubmitButton('updatedatasets');
!         $mform->addElement('header', 'additemhdr', get_string('itemtoadd', 'qtype_calculated'));
!         $idx = 1;
!         $data = array();
!         $j = (($this->noofitems) * count($this->datasetdefs))+1;
!         foreach ($this->datasetdefs as $defkey => $datasetdef){
!             if($datasetdef->category |= 0 ) { 
!                 $name = get_string('sharedwildcardname', 'qtype_calculated',$datasetdef->name) ;
!             }else {
!                 $name = get_string('wildcard', 'qtype_calculated', $datasetdef->name);
!             }
!             $mform->addElement('text', "number[$j]", $name);
!             $mform->setType("number[$j]", PARAM_NUMBER);
!        /*     if($datasetdef->category |= 0 && $datasetdef->category == $this->category){
!                                  $mform->addElement('static', "there is a category", $labelsharedwildcard." <strong>$datasetdef->name </strong>", get_string('dataitemdefined',"qtype_calculated", $datasetdef->itemcount));
!             }else  if($datasetdef->category |= 0 && $datasetdef->category != $this->category){
!                                  $mform->addElement('static', "BAD a category", $labelsharedwildcard." <strong>$datasetdef->name </strong>", get_string('dataitemdefined',"qtype_calculated", $datasetdef->itemcount));
!         }*/
!             $this->qtypeobj->custom_generator_tools_part($mform, $idx, $j);
!             $idx++;
!             $mform->addElement('hidden', "definition[$j]");
!             $mform->setType("definition[$j]", PARAM_RAW);
!             $mform->addElement('hidden', "itemid[$j]");
!             $mform->setType("itemid[$j]", PARAM_RAW);
!             $mform->addElement('static', "divider[$j]", '', '<hr />');
!             $mform->setType("divider[$j]", PARAM_RAW);
!             $j++;
!         }
!         
!         $mform->addElement('header', 'updateanswershdr', get_string('answerstoleranceparam', 'qtype_calculated'));
!         $mform->addElement('submit', 'updateanswers', get_string('updatetolerancesparam', 'qtype_calculated'));
!         $mform->setAdvanced('updateanswers',true);
!         $mform->registerNoSubmitButton('updateanswers');
! 
!         $answers = fullclone($this->question->options->answers);
!         $key1 =1;
!         foreach ($answers as $key => $answer) {
!             if ('' === $answer->answer){
!             }else if ('*' === $answer->answer){
!                 $mform->addElement('static', 'answercomment['.($this->noofitems+$key1).']', $answer->answer);
!                 $mform->addElement('hidden', 'tolerance['.$key.']', '');
!                 $mform->setType('tolerance['.$key.']', PARAM_RAW);
!                 $mform->setAdvanced('tolerance['.$key.']',true);
!                 $mform->addElement('hidden', 'tolerancetype['.$key.']', '');
!                 $mform->setType('tolerancetype['.$key.']', PARAM_RAW);
!                 $mform->setAdvanced('tolerancetype['.$key.']',true);
!                 $mform->addElement('hidden', 'correctanswerlength['.$key.']', '');
!                 $mform->setType('correctanswerlength['.$key.']', PARAM_RAW);
!                 $mform->setAdvanced('correctanswerlength['.$key.']',true);
!                 $mform->addElement('hidden', 'correctanswerformat['.$key.']', '');
!                 $mform->setType('correctanswerformat['.$key.']', PARAM_RAW);
!                 $mform->setAdvanced('correctanswerformat['.$key.']',true);
!             }else {
!                 $mform->addElement('static', 'answercomment['.($this->noofitems+$key1).']', $answer->answer);
!                 $mform->addElement('text', 'tolerance['.$key.']', get_string('tolerance', 'qtype_calculated'));
!                 $mform->setAdvanced('tolerance['.$key.']',true);
!                 $mform->addElement('select', 'tolerancetype['.$key.']', get_string('tolerancetype', 'quiz'), $this->qtypeobj->tolerance_types());
!                 $mform->setAdvanced('tolerancetype['.$key.']',true);
! 
!                 $mform->addElement('select', 'correctanswerlength['.$key.']', get_string('correctanswershows', 'qtype_calculated'), range(0, 9));
!                 $mform->setAdvanced('correctanswerlength['.$key.']',true);
! 
!                 $answerlengthformats = array('1' => get_string('decimalformat', 'quiz'), '2' => get_string('significantfiguresformat', 'quiz'));
!                 $mform->addElement('select', 'correctanswerformat['.$key.']', get_string('correctanswershowsformat', 'qtype_calculated'), $answerlengthformats);
!                 $mform->setAdvanced('correctanswerformat['.$key.']',true);
!                 $mform->addElement('static', 'dividertolerance', '', '<hr />');
!                 $mform->setAdvanced('dividertolerance',true);
!             }
!             $key1++;
!         }
! 
!         $addremoveoptions = array();
!         $addremoveoptions['1']='1';
!         for ($i=10; $i<=100 ; $i+=10){
!              $addremoveoptions["$i"]="$i";
!         }
!         $showoptions = Array();
!         $showoptions['1']='1';
!         $showoptions['2']='2';
!         $showoptions['5']='5';
!         for ($i=10; $i<=100 ; $i+=10){
!              $showoptions["$i"]="$i";
!         }
!         $mform->addElement('header', 'additemhdr', get_string('add', 'moodle'));
!         $mform->closeHeaderBefore('additemhdr');
! 
!         if ($this->qtypeobj->supports_dataset_item_generation()){
!             $radiogrp = array();
!             $radiogrp[] =& $mform->createElement('radio', 'nextpageparam[forceregeneration]', null, get_string('reuseifpossible', 'qtype_calculated'), 0);
!             $radiogrp[] =& $mform->createElement('radio', 'nextpageparam[forceregeneration]', null, get_string('forceregenerationshared', 'qtype_calculated'), 1);
!             $radiogrp[] =& $mform->createElement('radio', 'nextpageparam[forceregeneration]', null, get_string('forceregenerationall', 'qtype_calculated'), 2);
!             $mform->addGroup($radiogrp, 'forceregenerationgrp', get_string('nextitemtoadd', 'qtype_calculated'), "<br/>", false);
!         }
! 
!         $mform->addElement('submit', 'getnextbutton', get_string('getnextnow', 'qtype_calculated'));
!         $mform->addElement('static', "dividera", '', '<hr />');
!         $addgrp = array();
!         $addgrp[] =& $mform->createElement('submit', 'addbutton', get_string('add', 'moodle'));
!         $addgrp[] =& $mform->createElement('select', "selectadd", get_string('additem', 'qtype_calculated'), $addremoveoptions);
!         $addgrp[] = & $mform->createElement('static',"stat","Items",get_string('newsetwildcardvalues', 'qtype_calculatedsimple'));
!         $mform->addGroup($addgrp, 'addgrp', get_string('additem', 'qtype_calculated'), '   ', false);
!         $mform->addElement('static', "divideradd", '', '');
!     //     $mform->closeHeaderBefore('divideradd');
!         if ($this->noofitems > 0) {
!             $mform->addElement('header', 'additemhdr', get_string('delete', 'moodle'));
!             $deletegrp = array();
!             $deletegrp[] =& $mform->createElement('submit', 'deletebutton', get_string('delete', 'moodle'));
!             $deletegrp[] =& $mform->createElement('select', 'selectdelete', get_string('deleteitem', 'qtype_calculated')."1", $addremoveoptions);
!             $deletegrp[] = & $mform->createElement('static',"stat","Items",get_string('setwildcardvalues', 'qtype_calculatedsimple'));
!             $mform->addGroup($deletegrp, 'deletegrp', '', '   ', false);
!    //      $mform->addElement('static', "dividerdelete", '', '<hr />');
!    //      $mform->closeHeaderBefore('dividerdelete');
!         } else {
!             $mform->addElement('static','warning','','<span class="error">'.get_string('youmustaddatleastoneitem', 'qtype_calculated').'</span>');
!         }
! 
!       //  $mform->addElement('header', 'additemhdr', get_string('showitems', 'moodle'));
!         $addgrp1 = array();
!         $addgrp1[] =& $mform->createElement('submit', 'showbutton', get_string('showitems', 'qtype_calculated'));
!         $addgrp1[] =& $mform->createElement('select', "selectshow",'' , $showoptions);
!         $addgrp1[] = & $mform->createElement('static',"stat",'',get_string('setwildcardvalues', 'qtype_calculated'));
!         $mform->addGroup($addgrp1, 'addgrp1', '', '   ', false);
!         $mform->registerNoSubmitButton('showbutton');
!         $mform->closeHeaderBefore('addgrp1');
! //------------------------------------------------------------------------------------------------------------------------------
!         $j = $this->noofitems * count($this->datasetdefs);
!         $k = 1 ;
!         if ("" != optional_param('selectshow', '', PARAM_INT)){
!             $k = optional_param('selectshow', '', PARAM_INT);
!         }
!         for ($i = $this->noofitems; $i >= 1 ; $i--){
!                 if($k > 0  ){ //||  $this->outsidelimit || !empty($this->numbererrors )
!             $mform->addElement('header', '',"<b>".get_string('setno', 'qtype_calculated', $i)."</b>&nbsp;&nbsp;");
!            // $mform->addElement('header', '', get_string('itemno', 'qtype_calculated', $i));
!         }
!             foreach ($this->datasetdefs as $defkey => $datasetdef){
!                 if($k > 0  ){ //||  $this->outsidelimit || !empty($this->numbererrors )
!                     if($datasetdef->category == 0 ){
!                         $mform->addElement('text', "number[$j]", get_string('wildcard', 'qtype_calculated', $datasetdef->name));
!                     }else {
!                         $mform->addElement('text', "number[$j]", get_string('sharedwildcardname', 'qtype_calculated', $datasetdef->name));
!                     }
!                         
!             }else {
!                 $mform->addElement('hidden',"number[$j]" , '');
!             }    
!                 $mform->setType("number[$j]", PARAM_NUMBER);
!                 $mform->addElement('hidden', "itemid[$j]");
!                 $mform->setType("itemid[$j]", PARAM_INT);
! 
!                 $mform->addElement('hidden', "definition[$j]");
!                 $mform->setType("definition[$j]", PARAM_NOTAGS);
!                 $data[$datasetdef->name] =$datasetdef->items[$i]->value;
! 
!                 $j--;
!             }
!               if('' != $strquestionlabel && ($k > 0 )){ //||  $this->outsidelimit || !empty($this->numbererrors )
!                 $repeated[] =& $mform->addElement('static', "answercomment[$i]", $strquestionlabel);
!                 // decode equations in question text
!                 $qtext = $this->qtypeobj->substitute_variables($this->question->questiontext, $data);
!                 $textequations = $this->qtypeobj->find_math_equations($qtext);
!                 if($textequations != '' && count($textequations) > 0 ){
!                 $mform->addElement('static', "divider1[$j]", '', 'Formulas {=..} in question text');
!                     foreach($textequations as $key=>$equation){
!                             if( $formulaerrors = qtype_calculated_find_formula_errors($equation)){
!                                 $str=$formulaerrors ;
!                             }else {
!                                 eval('$str = '.$equation.';');
!                             }
! 
!                         $mform->addElement('static', "textequation","{=$equation}","=".$str);    
!                         }
!                 } 
! 
!                }
!                         $k-- ;
! 
!         }
!       //  if ($this->outsidelimit){
!             $mform->addElement('static','outsidelimit','','');
!       //  }
! //------------------------------------------------------------------------------------------------------------------------------
!         //non standard name for button element needed so not using add_action_buttons
!         if ( !($this->noofitems==0) ){
!         $mform->addElement('submit', 'backtoquiz', get_string('savechanges'));
!         $mform->closeHeaderBefore('backtoquiz');
!         }
!         //hidden elements
!         $mform->addElement('hidden', 'id');
!         $mform->setType('id', PARAM_INT);
! 
!         $mform->addElement('hidden', 'courseid');
!         $mform->setType('courseid', PARAM_INT);
!         $mform->setDefault('courseid', 0);
! 
!         $mform->addElement('hidden', 'category');
!         $mform->setType('category', PARAM_RAW);
!         $mform->setDefault('category', array('contexts' => array($this->categorycontext)));
! 
!         $mform->addElement('hidden', 'cmid');
!         $mform->setType('cmid', PARAM_INT);
!         $mform->setDefault('cmid', 0);
! 
!         $mform->addElement('hidden', 'wizard', 'datasetitems');
!         $mform->setType('wizard', PARAM_ALPHA);
! 
!         $mform->addElement('hidden', 'returnurl');
!         $mform->setType('returnurl', PARAM_LOCALURL);
!         $mform->setDefault('returnurl', 0);
!     }
! 
!     function set_data($question){
!         $formdata = array();
!         $fromform = new stdClass();
!         if (isset($question->options)){
!             $answers = $question->options->answers;
!             if (count($answers)) {
!                 if ( optional_param('updateanswers', '', PARAM_RAW) != '' || optional_param('updatedatasets', '', PARAM_RAW) != ''){
!                     foreach ($answers as $key => $answer){
!                         $fromform->tolerance[$key]= $this->_form->getElementValue('tolerance['.$key.']');
!                         $answer->tolerance = $fromform->tolerance[$key];
!                         $fromform->tolerancetype[$key]= $this->_form->getElementValue('tolerancetype['.$key.']');
!                         if( is_array($fromform->tolerancetype[$key])) $fromform->tolerancetype[$key]= $fromform->tolerancetype[$key][0];
!                         $answer->tolerancetype = $fromform->tolerancetype[$key];
!                         $fromform->correctanswerlength[$key]= $this->_form->getElementValue('correctanswerlength['.$key.']');
!                         if( is_array($fromform->correctanswerlength[$key])) $fromform->correctanswerlength[$key]= $fromform->correctanswerlength[$key][0];
!                         $answer->correctanswerlength = $fromform->correctanswerlength[$key];
!                         $fromform->correctanswerformat[$key]= $this->_form->getElementValue('correctanswerformat['.$key.']');
!                         if( is_array($fromform->correctanswerformat[$key])) $fromform->correctanswerformat[$key]= $fromform->correctanswerformat[$key][0];
!                         $answer->correctanswerformat = $fromform->correctanswerformat[$key];
!                     }
!                     $this->qtypeobj->save_question_calculated($question,$fromform);
!                 }else {
!                 foreach ($answers as $key => $answer){
! 
!                     $formdata['tolerance['.$key.']'] = $answer->tolerance;
!                     $formdata['tolerancetype['.$key.']'] = $answer->tolerancetype;
!                     $formdata['correctanswerlength['.$key.']'] = $answer->correctanswerlength;
!                     $formdata['correctanswerformat['.$key.']'] = $answer->correctanswerformat;
!                }
!             }
!         }
!     }
!         //fill out all data sets and also the fields for the next item to add.
!    //     echo "<p> qequation <pre>";print_r($question);echo "</pre></p>";
!    //     echo "<p> datasetdefs <pre>";print_r($this->datasetdefs);echo "</pre></p>";
!         $j = $this->noofitems * count($this->datasetdefs);
!          for ($itemnumber = $this->noofitems; $itemnumber >= 1; $itemnumber--){
!             $data = array();
!             foreach ($this->datasetdefs as $defid => $datasetdef){
!                 if (isset($datasetdef->items[$itemnumber])){
!                     $formdata["number[$j]"] = $datasetdef->items[$itemnumber]->value;
!                     $formdata["definition[$j]"] = $defid;
!                     $formdata["itemid[$j]"] = $datasetdef->items[$itemnumber]->id;
!                     $data[$datasetdef->name] = $datasetdef->items[$itemnumber]->value;
!                 }
!                 $j--;
!             }
!             $comment = $this->qtypeobj->comment_on_datasetitems($this->qtypeobj,$question->id,$question->questiontext,$answers, $data, $itemnumber);
!              if ($comment->outsidelimit) {
!                  $this->outsidelimit=$comment->outsidelimit ;
!             }
!             $totalcomment='';
!             foreach ($question->options->answers as $key => $answer) {
!                 $totalcomment .= $comment->stranswers[$key].'<br/>';
!             }
!             $formdata['answercomment['.$itemnumber.']'] = $totalcomment ;
!         }
! 
!         $formdata['nextpageparam[forceregeneration]'] = $this->regenerate;
!         $formdata['selectdelete'] = '1';
!         $formdata['selectadd'] = '1';
!         $j = $this->noofitems * count($this->datasetdefs)+1;
!         $data = array(); // data for comment_on_datasetitems later
!         //dataset generation dafaults
!         if ($this->qtypeobj->supports_dataset_item_generation()) {
!             $itemnumber = $this->noofitems+1;
!             foreach ($this->datasetdefs as $defid => $datasetdef){
!                 if( optional_param('updatedatasets', '', PARAM_RAW) == '' && optional_param('updateanswers', '', PARAM_RAW)== ''){
!                 $formdata["number[$j]"] = $this->qtypeobj->generate_dataset_item($datasetdef->options);
!             }else {
!                 $formdata["number[$j]"] = $this->_form->getElementValue("number[$j]") ;
!             }
!                 $formdata["definition[$j]"] = $defid;
!                 $formdata["itemid[$j]"] =
!                         isset($datasetdef->items[$itemnumber])?$datasetdef->items[$itemnumber]->id:0;
!                 $data[$datasetdef->name] = $formdata["number[$j]"];
!                 $j++;
!             }
!         }
! 
!         //existing records override generated data depending on radio element
!         $j = $this->noofitems * count($this->datasetdefs)+1;
!         if (!$this->regenerate && (optional_param('updatedatasets', '', PARAM_RAW) == '' && optional_param('updateanswers', '', PARAM_RAW)== '')){
!             $idx = 1;
!             $itemnumber = $this->noofitems+1;
!             foreach ($this->datasetdefs as $defid => $datasetdef){
!                 if (isset($datasetdef->items[$itemnumber])){
!                     $formdata["number[$j]"] = $datasetdef->items[$itemnumber]->value;
!                     $formdata["definition[$j]"] = $defid;
!                     $formdata["itemid[$j]"] = $datasetdef->items[$itemnumber]->id;
!                     $data[$datasetdef->name] = $datasetdef->items[$itemnumber]->value;
!                 }
!                 $j++;
!             }
! 
!         }
! 
!             $comment = $this->qtypeobj->comment_on_datasetitems($this->qtypeobj,$question->id,$question->questiontext,$answers, $data, ($this->noofitems+1));
!             if (isset($comment->outsidelimit)&&$comment->outsidelimit)  {
!                  $this->outsidelimit=$comment->outsidelimit ;
!             }
!             $key1 = 1;
!             foreach ($question->options->answers as $key => $answer) {
!                 $formdata['answercomment['.($this->noofitems+$key1).']'] = $comment->stranswers[$key];
!                 $key1++;
!             }
! 
!         if ($this->outsidelimit){
!             $formdata['outsidelimit']= '<span class="error">'.get_string('oneanswertrueansweroutsidelimits', 'qtype_calculated').'</span>';
!         }
!         $formdata = $this->qtypeobj->custom_generator_set_data($this->datasetdefs, $formdata);
! 
!         parent::set_data((object)($formdata + (array)$question));
!     }
! 
!     function validation($data, $files) {
!         $errors = array();
!         if (isset($data['backtoquiz']) && ($this->noofitems==0) ){
!             $errors['warning'] = get_string('warning', 'mnet');
!         }
!         if ($this->outsidelimit){
!          //   if(!isset($errors['warning'])) $errors['warning']=' ';
!            $errors['outsidelimits'] = get_string('oneanswertrueansweroutsidelimits','qtype_calculated');
!         }
!         $numbers = $data['number'];
!         foreach ($numbers as $key => $number){
!             if(! is_numeric($number)){
!                 if (stristr($number,',')){
!                     $errors['number['.$key.']'] = get_string('The , cannot be used, use . as in 0.013 or 1.3e-2', 'qtype_calculated');
!                 }else {
!                     $errors['number['.$key.']'] = get_string('This is not a valid number', 'qtype_calculated');
!                 }
!             }else if( stristr($number,'x')){
!                 $errors['number['.$key.']'] = get_string('Hexadecimal format (i.e. 0X12d) is not allowed', 'qtype_calculated');
!             } else if( is_nan($number)){
!                 $errors['number['.$key.']'] = get_string('is a NAN number', 'qtype_calculated');
!             }
!         }
!         return $errors;
!     }
  
  
  }
--- 1,437 ----
  <?php
  class question_dataset_dependent_items_form extends moodleform {
! 	/**
! 	 * Question object with options and answers already loaded by get_question_options
! 	 * Be careful how you use this it is needed sometimes to set up the structure of the
! 	 * form in definition_inner but data is always loaded into the form with set_defaults.
! 	 *
! 	 * @var object
! 	 */
! 	public $question;
! 	/**
! 	 * Reference to question type object
! 	 *
! 	 * @var question_dataset_dependent_questiontype
! 	 */
! 	public $qtypeobj;
! 
! 	public $datasetdefs;
! 
! 	public $maxnumber = -1;
! 
! 	public $regenerate;
! 
! 	public $noofitems;
! 
! 	public $outsidelimit = false ;
! 
! 	public $commentanswers = array();
! 	/**
! 	 * Add question-type specific form fields.
! 	 *
! 	 * @param MoodleQuickForm $mform the form being built.
! 	 */
! 	function question_dataset_dependent_items_form($submiturl, $question, $regenerate){
! 		global $QTYPES, $SESSION, $CFG, $DB;
! 		$this->regenerate = $regenerate;
! 		$this->question = $question;
! 		$this->qtypeobj =& $QTYPES[$this->question->qtype];
! 		// Validate the question category.
! 		if (!$category = $DB->get_record('question_categories', array('id' => $question->category))) {
! 			print_error('categorydoesnotexist', 'question', $returnurl);
! 		}
! 		$this->category = $category;
! 		$this->categorycontext = get_context_instance_by_id($category->contextid);
! 		//get the dataset defintions for this question
! 		if (empty($question->id)) {
! 			$this->datasetdefs = $this->qtypeobj->get_dataset_definitions($question->id, $SESSION->calculated->definitionform->dataset);
! 		} else {
! 			if (empty($question->options)) {
! 				$this->get_question_options($question);
! 			}
! 			$this->datasetdefs = $this->qtypeobj->get_dataset_definitions($question->id, array());
! 		}
! 
! 		foreach ($this->datasetdefs as $datasetdef) {
! 			// Get maxnumber
! 			if ($this->maxnumber == -1 || $datasetdef->itemcount < $this->maxnumber) {
! 				$this->maxnumber = $datasetdef->itemcount;
! 			}
! 		}
! 		foreach ($this->datasetdefs as $defid => $datasetdef) {
! 			if (isset($datasetdef->id)) {
! 				$this->datasetdefs[$defid]->items = $this->qtypeobj->get_database_dataset_items($datasetdef->id);
! 			}
! 		}
! 		parent::moodleform($submiturl);
! 	}
! 	function definition() {
! 		$labelsharedwildcard = get_string("sharedwildcard", "qtype_calculated");
! 
! 		$mform =& $this->_form;
! 		$strquestionlabel = $this->qtypeobj->comment_header($this->question);
! 		if ($this->maxnumber != -1){
! 			$this->noofitems = $this->maxnumber;
! 		} else {
! 			$this->noofitems = 0;
! 		}
! 		$label = get_string("sharedwildcards", "qtype_calculated");
! 		//
! 		$html2 = $this->qtypeobj->print_dataset_definitions_category_shared($this->question,$this->datasetdefs);
! 		$mform->addElement('static','listcategory',$label,$html2);
! 		//------------------------------------------------------------------------------------------------------------------------------
! 		$mform->addElement('submit', 'updatedatasets', get_string('updatedatasetparam', 'qtype_calculated'));
! 		$mform->registerNoSubmitButton('updatedatasets');
! 		$mform->addElement('header', 'additemhdr', get_string('itemtoadd', 'qtype_calculated'));
! 		$idx = 1;
! 		$data = array();
! 		$j = (($this->noofitems) * count($this->datasetdefs))+1;
! 		foreach ($this->datasetdefs as $defkey => $datasetdef){
! 			if($datasetdef->category |= 0 ) {
! 				$name = get_string('sharedwildcardname', 'qtype_calculated',$datasetdef->name) ;
! 			}else {
! 				$name = get_string('wildcard', 'qtype_calculated', $datasetdef->name);
! 			}
! 			$mform->addElement('text', "number[$j]", $name);
! 			$mform->setType("number[$j]", PARAM_NUMBER);
! 			/*     if($datasetdef->category |= 0 && $datasetdef->category == $this->category){
! 			 $mform->addElement('static', "there is a category", $labelsharedwildcard." <strong>$datasetdef->name </strong>", get_string('dataitemdefined',"qtype_calculated", $datasetdef->itemcount));
! 			 }else  if($datasetdef->category |= 0 && $datasetdef->category != $this->category){
! 			 $mform->addElement('static', "BAD a category", $labelsharedwildcard." <strong>$datasetdef->name </strong>", get_string('dataitemdefined',"qtype_calculated", $datasetdef->itemcount));
! 			 }*/
! 			$this->qtypeobj->custom_generator_tools_part($mform, $idx, $j);
! 			$idx++;
! 			$mform->addElement('hidden', "definition[$j]");
! 			$mform->setType("definition[$j]", PARAM_RAW);
! 			$mform->addElement('hidden', "itemid[$j]");
! 			$mform->setType("itemid[$j]", PARAM_RAW);
! 			$mform->addElement('static', "divider[$j]", '', '<hr />');
! 			$mform->setType("divider[$j]", PARAM_RAW);
! 			$j++;
! 		}
! 
! 		$mform->addElement('header', 'updateanswershdr', get_string('answerstoleranceparam', 'qtype_calculated'));
! 		$mform->addElement('submit', 'updateanswers', get_string('updatetolerancesparam', 'qtype_calculated'));
! 		$mform->setAdvanced('updateanswers',true);
! 		$mform->registerNoSubmitButton('updateanswers');
! 
! 		$answers = fullclone($this->question->options->answers);
! 		$key1 =1;
! 		foreach ($answers as $key => $answer) {
! 			if ('' === $answer->answer){
! 			}else if ('*' === $answer->answer){
! 				$mform->addElement('static', 'answercomment['.($this->noofitems+$key1).']', $answer->answer);
! 				$mform->addElement('hidden', 'tolerance['.$key.']', '');
! 				$mform->setType('tolerance['.$key.']', PARAM_RAW);
! 				$mform->setAdvanced('tolerance['.$key.']',true);
! 				$mform->addElement('hidden', 'tolerancetype['.$key.']', '');
! 				$mform->setType('tolerancetype['.$key.']', PARAM_RAW);
! 				$mform->setAdvanced('tolerancetype['.$key.']',true);
! 				$mform->addElement('hidden', 'correctanswerlength['.$key.']', '');
! 				$mform->setType('correctanswerlength['.$key.']', PARAM_RAW);
! 				$mform->setAdvanced('correctanswerlength['.$key.']',true);
! 				$mform->addElement('hidden', 'correctanswerformat['.$key.']', '');
! 				$mform->setType('correctanswerformat['.$key.']', PARAM_RAW);
! 				$mform->setAdvanced('correctanswerformat['.$key.']',true);
! 			}else {
! 				$mform->addElement('static', 'answercomment['.($this->noofitems+$key1).']', $answer->answer);
! 				$mform->addElement('text', 'tolerance['.$key.']', get_string('tolerance', 'qtype_calculated'));
! 				$mform->setAdvanced('tolerance['.$key.']',true);
! 				$mform->addElement('select', 'tolerancetype['.$key.']', get_string('tolerancetype', 'quiz'), $this->qtypeobj->tolerance_types());
! 				$mform->setAdvanced('tolerancetype['.$key.']',true);
! 
! 				$mform->addElement('select', 'correctanswerlength['.$key.']', get_string('correctanswershows', 'qtype_calculated'), range(0, 9));
! 				$mform->setAdvanced('correctanswerlength['.$key.']',true);
! 
! 				$answerlengthformats = array('1' => get_string('decimalformat', 'quiz'), '2' => get_string('significantfiguresformat', 'quiz'));
! 				$mform->addElement('select', 'correctanswerformat['.$key.']', get_string('correctanswershowsformat', 'qtype_calculated'), $answerlengthformats);
! 				$mform->setAdvanced('correctanswerformat['.$key.']',true);
! 				$mform->addElement('static', 'dividertolerance', '', '<hr />');
! 				$mform->setAdvanced('dividertolerance',true);
! 			}
! 			$key1++;
! 		}
! 
! 		$addremoveoptions = array();
! 		$addremoveoptions['1']='1';
! 		for ($i=10; $i<=100 ; $i+=10){
! 			$addremoveoptions["$i"]="$i";
! 		}
! 		$showoptions = Array();
! 		$showoptions['1']='1';
! 		$showoptions['2']='2';
! 		$showoptions['5']='5';
! 		for ($i=10; $i<=100 ; $i+=10){
! 			$showoptions["$i"]="$i";
! 		}
! 		$mform->addElement('header', 'additemhdr', get_string('add', 'moodle'));
! 		$mform->closeHeaderBefore('additemhdr');
! 
! 		if ($this->qtypeobj->supports_dataset_item_generation()){
! 			$radiogrp = array();
! 			$radiogrp[] =& $mform->createElement('radio', 'nextpageparam[forceregeneration]', null, get_string('reuseifpossible', 'qtype_calculated'), 0);
! 			$radiogrp[] =& $mform->createElement('radio', 'nextpageparam[forceregeneration]', null, get_string('forceregenerationshared', 'qtype_calculated'), 1);
! 			$radiogrp[] =& $mform->createElement('radio', 'nextpageparam[forceregeneration]', null, get_string('forceregenerationall', 'qtype_calculated'), 2);
! 			$mform->addGroup($radiogrp, 'forceregenerationgrp', get_string('nextitemtoadd', 'qtype_calculated'), "<br/>", false);
! 		}
! 
! 		$mform->addElement('submit', 'getnextbutton', get_string('getnextnow', 'qtype_calculated'));
! 		$mform->addElement('static', "dividera", '', '<hr />');
! 		$addgrp = array();
! 		$addgrp[] =& $mform->createElement('submit', 'addbutton', get_string('add', 'moodle'));
! 		$addgrp[] =& $mform->createElement('select', "selectadd", get_string('additem', 'qtype_calculated'), $addremoveoptions);
! 		$addgrp[] = & $mform->createElement('static',"stat","Items",get_string('newsetwildcardvalues', 'qtype_calculatedsimple'));
! 		$mform->addGroup($addgrp, 'addgrp', get_string('additem', 'qtype_calculated'), '   ', false);
! 		$mform->addElement('static', "divideradd", '', '');
! 		//     $mform->closeHeaderBefore('divideradd');
! 		if ($this->noofitems > 0) {
! 			$mform->addElement('header', 'additemhdr', get_string('delete', 'moodle'));
! 			$deletegrp = array();
! 			$deletegrp[] =& $mform->createElement('submit', 'deletebutton', get_string('delete', 'moodle'));
! 			$deletegrp[] =& $mform->createElement('select', 'selectdelete', get_string('deleteitem', 'qtype_calculated')."1", $addremoveoptions);
! 			$deletegrp[] = & $mform->createElement('static',"stat","Items",get_string('setwildcardvalues', 'qtype_calculatedsimple'));
! 			$mform->addGroup($deletegrp, 'deletegrp', '', '   ', false);
! 			//      $mform->addElement('static', "dividerdelete", '', '<hr />');
! 			//      $mform->closeHeaderBefore('dividerdelete');
! 		} else {
! 			$mform->addElement('static','warning','','<span class="error">'.get_string('youmustaddatleastoneitem', 'qtype_calculated').'</span>');
! 		}
! 
! 		//  $mform->addElement('header', 'additemhdr', get_string('showitems', 'moodle'));
! 		$addgrp1 = array();
! 		$addgrp1[] =& $mform->createElement('submit', 'showbutton', get_string('showitems', 'qtype_calculated'));
! 		$addgrp1[] =& $mform->createElement('select', "selectshow",'' , $showoptions);
! 		$addgrp1[] = & $mform->createElement('static',"stat",'',get_string('setwildcardvalues', 'qtype_calculated'));
! 		$mform->addGroup($addgrp1, 'addgrp1', '', '   ', false);
! 		$mform->registerNoSubmitButton('showbutton');
! 		$mform->closeHeaderBefore('addgrp1');
! 		//------------------------------------------------------------------------------------------------------------------------------
! 		$j = $this->noofitems * count($this->datasetdefs);
! 		$k = 1 ;
! 		if ("" != optional_param('selectshow', '', PARAM_INT)){
! 			$k = optional_param('selectshow', '', PARAM_INT);
! 		}
! 		for ($i = $this->noofitems; $i >= 1 ; $i--){
! 			if($k > 0  ){ //||  $this->outsidelimit || !empty($this->numbererrors )
! 				$mform->addElement('header', '',"<b>".get_string('setno', 'qtype_calculated', $i)."</b>&nbsp;&nbsp;");
! 				// $mform->addElement('header', '', get_string('itemno', 'qtype_calculated', $i));
! 			}
! 			foreach ($this->datasetdefs as $defkey => $datasetdef){
! 				if($k > 0  ){ //||  $this->outsidelimit || !empty($this->numbererrors )
! 					if($datasetdef->category == 0 ){
! 						$mform->addElement('text', "number[$j]", get_string('wildcard', 'qtype_calculated', $datasetdef->name));
! 					}else {
! 						$mform->addElement('text', "number[$j]", get_string('sharedwildcardname', 'qtype_calculated', $datasetdef->name));
! 					}
! 
! 				}else {
! 					$mform->addElement('hidden',"number[$j]" , '');
! 				}
! 				$mform->setType("number[$j]", PARAM_NUMBER);
! 				$mform->addElement('hidden', "itemid[$j]");
! 				$mform->setType("itemid[$j]", PARAM_INT);
! 
! 				$mform->addElement('hidden', "definition[$j]");
! 				$mform->setType("definition[$j]", PARAM_NOTAGS);
! 				$data[$datasetdef->name] =$datasetdef->items[$i]->value;
! 
! 				$j--;
! 			}
! 			if('' != $strquestionlabel && ($k > 0 )){ //||  $this->outsidelimit || !empty($this->numbererrors )
! 				$repeated[] =& $mform->addElement('static', "answercomment[$i]", $strquestionlabel);
! 				// decode equations in question text
! 				$qtext = $this->qtypeobj->substitute_variables($this->question->questiontext, $data);
! 				$textequations = $this->qtypeobj->find_math_equations($qtext);
! 				if($textequations != '' && count($textequations) > 0 ){
! 					$mform->addElement('static', "divider1[$j]", '', 'Formulas {=..} in question text');
! 					foreach($textequations as $key=>$equation){
! 						if( $formulaerrors = qtype_calculated_find_formula_errors($equation)){
! 							$str=$formulaerrors ;
! 						}else {
! 							eval('$str = '.$equation.';');
! 						}
! 
! 						$mform->addElement('static', "textequation","{=$equation}","=".$str);
! 					}
! 				}
! 
! 			}
! 			$k-- ;
! 
! 		}
! 		//  if ($this->outsidelimit){
! 		$mform->addElement('static','outsidelimit','','');
! 		//  }
! 		//------------------------------------------------------------------------------------------------------------------------------
! 		//non standard name for button element needed so not using add_action_buttons
! 		if ( !($this->noofitems==0) ){
! 			$mform->addElement('submit', 'backtoquiz', get_string('savechanges'));
! 			$mform->closeHeaderBefore('backtoquiz');
! 		}
! 		//hidden elements
! 		$mform->addElement('hidden', 'id');
! 		$mform->setType('id', PARAM_INT);
! 
! 		$mform->addElement('hidden', 'courseid');
! 		$mform->setType('courseid', PARAM_INT);
! 		$mform->setDefault('courseid', 0);
! 
! 		$mform->addElement('hidden', 'category');
! 		$mform->setType('category', PARAM_RAW);
! 		$mform->setDefault('category', array('contexts' => array($this->categorycontext)));
! 
! 		$mform->addElement('hidden', 'cmid');
! 		$mform->setType('cmid', PARAM_INT);
! 		$mform->setDefault('cmid', 0);
! 
! 		$mform->addElement('hidden', 'wizard', 'datasetitems');
! 		$mform->setType('wizard', PARAM_ALPHA);
! 
! 		$mform->addElement('hidden', 'returnurl');
! 		$mform->setType('returnurl', PARAM_LOCALURL);
! 		$mform->setDefault('returnurl', 0);
! 	}
! 
! 	function set_data($question){
! 		$formdata = array();
! 		$fromform = new stdClass();
! 		if (isset($question->options)){
! 			$answers = $question->options->answers;
! 			if (count($answers)) {
! 				if ( optional_param('updateanswers', '', PARAM_RAW) != '' || optional_param('updatedatasets', '', PARAM_RAW) != ''){
! 					foreach ($answers as $key => $answer){
! 						$fromform->tolerance[$key]= $this->_form->getElementValue('tolerance['.$key.']');
! 						$answer->tolerance = $fromform->tolerance[$key];
! 						$fromform->tolerancetype[$key]= $this->_form->getElementValue('tolerancetype['.$key.']');
! 						if( is_array($fromform->tolerancetype[$key])) $fromform->tolerancetype[$key]= $fromform->tolerancetype[$key][0];
! 						$answer->tolerancetype = $fromform->tolerancetype[$key];
! 						$fromform->correctanswerlength[$key]= $this->_form->getElementValue('correctanswerlength['.$key.']');
! 						if( is_array($fromform->correctanswerlength[$key])) $fromform->correctanswerlength[$key]= $fromform->correctanswerlength[$key][0];
! 						$answer->correctanswerlength = $fromform->correctanswerlength[$key];
! 						$fromform->correctanswerformat[$key]= $this->_form->getElementValue('correctanswerformat['.$key.']');
! 						if( is_array($fromform->correctanswerformat[$key])) $fromform->correctanswerformat[$key]= $fromform->correctanswerformat[$key][0];
! 						$answer->correctanswerformat = $fromform->correctanswerformat[$key];
! 					}
! 					$this->qtypeobj->save_question_calculated($question,$fromform);
! 				}else {
! 					foreach ($answers as $key => $answer){
! 
! 						$formdata['tolerance['.$key.']'] = $answer->tolerance;
! 						$formdata['tolerancetype['.$key.']'] = $answer->tolerancetype;
! 						$formdata['correctanswerlength['.$key.']'] = $answer->correctanswerlength;
! 						$formdata['correctanswerformat['.$key.']'] = $answer->correctanswerformat;
! 					}
! 				}
! 			}
! 		}
! 		//fill out all data sets and also the fields for the next item to add.
! 		//     echo "<p> qequation <pre>";print_r($question);echo "</pre></p>";
! 		//     echo "<p> datasetdefs <pre>";print_r($this->datasetdefs);echo "</pre></p>";
! 		$j = $this->noofitems * count($this->datasetdefs);
! 		for ($itemnumber = $this->noofitems; $itemnumber >= 1; $itemnumber--){
! 			$data = array();
! 			foreach ($this->datasetdefs as $defid => $datasetdef){
! 				if (isset($datasetdef->items[$itemnumber])){
! 					$formdata["number[$j]"] = $datasetdef->items[$itemnumber]->value;
! 					$formdata["definition[$j]"] = $defid;
! 					$formdata["itemid[$j]"] = $datasetdef->items[$itemnumber]->id;
! 					$data[$datasetdef->name] = $datasetdef->items[$itemnumber]->value;
! 				}
! 				$j--;
! 			}
! 			$comment = $this->qtypeobj->comment_on_datasetitems($this->qtypeobj,$question->id,$question->questiontext,$answers, $data, $itemnumber);
! 			if ($comment->outsidelimit) {
! 				$this->outsidelimit=$comment->outsidelimit ;
! 			}
! 			$totalcomment='';
! 			foreach ($question->options->answers as $key => $answer) {
! 				$totalcomment .= $comment->stranswers[$key].'<br/>';
! 			}
! 			$formdata['answercomment['.$itemnumber.']'] = $totalcomment ;
! 		}
! 
! 		$formdata['nextpageparam[forceregeneration]'] = $this->regenerate;
! 		$formdata['selectdelete'] = '1';
! 		$formdata['selectadd'] = '1';
! 		$j = $this->noofitems * count($this->datasetdefs)+1;
! 		$data = array(); // data for comment_on_datasetitems later
! 		//dataset generation dafaults
! 		if ($this->qtypeobj->supports_dataset_item_generation()) {
! 			$itemnumber = $this->noofitems+1;
! 			foreach ($this->datasetdefs as $defid => $datasetdef){
! 				if( optional_param('updatedatasets', '', PARAM_RAW) == '' && optional_param('updateanswers', '', PARAM_RAW)== ''){
! 					$formdata["number[$j]"] = $this->qtypeobj->generate_dataset_item($datasetdef->options);
! 				}else {
! 					$formdata["number[$j]"] = $this->_form->getElementValue("number[$j]") ;
! 				}
! 				$formdata["definition[$j]"] = $defid;
! 				$formdata["itemid[$j]"] =
! 				isset($datasetdef->items[$itemnumber])?$datasetdef->items[$itemnumber]->id:0;
! 				$data[$datasetdef->name] = $formdata["number[$j]"];
! 				$j++;
! 			}
! 		}
! 
! 		//existing records override generated data depending on radio element
! 		$j = $this->noofitems * count($this->datasetdefs)+1;
! 		if (!$this->regenerate && (optional_param('updatedatasets', '', PARAM_RAW) == '' && optional_param('updateanswers', '', PARAM_RAW)== '')){
! 			$idx = 1;
! 			$itemnumber = $this->noofitems+1;
! 			foreach ($this->datasetdefs as $defid => $datasetdef){
! 				if (isset($datasetdef->items[$itemnumber])){
! 					$formdata["number[$j]"] = $datasetdef->items[$itemnumber]->value;
! 					$formdata["definition[$j]"] = $defid;
! 					$formdata["itemid[$j]"] = $datasetdef->items[$itemnumber]->id;
! 					$data[$datasetdef->name] = $datasetdef->items[$itemnumber]->value;
! 				}
! 				$j++;
! 			}
! 
! 		}
! 
! 		$comment = $this->qtypeobj->comment_on_datasetitems($this->qtypeobj,$question->id,$question->questiontext,$answers, $data, ($this->noofitems+1));
! 		if (isset($comment->outsidelimit)&&$comment->outsidelimit)  {
! 			$this->outsidelimit=$comment->outsidelimit ;
! 		}
! 		$key1 = 1;
! 		foreach ($question->options->answers as $key => $answer) {
! 			$formdata['answercomment['.($this->noofitems+$key1).']'] = $comment->stranswers[$key];
! 			$key1++;
! 		}
! 
! 		if ($this->outsidelimit){
! 			$formdata['outsidelimit']= '<span class="error">'.get_string('oneanswertrueansweroutsidelimits', 'qtype_calculated').'</span>';
! 		}
! 		$formdata = $this->qtypeobj->custom_generator_set_data($this->datasetdefs, $formdata);
! 
! 		parent::set_data((object)($formdata + (array)$question));
! 	}
! 
! 	function validation($data, $files) {
! 		$errors = array();
! 		if (isset($data['backtoquiz']) && ($this->noofitems==0) ){
! 			$errors['warning'] = get_string('warning', 'mnet');
! 		}
! 		if ($this->outsidelimit){
! 			//   if(!isset($errors['warning'])) $errors['warning']=' ';
! 			$errors['outsidelimits'] = get_string('oneanswertrueansweroutsidelimits','qtype_calculated');
! 		}
! 		$numbers = $data['number'];
! 		foreach ($numbers as $key => $number){
! 			if(! is_numeric($number)){
! 				if (stristr($number,',')){
! 					$errors['number['.$key.']'] = get_string('The , cannot be used, use . as in 0.013 or 1.3e-2', 'qtype_calculated');
! 				}else {
! 					$errors['number['.$key.']'] = get_string('This is not a valid number', 'qtype_calculated');
! 				}
! 			}else if( stristr($number,'x')){
! 				$errors['number['.$key.']'] = get_string('Hexadecimal format (i.e. 0X12d) is not allowed', 'qtype_calculated');
! 			} else if( is_nan($number)){
! 				$errors['number['.$key.']'] = get_string('is a NAN number', 'qtype_calculated');
! 			}
! 		}
! 		return $errors;
! 	}
  
  
  }
diff -crB questionorg/type/calculated/db/install.xml questionupd/type/calculated/db/install.xml
*** questionorg/type/calculated/db/install.xml	2012-04-13 12:31:12.009178264 +0500
--- questionupd/type/calculated/db/install.xml	2012-04-13 09:42:56.000000000 +0500
***************
*** 1,89 ****
  <?xml version="1.0" encoding="UTF-8" ?>
! <XMLDB PATH="question/type/calculated/db" VERSION="20100720" COMMENT="XMLDB file for Moodle question/type/calculated. This question type also relies on the question_numerical_units table created by the numerical question type, and the tables created by the datasetdependent question type base class."
!     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
!     xsi:noNamespaceSchemaLocation="../../../../lib/xmldb/xmldb.xsd"
! >
!   <TABLES>
!     <TABLE NAME="question_calculated" COMMENT="Options for questions of type calculated" NEXT="question_calculated_options">
!       <FIELDS>
!         <FIELD NAME="id" TYPE="int" LENGTH="10" NOTNULL="true" UNSIGNED="true" SEQUENCE="true" NEXT="question"/>
!         <FIELD NAME="question" TYPE="int" LENGTH="10" NOTNULL="true" UNSIGNED="true" DEFAULT="0" SEQUENCE="false" PREVIOUS="id" NEXT="answer"/>
!         <FIELD NAME="answer" TYPE="int" LENGTH="10" NOTNULL="true" UNSIGNED="true" DEFAULT="0" SEQUENCE="false" PREVIOUS="question" NEXT="tolerance"/>
!         <FIELD NAME="tolerance" TYPE="char" LENGTH="20" NOTNULL="true" DEFAULT="0.0" SEQUENCE="false" PREVIOUS="answer" NEXT="tolerancetype"/>
!         <FIELD NAME="tolerancetype" TYPE="int" LENGTH="10" NOTNULL="true" UNSIGNED="false" DEFAULT="1" SEQUENCE="false" PREVIOUS="tolerance" NEXT="correctanswerlength"/>
!         <FIELD NAME="correctanswerlength" TYPE="int" LENGTH="10" NOTNULL="true" UNSIGNED="false" DEFAULT="2" SEQUENCE="false" PREVIOUS="tolerancetype" NEXT="correctanswerformat"/>
!         <FIELD NAME="correctanswerformat" TYPE="int" LENGTH="10" NOTNULL="true" UNSIGNED="false" DEFAULT="2" SEQUENCE="false" PREVIOUS="correctanswerlength"/>
!       </FIELDS>
!       <KEYS>
!         <KEY NAME="primary" TYPE="primary" FIELDS="id" NEXT="question"/>
!         <KEY NAME="question" TYPE="foreign" FIELDS="question" REFTABLE="question" REFFIELDS="id" PREVIOUS="primary"/>
!       </KEYS>
!       <INDEXES>
!         <INDEX NAME="answer" UNIQUE="false" FIELDS="answer"/>
!       </INDEXES>
!     </TABLE>
!     <TABLE NAME="question_calculated_options" COMMENT="Options for questions of type calculated" PREVIOUS="question_calculated" NEXT="question_dataset_definitions">
!       <FIELDS>
!         <FIELD NAME="id" TYPE="int" LENGTH="10" NOTNULL="true" UNSIGNED="true" SEQUENCE="true" NEXT="question"/>
!         <FIELD NAME="question" TYPE="int" LENGTH="10" NOTNULL="true" UNSIGNED="true" DEFAULT="0" SEQUENCE="false" PREVIOUS="id" NEXT="synchronize"/>
!         <FIELD NAME="synchronize" TYPE="int" LENGTH="2" NOTNULL="true" UNSIGNED="true" DEFAULT="0" SEQUENCE="false" PREVIOUS="question" NEXT="single"/>
!         <FIELD NAME="single" TYPE="int" LENGTH="4" NOTNULL="true" UNSIGNED="false" DEFAULT="0" SEQUENCE="false" COMMENT="If 0 it multiple response (checkboxes). Otherwise it is radio buttons." PREVIOUS="synchronize" NEXT="shuffleanswers"/>
!         <FIELD NAME="shuffleanswers" TYPE="int" LENGTH="4" NOTNULL="true" UNSIGNED="false" DEFAULT="0" SEQUENCE="false" COMMENT="Whether the choices can be randomly shuffled." PREVIOUS="single" NEXT="correctfeedback"/>
!         <FIELD NAME="correctfeedback" TYPE="text" LENGTH="small" NOTNULL="false" SEQUENCE="false" COMMENT="Feedback shown for any correct response." PREVIOUS="shuffleanswers" NEXT="correctfeedbackformat"/>
!         <FIELD NAME="correctfeedbackformat" TYPE="int" LENGTH="2" NOTNULL="true" UNSIGNED="false" DEFAULT="0" SEQUENCE="false" PREVIOUS="correctfeedback" NEXT="partiallycorrectfeedback"/>
!         <FIELD NAME="partiallycorrectfeedback" TYPE="text" LENGTH="small" NOTNULL="false" SEQUENCE="false" COMMENT="Feedback shown for any partially correct response." PREVIOUS="correctfeedbackformat" NEXT="partiallycorrectfeedbackformat"/>
!         <FIELD NAME="partiallycorrectfeedbackformat" TYPE="int" LENGTH="2" NOTNULL="true" UNSIGNED="false" DEFAULT="0" SEQUENCE="false" PREVIOUS="partiallycorrectfeedback" NEXT="incorrectfeedback"/>
!         <FIELD NAME="incorrectfeedback" TYPE="text" LENGTH="small" NOTNULL="false" SEQUENCE="false" COMMENT="Feedback shown for any incorrect response." PREVIOUS="partiallycorrectfeedbackformat" NEXT="incorrectfeedbackformat"/>
!         <FIELD NAME="incorrectfeedbackformat" TYPE="int" LENGTH="2" NOTNULL="true" UNSIGNED="false" DEFAULT="0" SEQUENCE="false" PREVIOUS="incorrectfeedback" NEXT="answernumbering"/>
!         <FIELD NAME="answernumbering" TYPE="char" LENGTH="10" NOTNULL="true" DEFAULT="abc" SEQUENCE="false" COMMENT="Indicates how and whether the choices should be numbered." PREVIOUS="incorrectfeedbackformat"/>
!       </FIELDS>
!       <KEYS>
!         <KEY NAME="primary" TYPE="primary" FIELDS="id" NEXT="question"/>
!         <KEY NAME="question" TYPE="foreign" FIELDS="question" REFTABLE="question" REFFIELDS="id" PREVIOUS="primary"/>
!       </KEYS>
!     </TABLE>
!     <TABLE NAME="question_dataset_definitions" COMMENT="Organises and stores properties for dataset items" PREVIOUS="question_calculated_options" NEXT="question_dataset_items">
!       <FIELDS>
!         <FIELD NAME="id" TYPE="int" LENGTH="10" NOTNULL="true" UNSIGNED="true" SEQUENCE="true" NEXT="category"/>
!         <FIELD NAME="category" TYPE="int" LENGTH="10" NOTNULL="true" UNSIGNED="true" DEFAULT="0" SEQUENCE="false" PREVIOUS="id" NEXT="name"/>
!         <FIELD NAME="name" TYPE="char" LENGTH="255" NOTNULL="true" SEQUENCE="false" PREVIOUS="category" NEXT="type"/>
!         <FIELD NAME="type" TYPE="int" LENGTH="10" NOTNULL="true" UNSIGNED="false" DEFAULT="0" SEQUENCE="false" PREVIOUS="name" NEXT="options"/>
!         <FIELD NAME="options" TYPE="char" LENGTH="255" NOTNULL="true" SEQUENCE="false" PREVIOUS="type" NEXT="itemcount"/>
!         <FIELD NAME="itemcount" TYPE="int" LENGTH="10" NOTNULL="true" UNSIGNED="true" DEFAULT="0" SEQUENCE="false" PREVIOUS="options"/>
!       </FIELDS>
!       <KEYS>
!         <KEY NAME="primary" TYPE="primary" FIELDS="id" NEXT="category"/>
!         <KEY NAME="category" TYPE="foreign" FIELDS="category" REFTABLE="question_categories" REFFIELDS="id" PREVIOUS="primary"/>
!       </KEYS>
!     </TABLE>
!     <TABLE NAME="question_dataset_items" COMMENT="Individual dataset items" PREVIOUS="question_dataset_definitions" NEXT="question_datasets">
!       <FIELDS>
!         <FIELD NAME="id" TYPE="int" LENGTH="10" NOTNULL="true" UNSIGNED="true" SEQUENCE="true" NEXT="definition"/>
!         <FIELD NAME="definition" TYPE="int" LENGTH="10" NOTNULL="true" UNSIGNED="true" DEFAULT="0" SEQUENCE="false" PREVIOUS="id" NEXT="itemnumber"/>
!         <FIELD NAME="itemnumber" TYPE="int" LENGTH="10" NOTNULL="true" UNSIGNED="true" DEFAULT="0" SEQUENCE="false" PREVIOUS="definition" NEXT="value"/>
!         <FIELD NAME="value" TYPE="char" LENGTH="255" NOTNULL="true" SEQUENCE="false" PREVIOUS="itemnumber"/>
!       </FIELDS>
!       <KEYS>
!         <KEY NAME="primary" TYPE="primary" FIELDS="id"/>
!       </KEYS>
!       <INDEXES>
!         <INDEX NAME="definition" UNIQUE="false" FIELDS="definition"/>
!       </INDEXES>
!     </TABLE>
!     <TABLE NAME="question_datasets" COMMENT="Many-many relation between questions and dataset definitions" PREVIOUS="question_dataset_items">
!       <FIELDS>
!         <FIELD NAME="id" TYPE="int" LENGTH="10" NOTNULL="true" UNSIGNED="true" SEQUENCE="true" NEXT="question"/>
!         <FIELD NAME="question" TYPE="int" LENGTH="10" NOTNULL="true" UNSIGNED="true" DEFAULT="0" SEQUENCE="false" PREVIOUS="id" NEXT="datasetdefinition"/>
!         <FIELD NAME="datasetdefinition" TYPE="int" LENGTH="10" NOTNULL="true" UNSIGNED="true" DEFAULT="0" SEQUENCE="false" PREVIOUS="question"/>
!       </FIELDS>
!       <KEYS>
!         <KEY NAME="primary" TYPE="primary" FIELDS="id" NEXT="question"/>
!         <KEY NAME="question" TYPE="foreign" FIELDS="question" REFTABLE="question" REFFIELDS="id" PREVIOUS="primary" NEXT="datasetdefinition"/>
!         <KEY NAME="datasetdefinition" TYPE="foreign" FIELDS="datasetdefinition" REFTABLE="question_dataset_definitions" REFFIELDS="id" PREVIOUS="question"/>
!       </KEYS>
!       <INDEXES>
!         <INDEX NAME="question-datasetdefinition" UNIQUE="false" FIELDS="question, datasetdefinition"/>
!       </INDEXES>
!     </TABLE>
!   </TABLES>
  </XMLDB>
\ No newline at end of file
--- 1,155 ----
  <?xml version="1.0" encoding="UTF-8" ?>
! <XMLDB PATH="question/type/calculated/db" VERSION="20100720"
! 	COMMENT="XMLDB file for Moodle question/type/calculated. This question type also relies on the question_numerical_units table created by the numerical question type, and the tables created by the datasetdependent question type base class."
! 	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
! 	xsi:noNamespaceSchemaLocation="../../../../lib/xmldb/xmldb.xsd">
! 	<TABLES>
! 		<TABLE NAME="question_calculated" COMMENT="Options for questions of type calculated"
! 			NEXT="question_calculated_options">
! 			<FIELDS>
! 				<FIELD NAME="id" TYPE="int" LENGTH="10" NOTNULL="true"
! 					UNSIGNED="true" SEQUENCE="true" NEXT="question" />
! 				<FIELD NAME="question" TYPE="int" LENGTH="10" NOTNULL="true"
! 					UNSIGNED="true" DEFAULT="0" SEQUENCE="false" PREVIOUS="id" NEXT="answer" />
! 				<FIELD NAME="answer" TYPE="int" LENGTH="10" NOTNULL="true"
! 					UNSIGNED="true" DEFAULT="0" SEQUENCE="false" PREVIOUS="question"
! 					NEXT="tolerance" />
! 				<FIELD NAME="tolerance" TYPE="char" LENGTH="20" NOTNULL="true"
! 					DEFAULT="0.0" SEQUENCE="false" PREVIOUS="answer" NEXT="tolerancetype" />
! 				<FIELD NAME="tolerancetype" TYPE="int" LENGTH="10" NOTNULL="true"
! 					UNSIGNED="false" DEFAULT="1" SEQUENCE="false" PREVIOUS="tolerance"
! 					NEXT="correctanswerlength" />
! 				<FIELD NAME="correctanswerlength" TYPE="int" LENGTH="10"
! 					NOTNULL="true" UNSIGNED="false" DEFAULT="2" SEQUENCE="false"
! 					PREVIOUS="tolerancetype" NEXT="correctanswerformat" />
! 				<FIELD NAME="correctanswerformat" TYPE="int" LENGTH="10"
! 					NOTNULL="true" UNSIGNED="false" DEFAULT="2" SEQUENCE="false"
! 					PREVIOUS="correctanswerlength" />
! 			</FIELDS>
! 			<KEYS>
! 				<KEY NAME="primary" TYPE="primary" FIELDS="id" NEXT="question" />
! 				<KEY NAME="question" TYPE="foreign" FIELDS="question" REFTABLE="question"
! 					REFFIELDS="id" PREVIOUS="primary" />
! 			</KEYS>
! 			<INDEXES>
! 				<INDEX NAME="answer" UNIQUE="false" FIELDS="answer" />
! 			</INDEXES>
! 		</TABLE>
! 		<TABLE NAME="question_calculated_options" COMMENT="Options for questions of type calculated"
! 			PREVIOUS="question_calculated" NEXT="question_dataset_definitions">
! 			<FIELDS>
! 				<FIELD NAME="id" TYPE="int" LENGTH="10" NOTNULL="true"
! 					UNSIGNED="true" SEQUENCE="true" NEXT="question" />
! 				<FIELD NAME="question" TYPE="int" LENGTH="10" NOTNULL="true"
! 					UNSIGNED="true" DEFAULT="0" SEQUENCE="false" PREVIOUS="id" NEXT="synchronize" />
! 				<FIELD NAME="synchronize" TYPE="int" LENGTH="2" NOTNULL="true"
! 					UNSIGNED="true" DEFAULT="0" SEQUENCE="false" PREVIOUS="question"
! 					NEXT="single" />
! 				<FIELD NAME="single" TYPE="int" LENGTH="4" NOTNULL="true"
! 					UNSIGNED="false" DEFAULT="0" SEQUENCE="false"
! 					COMMENT="If 0 it multiple response (checkboxes). Otherwise it is radio buttons."
! 					PREVIOUS="synchronize" NEXT="shuffleanswers" />
! 				<FIELD NAME="shuffleanswers" TYPE="int" LENGTH="4" NOTNULL="true"
! 					UNSIGNED="false" DEFAULT="0" SEQUENCE="false"
! 					COMMENT="Whether the choices can be randomly shuffled." PREVIOUS="single"
! 					NEXT="correctfeedback" />
! 				<FIELD NAME="correctfeedback" TYPE="text" LENGTH="small"
! 					NOTNULL="false" SEQUENCE="false" COMMENT="Feedback shown for any correct response."
! 					PREVIOUS="shuffleanswers" NEXT="correctfeedbackformat" />
! 				<FIELD NAME="correctfeedbackformat" TYPE="int" LENGTH="2"
! 					NOTNULL="true" UNSIGNED="false" DEFAULT="0" SEQUENCE="false"
! 					PREVIOUS="correctfeedback" NEXT="partiallycorrectfeedback" />
! 				<FIELD NAME="partiallycorrectfeedback" TYPE="text" LENGTH="small"
! 					NOTNULL="false" SEQUENCE="false"
! 					COMMENT="Feedback shown for any partially correct response."
! 					PREVIOUS="correctfeedbackformat" NEXT="partiallycorrectfeedbackformat" />
! 				<FIELD NAME="partiallycorrectfeedbackformat" TYPE="int"
! 					LENGTH="2" NOTNULL="true" UNSIGNED="false" DEFAULT="0" SEQUENCE="false"
! 					PREVIOUS="partiallycorrectfeedback" NEXT="incorrectfeedback" />
! 				<FIELD NAME="incorrectfeedback" TYPE="text" LENGTH="small"
! 					NOTNULL="false" SEQUENCE="false"
! 					COMMENT="Feedback shown for any incorrect response." PREVIOUS="partiallycorrectfeedbackformat"
! 					NEXT="incorrectfeedbackformat" />
! 				<FIELD NAME="incorrectfeedbackformat" TYPE="int" LENGTH="2"
! 					NOTNULL="true" UNSIGNED="false" DEFAULT="0" SEQUENCE="false"
! 					PREVIOUS="incorrectfeedback" NEXT="answernumbering" />
! 				<FIELD NAME="answernumbering" TYPE="char" LENGTH="10" NOTNULL="true"
! 					DEFAULT="abc" SEQUENCE="false"
! 					COMMENT="Indicates how and whether the choices should be numbered."
! 					PREVIOUS="incorrectfeedbackformat" />
! 			</FIELDS>
! 			<KEYS>
! 				<KEY NAME="primary" TYPE="primary" FIELDS="id" NEXT="question" />
! 				<KEY NAME="question" TYPE="foreign" FIELDS="question" REFTABLE="question"
! 					REFFIELDS="id" PREVIOUS="primary" />
! 			</KEYS>
! 		</TABLE>
! 		<TABLE NAME="question_dataset_definitions" COMMENT="Organises and stores properties for dataset items"
! 			PREVIOUS="question_calculated_options" NEXT="question_dataset_items">
! 			<FIELDS>
! 				<FIELD NAME="id" TYPE="int" LENGTH="10" NOTNULL="true"
! 					UNSIGNED="true" SEQUENCE="true" NEXT="category" />
! 				<FIELD NAME="category" TYPE="int" LENGTH="10" NOTNULL="true"
! 					UNSIGNED="true" DEFAULT="0" SEQUENCE="false" PREVIOUS="id" NEXT="name" />
! 				<FIELD NAME="name" TYPE="char" LENGTH="255" NOTNULL="true"
! 					SEQUENCE="false" PREVIOUS="category" NEXT="type" />
! 				<FIELD NAME="type" TYPE="int" LENGTH="10" NOTNULL="true"
! 					UNSIGNED="false" DEFAULT="0" SEQUENCE="false" PREVIOUS="name" NEXT="options" />
! 				<FIELD NAME="options" TYPE="char" LENGTH="255" NOTNULL="true"
! 					SEQUENCE="false" PREVIOUS="type" NEXT="itemcount" />
! 				<FIELD NAME="itemcount" TYPE="int" LENGTH="10" NOTNULL="true"
! 					UNSIGNED="true" DEFAULT="0" SEQUENCE="false" PREVIOUS="options" />
! 			</FIELDS>
! 			<KEYS>
! 				<KEY NAME="primary" TYPE="primary" FIELDS="id" NEXT="category" />
! 				<KEY NAME="category" TYPE="foreign" FIELDS="category" REFTABLE="question_categories"
! 					REFFIELDS="id" PREVIOUS="primary" />
! 			</KEYS>
! 		</TABLE>
! 		<TABLE NAME="question_dataset_items" COMMENT="Individual dataset items"
! 			PREVIOUS="question_dataset_definitions" NEXT="question_datasets">
! 			<FIELDS>
! 				<FIELD NAME="id" TYPE="int" LENGTH="10" NOTNULL="true"
! 					UNSIGNED="true" SEQUENCE="true" NEXT="definition" />
! 				<FIELD NAME="definition" TYPE="int" LENGTH="10" NOTNULL="true"
! 					UNSIGNED="true" DEFAULT="0" SEQUENCE="false" PREVIOUS="id" NEXT="itemnumber" />
! 				<FIELD NAME="itemnumber" TYPE="int" LENGTH="10" NOTNULL="true"
! 					UNSIGNED="true" DEFAULT="0" SEQUENCE="false" PREVIOUS="definition"
! 					NEXT="value" />
! 				<FIELD NAME="value" TYPE="char" LENGTH="255" NOTNULL="true"
! 					SEQUENCE="false" PREVIOUS="itemnumber" />
! 			</FIELDS>
! 			<KEYS>
! 				<KEY NAME="primary" TYPE="primary" FIELDS="id" />
! 			</KEYS>
! 			<INDEXES>
! 				<INDEX NAME="definition" UNIQUE="false" FIELDS="definition" />
! 			</INDEXES>
! 		</TABLE>
! 		<TABLE NAME="question_datasets"
! 			COMMENT="Many-many relation between questions and dataset definitions"
! 			PREVIOUS="question_dataset_items">
! 			<FIELDS>
! 				<FIELD NAME="id" TYPE="int" LENGTH="10" NOTNULL="true"
! 					UNSIGNED="true" SEQUENCE="true" NEXT="question" />
! 				<FIELD NAME="question" TYPE="int" LENGTH="10" NOTNULL="true"
! 					UNSIGNED="true" DEFAULT="0" SEQUENCE="false" PREVIOUS="id"
! 					NEXT="datasetdefinition" />
! 				<FIELD NAME="datasetdefinition" TYPE="int" LENGTH="10"
! 					NOTNULL="true" UNSIGNED="true" DEFAULT="0" SEQUENCE="false"
! 					PREVIOUS="question" />
! 			</FIELDS>
! 			<KEYS>
! 				<KEY NAME="primary" TYPE="primary" FIELDS="id" NEXT="question" />
! 				<KEY NAME="question" TYPE="foreign" FIELDS="question" REFTABLE="question"
! 					REFFIELDS="id" PREVIOUS="primary" NEXT="datasetdefinition" />
! 				<KEY NAME="datasetdefinition" TYPE="foreign" FIELDS="datasetdefinition"
! 					REFTABLE="question_dataset_definitions" REFFIELDS="id" PREVIOUS="question" />
! 			</KEYS>
! 			<INDEXES>
! 				<INDEX NAME="question-datasetdefinition" UNIQUE="false"
! 					FIELDS="question, datasetdefinition" />
! 			</INDEXES>
! 		</TABLE>
! 	</TABLES>
  </XMLDB>
\ No newline at end of file
diff -crB questionorg/type/calculated/db/upgrade.php questionupd/type/calculated/db/upgrade.php
*** questionorg/type/calculated/db/upgrade.php	2012-04-13 12:31:12.011178266 +0500
--- questionupd/type/calculated/db/upgrade.php	2012-04-13 09:42:56.000000000 +0500
***************
*** 21,200 ****
  // before any action that may take longer time to finish.
  
  function xmldb_qtype_calculated_upgrade($oldversion) {
!     global $CFG, $DB;
  
!     $dbman = $DB->get_manager();
  
!     // MDL-16505.
!     if ($oldversion < 2008091700 ) { //New version in version.php
!         if (get_config('qtype_datasetdependent', 'version')) {
!             unset_config('version', 'qtype_datasetdependent');
!         }
!         upgrade_plugin_savepoint(true, 2008091700, 'qtype', 'calculated');
!     }
! 
!     if ($oldversion < 2009082000) { //New version in version.php
! 
! // this should be changed if merged to 1.9
! //    let if ($dbman->table_exists()) replace the normal $oldversion test
! //    as in any case the question question_calculated_options should be created
! 
!     /// Define table question_calculated_options to be created
!         $table = new xmldb_table('question_calculated_options');
! 
!     /// Adding fields to table question_calculated_options
!         $table->add_field('id', XMLDB_TYPE_INTEGER, '10', XMLDB_UNSIGNED, XMLDB_NOTNULL, XMLDB_SEQUENCE, null);
!         $table->add_field('question', XMLDB_TYPE_INTEGER, '10', XMLDB_UNSIGNED, XMLDB_NOTNULL, null, '0');
!         $table->add_field('synchronize', XMLDB_TYPE_INTEGER, '2', XMLDB_UNSIGNED, XMLDB_NOTNULL, null, '0');
! 
!     /// Adding keys to table question_calculated_options
!         $table->add_key('primary', XMLDB_KEY_PRIMARY, array('id'));
!         $table->add_key('question', XMLDB_KEY_FOREIGN, array('question'), 'question', array('id'));
! 
!     /// Conditionally launch create table for question_calculated_options
!         if (!$dbman->table_exists($table)) {
!             // $dbman->create_table doesnt return a result, we just have to trust it
!             $dbman->create_table($table);
!         }
!         upgrade_plugin_savepoint(true, 2009082000 , 'qtype', 'calculated');
!     }
! 
!     if ( $oldversion < 2009092000) { //New version in version.php
! 
!     /// Define field multichoice to be added to question_calculated_options
!     ///ALTER TABLE `moodle`.`mdl_question_calculated_options` DROP COLUMN `multichoice`;
!     //    $table = new xmldb_table('question_calculated_options');
!     //    $field = new xmldb_field('multichoice', XMLDB_TYPE_INTEGER, '2', XMLDB_UNSIGNED, XMLDB_NOTNULL, null, '0', 'synchronize');
! 
!     /// Conditionally launch add field multichoice
!      //   if (!$dbman->field_exists($table, $field)) {
!     //        $dbman->add_field($table, $field);
!     //    }
!     /// Define field single to be added to question_calculated_options
!         $table = new xmldb_table('question_calculated_options');
!         $field = new xmldb_field('single', XMLDB_TYPE_INTEGER, '4', null, XMLDB_NOTNULL, null, '0', 'synchronize');
! 
!     /// Conditionally launch add field single
!         if (!$dbman->field_exists($table, $field)) {
!             $dbman->add_field($table, $field);
!         }
! 
!     /// Define field shuffleanswers to be added to question_calculated_options
!         $table = new xmldb_table('question_calculated_options');
!         $field = new xmldb_field('shuffleanswers', XMLDB_TYPE_INTEGER, '4', null, XMLDB_NOTNULL, null, '0', 'single');
! 
!     /// Conditionally launch add field shuffleanswers
!         if (!$dbman->field_exists($table, $field)) {
!             $dbman->add_field($table, $field);
!         }
!     /// Define field correctfeedback to be added to question_calculated_options
!         $table = new xmldb_table('question_calculated_options');
!         $field = new xmldb_field('correctfeedback', XMLDB_TYPE_TEXT, 'small', null, null, null, null, 'shuffleanswers');
! 
!     /// Conditionally launch add field correctfeedback
!         if (!$dbman->field_exists($table, $field)) {
!             $dbman->add_field($table, $field);
!         }
! 
!     /// Define field partiallycorrectfeedback to be added to question_calculated_options
!         $table = new xmldb_table('question_calculated_options');
!         $field = new xmldb_field('partiallycorrectfeedback', XMLDB_TYPE_TEXT, 'small', null, null, null, null, 'correctfeedback');
! 
!     /// Conditionally launch add field partiallycorrectfeedback
!         if (!$dbman->field_exists($table, $field)) {
!             $dbman->add_field($table, $field);
!         }
!     /// Define field incorrectfeedback to be added to question_calculated_options
!         $table = new xmldb_table('question_calculated_options');
!         $field = new xmldb_field('incorrectfeedback', XMLDB_TYPE_TEXT, 'small', null, null, null, null, 'partiallycorrectfeedback');
! 
!     /// Conditionally launch add field incorrectfeedback
!         if (!$dbman->field_exists($table, $field)) {
!             $dbman->add_field($table, $field);
!         }
!     /// Define field answernumbering to be added to question_calculated_options
!         $table = new xmldb_table('question_calculated_options');
!         $field = new xmldb_field('answernumbering', XMLDB_TYPE_CHAR, '10', null, XMLDB_NOTNULL, null, 'abc', 'incorrectfeedback');
! 
!     /// Conditionally launch add field answernumbering
!         if (!$dbman->field_exists($table, $field)) {
!             $dbman->add_field($table, $field);
!         }
!         upgrade_plugin_savepoint(true, 2009092000, 'qtype', 'calculated');
!     }
! 
!     if ($oldversion < 2010020800) {
! 
!     /// Define field multiplechoice to be dropped from question_calculated_options
!         $table = new xmldb_table('question_calculated_options');
!         $field = new xmldb_field('multichoice');
! 
!     /// Conditionally launch drop field multiplechoice
!         if ($dbman->field_exists($table, $field)) {
!             $dbman->drop_field($table, $field);
!         }
! 
!     /// calculated savepoint reached
!         upgrade_plugin_savepoint(true, 2010020800, 'qtype', 'calculated');
!     }
! 
!     if ($oldversion < 2010020801) {
! 
!         // Define field correctfeedbackformat to be added to question_calculated_options
!         $table = new xmldb_table('question_calculated_options');
!         $field = new xmldb_field('correctfeedbackformat', XMLDB_TYPE_INTEGER, '2', null, XMLDB_NOTNULL, null, '0', 'correctfeedback');
! 
!         // Conditionally launch add field correctfeedbackformat
!         if (!$dbman->field_exists($table, $field)) {
!             $dbman->add_field($table, $field);
!         }
! 
!         // Define field partiallycorrectfeedbackformat to be added to question_calculated_options
!         $field = new xmldb_field('partiallycorrectfeedbackformat', XMLDB_TYPE_INTEGER, '2', null, XMLDB_NOTNULL, null, '0', 'partiallycorrectfeedback');
! 
!         // Conditionally launch add field partiallycorrectfeedbackformat
!         if (!$dbman->field_exists($table, $field)) {
!             $dbman->add_field($table, $field);
!         }
! 
!         // Define field incorrectfeedbackformat to be added to question_calculated_options
!         $field = new xmldb_field('incorrectfeedbackformat', XMLDB_TYPE_INTEGER, '2', null, XMLDB_NOTNULL, null, '0', 'incorrectfeedback');
! 
!         // Conditionally launch add field incorrectfeedbackformat
!         if (!$dbman->field_exists($table, $field)) {
!             $dbman->add_field($table, $field);
!         }
! 
!         // In the past, the correctfeedback, partiallycorrectfeedback,
!         // incorrectfeedback columns were assumed to contain content of the same
!         // form as questiontextformat. If we are using the HTML editor, then
!         // convert FORMAT_MOODLE content to FORMAT_HTML.
!         $rs = $DB->get_recordset_sql('
                  SELECT qco.*, q.oldquestiontextformat
                  FROM {question_calculated_options} qco
                  JOIN {question} q ON qco.question = q.id');
!         foreach ($rs as $record) {
!             if ($CFG->texteditors !== 'textarea' && $record->oldquestiontextformat == FORMAT_MOODLE) {
!                 $record->correctfeedback = text_to_html($record->correctfeedback, false, false, true);
!                 $record->correctfeedbackformat = FORMAT_HTML;
!                 $record->partiallycorrectfeedback = text_to_html($record->partiallycorrectfeedback, false, false, true);
!                 $record->partiallycorrectfeedbackformat = FORMAT_HTML;
!                 $record->incorrectfeedback = text_to_html($record->incorrectfeedback, false, false, true);
!                 $record->incorrectfeedbackformat = FORMAT_HTML;
!             } else {
!                 $record->correctfeedbackformat = $record->oldquestiontextformat;
!                 $record->partiallycorrectfeedback = $record->oldquestiontextformat;
!                 $record->incorrectfeedbackformat = $record->oldquestiontextformat;
!             }
!             $DB->update_record('question_calculated_options', $record);
!         }
!         $rs->close();
! 
!         // calculated savepoint reached
!         upgrade_plugin_savepoint(true, 2010020801, 'qtype', 'calculated');
!     }
  
!     return true;
  }
  
  
--- 21,200 ----
  // before any action that may take longer time to finish.
  
  function xmldb_qtype_calculated_upgrade($oldversion) {
! 	global $CFG, $DB;
  
! 	$dbman = $DB->get_manager();
  
! 	// MDL-16505.
! 	if ($oldversion < 2008091700 ) { //New version in version.php
! 		if (get_config('qtype_datasetdependent', 'version')) {
! 			unset_config('version', 'qtype_datasetdependent');
! 		}
! 		upgrade_plugin_savepoint(true, 2008091700, 'qtype', 'calculated');
! 	}
! 
! 	if ($oldversion < 2009082000) { //New version in version.php
! 
! 		// this should be changed if merged to 1.9
! 		//    let if ($dbman->table_exists()) replace the normal $oldversion test
! 		//    as in any case the question question_calculated_options should be created
! 
! 		/// Define table question_calculated_options to be created
! 		$table = new xmldb_table('question_calculated_options');
! 
! 		/// Adding fields to table question_calculated_options
! 		$table->add_field('id', XMLDB_TYPE_INTEGER, '10', XMLDB_UNSIGNED, XMLDB_NOTNULL, XMLDB_SEQUENCE, null);
! 		$table->add_field('question', XMLDB_TYPE_INTEGER, '10', XMLDB_UNSIGNED, XMLDB_NOTNULL, null, '0');
! 		$table->add_field('synchronize', XMLDB_TYPE_INTEGER, '2', XMLDB_UNSIGNED, XMLDB_NOTNULL, null, '0');
! 
! 		/// Adding keys to table question_calculated_options
! 		$table->add_key('primary', XMLDB_KEY_PRIMARY, array('id'));
! 		$table->add_key('question', XMLDB_KEY_FOREIGN, array('question'), 'question', array('id'));
! 
! 		/// Conditionally launch create table for question_calculated_options
! 		if (!$dbman->table_exists($table)) {
! 			// $dbman->create_table doesnt return a result, we just have to trust it
! 			$dbman->create_table($table);
! 		}
! 		upgrade_plugin_savepoint(true, 2009082000 , 'qtype', 'calculated');
! 	}
! 
! 	if ( $oldversion < 2009092000) { //New version in version.php
! 
! 		/// Define field multichoice to be added to question_calculated_options
! 		///ALTER TABLE `moodle`.`mdl_question_calculated_options` DROP COLUMN `multichoice`;
! 		//    $table = new xmldb_table('question_calculated_options');
! 		//    $field = new xmldb_field('multichoice', XMLDB_TYPE_INTEGER, '2', XMLDB_UNSIGNED, XMLDB_NOTNULL, null, '0', 'synchronize');
! 
! 		/// Conditionally launch add field multichoice
! 		//   if (!$dbman->field_exists($table, $field)) {
! 		//        $dbman->add_field($table, $field);
! 			//    }
! 			/// Define field single to be added to question_calculated_options
! 			$table = new xmldb_table('question_calculated_options');
! 			$field = new xmldb_field('single', XMLDB_TYPE_INTEGER, '4', null, XMLDB_NOTNULL, null, '0', 'synchronize');
! 
! 			/// Conditionally launch add field single
! 			if (!$dbman->field_exists($table, $field)) {
! 				$dbman->add_field($table, $field);
! 			}
! 
! 			/// Define field shuffleanswers to be added to question_calculated_options
! 			$table = new xmldb_table('question_calculated_options');
! 			$field = new xmldb_field('shuffleanswers', XMLDB_TYPE_INTEGER, '4', null, XMLDB_NOTNULL, null, '0', 'single');
! 
! 			/// Conditionally launch add field shuffleanswers
! 			if (!$dbman->field_exists($table, $field)) {
! 				$dbman->add_field($table, $field);
! 			}
! 			/// Define field correctfeedback to be added to question_calculated_options
! 			$table = new xmldb_table('question_calculated_options');
! 			$field = new xmldb_field('correctfeedback', XMLDB_TYPE_TEXT, 'small', null, null, null, null, 'shuffleanswers');
! 
! 			/// Conditionally launch add field correctfeedback
! 			if (!$dbman->field_exists($table, $field)) {
! 				$dbman->add_field($table, $field);
! 			}
! 
! 			/// Define field partiallycorrectfeedback to be added to question_calculated_options
! 			$table = new xmldb_table('question_calculated_options');
! 			$field = new xmldb_field('partiallycorrectfeedback', XMLDB_TYPE_TEXT, 'small', null, null, null, null, 'correctfeedback');
! 
! 			/// Conditionally launch add field partiallycorrectfeedback
! 			if (!$dbman->field_exists($table, $field)) {
! 				$dbman->add_field($table, $field);
! 			}
! 			/// Define field incorrectfeedback to be added to question_calculated_options
! 			$table = new xmldb_table('question_calculated_options');
! 			$field = new xmldb_field('incorrectfeedback', XMLDB_TYPE_TEXT, 'small', null, null, null, null, 'partiallycorrectfeedback');
! 
! 			/// Conditionally launch add field incorrectfeedback
! 			if (!$dbman->field_exists($table, $field)) {
! 				$dbman->add_field($table, $field);
! 			}
! 			/// Define field answernumbering to be added to question_calculated_options
! 			$table = new xmldb_table('question_calculated_options');
! 			$field = new xmldb_field('answernumbering', XMLDB_TYPE_CHAR, '10', null, XMLDB_NOTNULL, null, 'abc', 'incorrectfeedback');
! 
! 			/// Conditionally launch add field answernumbering
! 			if (!$dbman->field_exists($table, $field)) {
! 				$dbman->add_field($table, $field);
! 			}
! 			upgrade_plugin_savepoint(true, 2009092000, 'qtype', 'calculated');
! 	}
! 
! 	if ($oldversion < 2010020800) {
! 
! 		/// Define field multiplechoice to be dropped from question_calculated_options
! 		$table = new xmldb_table('question_calculated_options');
! 		$field = new xmldb_field('multichoice');
! 
! 		/// Conditionally launch drop field multiplechoice
! 		if ($dbman->field_exists($table, $field)) {
! 			$dbman->drop_field($table, $field);
! 		}
! 
! 		/// calculated savepoint reached
! 		upgrade_plugin_savepoint(true, 2010020800, 'qtype', 'calculated');
! 	}
! 
! 	if ($oldversion < 2010020801) {
! 
! 		// Define field correctfeedbackformat to be added to question_calculated_options
! 		$table = new xmldb_table('question_calculated_options');
! 		$field = new xmldb_field('correctfeedbackformat', XMLDB_TYPE_INTEGER, '2', null, XMLDB_NOTNULL, null, '0', 'correctfeedback');
! 
! 		// Conditionally launch add field correctfeedbackformat
! 		if (!$dbman->field_exists($table, $field)) {
! 			$dbman->add_field($table, $field);
! 		}
! 
! 		// Define field partiallycorrectfeedbackformat to be added to question_calculated_options
! 		$field = new xmldb_field('partiallycorrectfeedbackformat', XMLDB_TYPE_INTEGER, '2', null, XMLDB_NOTNULL, null, '0', 'partiallycorrectfeedback');
! 
! 		// Conditionally launch add field partiallycorrectfeedbackformat
! 		if (!$dbman->field_exists($table, $field)) {
! 			$dbman->add_field($table, $field);
! 		}
! 
! 		// Define field incorrectfeedbackformat to be added to question_calculated_options
! 		$field = new xmldb_field('incorrectfeedbackformat', XMLDB_TYPE_INTEGER, '2', null, XMLDB_NOTNULL, null, '0', 'incorrectfeedback');
! 
! 		// Conditionally launch add field incorrectfeedbackformat
! 		if (!$dbman->field_exists($table, $field)) {
! 			$dbman->add_field($table, $field);
! 		}
! 
! 		// In the past, the correctfeedback, partiallycorrectfeedback,
! 		// incorrectfeedback columns were assumed to contain content of the same
! 		// form as questiontextformat. If we are using the HTML editor, then
! 		// convert FORMAT_MOODLE content to FORMAT_HTML.
! 		$rs = $DB->get_recordset_sql('
                  SELECT qco.*, q.oldquestiontextformat
                  FROM {question_calculated_options} qco
                  JOIN {question} q ON qco.question = q.id');
! 		foreach ($rs as $record) {
! 			if ($CFG->texteditors !== 'textarea' && $record->oldquestiontextformat == FORMAT_MOODLE) {
! 				$record->correctfeedback = text_to_html($record->correctfeedback, false, false, true);
! 				$record->correctfeedbackformat = FORMAT_HTML;
! 				$record->partiallycorrectfeedback = text_to_html($record->partiallycorrectfeedback, false, false, true);
! 				$record->partiallycorrectfeedbackformat = FORMAT_HTML;
! 				$record->incorrectfeedback = text_to_html($record->incorrectfeedback, false, false, true);
! 				$record->incorrectfeedbackformat = FORMAT_HTML;
! 			} else {
! 				$record->correctfeedbackformat = $record->oldquestiontextformat;
! 				$record->partiallycorrectfeedback = $record->oldquestiontextformat;
! 				$record->incorrectfeedbackformat = $record->oldquestiontextformat;
! 			}
! 			$DB->update_record('question_calculated_options', $record);
! 		}
! 		$rs->close();
! 
! 		// calculated savepoint reached
! 		upgrade_plugin_savepoint(true, 2010020801, 'qtype', 'calculated');
! 	}
  
! 	return true;
  }
  
  
diff -crB questionorg/type/calculated/edit_calculated_form.php questionupd/type/calculated/edit_calculated_form.php
*** questionorg/type/calculated/edit_calculated_form.php	2012-04-13 12:31:11.949178264 +0500
--- questionupd/type/calculated/edit_calculated_form.php	2012-04-13 09:42:56.000000000 +0500
***************
*** 29,344 ****
   * calculated editing form definition.
   */
  class question_edit_calculated_form extends question_edit_form {
!     /**
!      * Handle to the question type for this question.
!      *
!      * @var question_calculated_qtype
!      */
!     public $qtypeobj;
!     public $questiondisplay;
!     public $activecategory;
!     public $categorychanged = false;
!     public $initialname = '';
!     public $reload = false;
! 
!     function question_edit_calculated_form(&$submiturl, &$question, &$category, &$contexts, $formeditable = true){
!         global $QTYPES, $SESSION, $CFG, $DB;
!         $this->question = $question;
!         $this->qtypeobj =& $QTYPES[$this->question->qtype];
!         if  (  "1" == optional_param('reload','', PARAM_INT )) {
!             $this->reload = true ;
!         }else {
!             $this->reload = false ;
!         }
! 
!         if(!$this->reload ){ // use database data as this is first pass
!             if(isset($this->question->id )){
!                 // remove prefix #{..}# if exists
!                 $this->initialname = $question->name ;
!                 $regs= array();
!                 if(preg_match('~#\{([^[:space:]]*)#~',$question->name , $regs)){
!                     $question->name = str_replace($regs[0], '', $question->name);
!                 };
!             }
!         }else {
!         }
!         parent::question_edit_form($submiturl, $question, $category, $contexts, $formeditable);
!     }
! 
!     function get_per_answer_fields(&$mform, $label, $gradeoptions, &$repeatedoptions, &$answersoption) {
!         // $repeated = parent::get_per_answer_fields($mform, $label, $gradeoptions, $repeatedoptions, $answersoption);
!         $repeated = array();
!         $repeated[] =& $mform->createElement('header', 'answerhdr', $label);
!         $repeated[] =& $mform->createElement('text', 'answer', get_string('answer', 'quiz'), array('size' => 50));
!         $repeated[] =& $mform->createElement('select', 'fraction', get_string('grade'), $gradeoptions);
!         $repeated[] =& $mform->createElement('editor', 'feedback', get_string('feedback', 'quiz'), null, $this->editoroptions);
!         $repeatedoptions['answer']['type'] = PARAM_RAW;
!         $repeatedoptions['fraction']['default'] = 0;
!         $answersoption = 'answers';
! 
!         $mform->setType('answer', PARAM_NOTAGS);
! 
!         $addrepeated = array();
!         $addrepeated[] =& $mform->createElement('text', 'tolerance', get_string('tolerance', 'qtype_calculated'));
!         $addrepeated[] =& $mform->createElement('select', 'tolerancetype', get_string('tolerancetype', 'quiz'), $this->qtypeobj->tolerance_types());
!         $repeatedoptions['tolerance']['type'] = PARAM_NUMBER;
!         $repeatedoptions['tolerance']['default'] = 0.01;
! 
!         $addrepeated[] =&  $mform->createElement('select', 'correctanswerlength', get_string('correctanswershows', 'qtype_calculated'), range(0, 9));
!         $repeatedoptions['correctanswerlength']['default'] = 2;
! 
!         $answerlengthformats = array('1' => get_string('decimalformat', 'quiz'), '2' => get_string('significantfiguresformat', 'quiz'));
!         $addrepeated[] =&  $mform->createElement('select', 'correctanswerformat', get_string('correctanswershowsformat', 'qtype_calculated'), $answerlengthformats);
!         array_splice($repeated, 3, 0, $addrepeated);
!         $repeated[1]->setLabel(get_string('correctanswerformula', 'quiz').'=');
! 
!         return $repeated;
!     }
! 
!     /**
!      * Add question-type specific form fields.
!      *
!      * @param MoodleQuickForm $mform the form being built.
!      */
!     function definition_inner(&$mform) {
!         global $QTYPES;
!         $this->qtypeobj =& $QTYPES[$this->qtype()];
!         $label = get_string('sharedwildcards', 'qtype_calculated');
!         $mform->addElement('hidden', 'initialcategory', 1);
!         $mform->addElement('hidden', 'reload', 1);
!         $mform->setType('initialcategory', PARAM_INT);
!         $html2 = $this->qtypeobj->print_dataset_definitions_category($this->question);
!         $mform->insertElementBefore($mform->createElement('static','listcategory',$label,$html2),'name');
!         if(isset($this->question->id )){
!             $mform->insertElementBefore($mform->createElement('static','initialname',get_string('questionstoredname','qtype_calculated'),$this->initialname),'name');
!         };
!         $addfieldsname='updatecategory';
!         $addstring=get_string("updatecategory", "qtype_calculated");
!         $mform->registerNoSubmitButton($addfieldsname);
! 
!         $mform->insertElementBefore(    $mform->createElement('submit', $addfieldsname, $addstring),'listcategory');
!         $mform->registerNoSubmitButton('createoptionbutton');
! 
!         //editing as regular
!         $mform->setType('single', PARAM_INT);
! 
!         $mform->addElement('hidden','shuffleanswers', '1');
!         $mform->setType('shuffleanswers', PARAM_INT);
!         $mform->addElement('hidden','answernumbering', 'abc');
!         $mform->setType('answernumbering', PARAM_SAFEDIR);
! 
!         $creategrades = get_grade_options();
! 
!         $this->add_per_answer_fields($mform, get_string('answerhdr', 'qtype_calculated', '{no}'), $creategrades->gradeoptions, 1, 1);
! 
!         $repeated = array();
! 
!         $QTYPES['numerical']->add_units_options($mform,$this);
!         $QTYPES['numerical']->add_units_elements($mform,$this);
! 
!         //hidden elements
!         $mform->addElement('hidden', 'synchronize', '');
!         $mform->setType('synchronize', PARAM_INT);
!         $mform->addElement('hidden', 'wizard', 'datasetdefinitions');
!         $mform->setType('wizard', PARAM_ALPHA);
!     }
! 
!     function data_preprocessing($question) {
!         global $QTYPES;
! 
!         $default_values = array();
!         if (isset($question->options)){
!             $answers = $question->options->answers;
!             if (count($answers)) {
!                 $key = 0;
!                 foreach ($answers as $answer){
!                     $draftid = file_get_submitted_draft_itemid('feedback['.$key.']');
!                     $default_values['answer['.$key.']'] = $answer->answer;
!                     $default_values['fraction['.$key.']'] = $answer->fraction;
!                     $default_values['tolerance['.$key.']'] = $answer->tolerance;
!                     $default_values['tolerancetype['.$key.']'] = $answer->tolerancetype;
!                     $default_values['correctanswerlength['.$key.']'] = $answer->correctanswerlength;
!                     $default_values['correctanswerformat['.$key.']'] = $answer->correctanswerformat;
!                     $default_values['feedback['.$key.']'] = array();
!                     $default_values['feedback['.$key.']']['text'] = file_prepare_draft_area(
!                         $draftid,           // draftid
!                         $this->context->id, // context
                          'question', // component
                          'answerfeedback',         // filarea
!                         !empty($answer->id)?(int)$answer->id:null, // itemid
!                         $this->fileoptions, // options
!                         $answer->feedback   // text
!                     );
!                     $default_values['feedback['.$key.']']['format'] = $answer->feedbackformat;
!                     $default_values['feedback['.$key.']']['itemid'] = $draftid;
!                     $key++;
!                 }
!             }
!             $default_values['synchronize'] = $question->options->synchronize ;
!             // set unit data, prepare files in instruction area
!             $QTYPES['numerical']->set_numerical_unit_data($this, $question, $default_values);
!         }
!         if (isset($question->options->single)){
!             $default_values['single'] =  $question->options->single;
!             $default_values['answernumbering'] =  $question->options->answernumbering;
!             $default_values['shuffleanswers'] =  $question->options->shuffleanswers;
!             // prepare feedback editor to display files in draft area
!         }
!         $default_values['submitbutton'] = get_string('nextpage', 'qtype_calculated');
!         $default_values['makecopy'] = get_string('makecopynextpage', 'qtype_calculated');
!         $default_values['returnurl'] = '0' ;
!         /* set the wild cards category display given that on loading the category element is
!         unselected when processing this function but have a valid value when processing the
!         update category button. The value can be obtain by
!          $qu->category =$this->_form->_elements[$this->_form->_elementIndex['category']]->_values[0];
!          but is coded using existing functions
!          */
!         $qu = new stdClass;
!         $el = new stdClass;
!         /* no need to call elementExists() here */
!         if ($this->_form->elementExists('category')){
!             $el=$this->_form->getElement('category');
!         } else {
!             $el=$this->_form->getElement('categorymoveto');
!         }
!         if($value =$el->getSelected()) {
!             $qu->category =$value[0];
!         }else {
!             $qu->category=$question->category;// on load  $question->category is set by question.php
!         }
!         $html2 = $this->qtypeobj->print_dataset_definitions_category($qu);
!         $this->_form->_elements[$this->_form->_elementIndex['listcategory']]->_text = $html2 ;
!         $question = (object)((array)$question + $default_values);
! 
!         return $question;
!     }
! 
!     function qtype() {
!         return 'calculated';
!     }
! 
!     function validation($data, $files) {
!         global $QTYPES;
!         // echo code left for testing period
! 
!         // echo "<p>question <pre>";print_r($this->question);echo "</pre></p>";
!         // echo "<p>data <pre>";print_r($data);echo "</pre></p>";
! 
!         $errors = parent::validation($data, $files);
!         //verifying for errors in {=...} in question text;
!         $qtext = "";
!         $qtextremaining = $data['questiontext']['text'];
!         $possibledatasets = $this->qtypeobj->find_dataset_names($data['questiontext']['text']);
!         foreach ($possibledatasets as $name => $value) {
!             $qtextremaining = str_replace('{'.$name.'}', '1', $qtextremaining);
!         }
!         // echo "numericalquestion qtextremaining <pre>";print_r($possibledatasets);
!         while (preg_match('~\{=([^[:space:]}]*)}~', $qtextremaining, $regs1)) {
!             $qtextsplits = explode($regs1[0], $qtextremaining, 2);
!             $qtext =$qtext.$qtextsplits[0];
!             $qtextremaining = $qtextsplits[1];
!             if (!empty($regs1[1]) && $formulaerrors = qtype_calculated_find_formula_errors($regs1[1])) {
!                 if(!isset($errors['questiontext'])){
!                     $errors['questiontext'] = $formulaerrors.':'.$regs1[1] ;
!                 }else {
!                     $errors['questiontext'] .= '<br/>'.$formulaerrors.':'.$regs1[1];
!                 }
!             }
!         }
!         $answers = $data['answer'];
!         $answercount = 0;
!         $maxgrade = false;
!         $possibledatasets = $this->qtypeobj->find_dataset_names($data['questiontext']['text']);
!         $mandatorydatasets = array();
!         foreach ($answers as $key => $answer){
!             $mandatorydatasets += $this->qtypeobj->find_dataset_names($answer);
!         }
!         if ( count($mandatorydatasets )==0){
!             //  $errors['questiontext']=get_string('atleastonewildcard', 'qtype_datasetdependent');
!             foreach ($answers as $key => $answer){
!                 $errors['answer['.$key.']'] = get_string('atleastonewildcard', 'qtype_datasetdependent');
!             }
!         }
!         // regular calculated
!         foreach ($answers as $key => $answer){
!             //check no of choices
!             // the * for everykind of answer not actually implemented
!             $trimmedanswer = trim($answer);
!             if (($trimmedanswer!='')||$answercount==0){
!                 $eqerror = qtype_calculated_find_formula_errors($trimmedanswer);
!                 if (FALSE !== $eqerror){
!                     $errors['answer['.$key.']'] = $eqerror;
!                 }
!             }
!             if ($trimmedanswer!=''){
!                 if ('2' == $data['correctanswerformat'][$key]
!                     && '0' == $data['correctanswerlength'][$key]) {
!                         $errors['correctanswerlength['.$key.']'] = get_string('zerosignificantfiguresnotallowed','quiz');
!                     }
!                 if (!is_numeric($data['tolerance'][$key])){
!                     $errors['tolerance['.$key.']'] = get_string('mustbenumeric', 'qtype_calculated');
!                 }
!                 if ($data['fraction'][$key] == 1) {
!                     $maxgrade = true;
!                 }
! 
!                 $answercount++;
!             }
!             //check grades
! 
!             //TODO how should grade checking work here??
!                 /*if ($answer != '') {
!                     if ($data['fraction'][$key] > 0) {
!                         $totalfraction += $data['fraction'][$key];
!                     }
!                     if ($data['fraction'][$key] > $maxfraction) {
!                         $maxfraction = $data['fraction'][$key];
!                     }
!                 }*/
!         }
! 
!         //grade checking :
!         /// Perform sanity checks on fractional grades
!             /*if ( ) {
!                 if ($maxfraction != 1) {
!                     $maxfraction = $maxfraction * 100;
!                     $errors['fraction[0]'] = get_string('errfractionsnomax', 'qtype_multichoice', $maxfraction);
!                 }
!             } else {
!                 $totalfraction = round($totalfraction,2);
!                 if ($totalfraction != 1) {
!                     $totalfraction = $totalfraction * 100;
!                     $errors['fraction[0]'] = get_string('errfractionsaddwrong', 'qtype_multichoice', $totalfraction);
!                 }
!             }
!             $units = $data['unit'];
!             if (count($units)) {
!                 foreach ($units as $key => $unit){
!                     if (is_numeric($unit)){
!                         $errors['unit['.$key.']'] = get_string('mustnotbenumeric', 'qtype_calculated');
!                     }
!                     $trimmedunit = trim($unit);
!                     $trimmedmultiplier = trim($data['multiplier'][$key]);
!                     if (!empty($trimmedunit)){
!                         if (empty($trimmedmultiplier)){
!                             $errors['multiplier['.$key.']'] = get_string('youmustenteramultiplierhere', 'qtype_calculated');
!                         }
!                         if (!is_numeric($trimmedmultiplier)){
!                             $errors['multiplier['.$key.']'] = get_string('mustbenumeric', 'qtype_calculated');
!                         }
! 
!                     }
!                 }
!             }*/
!         $QTYPES['numerical']->validate_numerical_options($data, $errors) ;
!         if ($answercount==0){
!             $errors['answer[0]'] = get_string('atleastoneanswer', 'qtype_calculated');
!         }
!         if ($maxgrade == false) {
!             $errors['fraction[0]'] = get_string('fractionsnomax', 'question');
!         }
  
  
!         return $errors;
!     }
  }
--- 29,344 ----
   * calculated editing form definition.
   */
  class question_edit_calculated_form extends question_edit_form {
! 	/**
! 	 * Handle to the question type for this question.
! 	 *
! 	 * @var question_calculated_qtype
! 	 */
! 	public $qtypeobj;
! 	public $questiondisplay;
! 	public $activecategory;
! 	public $categorychanged = false;
! 	public $initialname = '';
! 	public $reload = false;
! 
! 	function question_edit_calculated_form(&$submiturl, &$question, &$category, &$contexts, $formeditable = true){
! 		global $QTYPES, $SESSION, $CFG, $DB;
! 		$this->question = $question;
! 		$this->qtypeobj =& $QTYPES[$this->question->qtype];
! 		if  (  "1" == optional_param('reload','', PARAM_INT )) {
! 			$this->reload = true ;
! 		}else {
! 			$this->reload = false ;
! 		}
! 
! 		if(!$this->reload ){ // use database data as this is first pass
! 			if(isset($this->question->id )){
! 				// remove prefix #{..}# if exists
! 				$this->initialname = $question->name ;
! 				$regs= array();
! 				if(preg_match('~#\{([^[:space:]]*)#~',$question->name , $regs)){
! 					$question->name = str_replace($regs[0], '', $question->name);
! 				};
! 			}
! 		}else {
! 		}
! 		parent::question_edit_form($submiturl, $question, $category, $contexts, $formeditable);
! 	}
! 
! 	function get_per_answer_fields(&$mform, $label, $gradeoptions, &$repeatedoptions, &$answersoption) {
! 		// $repeated = parent::get_per_answer_fields($mform, $label, $gradeoptions, $repeatedoptions, $answersoption);
! 		$repeated = array();
! 		$repeated[] =& $mform->createElement('header', 'answerhdr', $label);
! 		$repeated[] =& $mform->createElement('text', 'answer', get_string('answer', 'quiz'), array('size' => 50));
! 		$repeated[] =& $mform->createElement('select', 'fraction', get_string('grade'), $gradeoptions);
! 		$repeated[] =& $mform->createElement('editor', 'feedback', get_string('feedback', 'quiz'), null, $this->editoroptions);
! 		$repeatedoptions['answer']['type'] = PARAM_RAW;
! 		$repeatedoptions['fraction']['default'] = 0;
! 		$answersoption = 'answers';
! 
! 		$mform->setType('answer', PARAM_NOTAGS);
! 
! 		$addrepeated = array();
! 		$addrepeated[] =& $mform->createElement('text', 'tolerance', get_string('tolerance', 'qtype_calculated'));
! 		$addrepeated[] =& $mform->createElement('select', 'tolerancetype', get_string('tolerancetype', 'quiz'), $this->qtypeobj->tolerance_types());
! 		$repeatedoptions['tolerance']['type'] = PARAM_NUMBER;
! 		$repeatedoptions['tolerance']['default'] = 0.01;
! 
! 		$addrepeated[] =&  $mform->createElement('select', 'correctanswerlength', get_string('correctanswershows', 'qtype_calculated'), range(0, 9));
! 		$repeatedoptions['correctanswerlength']['default'] = 2;
! 
! 		$answerlengthformats = array('1' => get_string('decimalformat', 'quiz'), '2' => get_string('significantfiguresformat', 'quiz'));
! 		$addrepeated[] =&  $mform->createElement('select', 'correctanswerformat', get_string('correctanswershowsformat', 'qtype_calculated'), $answerlengthformats);
! 		array_splice($repeated, 3, 0, $addrepeated);
! 		$repeated[1]->setLabel(get_string('correctanswerformula', 'quiz').'=');
! 
! 		return $repeated;
! 	}
! 
! 	/**
! 	 * Add question-type specific form fields.
! 	 *
! 	 * @param MoodleQuickForm $mform the form being built.
! 	 */
! 	function definition_inner(&$mform) {
! 		global $QTYPES;
! 		$this->qtypeobj =& $QTYPES[$this->qtype()];
! 		$label = get_string('sharedwildcards', 'qtype_calculated');
! 		$mform->addElement('hidden', 'initialcategory', 1);
! 		$mform->addElement('hidden', 'reload', 1);
! 		$mform->setType('initialcategory', PARAM_INT);
! 		$html2 = $this->qtypeobj->print_dataset_definitions_category($this->question);
! 		$mform->insertElementBefore($mform->createElement('static','listcategory',$label,$html2),'name');
! 		if(isset($this->question->id )){
! 			$mform->insertElementBefore($mform->createElement('static','initialname',get_string('questionstoredname','qtype_calculated'),$this->initialname),'name');
! 		};
! 		$addfieldsname='updatecategory';
! 		$addstring=get_string("updatecategory", "qtype_calculated");
! 		$mform->registerNoSubmitButton($addfieldsname);
! 
! 		$mform->insertElementBefore(    $mform->createElement('submit', $addfieldsname, $addstring),'listcategory');
! 		$mform->registerNoSubmitButton('createoptionbutton');
! 
! 		//editing as regular
! 		$mform->setType('single', PARAM_INT);
! 
! 		$mform->addElement('hidden','shuffleanswers', '1');
! 		$mform->setType('shuffleanswers', PARAM_INT);
! 		$mform->addElement('hidden','answernumbering', 'abc');
! 		$mform->setType('answernumbering', PARAM_SAFEDIR);
! 
! 		$creategrades = get_grade_options();
! 
! 		$this->add_per_answer_fields($mform, get_string('answerhdr', 'qtype_calculated', '{no}'), $creategrades->gradeoptions, 1, 1);
! 
! 		$repeated = array();
! 
! 		$QTYPES['numerical']->add_units_options($mform,$this);
! 		$QTYPES['numerical']->add_units_elements($mform,$this);
! 
! 		//hidden elements
! 		$mform->addElement('hidden', 'synchronize', '');
! 		$mform->setType('synchronize', PARAM_INT);
! 		$mform->addElement('hidden', 'wizard', 'datasetdefinitions');
! 		$mform->setType('wizard', PARAM_ALPHA);
! 	}
! 
! 	function data_preprocessing($question) {
! 		global $QTYPES;
! 
! 		$default_values = array();
! 		if (isset($question->options)){
! 			$answers = $question->options->answers;
! 			if (count($answers)) {
! 				$key = 0;
! 				foreach ($answers as $answer){
! 					$draftid = file_get_submitted_draft_itemid('feedback['.$key.']');
! 					$default_values['answer['.$key.']'] = $answer->answer;
! 					$default_values['fraction['.$key.']'] = $answer->fraction;
! 					$default_values['tolerance['.$key.']'] = $answer->tolerance;
! 					$default_values['tolerancetype['.$key.']'] = $answer->tolerancetype;
! 					$default_values['correctanswerlength['.$key.']'] = $answer->correctanswerlength;
! 					$default_values['correctanswerformat['.$key.']'] = $answer->correctanswerformat;
! 					$default_values['feedback['.$key.']'] = array();
! 					$default_values['feedback['.$key.']']['text'] = file_prepare_draft_area(
! 					$draftid,           // draftid
! 					$this->context->id, // context
                          'question', // component
                          'answerfeedback',         // filarea
! 					!empty($answer->id)?(int)$answer->id:null, // itemid
! 					$this->fileoptions, // options
! 					$answer->feedback   // text
! 					);
! 					$default_values['feedback['.$key.']']['format'] = $answer->feedbackformat;
! 					$default_values['feedback['.$key.']']['itemid'] = $draftid;
! 					$key++;
! 				}
! 			}
! 			$default_values['synchronize'] = $question->options->synchronize ;
! 			// set unit data, prepare files in instruction area
! 			$QTYPES['numerical']->set_numerical_unit_data($this, $question, $default_values);
! 		}
! 		if (isset($question->options->single)){
! 			$default_values['single'] =  $question->options->single;
! 			$default_values['answernumbering'] =  $question->options->answernumbering;
! 			$default_values['shuffleanswers'] =  $question->options->shuffleanswers;
! 			// prepare feedback editor to display files in draft area
! 		}
! 		$default_values['submitbutton'] = get_string('nextpage', 'qtype_calculated');
! 		$default_values['makecopy'] = get_string('makecopynextpage', 'qtype_calculated');
! 		$default_values['returnurl'] = '0' ;
! 		/* set the wild cards category display given that on loading the category element is
! 		 unselected when processing this function but have a valid value when processing the
! 		 update category button. The value can be obtain by
! 		 $qu->category =$this->_form->_elements[$this->_form->_elementIndex['category']]->_values[0];
! 		 but is coded using existing functions
! 		 */
! 		$qu = new stdClass;
! 		$el = new stdClass;
! 		/* no need to call elementExists() here */
! 		if ($this->_form->elementExists('category')){
! 			$el=$this->_form->getElement('category');
! 		} else {
! 			$el=$this->_form->getElement('categorymoveto');
! 		}
! 		if($value =$el->getSelected()) {
! 			$qu->category =$value[0];
! 		}else {
! 			$qu->category=$question->category;// on load  $question->category is set by question.php
! 		}
! 		$html2 = $this->qtypeobj->print_dataset_definitions_category($qu);
! 		$this->_form->_elements[$this->_form->_elementIndex['listcategory']]->_text = $html2 ;
! 		$question = (object)((array)$question + $default_values);
! 
! 		return $question;
! 	}
! 
! 	function qtype() {
! 		return 'calculated';
! 	}
! 
! 	function validation($data, $files) {
! 		global $QTYPES;
! 		// echo code left for testing period
! 
! 		// echo "<p>question <pre>";print_r($this->question);echo "</pre></p>";
! 		// echo "<p>data <pre>";print_r($data);echo "</pre></p>";
! 
! 		$errors = parent::validation($data, $files);
! 		//verifying for errors in {=...} in question text;
! 		$qtext = "";
! 		$qtextremaining = $data['questiontext']['text'];
! 		$possibledatasets = $this->qtypeobj->find_dataset_names($data['questiontext']['text']);
! 		foreach ($possibledatasets as $name => $value) {
! 			$qtextremaining = str_replace('{'.$name.'}', '1', $qtextremaining);
! 		}
! 		// echo "numericalquestion qtextremaining <pre>";print_r($possibledatasets);
! 		while (preg_match('~\{=([^[:space:]}]*)}~', $qtextremaining, $regs1)) {
! 			$qtextsplits = explode($regs1[0], $qtextremaining, 2);
! 			$qtext =$qtext.$qtextsplits[0];
! 			$qtextremaining = $qtextsplits[1];
! 			if (!empty($regs1[1]) && $formulaerrors = qtype_calculated_find_formula_errors($regs1[1])) {
! 				if(!isset($errors['questiontext'])){
! 					$errors['questiontext'] = $formulaerrors.':'.$regs1[1] ;
! 				}else {
! 					$errors['questiontext'] .= '<br/>'.$formulaerrors.':'.$regs1[1];
! 				}
! 			}
! 		}
! 		$answers = $data['answer'];
! 		$answercount = 0;
! 		$maxgrade = false;
! 		$possibledatasets = $this->qtypeobj->find_dataset_names($data['questiontext']['text']);
! 		$mandatorydatasets = array();
! 		foreach ($answers as $key => $answer){
! 			$mandatorydatasets += $this->qtypeobj->find_dataset_names($answer);
! 		}
! 		if ( count($mandatorydatasets )==0){
! 			//  $errors['questiontext']=get_string('atleastonewildcard', 'qtype_datasetdependent');
! 			foreach ($answers as $key => $answer){
! 				$errors['answer['.$key.']'] = get_string('atleastonewildcard', 'qtype_datasetdependent');
! 			}
! 		}
! 		// regular calculated
! 		foreach ($answers as $key => $answer){
! 			//check no of choices
! 			// the * for everykind of answer not actually implemented
! 			$trimmedanswer = trim($answer);
! 			if (($trimmedanswer!='')||$answercount==0){
! 				$eqerror = qtype_calculated_find_formula_errors($trimmedanswer);
! 				if (FALSE !== $eqerror){
! 					$errors['answer['.$key.']'] = $eqerror;
! 				}
! 			}
! 			if ($trimmedanswer!=''){
! 				if ('2' == $data['correctanswerformat'][$key]
! 				&& '0' == $data['correctanswerlength'][$key]) {
! 					$errors['correctanswerlength['.$key.']'] = get_string('zerosignificantfiguresnotallowed','quiz');
! 				}
! 				if (!is_numeric($data['tolerance'][$key])){
! 					$errors['tolerance['.$key.']'] = get_string('mustbenumeric', 'qtype_calculated');
! 				}
! 				if ($data['fraction'][$key] == 1) {
! 					$maxgrade = true;
! 				}
! 
! 				$answercount++;
! 			}
! 			//check grades
! 
! 			//TODO how should grade checking work here??
! 			/*if ($answer != '') {
! 			if ($data['fraction'][$key] > 0) {
! 			$totalfraction += $data['fraction'][$key];
! 			}
! 			if ($data['fraction'][$key] > $maxfraction) {
! 			$maxfraction = $data['fraction'][$key];
! 			}
! 			}*/
! 		}
! 
! 		//grade checking :
! 		/// Perform sanity checks on fractional grades
! 		/*if ( ) {
! 		 if ($maxfraction != 1) {
! 		 $maxfraction = $maxfraction * 100;
! 		 $errors['fraction[0]'] = get_string('errfractionsnomax', 'qtype_multichoice', $maxfraction);
! 		 }
! 		 } else {
! 		 $totalfraction = round($totalfraction,2);
! 		 if ($totalfraction != 1) {
! 		 $totalfraction = $totalfraction * 100;
! 		 $errors['fraction[0]'] = get_string('errfractionsaddwrong', 'qtype_multichoice', $totalfraction);
! 		 }
! 		 }
! 		 $units = $data['unit'];
! 		 if (count($units)) {
! 		 foreach ($units as $key => $unit){
! 		 if (is_numeric($unit)){
! 		 $errors['unit['.$key.']'] = get_string('mustnotbenumeric', 'qtype_calculated');
! 		 }
! 		 $trimmedunit = trim($unit);
! 		 $trimmedmultiplier = trim($data['multiplier'][$key]);
! 		 if (!empty($trimmedunit)){
! 		 if (empty($trimmedmultiplier)){
! 		 $errors['multiplier['.$key.']'] = get_string('youmustenteramultiplierhere', 'qtype_calculated');
! 		 }
! 		 if (!is_numeric($trimmedmultiplier)){
! 		 $errors['multiplier['.$key.']'] = get_string('mustbenumeric', 'qtype_calculated');
! 		 }
! 
! 		 }
! 		 }
! 		 }*/
! 		$QTYPES['numerical']->validate_numerical_options($data, $errors) ;
! 		if ($answercount==0){
! 			$errors['answer[0]'] = get_string('atleastoneanswer', 'qtype_calculated');
! 		}
! 		if ($maxgrade == false) {
! 			$errors['fraction[0]'] = get_string('fractionsnomax', 'question');
! 		}
  
  
! 		return $errors;
! 	}
  }
diff -crB questionorg/type/calculated/lib.php questionupd/type/calculated/lib.php
*** questionorg/type/calculated/lib.php	2012-04-13 12:31:12.012178266 +0500
--- questionupd/type/calculated/lib.php	2012-04-13 09:42:56.000000000 +0500
***************
*** 25,31 ****
   * @license http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
   */
  function qtype_calculated_pluginfile($course, $cm, $context, $filearea, $args, $forcedownload) {
!     global $CFG;
!     require_once($CFG->libdir . '/questionlib.php');
!     question_pluginfile($course, $context, 'qtype_calculated', $filearea, $args, $forcedownload);
  }
--- 25,31 ----
   * @license http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
   */
  function qtype_calculated_pluginfile($course, $cm, $context, $filearea, $args, $forcedownload) {
! 	global $CFG;
! 	require_once($CFG->libdir . '/questionlib.php');
! 	question_pluginfile($course, $context, 'qtype_calculated', $filearea, $args, $forcedownload);
  }
diff -crB questionorg/type/calculated/questiontype.php questionupd/type/calculated/questiontype.php
*** questionorg/type/calculated/questiontype.php	2012-04-13 12:31:12.000178267 +0500
--- questionupd/type/calculated/questiontype.php	2012-04-13 09:42:56.000000000 +0500
***************
*** 24,1725 ****
  
  class question_calculated_qtype extends default_questiontype {
  
!     public $fileoptionsa = array(
          'subdirs' => false,
          'maxfiles' => -1,
          'maxbytes' => 0,
!     );
  
!     // Used by the function custom_generator_tools:
!     public $calcgenerateidhasbeenadded = false;
!     public $virtualqtype = false;
!     public $wizard_pages_number = 3 ;
! 
!     function name() {
!         return 'calculated';
!     }
! 
!     function has_wildcards_in_responses($question, $subqid) {
!         return true;
!     }
! 
!     function requires_qtypes() {
!         return array('numerical');
!     }
! 
!     function get_question_options(&$question) {
!         // First get the datasets and default options
!         // the code is used for calculated, calculatedsimple and calculatedmulti qtypes
!         global $CFG, $DB, $OUTPUT, $QTYPES;
!         if (!$question->options = $DB->get_record('question_calculated_options', array('question' => $question->id))) {
!             //  echo $OUTPUT->notification('Error: Missing question options for calculated question'.$question->id.'!');
!             //  return false;
!             $question->options->synchronize = 0;
!             $question->options->single = 0; //$question->single;
!             $question->options->answernumbering = 'abc';
!             $question->options->shuffleanswers = 0 ;
!             $question->options->correctfeedback = '';
!             $question->options->partiallycorrectfeedback = '';
!             $question->options->incorrectfeedback = '';
!             $question->options->correctfeedbackformat = 0;
!             $question->options->partiallycorrectfeedbackformat = 0;
!             $question->options->incorrectfeedbackformat = 0;
!         }
  
!         if (!$question->options->answers = $DB->get_records_sql(
              "SELECT a.*, c.tolerance, c.tolerancetype, c.correctanswerlength, c.correctanswerformat " .
              "FROM {question_answers} a, " .
              "     {question_calculated} c " .
              "WHERE a.question = ? " .
              "AND   a.id = c.answer ".
              "ORDER BY a.id ASC", array($question->id))) {
!                 // echo $OUTPUT->notification('Error: Missing question answer for calculated question ' . $question->id . '!');
!                 return false;
              }
  
!         if ( $this->get_virtual_qtype() ==  $QTYPES['numerical']){
!             $QTYPES['numerical']->get_numerical_units($question);
!             $QTYPES['numerical']->get_numerical_options($question);
!         }
! 
!         if( isset($question->export_process)&&$question->export_process){
!             $question->options->datasets = $this->get_datasets_for_export($question);
!         }
!         return true;
!     }
! 
!     function get_datasets_for_export(&$question){
!         global $DB, $CFG;
!         $datasetdefs = array();
!         if (!empty($question->id)) {
!             $sql = "SELECT i.*
!                       FROM {question_datasets} d, {question_dataset_definitions} i
!                      WHERE d.question = ? AND d.datasetdefinition = i.id";
!             if ($records = $DB->get_records_sql($sql, array($question->id))) {
!                 foreach ($records as $r) {
!                     $def = $r ;
!                     if ($def->category=='0'){
!                         $def->status='private';
!                     } else {
!                         $def->status='shared';
!                     }
!                     $def->type ='calculated' ;
!                     list($distribution, $min, $max,$dec) = explode(':', $def->options, 4);
!                     $def->distribution=$distribution;
!                     $def->minimum=$min;
!                     $def->maximum=$max;
!                     $def->decimals=$dec ;
!                     if ($def->itemcount > 0 ) {
!                         // get the datasetitems
!                         $def->items = array();
!                         if ($items = $this->get_database_dataset_items($def->id)){
!                             $n = 0;
!                             foreach( $items as $ii){
!                                 $n++;
!                                 $def->items[$n] = new stdClass;
!                                 $def->items[$n]->itemnumber=$ii->itemnumber;
!                                 $def->items[$n]->value=$ii->value;
!                             }
!                             $def->number_of_items=$n ;
!                         }
!                     }
!                     $datasetdefs["1-$r->category-$r->name"] = $def;
!                 }
!             }
!         }
!         return $datasetdefs ;
!     }
! 
!     function save_question_options($question) {
!         global $CFG, $DB, $QTYPES ;
!         // the code is used for calculated, calculatedsimple and calculatedmulti qtypes
!         $context = $question->context;
!         if (isset($question->answer) && !isset($question->answers)) {
!             $question->answers = $question->answer;
!         }
!         // calculated options
!         $update = true ;
!         $options = $DB->get_record("question_calculated_options", array("question" => $question->id));
!         if (!$options) {
!             $update = false;
!             $options = new stdClass;
!             $options->question = $question->id;
!         }
!         // as used only by calculated
!         if(isset($question->synchronize)){
!             $options->synchronize = $question->synchronize;
!         }else {
!             $options->synchronize = 0 ;
!         }
!         $options->single = 0; //$question->single;
!         $options->answernumbering =  $question->answernumbering;
!         $options->shuffleanswers = $question->shuffleanswers;
! 
!         foreach (array('correctfeedback', 'partiallycorrectfeedback', 'incorrectfeedback') as $feedbackname) {
!             $options->$feedbackname = '';
!             $feedbackformat = $feedbackname . 'format';
!             $options->$feedbackformat = 0 ;
!         }
! 
!         if ($update) {
!             $DB->update_record("question_calculated_options", $options);
!         } else {
!             $DB->insert_record("question_calculated_options", $options);
!         }
! 
!         // Get old versions of the objects
!         if (!$oldanswers = $DB->get_records('question_answers', array('question' => $question->id), 'id ASC')) {
!             $oldanswers = array();
!         }
! 
!         if (!$oldoptions = $DB->get_records('question_calculated', array('question' => $question->id), 'answer ASC')) {
!             $oldoptions = array();
!         }
! 
!         // Save the units.
!         $virtualqtype = $this->get_virtual_qtype();
!         $result = $virtualqtype->save_numerical_units($question);
!         if (isset($result->error)) {
!             return $result;
!         } else {
!             $units = &$result->units;
!         }
!         // Insert all the new answers
!         if (isset($question->answer) && !isset($question->answers)) {
!             $question->answers=$question->answer;
!         }
!         foreach ($question->answers as $key => $dataanswer) {
!             if (is_array($dataanswer)) {
!                 $dataanswer = $dataanswer['text'];
              }
-             if ( trim($dataanswer) != '' ) {
-                 $answer = new stdClass;
-                 $answer->question = $question->id;
-                 $answer->answer = trim($dataanswer);
-                 $answer->fraction = $question->fraction[$key];
-                 $answer->feedbackformat = $question->feedback[$key]['format'];
-                 if (isset($question->feedback[$key]['files'])) {
-                     $files = $question->feedback[$key]['files'];
-                 }
  
!                 if ($oldanswer = array_shift($oldanswers)) {  // Existing answer, so reuse it
!                     $answer->id = $oldanswer->id;
!                     $answer->feedback = file_save_draft_area_files($question->feedback[$key]['itemid'], $context->id, 'question', 'answerfeedback', $oldanswer->id, $this->fileoptionsa, trim($question->feedback[$key]['text']));
!                     $DB->update_record("question_answers", $answer);
!                 } else { // This is a completely new answer
!                     $answer->feedback = trim($question->feedback[$key]['text']);
!                     $answer->id = $DB->insert_record("question_answers", $answer);
!                     if (isset($files)) {
!                         foreach ($files as $file) {
!                             $this->import_file($context, 'question', 'answerfeedback', $answer->id, $file);
!                         }
!                     } else {
!                         $answer->feedback = file_save_draft_area_files($question->feedback[$key]['itemid'], $context->id, 'question', 'answerfeedback', $answer->id, $this->fileoptionsa , trim($question->feedback[$key]['text']));
!                     }
!                     $DB->set_field('question_answers', 'feedback', $answer->feedback, array('id'=>$answer->id));
!                 }
! 
!                 // Set up the options object
!                 if (!$options = array_shift($oldoptions)) {
!                     $options = new stdClass;
!                 }
!                 $options->question  = $question->id;
!                 $options->answer    = $answer->id;
!                 $options->tolerance = trim($question->tolerance[$key]);
!                 $options->tolerancetype  = trim($question->tolerancetype[$key]);
!                 $options->correctanswerlength  = trim($question->correctanswerlength[$key]);
!                 $options->correctanswerformat  = trim($question->correctanswerformat[$key]);
! 
!                 // Save options
!                 if (isset($options->id)) { // reusing existing record
!                     $DB->update_record('question_calculated', $options);
!                 } else { // new options
!                     $DB->insert_record('question_calculated', $options);
!                 }
!             }
!         }
!         // delete old answer records
!         if (!empty($oldanswers)) {
!             foreach($oldanswers as $oa) {
!                 $DB->delete_records('question_answers', array('id' => $oa->id));
              }
!         }
! 
!         // delete old answer records
!         if (!empty($oldoptions)) {
!             foreach($oldoptions as $oo) {
!                 $DB->delete_records('question_calculated', array('id' => $oo->id));
!             }
!         }
  
!         $result = $QTYPES['numerical']->save_numerical_options($question);
!         if (isset($result->error)) {
!             return $result;
!         }
! 
!         if( isset($question->import_process)&&$question->import_process){
!             $this->import_datasets($question);
!         }
!         // Report any problems.
!         if (!empty($result->notice)) {
!             return $result;
!         }
!         return true;
!     }
! 
!     function import_datasets($question){
!         global $DB;
!         $n = count($question->dataset);
!         foreach ($question->dataset as $dataset) {
!             // name, type, option,
!             $datasetdef = new stdClass();
!             $datasetdef->name = $dataset->name;
!             $datasetdef->type = 1 ;
!             $datasetdef->options =  $dataset->distribution.':'.$dataset->min.':'.$dataset->max.':'.$dataset->length;
!             $datasetdef->itemcount=$dataset->itemcount;
!             if ( $dataset->status =='private'){
!                 $datasetdef->category = 0;
!                 $todo='create' ;
!             }else if ($dataset->status =='shared' ){
!                 if ($sharedatasetdefs = $DB->get_records_select(
                      'question_dataset_definitions',
                      "type = '1'
                      AND name = ?
                      AND category = ?
                      ORDER BY id DESC ", array($dataset->name, $question->category)
!                 )) { // so there is at least one
!                     $sharedatasetdef = array_shift($sharedatasetdefs);
!                     if ( $sharedatasetdef->options ==  $datasetdef->options ){// identical so use it
!                         $todo='useit' ;
!                         $datasetdef =$sharedatasetdef ;
!                     } else { // different so create a private one
!                         $datasetdef->category = 0;
!                         $todo='create' ;
!                     }
!                 }else { // no so create one
!                     $datasetdef->category =$question->category ;
!                     $todo='create' ;
!                 }
!             }
!             if (  $todo=='create'){
!                 $datasetdef->id = $DB->insert_record( 'question_dataset_definitions', $datasetdef);
!             }
!             // Create relation to the dataset:
!             $questiondataset = new stdClass;
!             $questiondataset->question = $question->id;
!             $questiondataset->datasetdefinition = $datasetdef->id;
!             $DB->insert_record('question_datasets', $questiondataset);
!             if ($todo=='create'){ // add the items
!                 foreach ($dataset->datasetitem as $dataitem ){
!                     $datasetitem = new stdClass;
!                     $datasetitem->definition=$datasetdef->id ;
!                     $datasetitem->itemnumber = $dataitem->itemnumber ;
!                     $datasetitem->value = $dataitem->value ;
!                     $DB->insert_record('question_dataset_items', $datasetitem);
!                 }
!             }
!         }
!     }
! 
!     function restore_session_and_responses(&$question, &$state) {
!         global $OUTPUT;
!         if (!preg_match('~^dataset([0-9]+)[^-]*-(.*)$~',
!             $state->responses[''], $regs)) {
!                 echo $OUTPUT->notification("Wrongly formatted raw response answer " .
                      "{$state->responses['']}! Could not restore session for " .
                      " question #{$question->id}.");
!                 $state->options->datasetitem = 1;
!                 $state->options->dataset = array();
!                 $state->responses = array('' => '');
!                 return false;
!             }
! 
!         // Restore the chosen dataset
!         $state->options->datasetitem = $regs[1];
!         $state->options->dataset =
!             $this->pick_question_dataset($question,$state->options->datasetitem);
!         $state->responses = array('' => $regs[2]);
!         $virtualqtype = $this->get_virtual_qtype();
!         return $virtualqtype->restore_session_and_responses($question, $state);
!     }
! 
!     function create_session_and_responses(&$question, &$state, $cmoptions, $attempt) {
!         // Find out how many datasets are available
!         global $CFG, $DB, $QTYPES, $OUTPUT;
!         if(!$maxnumber = (int)$DB->get_field_sql(
              "SELECT MIN(a.itemcount)
                 FROM {question_dataset_definitions} a, {question_datasets} b
                WHERE b.question = ? AND a.id = b.datasetdefinition", array($question->id))) {
!             print_error('cannotgetdsforquestion', 'question', '', $question->id);
!         }
  
!         $sql = "SELECT i.*
                    FROM {question_datasets} d, {question_dataset_definitions} i
                   WHERE d.question = ? AND d.datasetdefinition = i.id AND i.category != 0";
  
!         if (!$question->options->synchronize || !$records = $DB->get_records_sql($sql, array($question->id))) {
!             $synchronize_calculated  =  false ;
!         }else {
!             // i.e records is true so test coherence
!             $coherence = true ;
!             $a = new stdClass ;
!             $a->qid = $question->id ;
!             $a->qcat = $question->category ;
!             foreach($records as $def ){
                  if ($def->category != $question->category){
!                     $a->name = $def->name;
!                     $a->sharedcat = $def->category ;
!                     $coherence = false ;
!                     break;
                  }
!             }
!             if(!$coherence){
                  echo $OUTPUT->notification(get_string('nocoherencequestionsdatyasetcategory','qtype_calculated',$a));
!             }
!             $synchronize_calculated  = true ;
!         }
! 
!         // Choose a random dataset
!         // maxnumber sould not be breater than 100
!         if ($maxnumber > CALCULATEDQUESTIONMAXITEMNUMBER ){
!             $maxnumber = CALCULATEDQUESTIONMAXITEMNUMBER ;
!         }
!         if ( $synchronize_calculated === false ) {
!             $state->options->datasetitem = rand(1, $maxnumber);
!         }else{
!             $state->options->datasetitem = intval( $maxnumber * substr($attempt->timestart,-2) /100 ) ;
!             if ($state->options->datasetitem < 1) {
                  $state->options->datasetitem =1 ;
!             } else if ($state->options->datasetitem > $maxnumber){
                  $state->options->datasetitem = $maxnumber ;
!             }
! 
!         };
!         $state->options->dataset =
!             $this->pick_question_dataset($question,$state->options->datasetitem);
!         $virtualqtype = $this->get_virtual_qtype( );
!         return $virtualqtype->create_session_and_responses($question, $state, $cmoptions, $attempt);
!     }
! 
!     function save_session_and_responses(&$question, &$state) {
!         global $DB;
!         $responses = 'dataset'.$state->options->datasetitem.'-' ;
!         // regular numeric type
!         if(isset($state->responses['unit']) && isset($question->options->units[$state->responses['unit']])){
!             $responses .= $state->responses['answer'].'|||||'.$question->options->units[$state->responses['unit']]->unit;
!         }else if(isset($state->responses['unit'])){
!             $responses .= $state->responses['answer'].'|||||'.$state->responses['unit'] ;
!         }else {
!             $responses .= $state->responses['answer'].'|||||';
!         }
! 
!         // Set the legacy answer field
!         $DB->set_field('question_states', 'answer', $responses, array('id'=> $state->id));
! 
!         return true;
!     }
! 
!     function create_runtime_question($question, $form) {
!         $question = parent::create_runtime_question($question, $form);
!         $question->options->answers = array();
!         foreach ($form->answers as $key => $answer) {
!             $a->answer              = trim($form->answer[$key]);
!             $a->fraction              = $form->fraction[$key];//new
!             $a->tolerance           = $form->tolerance[$key];
!             $a->tolerancetype       = $form->tolerancetype[$key];
!             $a->correctanswerlength = $form->correctanswerlength[$key];
!             $a->correctanswerformat = $form->correctanswerformat[$key];
!             $question->options->answers[] = clone($a);
!         }
! 
!         return $question;
!     }
! 
!     function validate_form($form) {
!         switch($form->wizardpage) {
!         case 'question':
!             $calculatedmessages = array();
!             if (empty($form->name)) {
!                 $calculatedmessages[] = get_string('missingname', 'quiz');
!             }
!             if (empty($form->questiontext)) {
!                 $calculatedmessages[] = get_string('missingquestiontext', 'quiz');
!             }
!             // Verify formulas
!             foreach ($form->answers as $key => $answer) {
!                 if ('' === trim($answer)) {
!                     $calculatedmessages[] =
!                         get_string('missingformula', 'quiz');
!                 }
!                 if ($formulaerrors =
!                     qtype_calculated_find_formula_errors($answer)) {
!                         $calculatedmessages[] = $formulaerrors;
!                     }
!                 if (! isset($form->tolerance[$key])) {
!                     $form->tolerance[$key] = 0.0;
!                 }
!                 if (! is_numeric($form->tolerance[$key])) {
!                     $calculatedmessages[] =
!                         get_string('tolerancemustbenumeric', 'quiz');
!                 }
!             }
! 
!             if (!empty($calculatedmessages)) {
!                 $errorstring = "The following errors were found:<br />";
!                 foreach ($calculatedmessages as $msg) {
!                     $errorstring .= $msg . '<br />';
!                 }
!                 print_error($errorstring);
!             }
  
!             break;
!         default:
!             return parent::validate_form($form);
!             break;
!         }
!         return true;
!     }
!     function finished_edit_wizard(&$form) {
!         return isset($form->backtoquiz);
!     }
!     function wizard_pages_number() {
!         return 3 ;
!     }
!     // This gets called by editquestion.php after the standard question is saved
!     function print_next_wizard_page(&$question, &$form, $course) {
!         global $CFG, $USER, $SESSION, $COURSE;
! 
!         // Catch invalid navigation & reloads
!         if (empty($question->id) && empty($SESSION->calculated)) {
!             redirect('edit.php?courseid='.$COURSE->id, 'The page you are loading has expired.', 3);
!         }
! 
!         // See where we're coming from
!         switch($form->wizardpage) {
!         case 'question':
!             require("$CFG->dirroot/question/type/calculated/datasetdefinitions.php");
!             break;
!         case 'datasetdefinitions':
!         case 'datasetitems':
!             require("$CFG->dirroot/question/type/calculated/datasetitems.php");
!             break;
!         default:
!             print_error('invalidwizardpage', 'question');
!             break;
!         }
!     }
! 
!     // This gets called by question2.php after the standard question is saved
!     function &next_wizard_form($submiturl, $question, $wizardnow){
!         global $CFG, $SESSION, $COURSE;
! 
!         // Catch invalid navigation & reloads
!         if (empty($question->id) && empty($SESSION->calculated)) {
!             redirect('edit.php?courseid='.$COURSE->id, 'The page you are loading has expired. Cannot get next wizard form.', 3);
!         }
!         if (empty($question->id)){
!             $question =& $SESSION->calculated->questionform;
!         }
! 
!         // See where we're coming from
!         switch($wizardnow) {
!         case 'datasetdefinitions':
!             require("$CFG->dirroot/question/type/calculated/datasetdefinitions_form.php");
!             $mform = new question_dataset_dependent_definitions_form("$submiturl?wizardnow=datasetdefinitions", $question);
!             break;
!         case 'datasetitems':
!             require("$CFG->dirroot/question/type/calculated/datasetitems_form.php");
!             $regenerate = optional_param('forceregeneration', 0, PARAM_BOOL);
!             $mform = new question_dataset_dependent_items_form("$submiturl?wizardnow=datasetitems", $question, $regenerate);
!             break;
!         default:
!             print_error('invalidwizardpage', 'question');
!             break;
!         }
! 
!         return $mform;
!     }
! 
!     /**
!      * This method should be overriden if you want to include a special heading or some other
!      * html on a question editing page besides the question editing form.
!      *
!      * @param question_edit_form $mform a child of question_edit_form
!      * @param object $question
!      * @param string $wizardnow is '' for first page.
!      */
!     function display_question_editing_page(&$mform, $question, $wizardnow){
!         global $OUTPUT ;
!         switch ($wizardnow){
!         case '':
!             //on first page default display is fine
!             parent::display_question_editing_page($mform, $question, $wizardnow);
!             return;
!             break;
!         case 'datasetdefinitions':
!             echo $OUTPUT->heading_with_help(get_string("choosedatasetproperties", "qtype_calculated"), 'questiondatasets', 'qtype_calculated');
!             break;
!         case 'datasetitems':
!             echo $OUTPUT->heading_with_help(get_string("editdatasets", "qtype_calculated"), 'questiondatasets', 'qtype_calculated');
!             break;
!         }
! 
!         $mform->display();
!     }
! 
!     /**
!      * This method prepare the $datasets in a format similar to dadatesetdefinitions_form.php
!      * so that they can be saved
!      * using the function save_dataset_definitions($form)
!      *  when creating a new calculated question or
!      *  whenediting an already existing calculated question
!      * or by  function save_as_new_dataset_definitions($form, $initialid)
!      *  when saving as new an already existing calculated question
!      *
!      * @param object $form
!      * @param int $questionfromid default = '0'
!      */
!     function preparedatasets(&$form , $questionfromid='0'){
!         // the dataset names present in the edit_question_form and edit_calculated_form are retrieved
!         $possibledatasets = $this->find_dataset_names($form->questiontext);
!         $mandatorydatasets = array();
!         foreach ($form->answers as $answer) {
!             $mandatorydatasets += $this->find_dataset_names($answer);
!         }
!         // if there are identical datasetdefs already saved in the original question.
!         // either when editing a question or saving as new
!         // they are retrieved using $questionfromid
!         if ($questionfromid!='0'){
!             $form->id = $questionfromid ;
!         }
!         $datasets = array();
!         $key = 0 ;
!         // always prepare the mandatorydatasets present in the answers
!         // the $options are not used here
!         foreach ($mandatorydatasets as $datasetname) {
!             if (!isset($datasets[$datasetname])) {
!                 list($options, $selected) =
!                     $this->dataset_options($form, $datasetname);
!                 $datasets[$datasetname]='';
!                 $form->dataset[$key]=$selected ;
!                 $key++;
!             }
!         }
!         // do not prepare possibledatasets when creating a question
!         // they will defined and stored with datasetdefinitions_form.php
!         // the $options are not used here
!         if ($questionfromid!='0'){
! 
!             foreach ($possibledatasets as $datasetname) {
!                 if (!isset($datasets[$datasetname])) {
!                     list($options, $selected) =
!                         $this->dataset_options($form, $datasetname,false);
!                     $datasets[$datasetname]='';
!                     $form->dataset[$key]=$selected ;
!                     $key++;
!                 }
!             }
!         }
!         return $datasets ;
!     }
!     function addnamecategory(&$question){
!         global $DB;
!         $categorydatasetdefs = $DB->get_records_sql(
              "SELECT  a.*
                 FROM {question_datasets} b, {question_dataset_definitions} a
                WHERE a.id = b.datasetdefinition AND a.type = '1' AND a.category != 0 AND b.question = ?
             ORDER BY a.name ", array($question->id));
!         $questionname = $question->name ;
!         $regs= array();
!         if(preg_match('~#\{([^[:space:]]*)#~',$questionname , $regs)){
!             $questionname = str_replace($regs[0], '', $questionname);
!         };
! 
!         if (!empty($categorydatasetdefs)){ // there is at least one with the same name
!             $questionname  ="#".$questionname;
!             foreach($categorydatasetdefs as $def) {
!                 if(strlen("{$def->name}")+strlen($questionname) < 250 ){
!                     $questionname = '{'.$def->name.'}'
!                         .$questionname;
!                 }
!             }
!             $questionname ="#".$questionname;
!         }
!         $DB->set_field('question', 'name', $questionname, array("id" => $question->id));
!     }
! 
!     /**
!      * this version save the available data at the different steps of the question editing process
!      * without using global $SESSION as storage between steps
!      * at the first step $wizardnow = 'question'
!      *  when creating a new question
!      *  when modifying a question
!      *  when copying as a new question
!      *  the general parameters and answers are saved using parent::save_question
!      *  then the datasets are prepared and saved
!      * at the second step $wizardnow = 'datasetdefinitions'
!      *  the datadefs final type are defined as private, category or not a datadef
!      * at the third step $wizardnow = 'datasetitems'
!      *  the datadefs parameters and the data items are created or defined
!      *
!      * @param object question
!      * @param object $form
!      * @param int $course
!      * @param PARAM_ALPHA $wizardnow should be added as we are coming from question2.php
!      */
!     function save_question($question, $form) {
!         global $DB;
!         if ($this->wizard_pages_number() == 1 ){
!                 $question = parent::save_question($question, $form);
!             return $question ;
!         }
! 
!         $wizardnow =  optional_param('wizardnow', '', PARAM_ALPHA);
!         $id = optional_param('id', 0, PARAM_INT); // question id
!         // in case 'question'
!         // for a new question $form->id is empty
!         // when saving as new question
!         //   $question->id = 0, $form is $data from question2.php
!         //   and $data->makecopy is defined as $data->id is the initial question id
!         // edit case. If it is a new question we don't necessarily need to
!         // return a valid question object
! 
!         // See where we're coming from
!         switch($wizardnow) {
!         case '' :
!         case 'question': // coming from the first page, creating the second
!             if (empty($form->id)) { // for a new question $form->id is empty
!                 $question = parent::save_question($question, $form);
!                 //prepare the datasets using default $questionfromid
!                 $this->preparedatasets($form);
!                 $form->id = $question->id;
!                 $this->save_dataset_definitions($form);
!                 if(isset($form->synchronize) && $form->synchronize == 2 ){
!                     $this->addnamecategory($question);
!                 }
!             } else if (!empty($form->makecopy)){
!                 $questionfromid =  $form->id ;
!                 $question = parent::save_question($question, $form);
!                 //prepare the datasets
!                 $this->preparedatasets($form,$questionfromid);
!                 $form->id = $question->id;
!                 $this->save_as_new_dataset_definitions($form,$questionfromid );
!                 if(isset($form->synchronize) && $form->synchronize == 2 ){
!                     $this->addnamecategory($question);
!                 }
!             }  else {// editing a question
!                 $question = parent::save_question($question, $form);
!                 //prepare the datasets
!                 $this->preparedatasets($form,$question->id);
!                 $form->id = $question->id;
!                 $this->save_dataset_definitions($form);
!                 if(isset($form->synchronize) && $form->synchronize == 2 ){
!                     $this->addnamecategory($question);
!                 }
!             }
!             break;
!         case 'datasetdefinitions':
!             // calculated options
!             // it cannot go here without having done the first page
!             // so the question_calculated_options should exist
!             // only need to update the synchronize field
!             if(isset($form->synchronize) ){
!                 $options_synchronize = $form->synchronize ;
!             }else {
!                 $options_synchronize = 0 ;
!             }
!             $DB->set_field('question_calculated_options', 'synchronize', $options_synchronize, array("question" => $question->id));
!             if(isset($form->synchronize) && $form->synchronize == 2 ){
!                 $this->addnamecategory($question);
!             }
! 
!             $this->save_dataset_definitions($form);
!             break;
!         case 'datasetitems':
!             $this->save_dataset_items($question, $form);
!             $this->save_question_calculated($question, $form);
!             break;
!         default:
!             print_error('invalidwizardpage', 'question');
!             break;
!         }
!         return $question;
!     }
! 
!     function delete_question($questionid, $contextid) {
!         global $DB;
! 
!         $DB->delete_records("question_calculated", array("question" => $questionid));
!         $DB->delete_records("question_calculated_options", array("question" => $questionid));
!         $DB->delete_records("question_numerical_units", array("question" => $questionid));
!         if ($datasets = $DB->get_records('question_datasets', array('question' => $questionid))) {
!             foreach ($datasets as $dataset) {
!                 if (!$DB->get_records_select(
                      'question_datasets',
                      "question != ?
                      AND datasetdefinition = ? ", array($questionid, $dataset->datasetdefinition))){
!                         $DB->delete_records('question_dataset_definitions', array('id' => $dataset->datasetdefinition));
!                         $DB->delete_records('question_dataset_items', array('definition' => $dataset->datasetdefinition));
!                     }
!             }
!         }
!         $DB->delete_records("question_datasets", array("question" => $questionid));
! 
!         parent::delete_question($questionid, $contextid);
!     }
! 
!     function test_response(&$question, &$state, $answer) {
!         $virtualqtype = $this->get_virtual_qtype();
!         return $virtualqtype->test_response($question, $state, $answer);
! 
!     }
! 
!     function compare_responses(&$question, $state, $teststate) {
! 
!         $virtualqtype = $this->get_virtual_qtype();
!         return $virtualqtype->compare_responses($question, $state, $teststate);
!     }
! 
!     function convert_answers (&$question, &$state){
!         foreach ($question->options->answers as $key => $answer) {
!             $answer = fullclone($question->options->answers[$key]);
!             $question->options->answers[$key]->answer = $this->substitute_variables_and_eval($answer->answer,
!                 $state->options->dataset);
!         }
!     }
!     function convert_questiontext (&$question, &$state){
!         $tolerancemax =0.01;
!         $tolerancetypemax = 1 ;
!         $correctanswerlengthmax = 2 ;
!         $correctanswerformatmax = 1 ;
!         $tolerancemaxset = false ;
!         foreach ($question->options->answers as $key => $answer) {
!             if($answer->fraction == 1.0 && !$tolerancemaxset){
!                 $tolerancemax = $answer->tolerance;
!                 $tolerancetypemax = $answer->tolerancetype ;
!                 $correctanswerlengthmax = $answer->correctanswerlength;
!                 $correctanswerformatmax =$answer->correctanswerformat;
!                 $tolerancemaxset = true ;
!             }
!         }
!         $question->questiontext = $this->substitute_variables($question->questiontext, $state->options->dataset);
!         //evaluate the equations i.e {=5+4)
!         $qtext = "";
!         $qtextremaining = $question->questiontext ;
!         while  (preg_match('~\{=([^[:space:]}]*)}~', $qtextremaining, $regs1)) {
!             //  while  (preg_match('~\{=|%=([^[:space:]}]*)}~', $qtextremaining, $regs1)) {
!             $qtextsplits = explode($regs1[0], $qtextremaining, 2);
!             $qtext =$qtext.$qtextsplits[0];
!             $qtextremaining = $qtextsplits[1];
!             if (empty($regs1[1])) {
!                 $str = '';
!             } else {
!                 if( $formulaerrors = qtype_calculated_find_formula_errors($regs1[1])){
!                     $str=$formulaerrors ;
!                 }else {
!                     eval('$str = '.$regs1[1].';');
!                     $texteval= qtype_calculated_calculate_answer(
!                         $str, $state->options->dataset, $tolerancemax,
!                         $tolerancetypemax, $correctanswerlengthmax,
!                         $correctanswerformatmax, '');
!                     $str = $texteval->answer;
! 
!                     ;
!                 }
!             }
!             $qtext = $qtext.$str ;
!         }
!         $question->questiontext = $qtext.$qtextremaining ; // end replace equations
!     }
! 
!     function get_default_numerical_unit($question,$virtualqtype){
!         if($unit = $virtualqtype->get_default_numerical_unit($question)){
!             $unit = $unit->unit;
!         } else {
!             $unit = '';
!         }
!         return $unit ;
! 
!     }
!     function print_question_formulation_and_controls(&$question, &$state, $cmoptions, $options) {
!         // Substitute variables in questiontext before giving the data to the
!         // virtual type for printing
!         $virtualqtype = $this->get_virtual_qtype();
!         // why $unit as it is not use
!         $unit = $this-> get_default_numerical_unit($question,$virtualqtype);
!         // We modify the question to look like a numerical question
!         $numericalquestion = fullclone($question);
!         $this->convert_answers($numericalquestion, $state);
!         $this->convert_questiontext($numericalquestion, $state);
!  /*        $tolerancemax =0.01;
!          $tolerancetypemax = 1 ;
!          $correctanswerlengthmax = 2 ;
!          $correctanswerformatmax = 1 ;
!          $tolerancemaxset = false ;
!         foreach ($numericalquestion->options->answers as $key => $answer) {
!              if($answer->fraction == 1.0 && !$tolerancemaxset){
!                 $tolerancemax = $answer->tolerance;
!                 $tolerancetypemax = $answer->tolerancetype ;
!                 $correctanswerlengthmax = $answer->correctanswerlength;
!                 $correctanswerformatmax =$answer->correctanswerformat;
!                 $tolerancemaxset = true ;
!             }
!         }
! 
!         $numericalquestion->questiontext = $this->substitute_variables(
!         $numericalquestion->questiontext, $state->options->dataset);
!         //evaluate the equations i.e {=5+4)
!         $qtext = "";
!         $qtextremaining = $numericalquestion->questiontext ;
!         while  (preg_match('~\{=([^[:space:]}]*)}~', $qtextremaining, $regs1)) {
!       //  while  (preg_match('~\{=|%=([^[:space:]}]*)}~', $qtextremaining, $regs1)) {
!             $qtextsplits = explode($regs1[0], $qtextremaining, 2);
!             $qtext =$qtext.$qtextsplits[0];
!             $qtextremaining = $qtextsplits[1];
!             if (empty($regs1[1])) {
!                     $str = '';
!                 } else {
!                     if( $formulaerrors = qtype_calculated_find_formula_errors($regs1[1])){
!                         $str=$formulaerrors ;
!                     }else {
!                        eval('$str = '.$regs1[1].';');
!                        $texteval= qtype_calculated_calculate_answer(
!                      $str, $state->options->dataset, $tolerancemax,
!                      $tolerancetypemax, $correctanswerlengthmax,
!                         $correctanswerformatmax, '');
!                         $str = $texteval->answer;
! 
!                         ;
                      }
!                 }
!                 $qtext = $qtext.$str ;
!         }
!         $numericalquestion->questiontext = $qtext.$qtextremaining ; // end replace equations
!   */
! 
!         $virtualqtype->print_question_formulation_and_controls($numericalquestion, $state, $cmoptions, $options);
!     }
!     function grade_responses(&$question, &$state, $cmoptions) {
!         // Forward the grading to the virtual qtype
!         // We modify the question to look like a numerical question
!         $numericalquestion = fullclone($question);
!         foreach ($numericalquestion->options->answers as $key => $answer) {
!             $answer = $numericalquestion->options->answers[$key]->answer; // for PHP 4.x
!             $numericalquestion->options->answers[$key]->answer = $this->substitute_variables_and_eval($answer,
!                 $state->options->dataset);
!         }
!         $virtualqtype = $this->get_virtual_qtype();
!         return $virtualqtype->grade_responses($numericalquestion, $state, $cmoptions) ;
!     }
! 
! 
!     // ULPGC ecastro
!     function check_response(&$question, &$state) {
!         // Forward the checking to the virtual qtype
!         // We modify the question to look like a numerical question
!         $numericalquestion = clone($question);
!         $numericalquestion->options = clone($question->options);
!         foreach ($question->options->answers as $key => $answer) {
!             $numericalquestion->options->answers[$key] = clone($answer);
!         }
!         foreach ($numericalquestion->options->answers as $key => $answer) {
!             $answer->answer = $this->substitute_variables_and_eval($answer->answer,
!                 $state->options->dataset);
!         }
!         $virtualqtype = $this->get_virtual_qtype();
!         return $virtualqtype->check_response($numericalquestion, $state) ;
!     }
! 
!     // ULPGC ecastro
!     function get_actual_response(&$question, &$state) {
!         // Substitute variables in questiontext before giving the data to the
!         // virtual type
!         $virtualqtype = $this->get_virtual_qtype();
!         $unit = $virtualqtype->get_default_numerical_unit($question);
! 
!         // We modify the question to look like a numerical question
!         $numericalquestion = clone($question);
!         $numericalquestion->options = clone($question->options);
!         foreach ($question->options->answers as $key => $answer) {
!             $numericalquestion->options->answers[$key] = clone($answer);
!         }
!         foreach ($numericalquestion->options->answers as $key => $answer) {
!             $answer = &$numericalquestion->options->answers[$key]; // for PHP 4.x
!             $answer->answer = $this->substitute_variables_and_eval($answer->answer,
!                 $state->options->dataset);
!             // apply_unit
!         }
!         $numericalquestion->questiontext = $this->substitute_variables_and_eval(
!             $numericalquestion->questiontext, $state->options->dataset);
!         $responses = $virtualqtype->get_all_responses($numericalquestion, $state);
!         $response = reset($responses->responses);
!         $correct = $response->answer.' : ';
! 
!         $responses = $virtualqtype->get_actual_response($numericalquestion, $state);
! 
!         foreach ($responses as $key=>$response){
!             $responses[$key] = $correct.$response;
!         }
! 
!         return $responses;
!     }
! 
!     function create_virtual_qtype() {
!         global $CFG;
!         require_once("$CFG->dirroot/question/type/numerical/questiontype.php");
!         return new question_numerical_qtype();
!     }
! 
!     function supports_dataset_item_generation() {
!         // Calcualted support generation of randomly distributed number data
!         return true;
!     }
!     function custom_generator_tools_part(&$mform, $idx, $j){
! 
!         $minmaxgrp = array();
!         $minmaxgrp[] =& $mform->createElement('text', "calcmin[$idx]", get_string('calcmin', 'qtype_calculated'));
!         $minmaxgrp[] =& $mform->createElement('text', "calcmax[$idx]", get_string('calcmax', 'qtype_calculated'));
!         $mform->addGroup($minmaxgrp, 'minmaxgrp', get_string('minmax', 'qtype_calculated'), ' - ', false);
!         $mform->setType("calcmin[$idx]", PARAM_NUMBER);
!         $mform->setType("calcmax[$idx]", PARAM_NUMBER);
! 
!         $precisionoptions = range(0, 10);
!         $mform->addElement('select', "calclength[$idx]", get_string('calclength', 'qtype_calculated'), $precisionoptions);
! 
!         $distriboptions = array('uniform' => get_string('uniform', 'qtype_calculated'), 'loguniform' => get_string('loguniform', 'qtype_calculated'));
!         $mform->addElement('select', "calcdistribution[$idx]", get_string('calcdistribution', 'qtype_calculated'), $distriboptions);
!     }
! 
!     function custom_generator_set_data($datasetdefs, $formdata){
!         $idx = 1;
!         foreach ($datasetdefs as $datasetdef){
!             if (preg_match('~^(uniform|loguniform):([^:]*):([^:]*):([0-9]*)$~', $datasetdef->options, $regs)) {
!                 $defid = "$datasetdef->type-$datasetdef->category-$datasetdef->name";
!                 $formdata["calcdistribution[$idx]"] = $regs[1];
!                 $formdata["calcmin[$idx]"] = $regs[2];
!                 $formdata["calcmax[$idx]"] = $regs[3];
!                 $formdata["calclength[$idx]"] = $regs[4];
!             }
!             $idx++;
!         }
!         return $formdata;
!     }
! 
!     function custom_generator_tools($datasetdef) {
!         global $OUTPUT;
!         if (preg_match('~^(uniform|loguniform):([^:]*):([^:]*):([0-9]*)$~',
!             $datasetdef->options, $regs)) {
!                 $defid = "$datasetdef->type-$datasetdef->category-$datasetdef->name";
!                 for ($i = 0 ; $i<10 ; ++$i) {
!                     $lengthoptions[$i] = get_string(($regs[1] == 'uniform'
!                         ? 'decimals'
!                         : 'significantfigures'), 'quiz', $i);
!                 }
!                 $menu1 = html_writer::select($lengthoptions, 'calclength[]', $regs[4], null);
! 
!                 $options = array('uniform' => get_string('uniform', 'quiz'), 'loguniform' => get_string('loguniform', 'quiz'));
!                 $menu2 = html_writer::select($options, 'calcdistribution[]', $regs[1], null);
!                 return '<input type="submit" onclick="'
!                     . "getElementById('addform').regenerateddefid.value='$defid'; return true;"
!                     .'" value="'. get_string('generatevalue', 'quiz') . '"/><br/>'
!                     . '<input type="text" size="3" name="calcmin[]" '
!                     . " value=\"$regs[2]\"/> &amp; <input name=\"calcmax[]\" "
!                     . ' type="text" size="3" value="' . $regs[3] .'"/> '
!                     . $menu1 . '<br/>'
!                     . $menu2;
!             } else {
!                 return '';
!             }
!     }
! 
! 
!     function update_dataset_options($datasetdefs, $form) {
!         global $OUTPUT;
!         // Do we have informatin about new options???
!         if (empty($form->definition) || empty($form->calcmin)
!             || empty($form->calcmax) || empty($form->calclength)
!             || empty($form->calcdistribution)) {
!                 // I guess not
! 
!             } else {
!                 // Looks like we just could have some new information here
!                 $uniquedefs = array_values(array_unique($form->definition));
!                 foreach ($uniquedefs as $key => $defid) {
!                     if (isset($datasetdefs[$defid])
!                         && is_numeric($form->calcmin[$key+1])
!                         && is_numeric($form->calcmax[$key+1])
!                         && is_numeric($form->calclength[$key+1])) {
!                             switch     ($form->calcdistribution[$key+1]) {
!                             case 'uniform': case 'loguniform':
!                                 $datasetdefs[$defid]->options =
!                                     $form->calcdistribution[$key+1] . ':'
!                                     . $form->calcmin[$key+1] . ':'
!                                     . $form->calcmax[$key+1] . ':'
!                                     . $form->calclength[$key+1];
!                                 break;
!                             default:
!                                 echo $OUTPUT->notification("Unexpected distribution ".$form->calcdistribution[$key+1]);
!                             }
!                         }
!                 }
!             }
! 
!         // Look for empty options, on which we set default values
!         foreach ($datasetdefs as $defid => $def) {
!             if (empty($def->options)) {
!                 $datasetdefs[$defid]->options = 'uniform:1.0:10.0:1';
!             }
!         }
!         return $datasetdefs;
!     }
! 
!     function save_question_calculated($question, $fromform){
!         global $DB;
! 
!         foreach ($question->options->answers as $key => $answer) {
!             if ($options = $DB->get_record('question_calculated', array('answer' => $key))) {
!                 $options->tolerance = trim($fromform->tolerance[$key]);
!                 $options->tolerancetype  = trim($fromform->tolerancetype[$key]);
!                 $options->correctanswerlength  = trim($fromform->correctanswerlength[$key]);
!                 $options->correctanswerformat  = trim($fromform->correctanswerformat[$key]);
!                 $DB->update_record('question_calculated', $options);
!             }
!         }
!     }
! 
!     /**
!      * This function get the dataset items using id as unique parameter and return an
!      * array with itemnumber as index sorted ascendant
!      * If the multiple records with the same itemnumber exist, only the newest one
!      * i.e with the greatest id is used, the others are ignored but not deleted.
!      * MDL-19210
!      */
!     function get_database_dataset_items($definition){
!         global $CFG, $DB;
!         $databasedataitems = $DB->get_records_sql( // Use number as key!!
              " SELECT id , itemnumber, definition,  value
              FROM {question_dataset_items}
              WHERE definition = $definition order by id DESC ", array($definition));
!         $dataitems = Array();
!         foreach($databasedataitems as $id => $dataitem  ){
!             if (!isset($dataitems[$dataitem->itemnumber])){
!                 $dataitems[$dataitem->itemnumber] = $dataitem ;
!             }else {
!                 // deleting the unused records could be added here
!             }
!         }
!         ksort($dataitems);
!         return $dataitems ;
!     }
! 
!     function save_dataset_items($question, $fromform){
!         global $CFG, $DB;
!         // max datasets = 100 items
!         $max100 = CALCULATEDQUESTIONMAXITEMNUMBER ;
!         $synchronize = false ;
!         if(isset($fromform->nextpageparam["forceregeneration"])) {
!             $regenerate = $fromform->nextpageparam["forceregeneration"];
!         }else{
!             $regenerate = 0 ;
!         }
!         if (empty($question->options)) {
!             $this->get_question_options($question);
!         }
!         if(!empty($question->options->synchronize)){
!             $synchronize = true ;
!         }
! 
! 
!         //get the old datasets for this question
!         $datasetdefs = $this->get_dataset_definitions($question->id, array());
!         // Handle generator options...
!         $olddatasetdefs = fullclone($datasetdefs);
!         $datasetdefs = $this->update_dataset_options($datasetdefs, $fromform);
!         $maxnumber = -1;
!         foreach ($datasetdefs as $defid => $datasetdef) {
!             if (isset($datasetdef->id)
!                 && $datasetdef->options != $olddatasetdefs[$defid]->options) {
!                     // Save the new value for options
!                     $DB->update_record('question_dataset_definitions', $datasetdef);
! 
!                 }
!             // Get maxnumber
!             if ($maxnumber == -1 || $datasetdef->itemcount < $maxnumber) {
!                 $maxnumber = $datasetdef->itemcount;
!             }
!         }
!         // Handle adding and removing of dataset items
!         $i = 1;
!         if ($maxnumber > CALCULATEDQUESTIONMAXITEMNUMBER ){
!             $maxnumber = CALCULATEDQUESTIONMAXITEMNUMBER ;
!         }
! 
!         ksort($fromform->definition);
!         foreach ($fromform->definition as $key => $defid) {
!             //if the delete button has not been pressed then skip the datasetitems
!             //in the 'add item' part of the form.
!             if ( $i > count($datasetdefs)*$maxnumber ) {
!                 break;
!             }
!             $addeditem = new stdClass();
!             $addeditem->definition = $datasetdefs[$defid]->id;
!             $addeditem->value = $fromform->number[$i];
!             $addeditem->itemnumber = ceil($i / count($datasetdefs));
! 
!             if ($fromform->itemid[$i]) {
!                 // Reuse any previously used record
!                 $addeditem->id = $fromform->itemid[$i];
!                 $DB->update_record('question_dataset_items', $addeditem);
!             } else {
!                 $DB->insert_record('question_dataset_items', $addeditem);
!             }
! 
!             $i++;
!         }
!         if (isset($addeditem->itemnumber) && $maxnumber < $addeditem->itemnumber
!             && $addeditem->itemnumber < CALCULATEDQUESTIONMAXITEMNUMBER ){
!                 $maxnumber = $addeditem->itemnumber;
!                 foreach ($datasetdefs as $key => $newdef) {
!                     if (isset($newdef->id) && $newdef->itemcount <= $maxnumber) {
!                         $newdef->itemcount = $maxnumber;
!                         // Save the new value for options
!                         $DB->update_record('question_dataset_definitions', $newdef);
!                     }
!                 }
!             }
!         // adding supplementary items
!         $numbertoadd =0;
!         if (isset($fromform->addbutton) && $fromform->selectadd > 0 && $maxnumber < CALCULATEDQUESTIONMAXITEMNUMBER ) {
!             $numbertoadd =$fromform->selectadd ;
!             if ( $max100 - $maxnumber < $numbertoadd ) {
!                 $numbertoadd = $max100 - $maxnumber ;
!             }
!             //add the other items.
!             // Generate a new dataset item (or reuse an old one)
!             foreach ($datasetdefs as $defid => $datasetdef) {
!                 // in case that for category datasets some new items has been added
!                 // get actual values
!                 // fix regenerate for this datadefs
!                 $defregenerate = 0 ;
!                 if($synchronize && !empty ($fromform->nextpageparam["datasetregenerate[$datasetdef->name"])) {
!                     $defregenerate = 1 ;
!                 }else if(!$synchronize && (($regenerate == 1 && $datasetdef->category == 0) ||$regenerate == 2 )){
!                     $defregenerate = 1 ;
!                 }
!                 if (isset($datasetdef->id)) {
!                     $datasetdefs[$defid]->items = $this->get_database_dataset_items($datasetdef->id);
!                 }
!                 for ($numberadded =$maxnumber+1 ; $numberadded <= $maxnumber+$numbertoadd ; $numberadded++){
!                     if (isset($datasetdefs[$defid]->items[$numberadded])  ){
!                         // in case of regenerate it modifies the already existing record
!                         if ( $defregenerate  ) {
!                             $datasetitem = new stdClass;
!                             $datasetitem->id = $datasetdefs[$defid]->items[$numberadded]->id;
!                             $datasetitem->definition = $datasetdef->id ;
!                             $datasetitem->itemnumber = $numberadded;
!                             $datasetitem->value = $this->generate_dataset_item($datasetdef->options);
!                             $DB->update_record('question_dataset_items', $datasetitem);
!                         }
!                         //if not regenerate do nothing as there is already a record
!                     } else {
!                         $datasetitem = new stdClass;
!                         $datasetitem->definition = $datasetdef->id ;
!                         $datasetitem->itemnumber = $numberadded;
!                         if ($this->supports_dataset_item_generation()) {
!                             $datasetitem->value = $this->generate_dataset_item($datasetdef->options);
!                         } else {
!                             $datasetitem->value = '';
!                         }
!                         $DB->insert_record('question_dataset_items', $datasetitem);
!                     }
!                 }//for number added
!             }// datasetsdefs end
!             $maxnumber += $numbertoadd ;
!             foreach ($datasetdefs as $key => $newdef) {
!                 if (isset($newdef->id) && $newdef->itemcount <= $maxnumber) {
!                     $newdef->itemcount = $maxnumber;
!                     // Save the new value for options
!                     $DB->update_record('question_dataset_definitions', $newdef);
!                 }
!             }
!         }
  
!         if (isset($fromform->deletebutton))  {
!             if(isset($fromform->selectdelete)) $newmaxnumber = $maxnumber-$fromform->selectdelete ;
!             else $newmaxnumber = $maxnumber-1 ;
!             if ($newmaxnumber < 0 ) $newmaxnumber = 0 ;
!             foreach ($datasetdefs as $datasetdef) {
!                 if ($datasetdef->itemcount == $maxnumber) {
!                     $datasetdef->itemcount= $newmaxnumber ;
!                     $DB->update_record('question_dataset_definitions', $datasetdef);
!                 }
!             }
!         }
!     }
!     function generate_dataset_item($options) {
!         if (!preg_match('~^(uniform|loguniform):([^:]*):([^:]*):([0-9]*)$~',
!             $options, $regs)) {
!                 // Unknown options...
!                 return false;
!             }
!         if ($regs[1] == 'uniform') {
!             $nbr = $regs[2] + ($regs[3]-$regs[2])*mt_rand()/mt_getrandmax();
!             return sprintf("%.".$regs[4]."f",$nbr);
! 
!         } else if ($regs[1] == 'loguniform') {
!             $log0 = log(abs($regs[2])); // It would have worked the other way to
!             $nbr = exp($log0 + (log(abs($regs[3])) - $log0)*mt_rand()/mt_getrandmax());
!             return sprintf("%.".$regs[4]."f",$nbr);
! 
!         } else {
!             print_error('disterror', 'question', '', $regs[1]);
!         }
!         return '';
!     }
! 
!     function comment_header($question) {
!         //$this->get_question_options($question);
!         $strheader = '';
!         $delimiter = '';
! 
!         $answers = $question->options->answers;
! 
!         foreach ($answers as $key => $answer) {
!             if (is_string($answer)) {
!                 $strheader .= $delimiter.$answer;
!             } else {
!                 $strheader .= $delimiter.$answer->answer;
!             }
!             $delimiter = '<br/><br/><br/>';
!         }
!         return $strheader;
!     }
! 
!     function comment_on_datasetitems($qtypeobj, $questionid, $questiontext, $answers, $data, $number) {
!         global $DB, $QTYPES;
!         $comment = new stdClass;
!         $comment->stranswers = array();
!         $comment->outsidelimit = false ;
!         $comment->answers = array();
!         /// Find a default unit:
!         if (!empty($questionid) && $unit = $DB->get_record('question_numerical_units', array('question'=> $questionid, 'multiplier' => 1.0))) {
!             $unit = $unit->unit;
!         } else {
!             $unit = '';
!         }
! 
!         $answers = fullclone($answers);
!         $strmin = get_string('min', 'quiz');
!         $strmax = get_string('max', 'quiz');
!         $errors = '';
!         $delimiter = ': ';
!         $virtualqtype =  $qtypeobj->get_virtual_qtype();//& $QTYPES['numerical'];
!         foreach ($answers as $key => $answer) {
!             $formula = $this->substitute_variables($answer->answer,$data);
!             $formattedanswer = qtype_calculated_calculate_answer(
!                 $answer->answer, $data, $answer->tolerance,
!                 $answer->tolerancetype, $answer->correctanswerlength,
!                 $answer->correctanswerformat, $unit);
!             if ( $formula === '*'){
!                 $answer->min = ' ';
!                 $formattedanswer->answer = $answer->answer ;
!             }else {
!                 eval('$answer->answer = '.$formula.';') ;
!                 $virtualqtype->get_tolerance_interval($answer);
!             }
!             if ($answer->min === '') {
!                 // This should mean that something is wrong
!                 $comment->stranswers[$key] = " $formattedanswer->answer".'<br/><br/>';
!             } else if ($formula === '*'){
!                 $comment->stranswers[$key] = $formula.' = '.get_string('anyvalue','qtype_calculated').'<br/><br/><br/>';
!             }else{
!                 $comment->stranswers[$key]= $formula.' = '.$formattedanswer->answer.'<br/>' ;
!                 $correcttrue->correct = $formattedanswer->answer ;
!                 $correcttrue->true = $answer->answer ;
!                 if ($formattedanswer->answer < $answer->min || $formattedanswer->answer > $answer->max){
!                     $comment->outsidelimit = true ;
!                     $comment->answers[$key] = $key;
!                     $comment->stranswers[$key] .=get_string('trueansweroutsidelimits','qtype_calculated',$correcttrue);//<span class="error">ERROR True answer '..' outside limits</span>';
!                 }else {
!                     $comment->stranswers[$key] .=get_string('trueanswerinsidelimits','qtype_calculated',$correcttrue);//' True answer :'.$calculated->trueanswer.' inside limits';
!                 }
!                 $comment->stranswers[$key] .='<br/>';
!                 $comment->stranswers[$key] .= $strmin.$delimiter.$answer->min.' --- ';
!                 $comment->stranswers[$key] .= $strmax.$delimiter.$answer->max;
!                 $comment->stranswers[$key] .='';
!             }
!         }
!         return fullclone($comment);
!     }
!     function multichoice_comment_on_datasetitems($questionid, $questiontext, $answers,$data, $number) {
!         global $DB;
!         $comment = new stdClass;
!         $comment->stranswers = array();
!         $comment->outsidelimit = false ;
!         $comment->answers = array();
!         /// Find a default unit:
!         if (!empty($questionid) && $unit = $DB->get_record('question_numerical_units', array('question'=> $questionid, 'multiplier' => 1.0))) {
!             $unit = $unit->unit;
!         } else {
!             $unit = '';
!         }
! 
!         $answers = fullclone($answers);
!         $strmin = get_string('min', 'quiz');
!         $strmax = get_string('max', 'quiz');
!         $errors = '';
!         $delimiter = ': ';
!         foreach ($answers as $key => $answer) {
!             $answer->answer = $this->substitute_variables($answer->answer, $data);
!             //evaluate the equations i.e {=5+4)
!             $qtext = "";
!             $qtextremaining = $answer->answer ;
!             while  (preg_match('~\{=([^[:space:]}]*)}~', $qtextremaining, $regs1)) {
!                 $qtextsplits = explode($regs1[0], $qtextremaining, 2);
!                 $qtext =$qtext.$qtextsplits[0];
!                 $qtextremaining = $qtextsplits[1];
!                 if (empty($regs1[1])) {
!                     $str = '';
!                 } else {
!                     if( $formulaerrors = qtype_calculated_find_formula_errors($regs1[1])){
!                         $str=$formulaerrors ;
!                     }else {
!                         eval('$str = '.$regs1[1].';');
! 
!                         $texteval= qtype_calculated_calculate_answer(
!                             $str, $data, $answer->tolerance,
!                             $answer->tolerancetype, $answer->correctanswerlength,
!                             $answer->correctanswerformat, '');
!                         $str = $texteval->answer;
! 
!                     }
!                 }
!                 $qtext = $qtext.$str ;
!             }
!             $answer->answer = $qtext.$qtextremaining ; ;
!             $comment->stranswers[$key]= $answer->answer ;
! 
! 
!           /*  $formula = $this->substitute_variables($answer->answer,$data);
!             $formattedanswer = qtype_calculated_calculate_answer(
!                     $answer->answer, $data, $answer->tolerance,
!                     $answer->tolerancetype, $answer->correctanswerlength,
!                     $answer->correctanswerformat, $unit);
!                     if ( $formula === '*'){
!                         $answer->min = ' ';
!                         $formattedanswer->answer = $answer->answer ;
!                     }else {
!                         eval('$answer->answer = '.$formula.';') ;
!                         $virtualqtype->get_tolerance_interval($answer);
!                     }
!             if ($answer->min === '') {
!                 // This should mean that something is wrong
!                 $comment->stranswers[$key] = " $formattedanswer->answer".'<br/><br/>';
!             } else if ($formula === '*'){
!                 $comment->stranswers[$key] = $formula.' = '.get_string('anyvalue','qtype_calculated').'<br/><br/><br/>';
!             }else{
!                 $comment->stranswers[$key]= $formula.' = '.$formattedanswer->answer.'<br/>' ;
!                 $comment->stranswers[$key] .= $strmin. $delimiter.$answer->min.'---';
!                 $comment->stranswers[$key] .= $strmax.$delimiter.$answer->max;
!                 $comment->stranswers[$key] .='<br/>';
!                 $correcttrue->correct = $formattedanswer->answer ;
!                 $correcttrue->true = $answer->answer ;
!                 if ($formattedanswer->answer < $answer->min || $formattedanswer->answer > $answer->max){
!                     $comment->outsidelimit = true ;
!                     $comment->answers[$key] = $key;
!                     $comment->stranswers[$key] .=get_string('trueansweroutsidelimits','qtype_calculated',$correcttrue);//<span class="error">ERROR True answer '..' outside limits</span>';
!                 }else {
!                     $comment->stranswers[$key] .=get_string('trueanswerinsidelimits','qtype_calculated',$correcttrue);//' True answer :'.$calculated->trueanswer.' inside limits';
!                 }
!                 $comment->stranswers[$key] .='';
!           }*/
!         }
!         return fullclone($comment);
!     }
! 
!     function tolerance_types() {
!         return array('1'  => get_string('relative', 'quiz'),
              '2'  => get_string('nominal', 'quiz'),
              '3'  => get_string('geometric', 'quiz'));
!     }
! 
!     function dataset_options($form, $name, $mandatory=true,$renameabledatasets=false) {
!         // Takes datasets from the parent implementation but
!         // filters options that are currently not accepted by calculated
!         // It also determines a default selection...
!         //$renameabledatasets not implemented anmywhere
!         list($options, $selected) = $this->dataset_options_from_database($form, $name,'','qtype_calculated');
!         //  list($options, $selected) = $this->dataset_optionsa($form, $name);
! 
!         foreach ($options as $key => $whatever) {
!             if (!preg_match('~^1-~', $key) && $key != '0') {
!                 unset($options[$key]);
!             }
!         }
!         if (!$selected) {
!             if ($mandatory){
!                 $selected =  "1-0-$name"; // Default
!             }else {
!                 $selected = "0"; // Default
!             }
!         }
!         return array($options, $selected);
!     }
! 
!     function construct_dataset_menus($form, $mandatorydatasets,
!         $optionaldatasets) {
!             global $OUTPUT;
!             $datasetmenus = array();
!             foreach ($mandatorydatasets as $datasetname) {
!                 if (!isset($datasetmenus[$datasetname])) {
!                     list($options, $selected) =
!                         $this->dataset_options($form, $datasetname);
!                     unset($options['0']); // Mandatory...
!                     $datasetmenus[$datasetname] = html_writer::select($options, 'dataset[]', $selected, null);
!                 }
!             }
!             foreach ($optionaldatasets as $datasetname) {
!                 if (!isset($datasetmenus[$datasetname])) {
!                     list($options, $selected) =
!                         $this->dataset_options($form, $datasetname);
!                     $datasetmenus[$datasetname] = html_writer::select($options, 'dataset[]', $selected, null);
!                 }
!             }
!             return $datasetmenus;
!         }
  
!     function print_question_grading_details(&$question, &$state, &$cmoptions, &$options) {
!         $virtualqtype = $this->get_virtual_qtype();
!         $virtualqtype->print_question_grading_details($question, $state, $cmoptions, $options) ;
!     }
! 
!     function get_correct_responses(&$question, &$state) {
!         // virtual type for printing
!         $virtualqtype = $this->get_virtual_qtype();
!         $unit = $this->get_default_numerical_unit($question,$virtualqtype);
!         // We modify the question to look like a numerical question
!         $this->convert_answers($question, $state);
!         return $virtualqtype->get_correct_responses($question, $state) ;
!     }
! 
!     function substitute_variables($str, $dataset) {
!         global $OUTPUT ;
!         //  testing for wrong numerical values
!         // all calculations used this function so testing here should be OK
! 
!         foreach ($dataset as $name => $value) {
!             $val = $value ;
!             if(! is_numeric($val)){
!                 $a = new stdClass;
!                 $a->name = '{'.$name.'}' ;
!                 $a->value = $value ;
!                 echo $OUTPUT->notification(get_string('notvalidnumber','qtype_calculated',$a));
!                 $val = 1.0 ;
!             }
!             if($val < 0 ){
!                 $str = str_replace('{'.$name.'}', '('.$val.')', $str);
!             } else {
!                 $str = str_replace('{'.$name.'}', $val, $str);
!             }
!         }
!         return $str;
!     }
!     function evaluate_equations($str, $dataset){
!         $formula = $this->substitute_variables($str, $dataset) ;
!         if ($error = qtype_calculated_find_formula_errors($formula)) {
!             return $error;
!         }
!         return $str;
!     }
! 
! 
!     function substitute_variables_and_eval($str, $dataset) {
!         $formula = $this->substitute_variables($str, $dataset) ;
!         if ($error = qtype_calculated_find_formula_errors($formula)) {
!             return $error;
!         }
!         /// Calculate the correct answer
!         if (empty($formula)) {
!             $str = '';
!         } else if ($formula === '*'){
!             $str = '*';
!         } else {
!             eval('$str = '.$formula.';');
!         }
!         return $str;
!     }
! 
!     function get_dataset_definitions($questionid, $newdatasets) {
!         global $DB;
!         //get the existing datasets for this question
!         $datasetdefs = array();
!         if (!empty($questionid)) {
!             global $CFG;
!             $sql = "SELECT i.*
                        FROM {question_datasets} d, {question_dataset_definitions} i
                       WHERE d.question = ? AND d.datasetdefinition = i.id";
!             if ($records = $DB->get_records_sql($sql, array($questionid))) {
!                 foreach ($records as $r) {
!                     $datasetdefs["$r->type-$r->category-$r->name"] = $r;
!                 }
!             }
!         }
! 
!         foreach ($newdatasets as $dataset) {
!             if (!$dataset) {
!                 continue; // The no dataset case...
!             }
! 
!             if (!isset($datasetdefs[$dataset])) {
!                 //make new datasetdef
!                 list($type, $category, $name) = explode('-', $dataset, 3);
!                 $datasetdef = new stdClass;
!                 $datasetdef->type = $type;
!                 $datasetdef->name = $name;
!                 $datasetdef->category  = $category;
!                 $datasetdef->itemcount = 0;
!                 $datasetdef->options   = 'uniform:1.0:10.0:1';
!                 $datasetdefs[$dataset] = clone($datasetdef);
!             }
!         }
!         return $datasetdefs;
!     }
! 
!     function save_dataset_definitions($form) {
!         global $DB;
!         // save synchronize
! 
!         if (empty($form->dataset)) {
!             $form->dataset = array();
!         }
!         // Save datasets
!         $datasetdefinitions = $this->get_dataset_definitions($form->id, $form->dataset);
!         $tmpdatasets = array_flip($form->dataset);
!         $defids = array_keys($datasetdefinitions);
!         foreach ($defids as $defid) {
!             $datasetdef = &$datasetdefinitions[$defid];
!             if (isset($datasetdef->id)) {
!                 if (!isset($tmpdatasets[$defid])) {
!                     // This dataset is not used any more, delete it
!                     $DB->delete_records('question_datasets', array('question' => $form->id, 'datasetdefinition' => $datasetdef->id));
!                     if ($datasetdef->category == 0) { // Question local dataset
!                         $DB->delete_records('question_dataset_definitions', array('id' => $datasetdef->id));
!                         $DB->delete_records('question_dataset_items', array('definition' => $datasetdef->id));
!                     }
!                 }
!                 // This has already been saved or just got deleted
!                 unset($datasetdefinitions[$defid]);
!                 continue;
!             }
! 
!             $datasetdef->id = $DB->insert_record('question_dataset_definitions', $datasetdef);
! 
!             if (0 != $datasetdef->category) {
!                 // We need to look for already existing
!                 // datasets in the category.
!                 // By first creating the datasetdefinition above we
!                 // can manage to automatically take care of
!                 // some possible realtime concurrence
!                 if ($olderdatasetdefs = $DB->get_records_select('question_dataset_definitions',
                           "type = ?
                        AND name = ?
                        AND category = ?
                        AND id < ?
                      ORDER BY id DESC", array($datasetdef->type, $datasetdef->name, $datasetdef->category, $datasetdef->id))) {
  
!                     while ($olderdatasetdef = array_shift($olderdatasetdefs)) {
!                         $DB->delete_records('question_dataset_definitions', array('id' => $datasetdef->id));
!                         $datasetdef = $olderdatasetdef;
!                     }
!                 }
!             }
! 
!             // Create relation to this dataset:
!             $questiondataset = new stdClass;
!             $questiondataset->question = $form->id;
!             $questiondataset->datasetdefinition = $datasetdef->id;
!             $DB->insert_record('question_datasets', $questiondataset);
!             unset($datasetdefinitions[$defid]);
!         }
! 
!         // Remove local obsolete datasets as well as relations
!         // to datasets in other categories:
!         if (!empty($datasetdefinitions)) {
!             foreach ($datasetdefinitions as $def) {
!                 $DB->delete_records('question_datasets', array('question' => $form->id, 'datasetdefinition' => $def->id));
! 
!                 if ($def->category == 0) { // Question local dataset
!                     $DB->delete_records('question_dataset_definitions', array('id' => $def->id));
!                     $DB->delete_records('question_dataset_items', array('definition' => $def->id));
!                 }
!             }
!         }
!     }
!     /** This function create a copy of the datasets ( definition and dataitems)
!      * from the preceding question if they remain in the new question
!      * otherwise its create the datasets that have been added as in the
!      * save_dataset_definitions()
!      */
!     function save_as_new_dataset_definitions($form, $initialid) {
!         global $CFG, $DB;
!         // Get the datasets from the intial question
!         $datasetdefinitions = $this->get_dataset_definitions($initialid, $form->dataset);
!         // $tmpdatasets contains those of the new question
!         $tmpdatasets = array_flip($form->dataset);
!         $defids = array_keys($datasetdefinitions);// new datasets
!         foreach ($defids as $defid) {
!             $datasetdef = &$datasetdefinitions[$defid];
!             if (isset($datasetdef->id)) {
!                 // This dataset exist in the initial question
!                 if (!isset($tmpdatasets[$defid])) {
!                     // do not exist in the new question so ignore
!                     unset($datasetdefinitions[$defid]);
!                     continue;
!                 }
!                 // create a copy but not for category one
!                 if (0 == $datasetdef->category) {
!                     $olddatasetid = $datasetdef->id ;
!                     $olditemcount = $datasetdef->itemcount ;
!                     $datasetdef->itemcount =0;
!                     $datasetdef->id = $DB->insert_record('question_dataset_definitions', $datasetdef);
!                     //copy the dataitems
!                     $olditems = $this->get_database_dataset_items($olddatasetid);
!                     if (count($olditems) > 0 ) {
!                         $itemcount = 0;
!                         foreach($olditems as $item ){
!                             $item->definition = $datasetdef->id;
!                             $DB->insert_record('question_dataset_items', $item);
!                             $itemcount++;
!                         }
!                         //update item count to olditemcount if
!                         // at least this number of items has been recover from the database
!                         if( $olditemcount <= $itemcount ) {
!                             $datasetdef->itemcount = $olditemcount;
!                         } else {
!                             $datasetdef->itemcount = $itemcount ;
!                         }
!                         $DB->update_record('question_dataset_definitions', $datasetdef);
!                     } // end of  copy the dataitems
!                 }// end of  copy the datasetdef
!                 // Create relation to the new question with this
!                 // copy as new datasetdef from the initial question
!                 $questiondataset = new stdClass;
!                 $questiondataset->question = $form->id;
!                 $questiondataset->datasetdefinition = $datasetdef->id;
!                 $DB->insert_record('question_datasets', $questiondataset);
!                 unset($datasetdefinitions[$defid]);
!                 continue;
!             }// end of datasetdefs from the initial question
!             // really new one code similar to save_dataset_definitions()
!             $datasetdef->id = $DB->insert_record('question_dataset_definitions', $datasetdef);
! 
!             if (0 != $datasetdef->category) {
!                 // We need to look for already existing
!                 // datasets in the category.
!                 // By first creating the datasetdefinition above we
!                 // can manage to automatically take care of
!                 // some possible realtime concurrence
!                 if ($olderdatasetdefs = $DB->get_records_select(
                      'question_dataset_definitions',
                      "type = ?
                      AND name = ?
--- 24,1725 ----
  
  class question_calculated_qtype extends default_questiontype {
  
! 	public $fileoptionsa = array(
          'subdirs' => false,
          'maxfiles' => -1,
          'maxbytes' => 0,
! 	);
  
! 	// Used by the function custom_generator_tools:
! 	public $calcgenerateidhasbeenadded = false;
! 	public $virtualqtype = false;
! 	public $wizard_pages_number = 3 ;
! 
! 	function name() {
! 		return 'calculated';
! 	}
! 
! 	function has_wildcards_in_responses($question, $subqid) {
! 		return true;
! 	}
! 
! 	function requires_qtypes() {
! 		return array('numerical');
! 	}
! 
! 	function get_question_options(&$question) {
! 		// First get the datasets and default options
! 		// the code is used for calculated, calculatedsimple and calculatedmulti qtypes
! 		global $CFG, $DB, $OUTPUT, $QTYPES;
! 		if (!$question->options = $DB->get_record('question_calculated_options', array('question' => $question->id))) {
! 			//  echo $OUTPUT->notification('Error: Missing question options for calculated question'.$question->id.'!');
! 			//  return false;
! 			$question->options->synchronize = 0;
! 			$question->options->single = 0; //$question->single;
! 			$question->options->answernumbering = 'abc';
! 			$question->options->shuffleanswers = 0 ;
! 			$question->options->correctfeedback = '';
! 			$question->options->partiallycorrectfeedback = '';
! 			$question->options->incorrectfeedback = '';
! 			$question->options->correctfeedbackformat = 0;
! 			$question->options->partiallycorrectfeedbackformat = 0;
! 			$question->options->incorrectfeedbackformat = 0;
! 		}
  
! 		if (!$question->options->answers = $DB->get_records_sql(
              "SELECT a.*, c.tolerance, c.tolerancetype, c.correctanswerlength, c.correctanswerformat " .
              "FROM {question_answers} a, " .
              "     {question_calculated} c " .
              "WHERE a.question = ? " .
              "AND   a.id = c.answer ".
              "ORDER BY a.id ASC", array($question->id))) {
! 		// echo $OUTPUT->notification('Error: Missing question answer for calculated question ' . $question->id . '!');
! 		return false;
              }
  
!             if ( $this->get_virtual_qtype() ==  $QTYPES['numerical']){
!             	$QTYPES['numerical']->get_numerical_units($question);
!             	$QTYPES['numerical']->get_numerical_options($question);
              }
  
!             if( isset($question->export_process)&&$question->export_process){
!             	$question->options->datasets = $this->get_datasets_for_export($question);
              }
!             return true;
! 	}
  
! 	function get_datasets_for_export(&$question){
! 		global $DB, $CFG;
! 		$datasetdefs = array();
! 		if (!empty($question->id)) {
! 			$sql = "SELECT i.*
!                       FROM {question_datasets} d, {question_dataset_definitions} i
!                      WHERE d.question = ? AND d.datasetdefinition = i.id";
! 			if ($records = $DB->get_records_sql($sql, array($question->id))) {
! 				foreach ($records as $r) {
! 					$def = $r ;
! 					if ($def->category=='0'){
! 						$def->status='private';
! 					} else {
! 						$def->status='shared';
! 					}
! 					$def->type ='calculated' ;
! 					list($distribution, $min, $max,$dec) = explode(':', $def->options, 4);
! 					$def->distribution=$distribution;
! 					$def->minimum=$min;
! 					$def->maximum=$max;
! 					$def->decimals=$dec ;
! 					if ($def->itemcount > 0 ) {
! 						// get the datasetitems
! 						$def->items = array();
! 						if ($items = $this->get_database_dataset_items($def->id)){
! 							$n = 0;
! 							foreach( $items as $ii){
! 								$n++;
! 								$def->items[$n] = new stdClass;
! 								$def->items[$n]->itemnumber=$ii->itemnumber;
! 								$def->items[$n]->value=$ii->value;
! 							}
! 							$def->number_of_items=$n ;
! 						}
! 					}
! 					$datasetdefs["1-$r->category-$r->name"] = $def;
! 				}
! 			}
! 		}
! 		return $datasetdefs ;
! 	}
! 
! 	function save_question_options($question) {
! 		global $CFG, $DB, $QTYPES ;
! 		// the code is used for calculated, calculatedsimple and calculatedmulti qtypes
! 		$context = $question->context;
! 		if (isset($question->answer) && !isset($question->answers)) {
! 			$question->answers = $question->answer;
! 		}
! 		// calculated options
! 		$update = true ;
! 		$options = $DB->get_record("question_calculated_options", array("question" => $question->id));
! 		if (!$options) {
! 			$update = false;
! 			$options = new stdClass;
! 			$options->question = $question->id;
! 		}
! 		// as used only by calculated
! 		if(isset($question->synchronize)){
! 			$options->synchronize = $question->synchronize;
! 		}else {
! 			$options->synchronize = 0 ;
! 		}
! 		$options->single = 0; //$question->single;
! 		$options->answernumbering =  $question->answernumbering;
! 		$options->shuffleanswers = $question->shuffleanswers;
! 
! 		foreach (array('correctfeedback', 'partiallycorrectfeedback', 'incorrectfeedback') as $feedbackname) {
! 			$options->$feedbackname = '';
! 			$feedbackformat = $feedbackname . 'format';
! 			$options->$feedbackformat = 0 ;
! 		}
! 
! 		if ($update) {
! 			$DB->update_record("question_calculated_options", $options);
! 		} else {
! 			$DB->insert_record("question_calculated_options", $options);
! 		}
! 
! 		// Get old versions of the objects
! 		if (!$oldanswers = $DB->get_records('question_answers', array('question' => $question->id), 'id ASC')) {
! 			$oldanswers = array();
! 		}
! 
! 		if (!$oldoptions = $DB->get_records('question_calculated', array('question' => $question->id), 'answer ASC')) {
! 			$oldoptions = array();
! 		}
! 
! 		// Save the units.
! 		$virtualqtype = $this->get_virtual_qtype();
! 		$result = $virtualqtype->save_numerical_units($question);
! 		if (isset($result->error)) {
! 			return $result;
! 		} else {
! 			$units = &$result->units;
! 		}
! 		// Insert all the new answers
! 		if (isset($question->answer) && !isset($question->answers)) {
! 			$question->answers=$question->answer;
! 		}
! 		foreach ($question->answers as $key => $dataanswer) {
! 			if (is_array($dataanswer)) {
! 				$dataanswer = $dataanswer['text'];
! 			}
! 			if ( trim($dataanswer) != '' ) {
! 				$answer = new stdClass;
! 				$answer->question = $question->id;
! 				$answer->answer = trim($dataanswer);
! 				$answer->fraction = $question->fraction[$key];
! 				$answer->feedbackformat = $question->feedback[$key]['format'];
! 				if (isset($question->feedback[$key]['files'])) {
! 					$files = $question->feedback[$key]['files'];
! 				}
! 
! 				if ($oldanswer = array_shift($oldanswers)) {  // Existing answer, so reuse it
! 					$answer->id = $oldanswer->id;
! 					$answer->feedback = file_save_draft_area_files($question->feedback[$key]['itemid'], $context->id, 'question', 'answerfeedback', $oldanswer->id, $this->fileoptionsa, trim($question->feedback[$key]['text']));
! 					$DB->update_record("question_answers", $answer);
! 				} else { // This is a completely new answer
! 					$answer->feedback = trim($question->feedback[$key]['text']);
! 					$answer->id = $DB->insert_record("question_answers", $answer);
! 					if (isset($files)) {
! 						foreach ($files as $file) {
! 							$this->import_file($context, 'question', 'answerfeedback', $answer->id, $file);
! 						}
! 					} else {
! 						$answer->feedback = file_save_draft_area_files($question->feedback[$key]['itemid'], $context->id, 'question', 'answerfeedback', $answer->id, $this->fileoptionsa , trim($question->feedback[$key]['text']));
! 					}
! 					$DB->set_field('question_answers', 'feedback', $answer->feedback, array('id'=>$answer->id));
! 				}
! 
! 				// Set up the options object
! 				if (!$options = array_shift($oldoptions)) {
! 					$options = new stdClass;
! 				}
! 				$options->question  = $question->id;
! 				$options->answer    = $answer->id;
! 				$options->tolerance = trim($question->tolerance[$key]);
! 				$options->tolerancetype  = trim($question->tolerancetype[$key]);
! 				$options->correctanswerlength  = trim($question->correctanswerlength[$key]);
! 				$options->correctanswerformat  = trim($question->correctanswerformat[$key]);
! 
! 				// Save options
! 				if (isset($options->id)) { // reusing existing record
! 					$DB->update_record('question_calculated', $options);
! 				} else { // new options
! 					$DB->insert_record('question_calculated', $options);
! 				}
! 			}
! 		}
! 		// delete old answer records
! 		if (!empty($oldanswers)) {
! 			foreach($oldanswers as $oa) {
! 				$DB->delete_records('question_answers', array('id' => $oa->id));
! 			}
! 		}
! 
! 		// delete old answer records
! 		if (!empty($oldoptions)) {
! 			foreach($oldoptions as $oo) {
! 				$DB->delete_records('question_calculated', array('id' => $oo->id));
! 			}
! 		}
! 
! 		$result = $QTYPES['numerical']->save_numerical_options($question);
! 		if (isset($result->error)) {
! 			return $result;
! 		}
! 
! 		if( isset($question->import_process)&&$question->import_process){
! 			$this->import_datasets($question);
! 		}
! 		// Report any problems.
! 		if (!empty($result->notice)) {
! 			return $result;
! 		}
! 		return true;
! 	}
! 
! 	function import_datasets($question){
! 		global $DB;
! 		$n = count($question->dataset);
! 		foreach ($question->dataset as $dataset) {
! 			// name, type, option,
! 			$datasetdef = new stdClass();
! 			$datasetdef->name = $dataset->name;
! 			$datasetdef->type = 1 ;
! 			$datasetdef->options =  $dataset->distribution.':'.$dataset->min.':'.$dataset->max.':'.$dataset->length;
! 			$datasetdef->itemcount=$dataset->itemcount;
! 			if ( $dataset->status =='private'){
! 				$datasetdef->category = 0;
! 				$todo='create' ;
! 			}else if ($dataset->status =='shared' ){
! 				if ($sharedatasetdefs = $DB->get_records_select(
                      'question_dataset_definitions',
                      "type = '1'
                      AND name = ?
                      AND category = ?
                      ORDER BY id DESC ", array($dataset->name, $question->category)
! 				)) { // so there is at least one
! 					$sharedatasetdef = array_shift($sharedatasetdefs);
! 					if ( $sharedatasetdef->options ==  $datasetdef->options ){// identical so use it
! 						$todo='useit' ;
! 						$datasetdef =$sharedatasetdef ;
! 					} else { // different so create a private one
! 						$datasetdef->category = 0;
! 						$todo='create' ;
! 					}
! 				}else { // no so create one
! 					$datasetdef->category =$question->category ;
! 					$todo='create' ;
! 				}
! 			}
! 			if (  $todo=='create'){
! 				$datasetdef->id = $DB->insert_record( 'question_dataset_definitions', $datasetdef);
! 			}
! 			// Create relation to the dataset:
! 			$questiondataset = new stdClass;
! 			$questiondataset->question = $question->id;
! 			$questiondataset->datasetdefinition = $datasetdef->id;
! 			$DB->insert_record('question_datasets', $questiondataset);
! 			if ($todo=='create'){ // add the items
! 				foreach ($dataset->datasetitem as $dataitem ){
! 					$datasetitem = new stdClass;
! 					$datasetitem->definition=$datasetdef->id ;
! 					$datasetitem->itemnumber = $dataitem->itemnumber ;
! 					$datasetitem->value = $dataitem->value ;
! 					$DB->insert_record('question_dataset_items', $datasetitem);
! 				}
! 			}
! 		}
! 	}
! 
! 	function restore_session_and_responses(&$question, &$state) {
! 		global $OUTPUT;
! 		if (!preg_match('~^dataset([0-9]+)[^-]*-(.*)$~',
! 		$state->responses[''], $regs)) {
! 			echo $OUTPUT->notification("Wrongly formatted raw response answer " .
                      "{$state->responses['']}! Could not restore session for " .
                      " question #{$question->id}.");
! 			$state->options->datasetitem = 1;
! 			$state->options->dataset = array();
! 			$state->responses = array('' => '');
! 			return false;
! 		}
! 
! 		// Restore the chosen dataset
! 		$state->options->datasetitem = $regs[1];
! 		$state->options->dataset =
! 		$this->pick_question_dataset($question,$state->options->datasetitem);
! 		$state->responses = array('' => $regs[2]);
! 		$virtualqtype = $this->get_virtual_qtype();
! 		return $virtualqtype->restore_session_and_responses($question, $state);
! 	}
! 
! 	function create_session_and_responses(&$question, &$state, $cmoptions, $attempt) {
! 		// Find out how many datasets are available
! 		global $CFG, $DB, $QTYPES, $OUTPUT;
! 		if(!$maxnumber = (int)$DB->get_field_sql(
              "SELECT MIN(a.itemcount)
                 FROM {question_dataset_definitions} a, {question_datasets} b
                WHERE b.question = ? AND a.id = b.datasetdefinition", array($question->id))) {
! 		print_error('cannotgetdsforquestion', 'question', '', $question->id);
!               }
  
!               $sql = "SELECT i.*
                    FROM {question_datasets} d, {question_dataset_definitions} i
                   WHERE d.question = ? AND d.datasetdefinition = i.id AND i.category != 0";
  
!               if (!$question->options->synchronize || !$records = $DB->get_records_sql($sql, array($question->id))) {
!               	$synchronize_calculated  =  false ;
!               }else {
!               	// i.e records is true so test coherence
!               	$coherence = true ;
!               	$a = new stdClass ;
!               	$a->qid = $question->id ;
!               	$a->qcat = $question->category ;
!               	foreach($records as $def ){
                  if ($def->category != $question->category){
!                 	$a->name = $def->name;
!                 	$a->sharedcat = $def->category ;
!                 	$coherence = false ;
!                 	break;
                  }
!               	}
!               	if(!$coherence){
                  echo $OUTPUT->notification(get_string('nocoherencequestionsdatyasetcategory','qtype_calculated',$a));
!               	}
!               	$synchronize_calculated  = true ;
!               }
! 
!               // Choose a random dataset
!               // maxnumber sould not be breater than 100
!               if ($maxnumber > CALCULATEDQUESTIONMAXITEMNUMBER ){
!               	$maxnumber = CALCULATEDQUESTIONMAXITEMNUMBER ;
!               }
!               if ( $synchronize_calculated === false ) {
!               	$state->options->datasetitem = rand(1, $maxnumber);
!               }else{
!               	$state->options->datasetitem = intval( $maxnumber * substr($attempt->timestart,-2) /100 ) ;
!               	if ($state->options->datasetitem < 1) {
                  $state->options->datasetitem =1 ;
!               	} else if ($state->options->datasetitem > $maxnumber){
                  $state->options->datasetitem = $maxnumber ;
!               	}
  
!               };
!               $state->options->dataset =
!               $this->pick_question_dataset($question,$state->options->datasetitem);
!               $virtualqtype = $this->get_virtual_qtype( );
!               return $virtualqtype->create_session_and_responses($question, $state, $cmoptions, $attempt);
! 	}
! 
! 	function save_session_and_responses(&$question, &$state) {
! 		global $DB;
! 		$responses = 'dataset'.$state->options->datasetitem.'-' ;
! 		// regular numeric type
! 		if(isset($state->responses['unit']) && isset($question->options->units[$state->responses['unit']])){
! 			$responses .= $state->responses['answer'].'|||||'.$question->options->units[$state->responses['unit']]->unit;
! 		}else if(isset($state->responses['unit'])){
! 			$responses .= $state->responses['answer'].'|||||'.$state->responses['unit'] ;
! 		}else {
! 			$responses .= $state->responses['answer'].'|||||';
! 		}
! 
! 		// Set the legacy answer field
! 		$DB->set_field('question_states', 'answer', $responses, array('id'=> $state->id));
! 
! 		return true;
! 	}
! 
! 	function create_runtime_question($question, $form) {
! 		$question = parent::create_runtime_question($question, $form);
! 		$question->options->answers = array();
! 		foreach ($form->answers as $key => $answer) {
! 			$a->answer              = trim($form->answer[$key]);
! 			$a->fraction              = $form->fraction[$key];//new
! 			$a->tolerance           = $form->tolerance[$key];
! 			$a->tolerancetype       = $form->tolerancetype[$key];
! 			$a->correctanswerlength = $form->correctanswerlength[$key];
! 			$a->correctanswerformat = $form->correctanswerformat[$key];
! 			$question->options->answers[] = clone($a);
! 		}
! 
! 		return $question;
! 	}
! 
! 	function validate_form($form) {
! 		switch($form->wizardpage) {
! 			case 'question':
! 				$calculatedmessages = array();
! 				if (empty($form->name)) {
! 					$calculatedmessages[] = get_string('missingname', 'quiz');
! 				}
! 				if (empty($form->questiontext)) {
! 					$calculatedmessages[] = get_string('missingquestiontext', 'quiz');
! 				}
! 				// Verify formulas
! 				foreach ($form->answers as $key => $answer) {
! 					if ('' === trim($answer)) {
! 						$calculatedmessages[] =
! 						get_string('missingformula', 'quiz');
! 					}
! 					if ($formulaerrors =
! 					qtype_calculated_find_formula_errors($answer)) {
! 						$calculatedmessages[] = $formulaerrors;
! 					}
! 					if (! isset($form->tolerance[$key])) {
! 						$form->tolerance[$key] = 0.0;
! 					}
! 					if (! is_numeric($form->tolerance[$key])) {
! 						$calculatedmessages[] =
! 						get_string('tolerancemustbenumeric', 'quiz');
! 					}
! 				}
! 
! 				if (!empty($calculatedmessages)) {
! 					$errorstring = "The following errors were found:<br />";
! 					foreach ($calculatedmessages as $msg) {
! 						$errorstring .= $msg . '<br />';
! 					}
! 					print_error($errorstring);
! 				}
! 
! 				break;
! 			default:
! 				return parent::validate_form($form);
! 				break;
! 		}
! 		return true;
! 	}
! 	function finished_edit_wizard(&$form) {
! 		return isset($form->backtoquiz);
! 	}
! 	function wizard_pages_number() {
! 		return 3 ;
! 	}
! 	// This gets called by editquestion.php after the standard question is saved
! 	function print_next_wizard_page(&$question, &$form, $course) {
! 		global $CFG, $USER, $SESSION, $COURSE;
! 
! 		// Catch invalid navigation & reloads
! 		if (empty($question->id) && empty($SESSION->calculated)) {
! 			redirect('edit.php?courseid='.$COURSE->id, 'The page you are loading has expired.', 3);
! 		}
! 
! 		// See where we're coming from
! 		switch($form->wizardpage) {
! 			case 'question':
! 				require("$CFG->dirroot/question/type/calculated/datasetdefinitions.php");
! 				break;
! 			case 'datasetdefinitions':
! 			case 'datasetitems':
! 				require("$CFG->dirroot/question/type/calculated/datasetitems.php");
! 				break;
! 			default:
! 				print_error('invalidwizardpage', 'question');
! 				break;
! 		}
! 	}
! 
! 	// This gets called by question2.php after the standard question is saved
! 	function &next_wizard_form($submiturl, $question, $wizardnow){
! 		global $CFG, $SESSION, $COURSE;
! 
! 		// Catch invalid navigation & reloads
! 		if (empty($question->id) && empty($SESSION->calculated)) {
! 			redirect('edit.php?courseid='.$COURSE->id, 'The page you are loading has expired. Cannot get next wizard form.', 3);
! 		}
! 		if (empty($question->id)){
! 			$question =& $SESSION->calculated->questionform;
! 		}
! 
! 		// See where we're coming from
! 		switch($wizardnow) {
! 			case 'datasetdefinitions':
! 				require("$CFG->dirroot/question/type/calculated/datasetdefinitions_form.php");
! 				$mform = new question_dataset_dependent_definitions_form("$submiturl?wizardnow=datasetdefinitions", $question);
! 				break;
! 			case 'datasetitems':
! 				require("$CFG->dirroot/question/type/calculated/datasetitems_form.php");
! 				$regenerate = optional_param('forceregeneration', 0, PARAM_BOOL);
! 				$mform = new question_dataset_dependent_items_form("$submiturl?wizardnow=datasetitems", $question, $regenerate);
! 				break;
! 			default:
! 				print_error('invalidwizardpage', 'question');
! 				break;
! 		}
! 
! 		return $mform;
! 	}
! 
! 	/**
! 	 * This method should be overriden if you want to include a special heading or some other
! 	 * html on a question editing page besides the question editing form.
! 	 *
! 	 * @param question_edit_form $mform a child of question_edit_form
! 	 * @param object $question
! 	 * @param string $wizardnow is '' for first page.
! 	 */
! 	function display_question_editing_page(&$mform, $question, $wizardnow){
! 		global $OUTPUT ;
! 		switch ($wizardnow){
! 			case '':
! 				//on first page default display is fine
! 				parent::display_question_editing_page($mform, $question, $wizardnow);
! 				return;
! 				break;
! 			case 'datasetdefinitions':
! 				echo $OUTPUT->heading_with_help(get_string("choosedatasetproperties", "qtype_calculated"), 'questiondatasets', 'qtype_calculated');
! 				break;
! 			case 'datasetitems':
! 				echo $OUTPUT->heading_with_help(get_string("editdatasets", "qtype_calculated"), 'questiondatasets', 'qtype_calculated');
! 				break;
! 		}
! 
! 		$mform->display();
! 	}
! 
! 	/**
! 	 * This method prepare the $datasets in a format similar to dadatesetdefinitions_form.php
! 	 * so that they can be saved
! 	 * using the function save_dataset_definitions($form)
! 	 *  when creating a new calculated question or
! 	 *  whenediting an already existing calculated question
! 	 * or by  function save_as_new_dataset_definitions($form, $initialid)
! 	 *  when saving as new an already existing calculated question
! 	 *
! 	 * @param object $form
! 	 * @param int $questionfromid default = '0'
! 	 */
! 	function preparedatasets(&$form , $questionfromid='0'){
! 		// the dataset names present in the edit_question_form and edit_calculated_form are retrieved
! 		$possibledatasets = $this->find_dataset_names($form->questiontext);
! 		$mandatorydatasets = array();
! 		foreach ($form->answers as $answer) {
! 			$mandatorydatasets += $this->find_dataset_names($answer);
! 		}
! 		// if there are identical datasetdefs already saved in the original question.
! 		// either when editing a question or saving as new
! 		// they are retrieved using $questionfromid
! 		if ($questionfromid!='0'){
! 			$form->id = $questionfromid ;
! 		}
! 		$datasets = array();
! 		$key = 0 ;
! 		// always prepare the mandatorydatasets present in the answers
! 		// the $options are not used here
! 		foreach ($mandatorydatasets as $datasetname) {
! 			if (!isset($datasets[$datasetname])) {
! 				list($options, $selected) =
! 				$this->dataset_options($form, $datasetname);
! 				$datasets[$datasetname]='';
! 				$form->dataset[$key]=$selected ;
! 				$key++;
! 			}
! 		}
! 		// do not prepare possibledatasets when creating a question
! 		// they will defined and stored with datasetdefinitions_form.php
! 		// the $options are not used here
! 		if ($questionfromid!='0'){
! 
! 			foreach ($possibledatasets as $datasetname) {
! 				if (!isset($datasets[$datasetname])) {
! 					list($options, $selected) =
! 					$this->dataset_options($form, $datasetname,false);
! 					$datasets[$datasetname]='';
! 					$form->dataset[$key]=$selected ;
! 					$key++;
! 				}
! 			}
! 		}
! 		return $datasets ;
! 	}
! 	function addnamecategory(&$question){
! 		global $DB;
! 		$categorydatasetdefs = $DB->get_records_sql(
              "SELECT  a.*
                 FROM {question_datasets} b, {question_dataset_definitions} a
                WHERE a.id = b.datasetdefinition AND a.type = '1' AND a.category != 0 AND b.question = ?
             ORDER BY a.name ", array($question->id));
! 		$questionname = $question->name ;
! 		$regs= array();
! 		if(preg_match('~#\{([^[:space:]]*)#~',$questionname , $regs)){
! 			$questionname = str_replace($regs[0], '', $questionname);
! 		};
! 
! 		if (!empty($categorydatasetdefs)){ // there is at least one with the same name
! 			$questionname  ="#".$questionname;
! 			foreach($categorydatasetdefs as $def) {
! 				if(strlen("{$def->name}")+strlen($questionname) < 250 ){
! 					$questionname = '{'.$def->name.'}'
! 					.$questionname;
! 				}
! 			}
! 			$questionname ="#".$questionname;
! 		}
! 		$DB->set_field('question', 'name', $questionname, array("id" => $question->id));
! 	}
! 
! 	/**
! 	 * this version save the available data at the different steps of the question editing process
! 	 * without using global $SESSION as storage between steps
! 	 * at the first step $wizardnow = 'question'
! 	 *  when creating a new question
! 	 *  when modifying a question
! 	 *  when copying as a new question
! 	 *  the general parameters and answers are saved using parent::save_question
! 	 *  then the datasets are prepared and saved
! 	 * at the second step $wizardnow = 'datasetdefinitions'
! 	 *  the datadefs final type are defined as private, category or not a datadef
! 	 * at the third step $wizardnow = 'datasetitems'
! 	 *  the datadefs parameters and the data items are created or defined
! 	 *
! 	 * @param object question
! 	 * @param object $form
! 	 * @param int $course
! 	 * @param PARAM_ALPHA $wizardnow should be added as we are coming from question2.php
! 	 */
! 	function save_question($question, $form) {
! 		global $DB;
! 		if ($this->wizard_pages_number() == 1 ){
! 			$question = parent::save_question($question, $form);
! 			return $question ;
! 		}
! 
! 		$wizardnow =  optional_param('wizardnow', '', PARAM_ALPHA);
! 		$id = optional_param('id', 0, PARAM_INT); // question id
! 		// in case 'question'
! 		// for a new question $form->id is empty
! 		// when saving as new question
! 		//   $question->id = 0, $form is $data from question2.php
! 		//   and $data->makecopy is defined as $data->id is the initial question id
! 		// edit case. If it is a new question we don't necessarily need to
! 		// return a valid question object
! 
! 		// See where we're coming from
! 		switch($wizardnow) {
! 			case '' :
! 			case 'question': // coming from the first page, creating the second
! 				if (empty($form->id)) { // for a new question $form->id is empty
! 					$question = parent::save_question($question, $form);
! 					//prepare the datasets using default $questionfromid
! 					$this->preparedatasets($form);
! 					$form->id = $question->id;
! 					$this->save_dataset_definitions($form);
! 					if(isset($form->synchronize) && $form->synchronize == 2 ){
! 						$this->addnamecategory($question);
! 					}
! 				} else if (!empty($form->makecopy)){
! 					$questionfromid =  $form->id ;
! 					$question = parent::save_question($question, $form);
! 					//prepare the datasets
! 					$this->preparedatasets($form,$questionfromid);
! 					$form->id = $question->id;
! 					$this->save_as_new_dataset_definitions($form,$questionfromid );
! 					if(isset($form->synchronize) && $form->synchronize == 2 ){
! 						$this->addnamecategory($question);
! 					}
! 				}  else {// editing a question
! 					$question = parent::save_question($question, $form);
! 					//prepare the datasets
! 					$this->preparedatasets($form,$question->id);
! 					$form->id = $question->id;
! 					$this->save_dataset_definitions($form);
! 					if(isset($form->synchronize) && $form->synchronize == 2 ){
! 						$this->addnamecategory($question);
! 					}
! 				}
! 				break;
! 			case 'datasetdefinitions':
! 				// calculated options
! 				// it cannot go here without having done the first page
! 				// so the question_calculated_options should exist
! 				// only need to update the synchronize field
! 				if(isset($form->synchronize) ){
! 					$options_synchronize = $form->synchronize ;
! 				}else {
! 					$options_synchronize = 0 ;
! 				}
! 				$DB->set_field('question_calculated_options', 'synchronize', $options_synchronize, array("question" => $question->id));
! 				if(isset($form->synchronize) && $form->synchronize == 2 ){
! 					$this->addnamecategory($question);
! 				}
! 
! 				$this->save_dataset_definitions($form);
! 				break;
! 			case 'datasetitems':
! 				$this->save_dataset_items($question, $form);
! 				$this->save_question_calculated($question, $form);
! 				break;
! 			default:
! 				print_error('invalidwizardpage', 'question');
! 				break;
! 		}
! 		return $question;
! 	}
! 
! 	function delete_question($questionid, $contextid) {
! 		global $DB;
! 
! 		$DB->delete_records("question_calculated", array("question" => $questionid));
! 		$DB->delete_records("question_calculated_options", array("question" => $questionid));
! 		$DB->delete_records("question_numerical_units", array("question" => $questionid));
! 		if ($datasets = $DB->get_records('question_datasets', array('question' => $questionid))) {
! 			foreach ($datasets as $dataset) {
! 				if (!$DB->get_records_select(
                      'question_datasets',
                      "question != ?
                      AND datasetdefinition = ? ", array($questionid, $dataset->datasetdefinition))){
! 				$DB->delete_records('question_dataset_definitions', array('id' => $dataset->datasetdefinition));
! 				$DB->delete_records('question_dataset_items', array('definition' => $dataset->datasetdefinition));
                      }
! 			}
! 		}
! 		$DB->delete_records("question_datasets", array("question" => $questionid));
! 
! 		parent::delete_question($questionid, $contextid);
! 	}
! 
! 	function test_response(&$question, &$state, $answer) {
! 		$virtualqtype = $this->get_virtual_qtype();
! 		return $virtualqtype->test_response($question, $state, $answer);
! 
! 	}
! 
! 	function compare_responses(&$question, $state, $teststate) {
! 
! 		$virtualqtype = $this->get_virtual_qtype();
! 		return $virtualqtype->compare_responses($question, $state, $teststate);
! 	}
! 
! 	function convert_answers (&$question, &$state){
! 		foreach ($question->options->answers as $key => $answer) {
! 			$answer = fullclone($question->options->answers[$key]);
! 			$question->options->answers[$key]->answer = $this->substitute_variables_and_eval($answer->answer,
! 			$state->options->dataset);
! 		}
! 	}
! 	function convert_questiontext (&$question, &$state){
! 		$tolerancemax =0.01;
! 		$tolerancetypemax = 1 ;
! 		$correctanswerlengthmax = 2 ;
! 		$correctanswerformatmax = 1 ;
! 		$tolerancemaxset = false ;
! 		foreach ($question->options->answers as $key => $answer) {
! 			if($answer->fraction == 1.0 && !$tolerancemaxset){
! 				$tolerancemax = $answer->tolerance;
! 				$tolerancetypemax = $answer->tolerancetype ;
! 				$correctanswerlengthmax = $answer->correctanswerlength;
! 				$correctanswerformatmax =$answer->correctanswerformat;
! 				$tolerancemaxset = true ;
! 			}
! 		}
! 		$question->questiontext = $this->substitute_variables($question->questiontext, $state->options->dataset);
! 		//evaluate the equations i.e {=5+4)
! 		$qtext = "";
! 		$qtextremaining = $question->questiontext ;
! 		while  (preg_match('~\{=([^[:space:]}]*)}~', $qtextremaining, $regs1)) {
! 			//  while  (preg_match('~\{=|%=([^[:space:]}]*)}~', $qtextremaining, $regs1)) {
! 			$qtextsplits = explode($regs1[0], $qtextremaining, 2);
! 			$qtext =$qtext.$qtextsplits[0];
! 			$qtextremaining = $qtextsplits[1];
! 			if (empty($regs1[1])) {
! 				$str = '';
! 			} else {
! 				if( $formulaerrors = qtype_calculated_find_formula_errors($regs1[1])){
! 					$str=$formulaerrors ;
! 				}else {
! 					eval('$str = '.$regs1[1].';');
! 					$texteval= qtype_calculated_calculate_answer(
! 					$str, $state->options->dataset, $tolerancemax,
! 					$tolerancetypemax, $correctanswerlengthmax,
! 					$correctanswerformatmax, '');
! 					$str = $texteval->answer;
! 
! 					;
! 				}
! 			}
! 			$qtext = $qtext.$str ;
! 		}
! 		$question->questiontext = $qtext.$qtextremaining ; // end replace equations
! 	}
! 
! 	function get_default_numerical_unit($question,$virtualqtype){
! 		if($unit = $virtualqtype->get_default_numerical_unit($question)){
! 			$unit = $unit->unit;
! 		} else {
! 			$unit = '';
! 		}
! 		return $unit ;
! 
! 	}
! 	function print_question_formulation_and_controls(&$question, &$state, $cmoptions, $options) {
! 		// Substitute variables in questiontext before giving the data to the
! 		// virtual type for printing
! 		$virtualqtype = $this->get_virtual_qtype();
! 		// why $unit as it is not use
! 		$unit = $this-> get_default_numerical_unit($question,$virtualqtype);
! 		// We modify the question to look like a numerical question
! 		$numericalquestion = fullclone($question);
! 		$this->convert_answers($numericalquestion, $state);
! 		$this->convert_questiontext($numericalquestion, $state);
! 		/*        $tolerancemax =0.01;
! 		 $tolerancetypemax = 1 ;
! 		 $correctanswerlengthmax = 2 ;
! 		 $correctanswerformatmax = 1 ;
! 		 $tolerancemaxset = false ;
! 		 foreach ($numericalquestion->options->answers as $key => $answer) {
! 		 if($answer->fraction == 1.0 && !$tolerancemaxset){
! 		 $tolerancemax = $answer->tolerance;
! 		 $tolerancetypemax = $answer->tolerancetype ;
! 		 $correctanswerlengthmax = $answer->correctanswerlength;
! 		 $correctanswerformatmax =$answer->correctanswerformat;
! 		 $tolerancemaxset = true ;
! 		 }
! 		 }
! 
! 		 $numericalquestion->questiontext = $this->substitute_variables(
! 		 $numericalquestion->questiontext, $state->options->dataset);
! 		 //evaluate the equations i.e {=5+4)
! 		 $qtext = "";
! 		 $qtextremaining = $numericalquestion->questiontext ;
! 		 while  (preg_match('~\{=([^[:space:]}]*)}~', $qtextremaining, $regs1)) {
! 		 //  while  (preg_match('~\{=|%=([^[:space:]}]*)}~', $qtextremaining, $regs1)) {
! 		 $qtextsplits = explode($regs1[0], $qtextremaining, 2);
! 		 $qtext =$qtext.$qtextsplits[0];
! 		 $qtextremaining = $qtextsplits[1];
! 		 if (empty($regs1[1])) {
! 		 $str = '';
! 		 } else {
! 		 if( $formulaerrors = qtype_calculated_find_formula_errors($regs1[1])){
! 		 $str=$formulaerrors ;
! 		 }else {
! 		 eval('$str = '.$regs1[1].';');
! 		 $texteval= qtype_calculated_calculate_answer(
! 		 $str, $state->options->dataset, $tolerancemax,
! 		 $tolerancetypemax, $correctanswerlengthmax,
! 		 $correctanswerformatmax, '');
! 		 $str = $texteval->answer;
! 
! 		 ;
! 		 }
! 		 }
! 		 $qtext = $qtext.$str ;
! 		 }
! 		 $numericalquestion->questiontext = $qtext.$qtextremaining ; // end replace equations
! 		 */
! 
! 		$virtualqtype->print_question_formulation_and_controls($numericalquestion, $state, $cmoptions, $options);
! 	}
! 	function grade_responses(&$question, &$state, $cmoptions) {
! 		// Forward the grading to the virtual qtype
! 		// We modify the question to look like a numerical question
! 		$numericalquestion = fullclone($question);
! 		foreach ($numericalquestion->options->answers as $key => $answer) {
! 			$answer = $numericalquestion->options->answers[$key]->answer; // for PHP 4.x
! 			$numericalquestion->options->answers[$key]->answer = $this->substitute_variables_and_eval($answer,
! 			$state->options->dataset);
! 		}
! 		$virtualqtype = $this->get_virtual_qtype();
! 		return $virtualqtype->grade_responses($numericalquestion, $state, $cmoptions) ;
! 	}
! 
! 
! 	// ULPGC ecastro
! 	function check_response(&$question, &$state) {
! 		// Forward the checking to the virtual qtype
! 		// We modify the question to look like a numerical question
! 		$numericalquestion = clone($question);
! 		$numericalquestion->options = clone($question->options);
! 		foreach ($question->options->answers as $key => $answer) {
! 			$numericalquestion->options->answers[$key] = clone($answer);
! 		}
! 		foreach ($numericalquestion->options->answers as $key => $answer) {
! 			$answer->answer = $this->substitute_variables_and_eval($answer->answer,
! 			$state->options->dataset);
! 		}
! 		$virtualqtype = $this->get_virtual_qtype();
! 		return $virtualqtype->check_response($numericalquestion, $state) ;
! 	}
! 
! 	// ULPGC ecastro
! 	function get_actual_response(&$question, &$state) {
! 		// Substitute variables in questiontext before giving the data to the
! 		// virtual type
! 		$virtualqtype = $this->get_virtual_qtype();
! 		$unit = $virtualqtype->get_default_numerical_unit($question);
! 
! 		// We modify the question to look like a numerical question
! 		$numericalquestion = clone($question);
! 		$numericalquestion->options = clone($question->options);
! 		foreach ($question->options->answers as $key => $answer) {
! 			$numericalquestion->options->answers[$key] = clone($answer);
! 		}
! 		foreach ($numericalquestion->options->answers as $key => $answer) {
! 			$answer = &$numericalquestion->options->answers[$key]; // for PHP 4.x
! 			$answer->answer = $this->substitute_variables_and_eval($answer->answer,
! 			$state->options->dataset);
! 			// apply_unit
! 		}
! 		$numericalquestion->questiontext = $this->substitute_variables_and_eval(
! 		$numericalquestion->questiontext, $state->options->dataset);
! 		$responses = $virtualqtype->get_all_responses($numericalquestion, $state);
! 		$response = reset($responses->responses);
! 		$correct = $response->answer.' : ';
! 
! 		$responses = $virtualqtype->get_actual_response($numericalquestion, $state);
! 
! 		foreach ($responses as $key=>$response){
! 			$responses[$key] = $correct.$response;
! 		}
! 
! 		return $responses;
! 	}
! 
! 	function create_virtual_qtype() {
! 		global $CFG;
! 		require_once("$CFG->dirroot/question/type/numerical/questiontype.php");
! 		return new question_numerical_qtype();
! 	}
! 
! 	function supports_dataset_item_generation() {
! 		// Calcualted support generation of randomly distributed number data
! 		return true;
! 	}
! 	function custom_generator_tools_part(&$mform, $idx, $j){
! 
! 		$minmaxgrp = array();
! 		$minmaxgrp[] =& $mform->createElement('text', "calcmin[$idx]", get_string('calcmin', 'qtype_calculated'));
! 		$minmaxgrp[] =& $mform->createElement('text', "calcmax[$idx]", get_string('calcmax', 'qtype_calculated'));
! 		$mform->addGroup($minmaxgrp, 'minmaxgrp', get_string('minmax', 'qtype_calculated'), ' - ', false);
! 		$mform->setType("calcmin[$idx]", PARAM_NUMBER);
! 		$mform->setType("calcmax[$idx]", PARAM_NUMBER);
! 
! 		$precisionoptions = range(0, 10);
! 		$mform->addElement('select', "calclength[$idx]", get_string('calclength', 'qtype_calculated'), $precisionoptions);
! 
! 		$distriboptions = array('uniform' => get_string('uniform', 'qtype_calculated'), 'loguniform' => get_string('loguniform', 'qtype_calculated'));
! 		$mform->addElement('select', "calcdistribution[$idx]", get_string('calcdistribution', 'qtype_calculated'), $distriboptions);
! 	}
! 
! 	function custom_generator_set_data($datasetdefs, $formdata){
! 		$idx = 1;
! 		foreach ($datasetdefs as $datasetdef){
! 			if (preg_match('~^(uniform|loguniform):([^:]*):([^:]*):([0-9]*)$~', $datasetdef->options, $regs)) {
! 				$defid = "$datasetdef->type-$datasetdef->category-$datasetdef->name";
! 				$formdata["calcdistribution[$idx]"] = $regs[1];
! 				$formdata["calcmin[$idx]"] = $regs[2];
! 				$formdata["calcmax[$idx]"] = $regs[3];
! 				$formdata["calclength[$idx]"] = $regs[4];
! 			}
! 			$idx++;
! 		}
! 		return $formdata;
! 	}
! 
! 	function custom_generator_tools($datasetdef) {
! 		global $OUTPUT;
! 		if (preg_match('~^(uniform|loguniform):([^:]*):([^:]*):([0-9]*)$~',
! 		$datasetdef->options, $regs)) {
! 			$defid = "$datasetdef->type-$datasetdef->category-$datasetdef->name";
! 			for ($i = 0 ; $i<10 ; ++$i) {
! 				$lengthoptions[$i] = get_string(($regs[1] == 'uniform'
! 				? 'decimals'
! 				: 'significantfigures'), 'quiz', $i);
! 			}
! 			$menu1 = html_writer::select($lengthoptions, 'calclength[]', $regs[4], null);
! 
! 			$options = array('uniform' => get_string('uniform', 'quiz'), 'loguniform' => get_string('loguniform', 'quiz'));
! 			$menu2 = html_writer::select($options, 'calcdistribution[]', $regs[1], null);
! 			return '<input type="submit" onclick="'
! 			. "getElementById('addform').regenerateddefid.value='$defid'; return true;"
! 			.'" value="'. get_string('generatevalue', 'quiz') . '"/><br/>'
! 			. '<input type="text" size="3" name="calcmin[]" '
! 			. " value=\"$regs[2]\"/> &amp; <input name=\"calcmax[]\" "
! 			. ' type="text" size="3" value="' . $regs[3] .'"/> '
! 			. $menu1 . '<br/>'
! 			. $menu2;
! 		} else {
! 			return '';
! 		}
! 	}
! 
! 
! 	function update_dataset_options($datasetdefs, $form) {
! 		global $OUTPUT;
! 		// Do we have informatin about new options???
! 		if (empty($form->definition) || empty($form->calcmin)
! 		|| empty($form->calcmax) || empty($form->calclength)
! 		|| empty($form->calcdistribution)) {
! 			// I guess not
! 
! 		} else {
! 			// Looks like we just could have some new information here
! 			$uniquedefs = array_values(array_unique($form->definition));
! 			foreach ($uniquedefs as $key => $defid) {
! 				if (isset($datasetdefs[$defid])
! 				&& is_numeric($form->calcmin[$key+1])
! 				&& is_numeric($form->calcmax[$key+1])
! 				&& is_numeric($form->calclength[$key+1])) {
! 					switch     ($form->calcdistribution[$key+1]) {
! 						case 'uniform': case 'loguniform':
! 							$datasetdefs[$defid]->options =
! 							$form->calcdistribution[$key+1] . ':'
! 							. $form->calcmin[$key+1] . ':'
! 							. $form->calcmax[$key+1] . ':'
! 							. $form->calclength[$key+1];
! 							break;
! 						default:
! 							echo $OUTPUT->notification("Unexpected distribution ".$form->calcdistribution[$key+1]);
! 					}
! 				}
! 			}
! 		}
! 
! 		// Look for empty options, on which we set default values
! 		foreach ($datasetdefs as $defid => $def) {
! 			if (empty($def->options)) {
! 				$datasetdefs[$defid]->options = 'uniform:1.0:10.0:1';
! 			}
! 		}
! 		return $datasetdefs;
! 	}
! 
! 	function save_question_calculated($question, $fromform){
! 		global $DB;
! 
! 		foreach ($question->options->answers as $key => $answer) {
! 			if ($options = $DB->get_record('question_calculated', array('answer' => $key))) {
! 				$options->tolerance = trim($fromform->tolerance[$key]);
! 				$options->tolerancetype  = trim($fromform->tolerancetype[$key]);
! 				$options->correctanswerlength  = trim($fromform->correctanswerlength[$key]);
! 				$options->correctanswerformat  = trim($fromform->correctanswerformat[$key]);
! 				$DB->update_record('question_calculated', $options);
! 			}
! 		}
! 	}
! 
! 	/**
! 	 * This function get the dataset items using id as unique parameter and return an
! 	 * array with itemnumber as index sorted ascendant
! 	 * If the multiple records with the same itemnumber exist, only the newest one
! 	 * i.e with the greatest id is used, the others are ignored but not deleted.
! 	 * MDL-19210
! 	 */
! 	function get_database_dataset_items($definition){
! 		global $CFG, $DB;
! 		$databasedataitems = $DB->get_records_sql( // Use number as key!!
              " SELECT id , itemnumber, definition,  value
              FROM {question_dataset_items}
              WHERE definition = $definition order by id DESC ", array($definition));
! 		$dataitems = Array();
! 		foreach($databasedataitems as $id => $dataitem  ){
! 			if (!isset($dataitems[$dataitem->itemnumber])){
! 				$dataitems[$dataitem->itemnumber] = $dataitem ;
! 			}else {
! 				// deleting the unused records could be added here
! 			}
! 		}
! 		ksort($dataitems);
! 		return $dataitems ;
! 	}
! 
! 	function save_dataset_items($question, $fromform){
! 		global $CFG, $DB;
! 		// max datasets = 100 items
! 		$max100 = CALCULATEDQUESTIONMAXITEMNUMBER ;
! 		$synchronize = false ;
! 		if(isset($fromform->nextpageparam["forceregeneration"])) {
! 			$regenerate = $fromform->nextpageparam["forceregeneration"];
! 		}else{
! 			$regenerate = 0 ;
! 		}
! 		if (empty($question->options)) {
! 			$this->get_question_options($question);
! 		}
! 		if(!empty($question->options->synchronize)){
! 			$synchronize = true ;
! 		}
! 
! 
! 		//get the old datasets for this question
! 		$datasetdefs = $this->get_dataset_definitions($question->id, array());
! 		// Handle generator options...
! 		$olddatasetdefs = fullclone($datasetdefs);
! 		$datasetdefs = $this->update_dataset_options($datasetdefs, $fromform);
! 		$maxnumber = -1;
! 		foreach ($datasetdefs as $defid => $datasetdef) {
! 			if (isset($datasetdef->id)
! 			&& $datasetdef->options != $olddatasetdefs[$defid]->options) {
! 				// Save the new value for options
! 				$DB->update_record('question_dataset_definitions', $datasetdef);
! 
! 			}
! 			// Get maxnumber
! 			if ($maxnumber == -1 || $datasetdef->itemcount < $maxnumber) {
! 				$maxnumber = $datasetdef->itemcount;
! 			}
! 		}
! 		// Handle adding and removing of dataset items
! 		$i = 1;
! 		if ($maxnumber > CALCULATEDQUESTIONMAXITEMNUMBER ){
! 			$maxnumber = CALCULATEDQUESTIONMAXITEMNUMBER ;
! 		}
! 
! 		ksort($fromform->definition);
! 		foreach ($fromform->definition as $key => $defid) {
! 			//if the delete button has not been pressed then skip the datasetitems
! 			//in the 'add item' part of the form.
! 			if ( $i > count($datasetdefs)*$maxnumber ) {
! 				break;
! 			}
! 			$addeditem = new stdClass();
! 			$addeditem->definition = $datasetdefs[$defid]->id;
! 			$addeditem->value = $fromform->number[$i];
! 			$addeditem->itemnumber = ceil($i / count($datasetdefs));
! 
! 			if ($fromform->itemid[$i]) {
! 				// Reuse any previously used record
! 				$addeditem->id = $fromform->itemid[$i];
! 				$DB->update_record('question_dataset_items', $addeditem);
! 			} else {
! 				$DB->insert_record('question_dataset_items', $addeditem);
! 			}
! 
! 			$i++;
! 		}
! 		if (isset($addeditem->itemnumber) && $maxnumber < $addeditem->itemnumber
! 		&& $addeditem->itemnumber < CALCULATEDQUESTIONMAXITEMNUMBER ){
! 			$maxnumber = $addeditem->itemnumber;
! 			foreach ($datasetdefs as $key => $newdef) {
! 				if (isset($newdef->id) && $newdef->itemcount <= $maxnumber) {
! 					$newdef->itemcount = $maxnumber;
! 					// Save the new value for options
! 					$DB->update_record('question_dataset_definitions', $newdef);
! 				}
! 			}
! 		}
! 		// adding supplementary items
! 		$numbertoadd =0;
! 		if (isset($fromform->addbutton) && $fromform->selectadd > 0 && $maxnumber < CALCULATEDQUESTIONMAXITEMNUMBER ) {
! 			$numbertoadd =$fromform->selectadd ;
! 			if ( $max100 - $maxnumber < $numbertoadd ) {
! 				$numbertoadd = $max100 - $maxnumber ;
! 			}
! 			//add the other items.
! 			// Generate a new dataset item (or reuse an old one)
! 			foreach ($datasetdefs as $defid => $datasetdef) {
! 				// in case that for category datasets some new items has been added
! 				// get actual values
! 				// fix regenerate for this datadefs
! 				$defregenerate = 0 ;
! 				if($synchronize && !empty ($fromform->nextpageparam["datasetregenerate[$datasetdef->name"])) {
! 					$defregenerate = 1 ;
! 				}else if(!$synchronize && (($regenerate == 1 && $datasetdef->category == 0) ||$regenerate == 2 )){
! 					$defregenerate = 1 ;
! 				}
! 				if (isset($datasetdef->id)) {
! 					$datasetdefs[$defid]->items = $this->get_database_dataset_items($datasetdef->id);
! 				}
! 				for ($numberadded =$maxnumber+1 ; $numberadded <= $maxnumber+$numbertoadd ; $numberadded++){
! 					if (isset($datasetdefs[$defid]->items[$numberadded])  ){
! 						// in case of regenerate it modifies the already existing record
! 						if ( $defregenerate  ) {
! 							$datasetitem = new stdClass;
! 							$datasetitem->id = $datasetdefs[$defid]->items[$numberadded]->id;
! 							$datasetitem->definition = $datasetdef->id ;
! 							$datasetitem->itemnumber = $numberadded;
! 							$datasetitem->value = $this->generate_dataset_item($datasetdef->options);
! 							$DB->update_record('question_dataset_items', $datasetitem);
! 						}
! 						//if not regenerate do nothing as there is already a record
! 					} else {
! 						$datasetitem = new stdClass;
! 						$datasetitem->definition = $datasetdef->id ;
! 						$datasetitem->itemnumber = $numberadded;
! 						if ($this->supports_dataset_item_generation()) {
! 							$datasetitem->value = $this->generate_dataset_item($datasetdef->options);
! 						} else {
! 							$datasetitem->value = '';
! 						}
! 						$DB->insert_record('question_dataset_items', $datasetitem);
! 					}
! 				}//for number added
! 			}// datasetsdefs end
! 			$maxnumber += $numbertoadd ;
! 			foreach ($datasetdefs as $key => $newdef) {
! 				if (isset($newdef->id) && $newdef->itemcount <= $maxnumber) {
! 					$newdef->itemcount = $maxnumber;
! 					// Save the new value for options
! 					$DB->update_record('question_dataset_definitions', $newdef);
! 				}
! 			}
! 		}
! 
! 		if (isset($fromform->deletebutton))  {
! 			if(isset($fromform->selectdelete)) $newmaxnumber = $maxnumber-$fromform->selectdelete ;
! 			else $newmaxnumber = $maxnumber-1 ;
! 			if ($newmaxnumber < 0 ) $newmaxnumber = 0 ;
! 			foreach ($datasetdefs as $datasetdef) {
! 				if ($datasetdef->itemcount == $maxnumber) {
! 					$datasetdef->itemcount= $newmaxnumber ;
! 					$DB->update_record('question_dataset_definitions', $datasetdef);
! 				}
! 			}
! 		}
! 	}
! 	function generate_dataset_item($options) {
! 		if (!preg_match('~^(uniform|loguniform):([^:]*):([^:]*):([0-9]*)$~',
! 		$options, $regs)) {
! 			// Unknown options...
! 			return false;
! 		}
! 		if ($regs[1] == 'uniform') {
! 			$nbr = $regs[2] + ($regs[3]-$regs[2])*mt_rand()/mt_getrandmax();
! 			return sprintf("%.".$regs[4]."f",$nbr);
! 
! 		} else if ($regs[1] == 'loguniform') {
! 			$log0 = log(abs($regs[2])); // It would have worked the other way to
! 			$nbr = exp($log0 + (log(abs($regs[3])) - $log0)*mt_rand()/mt_getrandmax());
! 			return sprintf("%.".$regs[4]."f",$nbr);
! 
! 		} else {
! 			print_error('disterror', 'question', '', $regs[1]);
! 		}
! 		return '';
! 	}
! 
! 	function comment_header($question) {
! 		//$this->get_question_options($question);
! 		$strheader = '';
! 		$delimiter = '';
! 
! 		$answers = $question->options->answers;
! 
! 		foreach ($answers as $key => $answer) {
! 			if (is_string($answer)) {
! 				$strheader .= $delimiter.$answer;
! 			} else {
! 				$strheader .= $delimiter.$answer->answer;
! 			}
! 			$delimiter = '<br/><br/><br/>';
! 		}
! 		return $strheader;
! 	}
! 
! 	function comment_on_datasetitems($qtypeobj, $questionid, $questiontext, $answers, $data, $number) {
! 		global $DB, $QTYPES;
! 		$comment = new stdClass;
! 		$comment->stranswers = array();
! 		$comment->outsidelimit = false ;
! 		$comment->answers = array();
! 		/// Find a default unit:
! 		if (!empty($questionid) && $unit = $DB->get_record('question_numerical_units', array('question'=> $questionid, 'multiplier' => 1.0))) {
! 			$unit = $unit->unit;
! 		} else {
! 			$unit = '';
! 		}
! 
! 		$answers = fullclone($answers);
! 		$strmin = get_string('min', 'quiz');
! 		$strmax = get_string('max', 'quiz');
! 		$errors = '';
! 		$delimiter = ': ';
! 		$virtualqtype =  $qtypeobj->get_virtual_qtype();//& $QTYPES['numerical'];
! 		foreach ($answers as $key => $answer) {
! 			$formula = $this->substitute_variables($answer->answer,$data);
! 			$formattedanswer = qtype_calculated_calculate_answer(
! 			$answer->answer, $data, $answer->tolerance,
! 			$answer->tolerancetype, $answer->correctanswerlength,
! 			$answer->correctanswerformat, $unit);
! 			if ( $formula === '*'){
! 				$answer->min = ' ';
! 				$formattedanswer->answer = $answer->answer ;
! 			}else {
! 				eval('$answer->answer = '.$formula.';') ;
! 				$virtualqtype->get_tolerance_interval($answer);
! 			}
! 			if ($answer->min === '') {
! 				// This should mean that something is wrong
! 				$comment->stranswers[$key] = " $formattedanswer->answer".'<br/><br/>';
! 			} else if ($formula === '*'){
! 				$comment->stranswers[$key] = $formula.' = '.get_string('anyvalue','qtype_calculated').'<br/><br/><br/>';
! 			}else{
! 				$comment->stranswers[$key]= $formula.' = '.$formattedanswer->answer.'<br/>' ;
! 				$correcttrue->correct = $formattedanswer->answer ;
! 				$correcttrue->true = $answer->answer ;
! 				if ($formattedanswer->answer < $answer->min || $formattedanswer->answer > $answer->max){
! 					$comment->outsidelimit = true ;
! 					$comment->answers[$key] = $key;
! 					$comment->stranswers[$key] .=get_string('trueansweroutsidelimits','qtype_calculated',$correcttrue);//<span class="error">ERROR True answer '..' outside limits</span>';
! 				}else {
! 					$comment->stranswers[$key] .=get_string('trueanswerinsidelimits','qtype_calculated',$correcttrue);//' True answer :'.$calculated->trueanswer.' inside limits';
! 				}
! 				$comment->stranswers[$key] .='<br/>';
! 				$comment->stranswers[$key] .= $strmin.$delimiter.$answer->min.' --- ';
! 				$comment->stranswers[$key] .= $strmax.$delimiter.$answer->max;
! 				$comment->stranswers[$key] .='';
! 			}
! 		}
! 		return fullclone($comment);
! 	}
! 	function multichoice_comment_on_datasetitems($questionid, $questiontext, $answers,$data, $number) {
! 		global $DB;
! 		$comment = new stdClass;
! 		$comment->stranswers = array();
! 		$comment->outsidelimit = false ;
! 		$comment->answers = array();
! 		/// Find a default unit:
! 		if (!empty($questionid) && $unit = $DB->get_record('question_numerical_units', array('question'=> $questionid, 'multiplier' => 1.0))) {
! 			$unit = $unit->unit;
! 		} else {
! 			$unit = '';
! 		}
! 
! 		$answers = fullclone($answers);
! 		$strmin = get_string('min', 'quiz');
! 		$strmax = get_string('max', 'quiz');
! 		$errors = '';
! 		$delimiter = ': ';
! 		foreach ($answers as $key => $answer) {
! 			$answer->answer = $this->substitute_variables($answer->answer, $data);
! 			//evaluate the equations i.e {=5+4)
! 			$qtext = "";
! 			$qtextremaining = $answer->answer ;
! 			while  (preg_match('~\{=([^[:space:]}]*)}~', $qtextremaining, $regs1)) {
! 				$qtextsplits = explode($regs1[0], $qtextremaining, 2);
! 				$qtext =$qtext.$qtextsplits[0];
! 				$qtextremaining = $qtextsplits[1];
! 				if (empty($regs1[1])) {
! 					$str = '';
! 				} else {
! 					if( $formulaerrors = qtype_calculated_find_formula_errors($regs1[1])){
! 						$str=$formulaerrors ;
! 					}else {
! 						eval('$str = '.$regs1[1].';');
! 
! 						$texteval= qtype_calculated_calculate_answer(
! 						$str, $data, $answer->tolerance,
! 						$answer->tolerancetype, $answer->correctanswerlength,
! 						$answer->correctanswerformat, '');
! 						$str = $texteval->answer;
! 
! 					}
! 				}
! 				$qtext = $qtext.$str ;
! 			}
! 			$answer->answer = $qtext.$qtextremaining ; ;
! 			$comment->stranswers[$key]= $answer->answer ;
! 
! 
! 			/*  $formula = $this->substitute_variables($answer->answer,$data);
! 			 $formattedanswer = qtype_calculated_calculate_answer(
! 			 $answer->answer, $data, $answer->tolerance,
! 			 $answer->tolerancetype, $answer->correctanswerlength,
! 			 $answer->correctanswerformat, $unit);
! 			 if ( $formula === '*'){
! 			 $answer->min = ' ';
! 			 $formattedanswer->answer = $answer->answer ;
! 			 }else {
! 			 eval('$answer->answer = '.$formula.';') ;
! 			 $virtualqtype->get_tolerance_interval($answer);
! 			 }
! 			 if ($answer->min === '') {
! 			 // This should mean that something is wrong
! 			 $comment->stranswers[$key] = " $formattedanswer->answer".'<br/><br/>';
! 			 } else if ($formula === '*'){
! 			 $comment->stranswers[$key] = $formula.' = '.get_string('anyvalue','qtype_calculated').'<br/><br/><br/>';
! 			 }else{
! 			 $comment->stranswers[$key]= $formula.' = '.$formattedanswer->answer.'<br/>' ;
! 			 $comment->stranswers[$key] .= $strmin. $delimiter.$answer->min.'---';
! 			 $comment->stranswers[$key] .= $strmax.$delimiter.$answer->max;
! 			 $comment->stranswers[$key] .='<br/>';
! 			 $correcttrue->correct = $formattedanswer->answer ;
! 			 $correcttrue->true = $answer->answer ;
! 			 if ($formattedanswer->answer < $answer->min || $formattedanswer->answer > $answer->max){
! 			 $comment->outsidelimit = true ;
! 			 $comment->answers[$key] = $key;
! 			 $comment->stranswers[$key] .=get_string('trueansweroutsidelimits','qtype_calculated',$correcttrue);//<span class="error">ERROR True answer '..' outside limits</span>';
! 			 }else {
! 			 $comment->stranswers[$key] .=get_string('trueanswerinsidelimits','qtype_calculated',$correcttrue);//' True answer :'.$calculated->trueanswer.' inside limits';
! 			 }
! 			 $comment->stranswers[$key] .='';
! 			 }*/
! 		}
! 		return fullclone($comment);
! 	}
  
! 	function tolerance_types() {
! 		return array('1'  => get_string('relative', 'quiz'),
              '2'  => get_string('nominal', 'quiz'),
              '3'  => get_string('geometric', 'quiz'));
! 	}
  
! 	function dataset_options($form, $name, $mandatory=true,$renameabledatasets=false) {
! 		// Takes datasets from the parent implementation but
! 		// filters options that are currently not accepted by calculated
! 		// It also determines a default selection...
! 		//$renameabledatasets not implemented anmywhere
! 		list($options, $selected) = $this->dataset_options_from_database($form, $name,'','qtype_calculated');
! 		//  list($options, $selected) = $this->dataset_optionsa($form, $name);
! 
! 		foreach ($options as $key => $whatever) {
! 			if (!preg_match('~^1-~', $key) && $key != '0') {
! 				unset($options[$key]);
! 			}
! 		}
! 		if (!$selected) {
! 			if ($mandatory){
! 				$selected =  "1-0-$name"; // Default
! 			}else {
! 				$selected = "0"; // Default
! 			}
! 		}
! 		return array($options, $selected);
! 	}
! 
! 	function construct_dataset_menus($form, $mandatorydatasets,
! 	$optionaldatasets) {
! 		global $OUTPUT;
! 		$datasetmenus = array();
! 		foreach ($mandatorydatasets as $datasetname) {
! 			if (!isset($datasetmenus[$datasetname])) {
! 				list($options, $selected) =
! 				$this->dataset_options($form, $datasetname);
! 				unset($options['0']); // Mandatory...
! 				$datasetmenus[$datasetname] = html_writer::select($options, 'dataset[]', $selected, null);
! 			}
! 		}
! 		foreach ($optionaldatasets as $datasetname) {
! 			if (!isset($datasetmenus[$datasetname])) {
! 				list($options, $selected) =
! 				$this->dataset_options($form, $datasetname);
! 				$datasetmenus[$datasetname] = html_writer::select($options, 'dataset[]', $selected, null);
! 			}
! 		}
! 		return $datasetmenus;
! 	}
! 
! 	function print_question_grading_details(&$question, &$state, &$cmoptions, &$options) {
! 		$virtualqtype = $this->get_virtual_qtype();
! 		$virtualqtype->print_question_grading_details($question, $state, $cmoptions, $options) ;
! 	}
! 
! 	function get_correct_responses(&$question, &$state) {
! 		// virtual type for printing
! 		$virtualqtype = $this->get_virtual_qtype();
! 		$unit = $this->get_default_numerical_unit($question,$virtualqtype);
! 		// We modify the question to look like a numerical question
! 		$this->convert_answers($question, $state);
! 		return $virtualqtype->get_correct_responses($question, $state) ;
! 	}
! 
! 	function substitute_variables($str, $dataset) {
! 		global $OUTPUT ;
! 		//  testing for wrong numerical values
! 		// all calculations used this function so testing here should be OK
! 
! 		foreach ($dataset as $name => $value) {
! 			$val = $value ;
! 			if(! is_numeric($val)){
! 				$a = new stdClass;
! 				$a->name = '{'.$name.'}' ;
! 				$a->value = $value ;
! 				echo $OUTPUT->notification(get_string('notvalidnumber','qtype_calculated',$a));
! 				$val = 1.0 ;
! 			}
! 			if($val < 0 ){
! 				$str = str_replace('{'.$name.'}', '('.$val.')', $str);
! 			} else {
! 				$str = str_replace('{'.$name.'}', $val, $str);
! 			}
! 		}
! 		return $str;
! 	}
! 	function evaluate_equations($str, $dataset){
! 		$formula = $this->substitute_variables($str, $dataset) ;
! 		if ($error = qtype_calculated_find_formula_errors($formula)) {
! 			return $error;
! 		}
! 		return $str;
! 	}
! 
! 
! 	function substitute_variables_and_eval($str, $dataset) {
! 		$formula = $this->substitute_variables($str, $dataset) ;
! 		if ($error = qtype_calculated_find_formula_errors($formula)) {
! 			return $error;
! 		}
! 		/// Calculate the correct answer
! 		if (empty($formula)) {
! 			$str = '';
! 		} else if ($formula === '*'){
! 			$str = '*';
! 		} else {
! 			eval('$str = '.$formula.';');
! 		}
! 		return $str;
! 	}
! 
! 	function get_dataset_definitions($questionid, $newdatasets) {
! 		global $DB;
! 		//get the existing datasets for this question
! 		$datasetdefs = array();
! 		if (!empty($questionid)) {
! 			global $CFG;
! 			$sql = "SELECT i.*
                        FROM {question_datasets} d, {question_dataset_definitions} i
                       WHERE d.question = ? AND d.datasetdefinition = i.id";
! 			if ($records = $DB->get_records_sql($sql, array($questionid))) {
! 				foreach ($records as $r) {
! 					$datasetdefs["$r->type-$r->category-$r->name"] = $r;
! 				}
! 			}
! 		}
! 
! 		foreach ($newdatasets as $dataset) {
! 			if (!$dataset) {
! 				continue; // The no dataset case...
! 			}
! 
! 			if (!isset($datasetdefs[$dataset])) {
! 				//make new datasetdef
! 				list($type, $category, $name) = explode('-', $dataset, 3);
! 				$datasetdef = new stdClass;
! 				$datasetdef->type = $type;
! 				$datasetdef->name = $name;
! 				$datasetdef->category  = $category;
! 				$datasetdef->itemcount = 0;
! 				$datasetdef->options   = 'uniform:1.0:10.0:1';
! 				$datasetdefs[$dataset] = clone($datasetdef);
! 			}
! 		}
! 		return $datasetdefs;
! 	}
! 
! 	function save_dataset_definitions($form) {
! 		global $DB;
! 		// save synchronize
! 
! 		if (empty($form->dataset)) {
! 			$form->dataset = array();
! 		}
! 		// Save datasets
! 		$datasetdefinitions = $this->get_dataset_definitions($form->id, $form->dataset);
! 		$tmpdatasets = array_flip($form->dataset);
! 		$defids = array_keys($datasetdefinitions);
! 		foreach ($defids as $defid) {
! 			$datasetdef = &$datasetdefinitions[$defid];
! 			if (isset($datasetdef->id)) {
! 				if (!isset($tmpdatasets[$defid])) {
! 					// This dataset is not used any more, delete it
! 					$DB->delete_records('question_datasets', array('question' => $form->id, 'datasetdefinition' => $datasetdef->id));
! 					if ($datasetdef->category == 0) { // Question local dataset
! 						$DB->delete_records('question_dataset_definitions', array('id' => $datasetdef->id));
! 						$DB->delete_records('question_dataset_items', array('definition' => $datasetdef->id));
! 					}
! 				}
! 				// This has already been saved or just got deleted
! 				unset($datasetdefinitions[$defid]);
! 				continue;
! 			}
! 
! 			$datasetdef->id = $DB->insert_record('question_dataset_definitions', $datasetdef);
! 
! 			if (0 != $datasetdef->category) {
! 				// We need to look for already existing
! 				// datasets in the category.
! 				// By first creating the datasetdefinition above we
! 				// can manage to automatically take care of
! 				// some possible realtime concurrence
! 				if ($olderdatasetdefs = $DB->get_records_select('question_dataset_definitions',
                           "type = ?
                        AND name = ?
                        AND category = ?
                        AND id < ?
                      ORDER BY id DESC", array($datasetdef->type, $datasetdef->name, $datasetdef->category, $datasetdef->id))) {
  
! 				while ($olderdatasetdef = array_shift($olderdatasetdefs)) {
! 					$DB->delete_records('question_dataset_definitions', array('id' => $datasetdef->id));
! 					$datasetdef = $olderdatasetdef;
! 				}
!                     }
! 			}
! 
! 			// Create relation to this dataset:
! 			$questiondataset = new stdClass;
! 			$questiondataset->question = $form->id;
! 			$questiondataset->datasetdefinition = $datasetdef->id;
! 			$DB->insert_record('question_datasets', $questiondataset);
! 			unset($datasetdefinitions[$defid]);
! 		}
! 
! 		// Remove local obsolete datasets as well as relations
! 		// to datasets in other categories:
! 		if (!empty($datasetdefinitions)) {
! 			foreach ($datasetdefinitions as $def) {
! 				$DB->delete_records('question_datasets', array('question' => $form->id, 'datasetdefinition' => $def->id));
! 
! 				if ($def->category == 0) { // Question local dataset
! 					$DB->delete_records('question_dataset_definitions', array('id' => $def->id));
! 					$DB->delete_records('question_dataset_items', array('definition' => $def->id));
! 				}
! 			}
! 		}
! 	}
! 	/** This function create a copy of the datasets ( definition and dataitems)
! 	 * from the preceding question if they remain in the new question
! 	 * otherwise its create the datasets that have been added as in the
! 	 * save_dataset_definitions()
! 	 */
! 	function save_as_new_dataset_definitions($form, $initialid) {
! 		global $CFG, $DB;
! 		// Get the datasets from the intial question
! 		$datasetdefinitions = $this->get_dataset_definitions($initialid, $form->dataset);
! 		// $tmpdatasets contains those of the new question
! 		$tmpdatasets = array_flip($form->dataset);
! 		$defids = array_keys($datasetdefinitions);// new datasets
! 		foreach ($defids as $defid) {
! 			$datasetdef = &$datasetdefinitions[$defid];
! 			if (isset($datasetdef->id)) {
! 				// This dataset exist in the initial question
! 				if (!isset($tmpdatasets[$defid])) {
! 					// do not exist in the new question so ignore
! 					unset($datasetdefinitions[$defid]);
! 					continue;
! 				}
! 				// create a copy but not for category one
! 				if (0 == $datasetdef->category) {
! 					$olddatasetid = $datasetdef->id ;
! 					$olditemcount = $datasetdef->itemcount ;
! 					$datasetdef->itemcount =0;
! 					$datasetdef->id = $DB->insert_record('question_dataset_definitions', $datasetdef);
! 					//copy the dataitems
! 					$olditems = $this->get_database_dataset_items($olddatasetid);
! 					if (count($olditems) > 0 ) {
! 						$itemcount = 0;
! 						foreach($olditems as $item ){
! 							$item->definition = $datasetdef->id;
! 							$DB->insert_record('question_dataset_items', $item);
! 							$itemcount++;
! 						}
! 						//update item count to olditemcount if
! 						// at least this number of items has been recover from the database
! 						if( $olditemcount <= $itemcount ) {
! 							$datasetdef->itemcount = $olditemcount;
! 						} else {
! 							$datasetdef->itemcount = $itemcount ;
! 						}
! 						$DB->update_record('question_dataset_definitions', $datasetdef);
! 					} // end of  copy the dataitems
! 				}// end of  copy the datasetdef
! 				// Create relation to the new question with this
! 				// copy as new datasetdef from the initial question
! 				$questiondataset = new stdClass;
! 				$questiondataset->question = $form->id;
! 				$questiondataset->datasetdefinition = $datasetdef->id;
! 				$DB->insert_record('question_datasets', $questiondataset);
! 				unset($datasetdefinitions[$defid]);
! 				continue;
! 			}// end of datasetdefs from the initial question
! 			// really new one code similar to save_dataset_definitions()
! 			$datasetdef->id = $DB->insert_record('question_dataset_definitions', $datasetdef);
! 
! 			if (0 != $datasetdef->category) {
! 				// We need to look for already existing
! 				// datasets in the category.
! 				// By first creating the datasetdefinition above we
! 				// can manage to automatically take care of
! 				// some possible realtime concurrence
! 				if ($olderdatasetdefs = $DB->get_records_select(
                      'question_dataset_definitions',
                      "type = ?
                      AND name = ?
***************
*** 1727,1820 ****
                      AND id < ?
                      ORDER BY id DESC", array($datasetdef->type, $datasetdef->name, $datasetdef->category, $datasetdef->id))) {
  
!                         while ($olderdatasetdef = array_shift($olderdatasetdefs)) {
!                             $DB->delete_records('question_dataset_definitions', array('id' => $datasetdef->id));
!                             $datasetdef = $olderdatasetdef;
!                         }
!                     }
!             }
! 
!             // Create relation to this dataset:
!             $questiondataset = new stdClass;
!             $questiondataset->question = $form->id;
!             $questiondataset->datasetdefinition = $datasetdef->id;
!             $DB->insert_record('question_datasets', $questiondataset);
!             unset($datasetdefinitions[$defid]);
!         }
! 
!         // Remove local obsolete datasets as well as relations
!         // to datasets in other categories:
!         if (!empty($datasetdefinitions)) {
!             foreach ($datasetdefinitions as $def) {
!                 $DB->delete_records('question_datasets', array('question' => $form->id, 'datasetdefinition' => $def->id));
! 
!                 if ($def->category == 0) { // Question local dataset
!                     $DB->delete_records('question_dataset_definitions', array('id' => $def->id));
!                     $DB->delete_records('question_dataset_items', array('definition' => $def->id));
!                 }
!             }
!         }
!     }
! 
!     /// Dataset functionality
!     function pick_question_dataset($question, $datasetitem) {
!         // Select a dataset in the following format:
!         // An array indexed by the variable names (d.name) pointing to the value
!         // to be substituted
!         global $CFG, $DB;
!         if (!$dataitems = $DB->get_records_sql(
              "SELECT i.id, d.name, i.value
                 FROM {question_dataset_definitions} d, {question_dataset_items} i, {question_datasets} q
                WHERE q.question = ? AND q.datasetdefinition = d.id AND d.id = i.definition AND i.itemnumber = ?
             ORDER by i.id DESC ", array($question->id, $datasetitem))) {
!            $a = new stdClass;
!            $a->id = $question->id;
!            $a->item = $datasetitem ;
!             print_error('cannotgetdsfordependent', 'question', '', $a );
!         }
!         $dataset = Array();
!         foreach($dataitems as $id => $dataitem  ){
              if (!isset($dataset[$dataitem->name])){
!                 $dataset[$dataitem->name] = $dataitem->value ;
              }else {
!                 // deleting the unused records could be added here
              }
!         }
!         return $dataset;
!     }
! 
!     function dataset_options_from_database($form, $name,$prefix='',$langfile='quiz') {
!         global $CFG, $DB;
!         $type = 1 ; // only type = 1 (i.e. old 'LITERAL') has ever been used
! 
!         // First options - it is not a dataset...
!         $options['0'] = get_string($prefix.'nodataset', $langfile);
!         // new question no local
!         if (!isset($form->id) || $form->id == 0 ){
!             $key = "$type-0-$name";
!             $options[$key] = get_string($prefix."newlocal$type", $langfile);
!             $currentdatasetdef = new stdClass;
!             $currentdatasetdef->type = '0';
!         }else {
  
!             // Construct question local options
!             $sql = "SELECT a.*
                  FROM {question_dataset_definitions} a, {question_datasets} b
                 WHERE a.id = b.datasetdefinition AND a.type = '1' AND b.question = ? AND a.name = ?";
!             $currentdatasetdef = $DB->get_record_sql($sql, array($form->id, $name));
!             if (!$currentdatasetdef) {
!                 $currentdatasetdef->type = '0';
!             }
!             $key = "$type-0-$name";
!             if ($currentdatasetdef->type == $type
!                 and $currentdatasetdef->category == 0) {
!                     $options[$key] = get_string($prefix."keptlocal$type", $langfile);
!                 } else {
!                     $options[$key] = get_string($prefix."newlocal$type", $langfile);
!                 }
!         }
!         // Construct question category options
!         $categorydatasetdefs = $DB->get_records_sql(
              "SELECT b.question, a.*
              FROM {question_datasets} b,
              {question_dataset_definitions} a
--- 1727,1820 ----
                      AND id < ?
                      ORDER BY id DESC", array($datasetdef->type, $datasetdef->name, $datasetdef->category, $datasetdef->id))) {
  
! 				while ($olderdatasetdef = array_shift($olderdatasetdefs)) {
! 					$DB->delete_records('question_dataset_definitions', array('id' => $datasetdef->id));
! 					$datasetdef = $olderdatasetdef;
! 				}
!                     }
! 			}
! 
! 			// Create relation to this dataset:
! 			$questiondataset = new stdClass;
! 			$questiondataset->question = $form->id;
! 			$questiondataset->datasetdefinition = $datasetdef->id;
! 			$DB->insert_record('question_datasets', $questiondataset);
! 			unset($datasetdefinitions[$defid]);
! 		}
! 
! 		// Remove local obsolete datasets as well as relations
! 		// to datasets in other categories:
! 		if (!empty($datasetdefinitions)) {
! 			foreach ($datasetdefinitions as $def) {
! 				$DB->delete_records('question_datasets', array('question' => $form->id, 'datasetdefinition' => $def->id));
! 
! 				if ($def->category == 0) { // Question local dataset
! 					$DB->delete_records('question_dataset_definitions', array('id' => $def->id));
! 					$DB->delete_records('question_dataset_items', array('definition' => $def->id));
! 				}
! 			}
! 		}
! 	}
! 
! 	/// Dataset functionality
! 	function pick_question_dataset($question, $datasetitem) {
! 		// Select a dataset in the following format:
! 		// An array indexed by the variable names (d.name) pointing to the value
! 		// to be substituted
! 		global $CFG, $DB;
! 		if (!$dataitems = $DB->get_records_sql(
              "SELECT i.id, d.name, i.value
                 FROM {question_dataset_definitions} d, {question_dataset_items} i, {question_datasets} q
                WHERE q.question = ? AND q.datasetdefinition = d.id AND d.id = i.definition AND i.itemnumber = ?
             ORDER by i.id DESC ", array($question->id, $datasetitem))) {
! 		$a = new stdClass;
! 		$a->id = $question->id;
! 		$a->item = $datasetitem ;
! 		print_error('cannotgetdsfordependent', 'question', '', $a );
!            }
!            $dataset = Array();
!            foreach($dataitems as $id => $dataitem  ){
              if (!isset($dataset[$dataitem->name])){
!             	$dataset[$dataitem->name] = $dataitem->value ;
              }else {
!             	// deleting the unused records could be added here
              }
!            }
!            return $dataset;
! 	}
! 
! 	function dataset_options_from_database($form, $name,$prefix='',$langfile='quiz') {
! 		global $CFG, $DB;
! 		$type = 1 ; // only type = 1 (i.e. old 'LITERAL') has ever been used
! 
! 		// First options - it is not a dataset...
! 		$options['0'] = get_string($prefix.'nodataset', $langfile);
! 		// new question no local
! 		if (!isset($form->id) || $form->id == 0 ){
! 			$key = "$type-0-$name";
! 			$options[$key] = get_string($prefix."newlocal$type", $langfile);
! 			$currentdatasetdef = new stdClass;
! 			$currentdatasetdef->type = '0';
! 		}else {
  
! 			// Construct question local options
! 			$sql = "SELECT a.*
                  FROM {question_dataset_definitions} a, {question_datasets} b
                 WHERE a.id = b.datasetdefinition AND a.type = '1' AND b.question = ? AND a.name = ?";
! 			$currentdatasetdef = $DB->get_record_sql($sql, array($form->id, $name));
! 			if (!$currentdatasetdef) {
! 				$currentdatasetdef->type = '0';
! 			}
! 			$key = "$type-0-$name";
! 			if ($currentdatasetdef->type == $type
! 			and $currentdatasetdef->category == 0) {
! 				$options[$key] = get_string($prefix."keptlocal$type", $langfile);
! 			} else {
! 				$options[$key] = get_string($prefix."newlocal$type", $langfile);
! 			}
! 		}
! 		// Construct question category options
! 		$categorydatasetdefs = $DB->get_records_sql(
              "SELECT b.question, a.*
              FROM {question_datasets} b,
              {question_dataset_definitions} a
***************
*** 1822,2164 ****
              AND a.type = '1'
              AND a.category = ?
              AND a.name = ?", array($form->category, $name));
!         $type = 1 ;
!         $key = "$type-$form->category-$name";
!         if (!empty($categorydatasetdefs)){ // there is at least one with the same name
!             if (isset($form->id) && isset($categorydatasetdefs[$form->id])) {// it is already used by this question
!                 $options[$key] = get_string($prefix."keptcategory$type", $langfile);
!             } else {
!                 $options[$key] = get_string($prefix."existingcategory$type", $langfile);
!             }
!         } else {
!             $options[$key] = get_string($prefix."newcategory$type", $langfile);
!         }
!         // All done!
!         return array($options, $currentdatasetdef->type
!             ? "$currentdatasetdef->type-$currentdatasetdef->category-$name"
!             : '');
!     }
! 
!     function find_dataset_names($text) {
!         /// Returns the possible dataset names found in the text as an array
!         /// The array has the dataset name for both key and value
!         $datasetnames = array();
!         while (preg_match('~\\{([[:alpha:]][^>} <{"\']*)\\}~', $text, $regs)) {
!             $datasetnames[$regs[1]] = $regs[1];
!             $text = str_replace($regs[0], '', $text);
!         }
!         return $datasetnames;
!     }
! 
!     /**
!      * This function retrieve the item count of the available category shareable
!      * wild cards that is added as a comment displayed when a wild card with
!      * the same name is displayed in datasetdefinitions_form.php
!      */
!     function get_dataset_definitions_category($form) {
!         global $CFG, $DB;
!         $datasetdefs = array();
!         $lnamemax = 30;
!         if (!empty($form->category)) {
!             $sql = "SELECT i.*,d.*
                        FROM {question_datasets} d, {question_dataset_definitions} i
                       WHERE i.id = d.datasetdefinition AND i.category = ?";
!             if ($records = $DB->get_records_sql($sql, array($form->category))) {
!                 foreach ($records as $r) {
!                     if ( !isset ($datasetdefs["$r->name"])) $datasetdefs["$r->name"] = $r->itemcount;
!                 }
!             }
!         }
!         return  $datasetdefs ;
!     }
! 
!     /**
!      * This function build a table showing the available category shareable
!      * wild cards, their name, their definition (Min, Max, Decimal) , the item count
!      * and the name of the question where they are used.
!      * This table is intended to be add before the question text to help the user use
!      * these wild cards
!      */
!     function print_dataset_definitions_category($form) {
!         global $CFG, $DB;
!         $datasetdefs = array();
!         $lnamemax = 22;
!         $namestr =get_string('name', 'quiz');
!         $minstr=get_string('min', 'quiz');
!         $maxstr=get_string('max', 'quiz');
!         $rangeofvaluestr=get_string('minmax','qtype_calculated');
!         $questionusingstr = get_string('usedinquestion','qtype_calculated');
!         $itemscountstr = get_string('itemscount','qtype_calculated');
!         $text ='';
!         if (!empty($form->category)) {
!             list($category) = explode(',', $form->category);
!             $sql = "SELECT i.*,d.*
                  FROM {question_datasets} d,
          {question_dataset_definitions} i
          WHERE i.id = d.datasetdefinition
          AND i.category = ?";
!             if ($records = $DB->get_records_sql($sql, array($category))) {
!                 foreach ($records as $r) {
!                     $sql1 = "SELECT q.*
                                 FROM {question} q
                                WHERE q.id = ?";
!                     if ( !isset ($datasetdefs["$r->type-$r->category-$r->name"])){
!                         $datasetdefs["$r->type-$r->category-$r->name"]= $r;
!                     }
!                     if ($questionb = $DB->get_records_sql($sql1, array($r->question))) {
!                         $datasetdefs["$r->type-$r->category-$r->name"]->questions[$r->question]->name =$questionb[$r->question]->name ;
!                     }
!                 }
!             }
!         }
!         if (!empty ($datasetdefs)){
! 
!             $text ="<table width=\"100%\" border=\"1\"><tr><th  style=\"white-space:nowrap;\" class=\"header\" scope=\"col\" >$namestr</th><th   style=\"white-space:nowrap;\" class=\"header\" scope=\"col\">$rangeofvaluestr</th><th  style=\"white-space:nowrap;\" class=\"header\" scope=\"col\">$itemscountstr</th><th style=\"white-space:nowrap;\" class=\"header\" scope=\"col\">$questionusingstr</th></tr>";
!             foreach ($datasetdefs as $datasetdef){
!                 list($distribution, $min, $max,$dec) = explode(':', $datasetdef->options, 4);
!                 $text .="<tr><td valign=\"top\" align=\"center\"> $datasetdef->name </td><td align=\"center\" valign=\"top\"> $min <strong>-</strong> $max </td><td align=\"right\" valign=\"top\">$datasetdef->itemcount&nbsp;&nbsp;</td><td align=\"left\">";
!                 foreach ($datasetdef->questions as $qu) {
!                     //limit the name length displayed
!                     if (!empty($qu->name)) {
!                         $qu->name = (strlen($qu->name) > $lnamemax) ?
!                             substr($qu->name, 0, $lnamemax).'...' : $qu->name;
!                     } else {
!                         $qu->name = '';
!                     }
!                     $text .=" &nbsp;&nbsp; $qu->name <br/>";
!                 }
!                 $text .="</td></tr>";
!             }
!             $text .="</table>";
!         }else{
!             $text .=get_string('nosharedwildcard', 'qtype_calculated');
!         }
!         return  $text ;
!     }
! 
!     /**
!      * This function build a table showing the available category shareable
!      * wild cards, their name, their definition (Min, Max, Decimal) , the item count
!      * and the name of the question where they are used.
!      * This table is intended to be add before the question text to help the user use
!      * these wild cards
!      */
! 
!     function print_dataset_definitions_category_shared($question,$datasetdefsq) {
!         global $CFG, $DB;
!         $datasetdefs = array();
!         $lnamemax = 22;
!         $namestr =get_string('name', 'quiz');
!         $minstr=get_string('min', 'quiz');
!         $maxstr=get_string('max', 'quiz');
!         $rangeofvaluestr=get_string('minmax','qtype_calculated');
!         $questionusingstr = get_string('usedinquestion','qtype_calculated');
!         $itemscountstr = get_string('itemscount','qtype_calculated');
!         $text ='';
!         if (!empty($question->category)) {
!             list($category) = explode(',', $question->category);
!             $sql = "SELECT i.*,d.*
                        FROM {question_datasets} d, {question_dataset_definitions} i
                       WHERE i.id = d.datasetdefinition AND i.category = ?";
!             if ($records = $DB->get_records_sql($sql, array($category))) {
!                 foreach ($records as $r) {
!                     $sql1 = "SELECT q.*
                                 FROM {question} q
                                WHERE q.id = ?";
!                     if ( !isset ($datasetdefs["$r->type-$r->category-$r->name"])){
!                         $datasetdefs["$r->type-$r->category-$r->name"]= $r;
!                     }
!                     if ($questionb = $DB->get_records_sql($sql1, array($r->question))) {
!                         $datasetdefs["$r->type-$r->category-$r->name"]->questions[$r->question]->name =$questionb[$r->question]->name ;
!                         $datasetdefs["$r->type-$r->category-$r->name"]->questions[$r->question]->id =$questionb[$r->question]->id ;
!                     }
!                 }
!             }
!         }
!         if (!empty ($datasetdefs)){
! 
!             $text ="<table width=\"100%\" border=\"1\"><tr><th  style=\"white-space:nowrap;\" class=\"header\" scope=\"col\" >$namestr</th>";
!             $text .="<th  style=\"white-space:nowrap;\" class=\"header\" scope=\"col\">$itemscountstr</th>";
!             $text .="<th style=\"white-space:nowrap;\" class=\"header\" scope=\"col\">&nbsp;&nbsp;$questionusingstr &nbsp;&nbsp; </th>";
!             $text .="<th style=\"white-space:nowrap;\" class=\"header\" scope=\"col\">Quiz</th>";
!             $text .="<th style=\"white-space:nowrap;\" class=\"header\" scope=\"col\">Attempts</th></tr>";
!             foreach ($datasetdefs as $datasetdef){
!                 list($distribution, $min, $max,$dec) = explode(':', $datasetdef->options, 4);
!                 $count = count($datasetdef->questions);
!                 $text .="<tr><td style=\"white-space:nowrap;\" valign=\"top\" align=\"center\" rowspan=\"$count\"> $datasetdef->name </td><td align=\"right\" valign=\"top\" rowspan=\"$count\" >$datasetdef->itemcount&nbsp;&nbsp;</td>";
!                 //$text .="<td align=\"left\">";
!                 $line = 0 ;
!                 foreach ($datasetdef->questions as $qu) {
!                     //limit the name length displayed
!                     if (!empty($qu->name)) {
!                         $qu->name = (strlen($qu->name) > $lnamemax) ?
!                             substr($qu->name, 0, $lnamemax).'...' : $qu->name;
!                     } else {
!                         $qu->name = '';
!                     }
!                     if( $line ) {
!                         $text .="<tr>";
!                     }
!                     $line++;
!                     $text .="<td align=\"left\" style=\"white-space:nowrap;\" >$qu->name</td>";
!                     $nb_of_quiz = 0;
!                     $nb_of_attempts=0;
!                     $used_in_quiz = false ;
!                     if ($list = $DB->get_records('quiz_question_instances', array( 'question'=> $qu->id))){
!                         $used_in_quiz = true;
!                         foreach($list as $key => $li){
!                             $nb_of_quiz ++;
!                             if($att = $DB->get_records('quiz_attempts',array( 'quiz'=> $li->quiz, 'preview'=> '0'))){
!                                 $nb_of_attempts+= count($att);
!                             }
!                         }
!                     }
!                     if($used_in_quiz){
!                         $text .="<td align=\"center\">$nb_of_quiz</td>";
!                     }else {
!                         $text .="<td align=\"center\">0</td>";
!                     }
!                     if($used_in_quiz){
!                         $text .="<td align=\"center\">$nb_of_attempts";
!                     }else {
!                         $text .="<td align=\"left\"><br/>";
!                     }
! 
!                     $text .="</td></tr>";
!                 }
!             }
!             $text .="</table>";
!         }else{
!             $text .=get_string('nosharedwildcard', 'qtype_calculated');
!         }
!         return  $text ;
!     }
! 
!     function find_math_equations($text) {
!         /// Returns the possible dataset names found in the text as an array
!         /// The array has the dataset name for both key and value
!         $equations = array();
!  /*               $qtext = "";
!         $qtextremaining = $numericalquestion->questiontext ;
!         while  (preg_match('~\{=([^[:space:]}]*)}~', $qtextremaining, $regs1)) {
!       //  while  (preg_match('~\{=|%=([^[:space:]}]*)}~', $qtextremaining, $regs1)) {
!             $qtextsplits = explode($regs1[0], $qtextremaining, 2);
!             $qtext =$qtext.$qtextsplits[0];
!             $qtextremaining = $qtextsplits[1];
!             if (empty($regs1[1])) {
!                     $str = '';
!                 } else {
!   */
!         while (preg_match('~\{=([^[:space:]}]*)}~', $text, $regs)) {
!             $equations[] = $regs[1];
!             $text = str_replace($regs[0], '', $text);
!         }
!         return $equations;
!     }
! 
!     function get_virtual_qtype() {
!         global $QTYPES;
!         $this->virtualqtype =& $QTYPES['numerical'];
!         return $this->virtualqtype;
!     }
! 
!     /**
!      * Runs all the code required to set up and save an essay question for testing purposes.
!      * Alternate DB table prefix may be used to facilitate data deletion.
!      */
!     function generate_test($name, $courseid = null) {
!         global $DB;
!         list($form, $question) = parent::generate_test($name, $courseid);
!         $form->feedback = 1;
!         $form->multiplier = array(1, 1);
!         $form->shuffleanswers = 1;
!         $form->noanswers = 1;
!         $form->qtype ='calculated';
!         $question->qtype ='calculated';
!         $form->answers = array('{a} + {b}');
!         $form->fraction = array(1);
!         $form->tolerance = array(0.01);
!         $form->tolerancetype = array(1);
!         $form->correctanswerlength = array(2);
!         $form->correctanswerformat = array(1);
!         $form->questiontext = "What is {a} + {b}?";
! 
!         if ($courseid) {
!             $course = $DB->get_record('course', array('id'=> $courseid));
!         }
! 
!         $new_question = $this->save_question($question, $form);
! 
!         $dataset_form = new stdClass();
!         $dataset_form->nextpageparam["forceregeneration"]= 1;
!         $dataset_form->calcmin = array(1 => 1.0, 2 => 1.0);
!         $dataset_form->calcmax = array(1 => 10.0, 2 => 10.0);
!         $dataset_form->calclength = array(1 => 1, 2 => 1);
!         $dataset_form->number = array(1 => 5.4 , 2 => 4.9);
!         $dataset_form->itemid = array(1 => '' , 2 => '');
!         $dataset_form->calcdistribution = array(1 => 'uniform', 2 => 'uniform');
!         $dataset_form->definition = array(1 => "1-0-a",
!             2 => "1-0-b");
!         $dataset_form->nextpageparam = array('forceregeneration' => false);
!         $dataset_form->addbutton = 1;
!         $dataset_form->selectadd = 1;
!         $dataset_form->courseid = $courseid;
!         $dataset_form->cmid = 0;
!         $dataset_form->id = $new_question->id;
!         $this->save_dataset_items($new_question, $dataset_form);
! 
!         return $new_question;
!     }
! 
!     function move_files($questionid, $oldcontextid, $newcontextid) {
!         $fs = get_file_storage();
! 
!         parent::move_files($questionid, $oldcontextid, $newcontextid);
!         $this->move_files_in_answers($questionid, $oldcontextid, $newcontextid);
! 
!         $fs->move_area_files_to_new_context($oldcontextid,
!                 $newcontextid, 'qtype_calculated', 'instruction', $questionid);
!     }
! 
!     protected function delete_files($questionid, $contextid) {
!         $fs = get_file_storage();
! 
!         parent::delete_files($questionid, $contextid);
!         $this->delete_files_in_answers($questionid, $contextid);
!         $fs->delete_area_files($contextid, 'qtype_calculated', 'instruction', $questionid);
!     }
! 
!     function check_file_access($question, $state, $options, $contextid, $component,
!             $filearea, $args) {
!         $itemid = reset($args);
!         if ($component == 'question' && $filearea == 'answerfeedback') {
! 
!             // check if answer id exists
!             $result = $options->feedback && array_key_exists($itemid, $question->options->answers);
!             if (!$result) {
!                 return false;
!             }
!             // check response
!             if (!$this->check_response($question, $state)) {
!                 return false;
!             }
!             return true;
!         } else if ($filearea == 'instruction') {
!             // TODO: should it be display all the time like questiontext?
!             // check if question id exists
!             if ($itemid != $question->id) {
!                 return false;
!             } else {
!                 return true;
!             }
!         } else if (in_array($filearea, array('correctfeedback', 'partiallycorrectfeedback', 'incorrectfeedback'))) {
!             // TODO: calculated type doesn't display question feedback yet
!             return false;
!         } else {
!             return parent::check_file_access($question, $state, $options, $contextid, $component,
!                     $filearea, $args);
!         }
!     }
  }
  //// END OF CLASS ////
  
--- 1822,2164 ----
              AND a.type = '1'
              AND a.category = ?
              AND a.name = ?", array($form->category, $name));
! 		$type = 1 ;
! 		$key = "$type-$form->category-$name";
! 		if (!empty($categorydatasetdefs)){ // there is at least one with the same name
! 			if (isset($form->id) && isset($categorydatasetdefs[$form->id])) {// it is already used by this question
! 				$options[$key] = get_string($prefix."keptcategory$type", $langfile);
! 			} else {
! 				$options[$key] = get_string($prefix."existingcategory$type", $langfile);
! 			}
! 		} else {
! 			$options[$key] = get_string($prefix."newcategory$type", $langfile);
! 		}
! 		// All done!
! 		return array($options, $currentdatasetdef->type
! 		? "$currentdatasetdef->type-$currentdatasetdef->category-$name"
! 		: '');
! 	}
! 
! 	function find_dataset_names($text) {
! 		/// Returns the possible dataset names found in the text as an array
! 		/// The array has the dataset name for both key and value
! 		$datasetnames = array();
! 		while (preg_match('~\\{([[:alpha:]][^>} <{"\']*)\\}~', $text, $regs)) {
! 			$datasetnames[$regs[1]] = $regs[1];
! 			$text = str_replace($regs[0], '', $text);
! 		}
! 		return $datasetnames;
! 	}
! 
! 	/**
! 	 * This function retrieve the item count of the available category shareable
! 	 * wild cards that is added as a comment displayed when a wild card with
! 	 * the same name is displayed in datasetdefinitions_form.php
! 	 */
! 	function get_dataset_definitions_category($form) {
! 		global $CFG, $DB;
! 		$datasetdefs = array();
! 		$lnamemax = 30;
! 		if (!empty($form->category)) {
! 			$sql = "SELECT i.*,d.*
                        FROM {question_datasets} d, {question_dataset_definitions} i
                       WHERE i.id = d.datasetdefinition AND i.category = ?";
! 			if ($records = $DB->get_records_sql($sql, array($form->category))) {
! 				foreach ($records as $r) {
! 					if ( !isset ($datasetdefs["$r->name"])) $datasetdefs["$r->name"] = $r->itemcount;
! 				}
! 			}
! 		}
! 		return  $datasetdefs ;
! 	}
! 
! 	/**
! 	 * This function build a table showing the available category shareable
! 	 * wild cards, their name, their definition (Min, Max, Decimal) , the item count
! 	 * and the name of the question where they are used.
! 	 * This table is intended to be add before the question text to help the user use
! 	 * these wild cards
! 	 */
! 	function print_dataset_definitions_category($form) {
! 		global $CFG, $DB;
! 		$datasetdefs = array();
! 		$lnamemax = 22;
! 		$namestr =get_string('name', 'quiz');
! 		$minstr=get_string('min', 'quiz');
! 		$maxstr=get_string('max', 'quiz');
! 		$rangeofvaluestr=get_string('minmax','qtype_calculated');
! 		$questionusingstr = get_string('usedinquestion','qtype_calculated');
! 		$itemscountstr = get_string('itemscount','qtype_calculated');
! 		$text ='';
! 		if (!empty($form->category)) {
! 			list($category) = explode(',', $form->category);
! 			$sql = "SELECT i.*,d.*
                  FROM {question_datasets} d,
          {question_dataset_definitions} i
          WHERE i.id = d.datasetdefinition
          AND i.category = ?";
! 			if ($records = $DB->get_records_sql($sql, array($category))) {
! 				foreach ($records as $r) {
! 					$sql1 = "SELECT q.*
                                 FROM {question} q
                                WHERE q.id = ?";
! 					if ( !isset ($datasetdefs["$r->type-$r->category-$r->name"])){
! 						$datasetdefs["$r->type-$r->category-$r->name"]= $r;
! 					}
! 					if ($questionb = $DB->get_records_sql($sql1, array($r->question))) {
! 						$datasetdefs["$r->type-$r->category-$r->name"]->questions[$r->question]->name =$questionb[$r->question]->name ;
! 					}
! 				}
! 			}
! 		}
! 		if (!empty ($datasetdefs)){
! 
! 			$text ="<table width=\"100%\" border=\"1\"><tr><th  style=\"white-space:nowrap;\" class=\"header\" scope=\"col\" >$namestr</th><th   style=\"white-space:nowrap;\" class=\"header\" scope=\"col\">$rangeofvaluestr</th><th  style=\"white-space:nowrap;\" class=\"header\" scope=\"col\">$itemscountstr</th><th style=\"white-space:nowrap;\" class=\"header\" scope=\"col\">$questionusingstr</th></tr>";
! 			foreach ($datasetdefs as $datasetdef){
! 				list($distribution, $min, $max,$dec) = explode(':', $datasetdef->options, 4);
! 				$text .="<tr><td valign=\"top\" align=\"center\"> $datasetdef->name </td><td align=\"center\" valign=\"top\"> $min <strong>-</strong> $max </td><td align=\"right\" valign=\"top\">$datasetdef->itemcount&nbsp;&nbsp;</td><td align=\"left\">";
! 				foreach ($datasetdef->questions as $qu) {
! 					//limit the name length displayed
! 					if (!empty($qu->name)) {
! 						$qu->name = (strlen($qu->name) > $lnamemax) ?
! 						substr($qu->name, 0, $lnamemax).'...' : $qu->name;
! 					} else {
! 						$qu->name = '';
! 					}
! 					$text .=" &nbsp;&nbsp; $qu->name <br/>";
! 				}
! 				$text .="</td></tr>";
! 			}
! 			$text .="</table>";
! 		}else{
! 			$text .=get_string('nosharedwildcard', 'qtype_calculated');
! 		}
! 		return  $text ;
! 	}
! 
! 	/**
! 	 * This function build a table showing the available category shareable
! 	 * wild cards, their name, their definition (Min, Max, Decimal) , the item count
! 	 * and the name of the question where they are used.
! 	 * This table is intended to be add before the question text to help the user use
! 	 * these wild cards
! 	 */
! 
! 	function print_dataset_definitions_category_shared($question,$datasetdefsq) {
! 		global $CFG, $DB;
! 		$datasetdefs = array();
! 		$lnamemax = 22;
! 		$namestr =get_string('name', 'quiz');
! 		$minstr=get_string('min', 'quiz');
! 		$maxstr=get_string('max', 'quiz');
! 		$rangeofvaluestr=get_string('minmax','qtype_calculated');
! 		$questionusingstr = get_string('usedinquestion','qtype_calculated');
! 		$itemscountstr = get_string('itemscount','qtype_calculated');
! 		$text ='';
! 		if (!empty($question->category)) {
! 			list($category) = explode(',', $question->category);
! 			$sql = "SELECT i.*,d.*
                        FROM {question_datasets} d, {question_dataset_definitions} i
                       WHERE i.id = d.datasetdefinition AND i.category = ?";
! 			if ($records = $DB->get_records_sql($sql, array($category))) {
! 				foreach ($records as $r) {
! 					$sql1 = "SELECT q.*
                                 FROM {question} q
                                WHERE q.id = ?";
! 					if ( !isset ($datasetdefs["$r->type-$r->category-$r->name"])){
! 						$datasetdefs["$r->type-$r->category-$r->name"]= $r;
! 					}
! 					if ($questionb = $DB->get_records_sql($sql1, array($r->question))) {
! 						$datasetdefs["$r->type-$r->category-$r->name"]->questions[$r->question]->name =$questionb[$r->question]->name ;
! 						$datasetdefs["$r->type-$r->category-$r->name"]->questions[$r->question]->id =$questionb[$r->question]->id ;
! 					}
! 				}
! 			}
! 		}
! 		if (!empty ($datasetdefs)){
! 
! 			$text ="<table width=\"100%\" border=\"1\"><tr><th  style=\"white-space:nowrap;\" class=\"header\" scope=\"col\" >$namestr</th>";
! 			$text .="<th  style=\"white-space:nowrap;\" class=\"header\" scope=\"col\">$itemscountstr</th>";
! 			$text .="<th style=\"white-space:nowrap;\" class=\"header\" scope=\"col\">&nbsp;&nbsp;$questionusingstr &nbsp;&nbsp; </th>";
! 			$text .="<th style=\"white-space:nowrap;\" class=\"header\" scope=\"col\">Quiz</th>";
! 			$text .="<th style=\"white-space:nowrap;\" class=\"header\" scope=\"col\">Attempts</th></tr>";
! 			foreach ($datasetdefs as $datasetdef){
! 				list($distribution, $min, $max,$dec) = explode(':', $datasetdef->options, 4);
! 				$count = count($datasetdef->questions);
! 				$text .="<tr><td style=\"white-space:nowrap;\" valign=\"top\" align=\"center\" rowspan=\"$count\"> $datasetdef->name </td><td align=\"right\" valign=\"top\" rowspan=\"$count\" >$datasetdef->itemcount&nbsp;&nbsp;</td>";
! 				//$text .="<td align=\"left\">";
! 				$line = 0 ;
! 				foreach ($datasetdef->questions as $qu) {
! 					//limit the name length displayed
! 					if (!empty($qu->name)) {
! 						$qu->name = (strlen($qu->name) > $lnamemax) ?
! 						substr($qu->name, 0, $lnamemax).'...' : $qu->name;
! 					} else {
! 						$qu->name = '';
! 					}
! 					if( $line ) {
! 						$text .="<tr>";
! 					}
! 					$line++;
! 					$text .="<td align=\"left\" style=\"white-space:nowrap;\" >$qu->name</td>";
! 					$nb_of_quiz = 0;
! 					$nb_of_attempts=0;
! 					$used_in_quiz = false ;
! 					if ($list = $DB->get_records('quiz_question_instances', array( 'question'=> $qu->id))){
! 						$used_in_quiz = true;
! 						foreach($list as $key => $li){
! 							$nb_of_quiz ++;
! 							if($att = $DB->get_records('quiz_attempts',array( 'quiz'=> $li->quiz, 'preview'=> '0'))){
! 								$nb_of_attempts+= count($att);
! 							}
! 						}
! 					}
! 					if($used_in_quiz){
! 						$text .="<td align=\"center\">$nb_of_quiz</td>";
! 					}else {
! 						$text .="<td align=\"center\">0</td>";
! 					}
! 					if($used_in_quiz){
! 						$text .="<td align=\"center\">$nb_of_attempts";
! 					}else {
! 						$text .="<td align=\"left\"><br/>";
! 					}
! 
! 					$text .="</td></tr>";
! 				}
! 			}
! 			$text .="</table>";
! 		}else{
! 			$text .=get_string('nosharedwildcard', 'qtype_calculated');
! 		}
! 		return  $text ;
! 	}
! 
! 	function find_math_equations($text) {
! 		/// Returns the possible dataset names found in the text as an array
! 		/// The array has the dataset name for both key and value
! 		$equations = array();
! 		/*               $qtext = "";
! 		 $qtextremaining = $numericalquestion->questiontext ;
! 		 while  (preg_match('~\{=([^[:space:]}]*)}~', $qtextremaining, $regs1)) {
! 		 //  while  (preg_match('~\{=|%=([^[:space:]}]*)}~', $qtextremaining, $regs1)) {
! 		 $qtextsplits = explode($regs1[0], $qtextremaining, 2);
! 		 $qtext =$qtext.$qtextsplits[0];
! 		 $qtextremaining = $qtextsplits[1];
! 		 if (empty($regs1[1])) {
! 		 $str = '';
! 		 } else {
! 		 */
! 		while (preg_match('~\{=([^[:space:]}]*)}~', $text, $regs)) {
! 			$equations[] = $regs[1];
! 			$text = str_replace($regs[0], '', $text);
! 		}
! 		return $equations;
! 	}
! 
! 	function get_virtual_qtype() {
! 		global $QTYPES;
! 		$this->virtualqtype =& $QTYPES['numerical'];
! 		return $this->virtualqtype;
! 	}
! 
! 	/**
! 	 * Runs all the code required to set up and save an essay question for testing purposes.
! 	 * Alternate DB table prefix may be used to facilitate data deletion.
! 	 */
! 	function generate_test($name, $courseid = null) {
! 		global $DB;
! 		list($form, $question) = parent::generate_test($name, $courseid);
! 		$form->feedback = 1;
! 		$form->multiplier = array(1, 1);
! 		$form->shuffleanswers = 1;
! 		$form->noanswers = 1;
! 		$form->qtype ='calculated';
! 		$question->qtype ='calculated';
! 		$form->answers = array('{a} + {b}');
! 		$form->fraction = array(1);
! 		$form->tolerance = array(0.01);
! 		$form->tolerancetype = array(1);
! 		$form->correctanswerlength = array(2);
! 		$form->correctanswerformat = array(1);
! 		$form->questiontext = "What is {a} + {b}?";
! 
! 		if ($courseid) {
! 			$course = $DB->get_record('course', array('id'=> $courseid));
! 		}
! 
! 		$new_question = $this->save_question($question, $form);
! 
! 		$dataset_form = new stdClass();
! 		$dataset_form->nextpageparam["forceregeneration"]= 1;
! 		$dataset_form->calcmin = array(1 => 1.0, 2 => 1.0);
! 		$dataset_form->calcmax = array(1 => 10.0, 2 => 10.0);
! 		$dataset_form->calclength = array(1 => 1, 2 => 1);
! 		$dataset_form->number = array(1 => 5.4 , 2 => 4.9);
! 		$dataset_form->itemid = array(1 => '' , 2 => '');
! 		$dataset_form->calcdistribution = array(1 => 'uniform', 2 => 'uniform');
! 		$dataset_form->definition = array(1 => "1-0-a",
! 		2 => "1-0-b");
! 		$dataset_form->nextpageparam = array('forceregeneration' => false);
! 		$dataset_form->addbutton = 1;
! 		$dataset_form->selectadd = 1;
! 		$dataset_form->courseid = $courseid;
! 		$dataset_form->cmid = 0;
! 		$dataset_form->id = $new_question->id;
! 		$this->save_dataset_items($new_question, $dataset_form);
! 
! 		return $new_question;
! 	}
! 
! 	function move_files($questionid, $oldcontextid, $newcontextid) {
! 		$fs = get_file_storage();
! 
! 		parent::move_files($questionid, $oldcontextid, $newcontextid);
! 		$this->move_files_in_answers($questionid, $oldcontextid, $newcontextid);
! 
! 		$fs->move_area_files_to_new_context($oldcontextid,
! 		$newcontextid, 'qtype_calculated', 'instruction', $questionid);
! 	}
! 
! 	protected function delete_files($questionid, $contextid) {
! 		$fs = get_file_storage();
! 
! 		parent::delete_files($questionid, $contextid);
! 		$this->delete_files_in_answers($questionid, $contextid);
! 		$fs->delete_area_files($contextid, 'qtype_calculated', 'instruction', $questionid);
! 	}
! 
! 	function check_file_access($question, $state, $options, $contextid, $component,
! 	$filearea, $args) {
! 		$itemid = reset($args);
! 		if ($component == 'question' && $filearea == 'answerfeedback') {
! 
! 			// check if answer id exists
! 			$result = $options->feedback && array_key_exists($itemid, $question->options->answers);
! 			if (!$result) {
! 				return false;
! 			}
! 			// check response
! 			if (!$this->check_response($question, $state)) {
! 				return false;
! 			}
! 			return true;
! 		} else if ($filearea == 'instruction') {
! 			// TODO: should it be display all the time like questiontext?
! 			// check if question id exists
! 			if ($itemid != $question->id) {
! 				return false;
! 			} else {
! 				return true;
! 			}
! 		} else if (in_array($filearea, array('correctfeedback', 'partiallycorrectfeedback', 'incorrectfeedback'))) {
! 			// TODO: calculated type doesn't display question feedback yet
! 			return false;
! 		} else {
! 			return parent::check_file_access($question, $state, $options, $contextid, $component,
! 			$filearea, $args);
! 		}
! 	}
  }
  //// END OF CLASS ////
  
***************
*** 2168,2359 ****
  question_register_questiontype(new question_calculated_qtype());
  
  if ( ! defined ("CALCULATEDQUESTIONMAXITEMNUMBER")) {
!     define("CALCULATEDQUESTIONMAXITEMNUMBER", 100);
  }
  
  function qtype_calculated_calculate_answer($formula, $individualdata,
!     $tolerance, $tolerancetype, $answerlength, $answerformat='1', $unit='') {
!     /// The return value has these properties:
!     /// ->answer    the correct answer
!     /// ->min       the lower bound for an acceptable response
!     /// ->max       the upper bound for an accetpable response
! 
!     /// Exchange formula variables with the correct values...
!     global $QTYPES;
!     $answer = $QTYPES['calculated']->substitute_variables_and_eval($formula, $individualdata);
!     if ('1' == $answerformat) { /* Answer is to have $answerlength decimals */
!         /*** Adjust to the correct number of decimals ***/
!         if (stripos($answer,'e')>0 ){
!             $answerlengthadd = strlen($answer)-stripos($answer,'e');
!         }else {
!             $answerlengthadd = 0 ;
!         }
!         $calculated->answer = round(floatval($answer), $answerlength+$answerlengthadd);
! 
!         if ($answerlength) {
!             /* Try to include missing zeros at the end */
! 
!             if (preg_match('~^(.*\\.)(.*)$~', $calculated->answer, $regs)) {
!                 $calculated->answer = $regs[1] . substr(
!                     $regs[2] . '00000000000000000000000000000000000000000x',
!                     0, $answerlength)
!                     . $unit;
!             } else {
!                 $calculated->answer .=
!                     substr('.00000000000000000000000000000000000000000x',
!                         0, $answerlength + 1) . $unit;
!             }
!         } else {
!             /* Attach unit */
!             $calculated->answer .= $unit;
!         }
! 
!     } else if ($answer) { // Significant figures does only apply if the result is non-zero
! 
!         // Convert to positive answer...
!         if ($answer < 0) {
!             $answer = -$answer;
!             $sign = '-';
!         } else {
!             $sign = '';
!         }
! 
!         // Determine the format 0.[1-9][0-9]* for the answer...
!         $p10 = 0;
!         while ($answer < 1) {
!             --$p10;
!             $answer *= 10;
!         }
!         while ($answer >= 1) {
!             ++$p10;
!             $answer /= 10;
!         }
!         // ... and have the answer rounded of to the correct length
!         $answer = round($answer, $answerlength);
! 
!         // Have the answer written on a suitable format,
!         // Either scientific or plain numeric
!         if (-2 > $p10 || 4 < $p10) {
!             // Use scientific format:
!             $eX = 'e'.--$p10;
!             $answer *= 10;
!             if (1 == $answerlength) {
!                 $calculated->answer = $sign.$answer.$eX.$unit;
!             } else {
!                 // Attach additional zeros at the end of $answer,
!                 $answer .= (1==strlen($answer) ? '.' : '')
!                     . '00000000000000000000000000000000000000000x';
!                 $calculated->answer = $sign
!                     .substr($answer, 0, $answerlength +1).$eX.$unit;
!             }
!         } else {
!             // Stick to plain numeric format
!             $answer *= "1e$p10";
!             if (0.1 <= $answer / "1e$answerlength") {
!                 $calculated->answer = $sign.$answer.$unit;
!             } else {
!                 // Could be an idea to add some zeros here
!                 $answer .= (preg_match('~^[0-9]*$~', $answer) ? '.' : '')
!                     . '00000000000000000000000000000000000000000x';
!                 $oklen = $answerlength + ($p10 < 1 ? 2-$p10 : 1);
!                 $calculated->answer = $sign.substr($answer, 0, $oklen).$unit;
!             }
!         }
! 
!     } else {
!         $calculated->answer = 0.0;
!     }
  
!     /// Return the result
!     return $calculated;
  }
  
  
  function qtype_calculated_find_formula_errors($formula) {
!     /// Validates the formula submitted from the question edit page.
!     /// Returns false if everything is alright.
!     /// Otherwise it constructs an error message
!     // Strip away dataset names
!     while (preg_match('~\\{[[:alpha:]][^>} <{"\']*\\}~', $formula, $regs)) {
!         $formula = str_replace($regs[0], '1', $formula);
!     }
! 
!     // Strip away empty space and lowercase it
!     $formula = strtolower(str_replace(' ', '', $formula));
! 
!     $safeoperatorchar = '-+/*%>:^\~<?=&|!'; /* */
!     $operatorornumber = "[$safeoperatorchar.0-9eE]";
! 
!     while ( preg_match("~(^|[$safeoperatorchar,(])([a-z0-9_]*)\\(($operatorornumber+(,$operatorornumber+((,$operatorornumber+)+)?)?)?\\)~",
!         $formula, $regs)) {
!         switch ($regs[2]) {
!             // Simple parenthesis
!         case '':
!             if ((isset($regs[4])&& $regs[4]) || strlen($regs[3])==0) {
!                 return get_string('illegalformulasyntax', 'quiz', $regs[0]);
!             }
!             break;
! 
!             // Zero argument functions
!         case 'pi':
!             if ($regs[3]) {
!                 return get_string('functiontakesnoargs', 'quiz', $regs[2]);
!             }
!             break;
! 
!             // Single argument functions (the most common case)
!         case 'abs': case 'acos': case 'acosh': case 'asin': case 'asinh':
!         case 'atan': case 'atanh': case 'bindec': case 'ceil': case 'cos':
!         case 'cosh': case 'decbin': case 'decoct': case 'deg2rad':
!         case 'exp': case 'expm1': case 'floor': case 'is_finite':
!         case 'is_infinite': case 'is_nan': case 'log10': case 'log1p':
!         case 'octdec': case 'rad2deg': case 'sin': case 'sinh': case 'sqrt':
!         case 'tan': case 'tanh':
!             if (!empty($regs[4]) || empty($regs[3])) {
!                 return get_string('functiontakesonearg','quiz',$regs[2]);
!             }
!             break;
! 
!             // Functions that take one or two arguments
!         case 'log': case 'round':
!             if (!empty($regs[5]) || empty($regs[3])) {
!                 return get_string('functiontakesoneortwoargs','quiz',$regs[2]);
!             }
!             break;
! 
!             // Functions that must have two arguments
!         case 'atan2': case 'fmod': case 'pow':
!             if (!empty($regs[5]) || empty($regs[4])) {
!                 return get_string('functiontakestwoargs', 'quiz', $regs[2]);
!             }
!             break;
! 
!             // Functions that take two or more arguments
!         case 'min': case 'max':
!             if (empty($regs[4])) {
!                 return get_string('functiontakesatleasttwo','quiz',$regs[2]);
!             }
!             break;
! 
!         default:
!             return get_string('unsupportedformulafunction','quiz',$regs[2]);
!         }
! 
!         // Exchange the function call with '1' and then chack for
!         // another function call...
!         if ($regs[1]) {
!             // The function call is proceeded by an operator
!             $formula = str_replace($regs[0], $regs[1] . '1', $formula);
!         } else {
!             // The function call starts the formula
!             $formula = preg_replace("~^$regs[2]\\([^)]*\\)~", '1', $formula);
!         }
!     }
! 
!     if (preg_match("~[^$safeoperatorchar.0-9eE]+~", $formula, $regs)) {
!         return get_string('illegalformulasyntax', 'quiz', $regs[0]);
!     } else {
!         // Formula just might be valid
!         return false;
!     }
  }
--- 2168,2359 ----
  question_register_questiontype(new question_calculated_qtype());
  
  if ( ! defined ("CALCULATEDQUESTIONMAXITEMNUMBER")) {
! 	define("CALCULATEDQUESTIONMAXITEMNUMBER", 100);
  }
  
  function qtype_calculated_calculate_answer($formula, $individualdata,
! $tolerance, $tolerancetype, $answerlength, $answerformat='1', $unit='') {
! 	/// The return value has these properties:
! 	/// ->answer    the correct answer
! 	/// ->min       the lower bound for an acceptable response
! 	/// ->max       the upper bound for an accetpable response
! 
! 	/// Exchange formula variables with the correct values...
! 	global $QTYPES;
! 	$answer = $QTYPES['calculated']->substitute_variables_and_eval($formula, $individualdata);
! 	if ('1' == $answerformat) { /* Answer is to have $answerlength decimals */
! 		/*** Adjust to the correct number of decimals ***/
! 		if (stripos($answer,'e')>0 ){
! 			$answerlengthadd = strlen($answer)-stripos($answer,'e');
! 		}else {
! 			$answerlengthadd = 0 ;
! 		}
! 		$calculated->answer = round(floatval($answer), $answerlength+$answerlengthadd);
! 
! 		if ($answerlength) {
! 			/* Try to include missing zeros at the end */
! 
! 			if (preg_match('~^(.*\\.)(.*)$~', $calculated->answer, $regs)) {
! 				$calculated->answer = $regs[1] . substr(
! 				$regs[2] . '00000000000000000000000000000000000000000x',
! 				0, $answerlength)
! 				. $unit;
! 			} else {
! 				$calculated->answer .=
! 				substr('.00000000000000000000000000000000000000000x',
! 				0, $answerlength + 1) . $unit;
! 			}
! 		} else {
! 			/* Attach unit */
! 			$calculated->answer .= $unit;
! 		}
! 
! 	} else if ($answer) { // Significant figures does only apply if the result is non-zero
! 
! 		// Convert to positive answer...
! 		if ($answer < 0) {
! 			$answer = -$answer;
! 			$sign = '-';
! 		} else {
! 			$sign = '';
! 		}
! 
! 		// Determine the format 0.[1-9][0-9]* for the answer...
! 		$p10 = 0;
! 		while ($answer < 1) {
! 			--$p10;
! 			$answer *= 10;
! 		}
! 		while ($answer >= 1) {
! 			++$p10;
! 			$answer /= 10;
! 		}
! 		// ... and have the answer rounded of to the correct length
! 		$answer = round($answer, $answerlength);
! 
! 		// Have the answer written on a suitable format,
! 		// Either scientific or plain numeric
! 		if (-2 > $p10 || 4 < $p10) {
! 			// Use scientific format:
! 			$eX = 'e'.--$p10;
! 			$answer *= 10;
! 			if (1 == $answerlength) {
! 				$calculated->answer = $sign.$answer.$eX.$unit;
! 			} else {
! 				// Attach additional zeros at the end of $answer,
! 				$answer .= (1==strlen($answer) ? '.' : '')
! 				. '00000000000000000000000000000000000000000x';
! 				$calculated->answer = $sign
! 				.substr($answer, 0, $answerlength +1).$eX.$unit;
! 			}
! 		} else {
! 			// Stick to plain numeric format
! 			$answer *= "1e$p10";
! 			if (0.1 <= $answer / "1e$answerlength") {
! 				$calculated->answer = $sign.$answer.$unit;
! 			} else {
! 				// Could be an idea to add some zeros here
! 				$answer .= (preg_match('~^[0-9]*$~', $answer) ? '.' : '')
! 				. '00000000000000000000000000000000000000000x';
! 				$oklen = $answerlength + ($p10 < 1 ? 2-$p10 : 1);
! 				$calculated->answer = $sign.substr($answer, 0, $oklen).$unit;
! 			}
! 		}
! 
! 	} else {
! 		$calculated->answer = 0.0;
! 	}
  
! 	/// Return the result
! 	return $calculated;
  }
  
  
  function qtype_calculated_find_formula_errors($formula) {
! 	/// Validates the formula submitted from the question edit page.
! 	/// Returns false if everything is alright.
! 	/// Otherwise it constructs an error message
! 	// Strip away dataset names
! 	while (preg_match('~\\{[[:alpha:]][^>} <{"\']*\\}~', $formula, $regs)) {
! 		$formula = str_replace($regs[0], '1', $formula);
! 	}
! 
! 	// Strip away empty space and lowercase it
! 	$formula = strtolower(str_replace(' ', '', $formula));
! 
! 	$safeoperatorchar = '-+/*%>:^\~<?=&|!'; /* */
! 	$operatorornumber = "[$safeoperatorchar.0-9eE]";
! 
! 	while ( preg_match("~(^|[$safeoperatorchar,(])([a-z0-9_]*)\\(($operatorornumber+(,$operatorornumber+((,$operatorornumber+)+)?)?)?\\)~",
! 	$formula, $regs)) {
! 		switch ($regs[2]) {
! 			// Simple parenthesis
! 			case '':
! 				if ((isset($regs[4])&& $regs[4]) || strlen($regs[3])==0) {
! 					return get_string('illegalformulasyntax', 'quiz', $regs[0]);
! 				}
! 				break;
! 
! 				// Zero argument functions
! 			case 'pi':
! 				if ($regs[3]) {
! 					return get_string('functiontakesnoargs', 'quiz', $regs[2]);
! 				}
! 				break;
! 
! 				// Single argument functions (the most common case)
! 			case 'abs': case 'acos': case 'acosh': case 'asin': case 'asinh':
! 			case 'atan': case 'atanh': case 'bindec': case 'ceil': case 'cos':
! 			case 'cosh': case 'decbin': case 'decoct': case 'deg2rad':
! 			case 'exp': case 'expm1': case 'floor': case 'is_finite':
! 			case 'is_infinite': case 'is_nan': case 'log10': case 'log1p':
! 			case 'octdec': case 'rad2deg': case 'sin': case 'sinh': case 'sqrt':
! 			case 'tan': case 'tanh':
! 				if (!empty($regs[4]) || empty($regs[3])) {
! 					return get_string('functiontakesonearg','quiz',$regs[2]);
! 				}
! 				break;
! 
! 				// Functions that take one or two arguments
! 			case 'log': case 'round':
! 				if (!empty($regs[5]) || empty($regs[3])) {
! 					return get_string('functiontakesoneortwoargs','quiz',$regs[2]);
! 				}
! 				break;
! 
! 				// Functions that must have two arguments
! 			case 'atan2': case 'fmod': case 'pow':
! 				if (!empty($regs[5]) || empty($regs[4])) {
! 					return get_string('functiontakestwoargs', 'quiz', $regs[2]);
! 				}
! 				break;
! 
! 				// Functions that take two or more arguments
! 			case 'min': case 'max':
! 				if (empty($regs[4])) {
! 					return get_string('functiontakesatleasttwo','quiz',$regs[2]);
! 				}
! 				break;
! 
! 			default:
! 				return get_string('unsupportedformulafunction','quiz',$regs[2]);
! 		}
! 
! 		// Exchange the function call with '1' and then chack for
! 		// another function call...
! 		if ($regs[1]) {
! 			// The function call is proceeded by an operator
! 			$formula = str_replace($regs[0], $regs[1] . '1', $formula);
! 		} else {
! 			// The function call starts the formula
! 			$formula = preg_replace("~^$regs[2]\\([^)]*\\)~", '1', $formula);
! 		}
! 	}
! 
! 	if (preg_match("~[^$safeoperatorchar.0-9eE]+~", $formula, $regs)) {
! 		return get_string('illegalformulasyntax', 'quiz', $regs[0]);
! 	} else {
! 		// Formula just might be valid
! 		return false;
! 	}
  }
diff -crB questionorg/type/calculatedmulti/backup/moodle2/restore_qtype_calculatedmulti_plugin.class.php questionupd/type/calculatedmulti/backup/moodle2/restore_qtype_calculatedmulti_plugin.class.php
*** questionorg/type/calculatedmulti/backup/moodle2/restore_qtype_calculatedmulti_plugin.class.php	2012-04-13 12:31:14.198178301 +0500
--- questionupd/type/calculatedmulti/backup/moodle2/restore_qtype_calculatedmulti_plugin.class.php	2012-04-13 09:42:56.000000000 +0500
***************
*** 31,61 ****
   */
  class restore_qtype_calculatedmulti_plugin extends restore_qtype_calculated_plugin {
  
!     /**
!      * Given one question_states record, return the answer
!      * recoded pointing to all the restored stuff for calculatedmulti questions
!      *
!      * answer format is datasetxx-yy:zz, where xx is the itemnumber in the dataset
!      * (doesn't need conversion), and both yy and zz are two (hypen speparated)
!      * lists of comma separated question_answers, the first to specify the order
!      * of the answers and the second to specify the responses.
!      *
!      * in fact, this qtype behaves exactly like the multichoice one, so we'll delegate
!      * recoding of those yy:zz to it
!      */
!     public function recode_state_answer($state) {
!         $answer = $state->answer;
!         $result = '';
!         // datasetxx-yy:zz format
!         if (preg_match('~^dataset([0-9]+)-(.*)$~', $answer, $matches)) {
!             $itemid = $matches[1];
!             $subanswer  = $matches[2];
!             // Delegate subanswer recode to multichoice qtype, faking one question_states record
!             $substate = new stdClass();
!             $substate->answer = $subanswer;
!             $newanswer = $this->step->restore_recode_answer($substate, 'multichoice');
!             $result = 'dataset' . $itemid . '-' . $newanswer;
!         }
!         return $result ? $result : $answer;
!     }
  }
--- 31,61 ----
   */
  class restore_qtype_calculatedmulti_plugin extends restore_qtype_calculated_plugin {
  
! 	/**
! 	 * Given one question_states record, return the answer
! 	 * recoded pointing to all the restored stuff for calculatedmulti questions
! 	 *
! 	 * answer format is datasetxx-yy:zz, where xx is the itemnumber in the dataset
! 	 * (doesn't need conversion), and both yy and zz are two (hypen speparated)
! 	 * lists of comma separated question_answers, the first to specify the order
! 	 * of the answers and the second to specify the responses.
! 	 *
! 	 * in fact, this qtype behaves exactly like the multichoice one, so we'll delegate
! 	 * recoding of those yy:zz to it
! 	 */
! 	public function recode_state_answer($state) {
! 		$answer = $state->answer;
! 		$result = '';
! 		// datasetxx-yy:zz format
! 		if (preg_match('~^dataset([0-9]+)-(.*)$~', $answer, $matches)) {
! 			$itemid = $matches[1];
! 			$subanswer  = $matches[2];
! 			// Delegate subanswer recode to multichoice qtype, faking one question_states record
! 			$substate = new stdClass();
! 			$substate->answer = $subanswer;
! 			$newanswer = $this->step->restore_recode_answer($substate, 'multichoice');
! 			$result = 'dataset' . $itemid . '-' . $newanswer;
! 		}
! 		return $result ? $result : $answer;
! 	}
  }
diff -crB questionorg/type/calculatedmulti/edit_calculatedmulti_form.php questionupd/type/calculatedmulti/edit_calculatedmulti_form.php
*** questionorg/type/calculatedmulti/edit_calculatedmulti_form.php	2012-04-13 12:31:14.205178301 +0500
--- questionupd/type/calculatedmulti/edit_calculatedmulti_form.php	2012-04-13 09:42:56.000000000 +0500
***************
*** 13,389 ****
   * calculated editing form definition.
   */
  class question_edit_calculatedmulti_form extends question_edit_form {
!     /**
!      * Handle to the question type for this question.
!      *
!      * @var question_calculatedmulti_qtype
!      */
!     public $qtypeobj;
!     public $questiondisplay ;
!     public $initialname = '';
!     public $reload = false ;
!     function question_edit_calculatedmulti_form(&$submiturl, &$question, &$category, &$contexts, $formeditable = true) {
!         global $QTYPES, $SESSION, $CFG, $DB;
!         $this->question = $question;
!         $this->qtypeobj =& $QTYPES[$this->question->qtype];
!         if  (  "1" == optional_param('reload','', PARAM_INT )) {
!             $this->reload = true ;
!         }else {
!             $this->reload = false ;
!         }
!         if(!$this->reload ){ // use database data as this is first pass
!             if(isset($this->question->id )){
!                 // remove prefix #{..}# if exists
!                 $this->initialname = $question->name ;
!                 $regs= array();
!                 if(preg_match('~#\{([^[:space:]]*)#~',$question->name , $regs)){
!                     $question->name = str_replace($regs[0], '', $question->name);
!                 };
!             }
!         }else {
!         }
!         parent::question_edit_form($submiturl, $question, $category, $contexts, $formeditable);
!     }
! 
!     function get_per_answer_fields(&$mform, $label, $gradeoptions, &$repeatedoptions, &$answersoption) {
!         //     $repeated = parent::get_per_answer_fields($mform, $label, $gradeoptions, $repeatedoptions, $answersoption);
!         $repeated = array();
!         $repeated[] =& $mform->createElement('header', 'answerhdr', $label);
!         //   if ($this->editasmultichoice == 1){
!         $repeated[] =& $mform->createElement('text', 'answer', get_string('answer', 'quiz'), array('size' => 50));
!         $repeated[] =& $mform->createElement('select', 'fraction', get_string('grade'), $gradeoptions);
!         $repeated[] =& $mform->createElement('editor', 'feedback', get_string('feedback', 'quiz'), null, $this->editoroptions);
!         $repeatedoptions['answer']['type'] = PARAM_RAW;
!         $repeatedoptions['fraction']['default'] = 0;
!         $answersoption = 'answers';
! 
!         $mform->setType('answer', PARAM_NOTAGS);
! 
!         $addrepeated = array();
!         $addrepeated[] =& $mform->createElement('hidden', 'tolerance');
!         $addrepeated[] =& $mform->createElement('hidden', 'tolerancetype',1);
!         $repeatedoptions['tolerance']['type'] = PARAM_NUMBER;
!         $repeatedoptions['tolerance']['default'] = 0.01;
! 
!         $addrepeated[] =&  $mform->createElement('select', 'correctanswerlength', get_string('correctanswershows', 'qtype_calculated'), range(0, 9));
!         $repeatedoptions['correctanswerlength']['default'] = 2;
! 
!         $answerlengthformats = array('1' => get_string('decimalformat', 'quiz'), '2' => get_string('significantfiguresformat', 'quiz'));
!         $addrepeated[] =&  $mform->createElement('select', 'correctanswerformat', get_string('correctanswershowsformat', 'qtype_calculated'), $answerlengthformats);
!         array_splice($repeated, 3, 0, $addrepeated);
!         $repeated[1]->setLabel('...<strong>{={x}+..}</strong>...');
! 
!         return $repeated;
!     }
! 
!     /**
!      * Add question-type specific form fields.
!      *
!      * @param MoodleQuickForm $mform the form being built.
!      */
!     function definition_inner(&$mform) {
!         global $QTYPES;
!         $this->qtypeobj =& $QTYPES[$this->qtype()];
!         // echo code left for testing period
!         // echo "<p>question ".optional_param('multichoice', '', PARAM_RAW)." optional<pre>";print_r($this->question);echo "</pre></p>";
!         $label = get_string("sharedwildcards", "qtype_calculated");
!         $mform->addElement('hidden', 'initialcategory', 1);
!         $mform->addElement('hidden', 'reload', 1);
!         $mform->setType('initialcategory', PARAM_INT);
! 
!         //     $html2 = $this->qtypeobj->print_dataset_definitions_category($this->question);
!         $html2 ="";
!         $mform->insertElementBefore($mform->createElement('static','listcategory',$label,$html2),'name');
!         if(isset($this->question->id )){
!             $mform->insertElementBefore($mform->createElement('static','initialname',get_string('questionstoredname','qtype_calculated'),$this->initialname),'name');
!         };
!         $addfieldsname='updatecategory';
!         $addstring=get_string("updatecategory", "qtype_calculated");
!         $mform->registerNoSubmitButton($addfieldsname);
!         $this->editasmultichoice =  1 ;
! 
! 
!         $mform->insertElementBefore(    $mform->createElement('submit', $addfieldsname, $addstring),'listcategory');
!         $mform->registerNoSubmitButton('createoptionbutton');
!         $mform->addElement('hidden', 'multichoice',$this->editasmultichoice);
!         $mform->setType('multichoice', PARAM_INT);
! 
! 
!         //            $mform->addElement('header', 'choicehdr',get_string('multichoicecalculatedquestion', 'qtype_calculated'));
!         $menu = array(get_string('answersingleno', 'qtype_multichoice'), get_string('answersingleyes', 'qtype_multichoice'));
!         $mform->addElement('select', 'single', get_string('answerhowmany', 'qtype_multichoice'), $menu);
!         $mform->setDefault('single', 1);
! 
!         $mform->addElement('advcheckbox', 'shuffleanswers', get_string('shuffleanswers', 'qtype_multichoice'), null, null, array(0,1));
!         $mform->addHelpButton('shuffleanswers', 'shuffleanswers', 'qtype_multichoice');
!         $mform->setDefault('shuffleanswers', 1);
! 
!         $numberingoptions = $QTYPES['multichoice']->get_numbering_styles();
!         $menu = array();
!         foreach ($numberingoptions as $numberingoption) {
!             $menu[$numberingoption] = get_string('answernumbering' . $numberingoption, 'qtype_multichoice');
!         }
!         $mform->addElement('select', 'answernumbering', get_string('answernumbering', 'qtype_multichoice'), $menu);
!         $mform->setDefault('answernumbering', 'abc');
! 
!         $creategrades = get_grade_options();
!         $this->add_per_answer_fields($mform, get_string('choiceno', 'qtype_multichoice', '{no}'),
!             $creategrades->gradeoptionsfull, max(5, QUESTION_NUMANS_START));
! 
! 
!         $repeated = array();
!         //   if ($this->editasmultichoice == 1){
!         $nounits = optional_param('nounits', 1, PARAM_INT);
!         $mform->addElement('hidden', 'nounits', $nounits);
!         $mform->setType('nounits', PARAM_INT);
!         $mform->setConstants(array('nounits'=>$nounits));
!         for ($i=0; $i< $nounits; $i++) {
!             $mform->addElement('hidden','unit'."[$i]", optional_param('unit'."[$i]", '', PARAM_NOTAGS));
!             $mform->setType('unit'."[$i]", PARAM_NOTAGS);
!             $mform->addElement('hidden', 'multiplier'."[$i]", optional_param('multiplier'."[$i]", '', PARAM_NUMBER));
!             $mform->setType('multiplier'."[$i]", PARAM_NUMBER);
!         }
! 
!         $mform->setType('addunits','hidden');
!         $mform->addElement('header', 'overallfeedbackhdr', get_string('overallfeedback', 'qtype_multichoice'));
! 
!         foreach (array('correctfeedback', 'partiallycorrectfeedback', 'incorrectfeedback') as $feedbackname) {
!             $mform->addElement('editor', $feedbackname, get_string($feedbackname, 'qtype_multichoice'), null, $this->editoroptions);
!             $mform->setType($feedbackname, PARAM_RAW);
!         }
!         //hidden elements
!         $mform->addElement('hidden', 'synchronize', '');
!         $mform->setType('synchronize', PARAM_INT);
!         if (isset($this->question->options)&& isset($this->question->options->synchronize) ){
!             $mform->setDefault("synchronize", $this->question->options->synchronize);
!         } else {
!             $mform->setDefault("synchronize", 0 );
!         }
!         $mform->addElement('hidden', 'wizard', 'datasetdefinitions');
!         $mform->setType('wizard', PARAM_ALPHA);
!     }
! 
!     function data_preprocessing($question) {
!         $default_values['multichoice']= $this->editasmultichoice ; //$this->editasmultichoice ;
!         if (isset($question->options)){
!             $answers = $question->options->answers;
!             if (count($answers)) {
!                 $key = 0;
!                 foreach ($answers as $answer){
!                     $draftid = file_get_submitted_draft_itemid('feedback['.$key.']');
!                     $default_values['answer['.$key.']'] = $answer->answer;
!                     $default_values['fraction['.$key.']'] = $answer->fraction;
!                     $default_values['tolerance['.$key.']'] = $answer->tolerance;
!                     $default_values['tolerancetype['.$key.']'] = $answer->tolerancetype;
!                     $default_values['correctanswerlength['.$key.']'] = $answer->correctanswerlength;
!                     $default_values['correctanswerformat['.$key.']'] = $answer->correctanswerformat;
!                     $default_values['feedback['.$key.']'] = array();
!                     // prepare draftarea
!                     $default_values['feedback['.$key.']']['text'] = file_prepare_draft_area($draftid, $this->context->id, 'question', 'answerfeedback', empty($answer->id)?null:(int)$answer->id, $this->fileoptions, $answer->feedback);
!                     $default_values['feedback['.$key.']']['format'] = $answer->feedbackformat;
!                     $default_values['feedback['.$key.']']['itemid'] = $draftid;
!                     $key++;
!                 }
!             }
!             $default_values['synchronize'] = $question->options->synchronize ;
! 
!             if (isset($question->options->units)){
!                 $units  = array_values($question->options->units);
!                 // make sure the default unit is at index 0
!                 usort($units, create_function('$a, $b',
                      'if (1.0 === (float)$a->multiplier) { return -1; } else '.
                      'if (1.0 === (float)$b->multiplier) { return 1; } else { return 0; }'));
!                 if (count($units)) {
!                     $key = 0;
!                     foreach ($units as $unit){
!                         $default_values['unit['.$key.']'] = $unit->unit;
!                         $default_values['multiplier['.$key.']'] = $unit->multiplier;
!                         $key++;
!                     }
!                 }
!             }
!         }
!         if (isset($question->options->single)){
!             $default_values['single'] =  $question->options->single;
!             $default_values['answernumbering'] =  $question->options->answernumbering;
!             $default_values['shuffleanswers'] =  $question->options->shuffleanswers;
!         }
!         $default_values['submitbutton'] = get_string('nextpage', 'qtype_calculated');
!         $default_values['makecopy'] = get_string('makecopynextpage', 'qtype_calculated');
! 
!         // prepare draft files
!         foreach (array('correctfeedback', 'partiallycorrectfeedback', 'incorrectfeedback') as $feedbackname) {
!             if (!isset($question->options->$feedbackname)) {
!                 continue;
!             }
!             $text = $question->options->$feedbackname;
!             $draftid = file_get_submitted_draft_itemid($feedbackname);
!             $feedbackformat = $feedbackname . 'format';
!             $format = $question->options->$feedbackformat;
!             $default_values[$feedbackname] = array();
!             $default_values[$feedbackname]['text'] = file_prepare_draft_area(
!                 $draftid,                // draftid
!                 $this->context->id,      // context
                  'qtype_calculatedmulti', // component
!                 $feedbackname,           // filarea
!                 !empty($question->id)?(int)$question->id:null, // itemid
!                 $this->fileoptions,      // options
!                 $text                    // text
!             );
!             $default_values[$feedbackname]['format'] = $format;
!             $default_values[$feedbackname]['itemid'] = $draftid;
!         }
!         /**
!          * set the wild cards category display given that on loading the category element is
!          * unselected when processing this function but have a valid value when processing the
!          * update category button. The value can be obtain by
!          * $qu->category =$this->_form->_elements[$this->_form->_elementIndex['category']]->_values[0];
!          * but is coded using existing functions
!          */
!         $qu = new stdClass;
!         $el = new stdClass;
!         /* no need to call elementExists() here */
!         if ($this->_form->elementExists('category')){
!             $el=$this->_form->getElement('category');
!         } else {
!             $el=$this->_form->getElement('categorymoveto');
!         }
!         if($value =$el->getSelected()) {
!             $qu->category =$value[0];
!         }else {
!             $qu->category=$question->category;// on load  $question->category is set by question.php
!         }
!         $html2 = $this->qtypeobj->print_dataset_definitions_category($qu);
!         $this->_form->_elements[$this->_form->_elementIndex['listcategory']]->_text = $html2 ;
!         $question = (object)((array)$question + $default_values);
!         return $question;
!     }
! 
!     function qtype() {
!         return 'calculatedmulti';
!     }
! 
!     function validation($data, $files) {
!         // echo code left for testing period
!         // echo "<p>question <pre>";print_r($this->question);echo "</pre></p>";
!         // echo "<p>data <pre>";print_r($data);echo "</pre></p>";
! 
!         $errors = parent::validation($data, $files);
!         //verifying for errors in {=...} in question text;
!         $qtext = "";
!         $qtextremaining = $data['questiontext']['text'];
!         $possibledatasets = $this->qtypeobj->find_dataset_names($data['questiontext']['text']);
!         foreach ($possibledatasets as $name => $value) {
!             $qtextremaining = str_replace('{'.$name.'}', '1', $qtextremaining);
!         }
!         // echo "numericalquestion qtextremaining <pre>";print_r($possibledatasets);
!         while (preg_match('~\{=([^[:space:]}]*)}~', $qtextremaining, $regs1)) {
!             $qtextsplits = explode($regs1[0], $qtextremaining, 2);
!             $qtext =$qtext.$qtextsplits[0];
!             $qtextremaining = $qtextsplits[1];
!             if (!empty($regs1[1]) && $formulaerrors = qtype_calculated_find_formula_errors($regs1[1])) {
!                 if(!isset($errors['questiontext'])){
!                     $errors['questiontext'] = $formulaerrors.':'.$regs1[1] ;
!                 }else {
!                     $errors['questiontext'] .= '<br/>'.$formulaerrors.':'.$regs1[1];
!                 }
!             }
!         }
!         $answers = $data['answer'];
!         $answercount = 0;
!         $maxgrade = false;
!         $possibledatasets = $this->qtypeobj->find_dataset_names($data['questiontext']['text']);
!         $mandatorydatasets = array();
!         foreach ($answers as $key => $answer){
!             $mandatorydatasets += $this->qtypeobj->find_dataset_names($answer);
!         }
!         if ( count($mandatorydatasets )==0){
!             //  $errors['questiontext']=get_string('atleastonewildcard', 'qtype_datasetdependent');
!             foreach ($answers as $key => $answer){
!                 $errors['answer['.$key.']'] = get_string('atleastonewildcard', 'qtype_datasetdependent');
!             }
!         }
!         if ($data['multichoice']== 1 ){
!             foreach ($answers as $key => $answer){
!                 $trimmedanswer = trim($answer);
!                 if (($trimmedanswer!='')||$answercount==0){
!                     //verifying for errors in {=...} in answer text;
!                     $qanswer = "";
!                     $qanswerremaining =  $trimmedanswer ;
!                     $possibledatasets = $this->qtypeobj->find_dataset_names($trimmedanswer);
!                     foreach ($possibledatasets as $name => $value) {
!                         $qanswerremaining = str_replace('{'.$name.'}', '1', $qanswerremaining);
!                     }
!                     //     echo "numericalquestion qanswerremaining <pre>";print_r($possibledatasets);
!                     while  (preg_match('~\{=([^[:space:]}]*)}~', $qanswerremaining, $regs1)) {
!                         $qanswersplits = explode($regs1[0], $qanswerremaining, 2);
!                         $qanswer =$qanswer.$qanswersplits[0];
!                         $qanswerremaining = $qanswersplits[1];
!                         if (!empty($regs1[1]) && $formulaerrors = qtype_calculated_find_formula_errors($regs1[1])) {
!                             if(!isset($errors['answer['.$key.']'])){
!                                 $errors['answer['.$key.']'] = $formulaerrors.':'.$regs1[1] ;
!                             }else {
!                                 $errors['answer['.$key.']'] .= '<br/>'.$formulaerrors.':'.$regs1[1];
!                             }
!                         }
!                     }
!                 }
!                 if ($trimmedanswer!=''){
!                     if ('2' == $data['correctanswerformat'][$key]
!                         && '0' == $data['correctanswerlength'][$key]) {
!                             $errors['correctanswerlength['.$key.']'] = get_string('zerosignificantfiguresnotallowed','quiz');
!                         }
!                     if (!is_numeric($data['tolerance'][$key])){
!                         $errors['tolerance['.$key.']'] = get_string('mustbenumeric', 'qtype_calculated');
!                     }
!                     if ($data['fraction'][$key] == 1) {
!                         $maxgrade = true;
!                     }
! 
!                     $answercount++;
!                 }
!                 //check grades
!                 $totalfraction = 0 ;
!                 $maxfraction = 0 ;
!                 if ($answer != '') {
!                     if ($data['fraction'][$key] > 0) {
!                         $totalfraction += $data['fraction'][$key];
!                     }
!                     if ($data['fraction'][$key] > $maxfraction) {
!                         $maxfraction = $data['fraction'][$key];
!                     }
!                 }
!             }
!             if ($answercount==0){
!                 $errors['answer[0]'] = get_string('notenoughanswers', 'qtype_multichoice', 2);
!                 $errors['answer[1]'] = get_string('notenoughanswers', 'qtype_multichoice', 2);
!             } elseif ($answercount==1){
!                 $errors['answer[1]'] = get_string('notenoughanswers', 'qtype_multichoice', 2);
! 
!             }
! 
!             /// Perform sanity checks on fractional grades
!             if ($data['single']) {
!                 if ($maxfraction > 0.999 ) {
!                     $maxfraction = $maxfraction * 100;
!                     $errors['fraction[0]'] = get_string('errfractionsnomax', 'qtype_multichoice', $maxfraction);
!                 }
!             } else {
!                 $totalfraction = round($totalfraction,2);
!                 if ($totalfraction != 1) {
!                     $totalfraction = $totalfraction * 100;
!                     $errors['fraction[0]'] = get_string('errfractionsaddwrong', 'qtype_multichoice', $totalfraction);
!                 }
!             }
! 
!             if ($answercount==0){
!                 $errors['answer[0]'] = get_string('atleastoneanswer', 'qtype_calculated');
!             }
!             if ($maxgrade == false) {
!                 $errors['fraction[0]'] = get_string('fractionsnomax', 'question');
!             }
! 
!         }
!         return $errors;
!     }
  }
--- 13,389 ----
   * calculated editing form definition.
   */
  class question_edit_calculatedmulti_form extends question_edit_form {
! 	/**
! 	 * Handle to the question type for this question.
! 	 *
! 	 * @var question_calculatedmulti_qtype
! 	 */
! 	public $qtypeobj;
! 	public $questiondisplay ;
! 	public $initialname = '';
! 	public $reload = false ;
! 	function question_edit_calculatedmulti_form(&$submiturl, &$question, &$category, &$contexts, $formeditable = true) {
! 		global $QTYPES, $SESSION, $CFG, $DB;
! 		$this->question = $question;
! 		$this->qtypeobj =& $QTYPES[$this->question->qtype];
! 		if  (  "1" == optional_param('reload','', PARAM_INT )) {
! 			$this->reload = true ;
! 		}else {
! 			$this->reload = false ;
! 		}
! 		if(!$this->reload ){ // use database data as this is first pass
! 			if(isset($this->question->id )){
! 				// remove prefix #{..}# if exists
! 				$this->initialname = $question->name ;
! 				$regs= array();
! 				if(preg_match('~#\{([^[:space:]]*)#~',$question->name , $regs)){
! 					$question->name = str_replace($regs[0], '', $question->name);
! 				};
! 			}
! 		}else {
! 		}
! 		parent::question_edit_form($submiturl, $question, $category, $contexts, $formeditable);
! 	}
! 
! 	function get_per_answer_fields(&$mform, $label, $gradeoptions, &$repeatedoptions, &$answersoption) {
! 		//     $repeated = parent::get_per_answer_fields($mform, $label, $gradeoptions, $repeatedoptions, $answersoption);
! 		$repeated = array();
! 		$repeated[] =& $mform->createElement('header', 'answerhdr', $label);
! 		//   if ($this->editasmultichoice == 1){
! 		$repeated[] =& $mform->createElement('text', 'answer', get_string('answer', 'quiz'), array('size' => 50));
! 		$repeated[] =& $mform->createElement('select', 'fraction', get_string('grade'), $gradeoptions);
! 		$repeated[] =& $mform->createElement('editor', 'feedback', get_string('feedback', 'quiz'), null, $this->editoroptions);
! 		$repeatedoptions['answer']['type'] = PARAM_RAW;
! 		$repeatedoptions['fraction']['default'] = 0;
! 		$answersoption = 'answers';
! 
! 		$mform->setType('answer', PARAM_NOTAGS);
! 
! 		$addrepeated = array();
! 		$addrepeated[] =& $mform->createElement('hidden', 'tolerance');
! 		$addrepeated[] =& $mform->createElement('hidden', 'tolerancetype',1);
! 		$repeatedoptions['tolerance']['type'] = PARAM_NUMBER;
! 		$repeatedoptions['tolerance']['default'] = 0.01;
! 
! 		$addrepeated[] =&  $mform->createElement('select', 'correctanswerlength', get_string('correctanswershows', 'qtype_calculated'), range(0, 9));
! 		$repeatedoptions['correctanswerlength']['default'] = 2;
! 
! 		$answerlengthformats = array('1' => get_string('decimalformat', 'quiz'), '2' => get_string('significantfiguresformat', 'quiz'));
! 		$addrepeated[] =&  $mform->createElement('select', 'correctanswerformat', get_string('correctanswershowsformat', 'qtype_calculated'), $answerlengthformats);
! 		array_splice($repeated, 3, 0, $addrepeated);
! 		$repeated[1]->setLabel('...<strong>{={x}+..}</strong>...');
! 
! 		return $repeated;
! 	}
! 
! 	/**
! 	 * Add question-type specific form fields.
! 	 *
! 	 * @param MoodleQuickForm $mform the form being built.
! 	 */
! 	function definition_inner(&$mform) {
! 		global $QTYPES;
! 		$this->qtypeobj =& $QTYPES[$this->qtype()];
! 		// echo code left for testing period
! 		// echo "<p>question ".optional_param('multichoice', '', PARAM_RAW)." optional<pre>";print_r($this->question);echo "</pre></p>";
! 		$label = get_string("sharedwildcards", "qtype_calculated");
! 		$mform->addElement('hidden', 'initialcategory', 1);
! 		$mform->addElement('hidden', 'reload', 1);
! 		$mform->setType('initialcategory', PARAM_INT);
! 
! 		//     $html2 = $this->qtypeobj->print_dataset_definitions_category($this->question);
! 		$html2 ="";
! 		$mform->insertElementBefore($mform->createElement('static','listcategory',$label,$html2),'name');
! 		if(isset($this->question->id )){
! 			$mform->insertElementBefore($mform->createElement('static','initialname',get_string('questionstoredname','qtype_calculated'),$this->initialname),'name');
! 		};
! 		$addfieldsname='updatecategory';
! 		$addstring=get_string("updatecategory", "qtype_calculated");
! 		$mform->registerNoSubmitButton($addfieldsname);
! 		$this->editasmultichoice =  1 ;
! 
! 
! 		$mform->insertElementBefore(    $mform->createElement('submit', $addfieldsname, $addstring),'listcategory');
! 		$mform->registerNoSubmitButton('createoptionbutton');
! 		$mform->addElement('hidden', 'multichoice',$this->editasmultichoice);
! 		$mform->setType('multichoice', PARAM_INT);
! 
! 
! 		//            $mform->addElement('header', 'choicehdr',get_string('multichoicecalculatedquestion', 'qtype_calculated'));
! 		$menu = array(get_string('answersingleno', 'qtype_multichoice'), get_string('answersingleyes', 'qtype_multichoice'));
! 		$mform->addElement('select', 'single', get_string('answerhowmany', 'qtype_multichoice'), $menu);
! 		$mform->setDefault('single', 1);
! 
! 		$mform->addElement('advcheckbox', 'shuffleanswers', get_string('shuffleanswers', 'qtype_multichoice'), null, null, array(0,1));
! 		$mform->addHelpButton('shuffleanswers', 'shuffleanswers', 'qtype_multichoice');
! 		$mform->setDefault('shuffleanswers', 1);
! 
! 		$numberingoptions = $QTYPES['multichoice']->get_numbering_styles();
! 		$menu = array();
! 		foreach ($numberingoptions as $numberingoption) {
! 			$menu[$numberingoption] = get_string('answernumbering' . $numberingoption, 'qtype_multichoice');
! 		}
! 		$mform->addElement('select', 'answernumbering', get_string('answernumbering', 'qtype_multichoice'), $menu);
! 		$mform->setDefault('answernumbering', 'abc');
! 
! 		$creategrades = get_grade_options();
! 		$this->add_per_answer_fields($mform, get_string('choiceno', 'qtype_multichoice', '{no}'),
! 		$creategrades->gradeoptionsfull, max(5, QUESTION_NUMANS_START));
! 
! 
! 		$repeated = array();
! 		//   if ($this->editasmultichoice == 1){
! 		$nounits = optional_param('nounits', 1, PARAM_INT);
! 		$mform->addElement('hidden', 'nounits', $nounits);
! 		$mform->setType('nounits', PARAM_INT);
! 		$mform->setConstants(array('nounits'=>$nounits));
! 		for ($i=0; $i< $nounits; $i++) {
! 			$mform->addElement('hidden','unit'."[$i]", optional_param('unit'."[$i]", '', PARAM_NOTAGS));
! 			$mform->setType('unit'."[$i]", PARAM_NOTAGS);
! 			$mform->addElement('hidden', 'multiplier'."[$i]", optional_param('multiplier'."[$i]", '', PARAM_NUMBER));
! 			$mform->setType('multiplier'."[$i]", PARAM_NUMBER);
! 		}
! 
! 		$mform->setType('addunits','hidden');
! 		$mform->addElement('header', 'overallfeedbackhdr', get_string('overallfeedback', 'qtype_multichoice'));
! 
! 		foreach (array('correctfeedback', 'partiallycorrectfeedback', 'incorrectfeedback') as $feedbackname) {
! 			$mform->addElement('editor', $feedbackname, get_string($feedbackname, 'qtype_multichoice'), null, $this->editoroptions);
! 			$mform->setType($feedbackname, PARAM_RAW);
! 		}
! 		//hidden elements
! 		$mform->addElement('hidden', 'synchronize', '');
! 		$mform->setType('synchronize', PARAM_INT);
! 		if (isset($this->question->options)&& isset($this->question->options->synchronize) ){
! 			$mform->setDefault("synchronize", $this->question->options->synchronize);
! 		} else {
! 			$mform->setDefault("synchronize", 0 );
! 		}
! 		$mform->addElement('hidden', 'wizard', 'datasetdefinitions');
! 		$mform->setType('wizard', PARAM_ALPHA);
! 	}
! 
! 	function data_preprocessing($question) {
! 		$default_values['multichoice']= $this->editasmultichoice ; //$this->editasmultichoice ;
! 		if (isset($question->options)){
! 			$answers = $question->options->answers;
! 			if (count($answers)) {
! 				$key = 0;
! 				foreach ($answers as $answer){
! 					$draftid = file_get_submitted_draft_itemid('feedback['.$key.']');
! 					$default_values['answer['.$key.']'] = $answer->answer;
! 					$default_values['fraction['.$key.']'] = $answer->fraction;
! 					$default_values['tolerance['.$key.']'] = $answer->tolerance;
! 					$default_values['tolerancetype['.$key.']'] = $answer->tolerancetype;
! 					$default_values['correctanswerlength['.$key.']'] = $answer->correctanswerlength;
! 					$default_values['correctanswerformat['.$key.']'] = $answer->correctanswerformat;
! 					$default_values['feedback['.$key.']'] = array();
! 					// prepare draftarea
! 					$default_values['feedback['.$key.']']['text'] = file_prepare_draft_area($draftid, $this->context->id, 'question', 'answerfeedback', empty($answer->id)?null:(int)$answer->id, $this->fileoptions, $answer->feedback);
! 					$default_values['feedback['.$key.']']['format'] = $answer->feedbackformat;
! 					$default_values['feedback['.$key.']']['itemid'] = $draftid;
! 					$key++;
! 				}
! 			}
! 			$default_values['synchronize'] = $question->options->synchronize ;
! 
! 			if (isset($question->options->units)){
! 				$units  = array_values($question->options->units);
! 				// make sure the default unit is at index 0
! 				usort($units, create_function('$a, $b',
                      'if (1.0 === (float)$a->multiplier) { return -1; } else '.
                      'if (1.0 === (float)$b->multiplier) { return 1; } else { return 0; }'));
! 				if (count($units)) {
! 					$key = 0;
! 					foreach ($units as $unit){
! 						$default_values['unit['.$key.']'] = $unit->unit;
! 						$default_values['multiplier['.$key.']'] = $unit->multiplier;
! 						$key++;
! 					}
! 				}
! 			}
! 		}
! 		if (isset($question->options->single)){
! 			$default_values['single'] =  $question->options->single;
! 			$default_values['answernumbering'] =  $question->options->answernumbering;
! 			$default_values['shuffleanswers'] =  $question->options->shuffleanswers;
! 		}
! 		$default_values['submitbutton'] = get_string('nextpage', 'qtype_calculated');
! 		$default_values['makecopy'] = get_string('makecopynextpage', 'qtype_calculated');
! 
! 		// prepare draft files
! 		foreach (array('correctfeedback', 'partiallycorrectfeedback', 'incorrectfeedback') as $feedbackname) {
! 			if (!isset($question->options->$feedbackname)) {
! 				continue;
! 			}
! 			$text = $question->options->$feedbackname;
! 			$draftid = file_get_submitted_draft_itemid($feedbackname);
! 			$feedbackformat = $feedbackname . 'format';
! 			$format = $question->options->$feedbackformat;
! 			$default_values[$feedbackname] = array();
! 			$default_values[$feedbackname]['text'] = file_prepare_draft_area(
! 			$draftid,                // draftid
! 			$this->context->id,      // context
                  'qtype_calculatedmulti', // component
! 			$feedbackname,           // filarea
! 			!empty($question->id)?(int)$question->id:null, // itemid
! 			$this->fileoptions,      // options
! 			$text                    // text
! 			);
! 			$default_values[$feedbackname]['format'] = $format;
! 			$default_values[$feedbackname]['itemid'] = $draftid;
! 		}
! 		/**
! 		 * set the wild cards category display given that on loading the category element is
! 		 * unselected when processing this function but have a valid value when processing the
! 		 * update category button. The value can be obtain by
! 		 * $qu->category =$this->_form->_elements[$this->_form->_elementIndex['category']]->_values[0];
! 		 * but is coded using existing functions
! 		 */
! 		$qu = new stdClass;
! 		$el = new stdClass;
! 		/* no need to call elementExists() here */
! 		if ($this->_form->elementExists('category')){
! 			$el=$this->_form->getElement('category');
! 		} else {
! 			$el=$this->_form->getElement('categorymoveto');
! 		}
! 		if($value =$el->getSelected()) {
! 			$qu->category =$value[0];
! 		}else {
! 			$qu->category=$question->category;// on load  $question->category is set by question.php
! 		}
! 		$html2 = $this->qtypeobj->print_dataset_definitions_category($qu);
! 		$this->_form->_elements[$this->_form->_elementIndex['listcategory']]->_text = $html2 ;
! 		$question = (object)((array)$question + $default_values);
! 		return $question;
! 	}
! 
! 	function qtype() {
! 		return 'calculatedmulti';
! 	}
! 
! 	function validation($data, $files) {
! 		// echo code left for testing period
! 		// echo "<p>question <pre>";print_r($this->question);echo "</pre></p>";
! 		// echo "<p>data <pre>";print_r($data);echo "</pre></p>";
! 
! 		$errors = parent::validation($data, $files);
! 		//verifying for errors in {=...} in question text;
! 		$qtext = "";
! 		$qtextremaining = $data['questiontext']['text'];
! 		$possibledatasets = $this->qtypeobj->find_dataset_names($data['questiontext']['text']);
! 		foreach ($possibledatasets as $name => $value) {
! 			$qtextremaining = str_replace('{'.$name.'}', '1', $qtextremaining);
! 		}
! 		// echo "numericalquestion qtextremaining <pre>";print_r($possibledatasets);
! 		while (preg_match('~\{=([^[:space:]}]*)}~', $qtextremaining, $regs1)) {
! 			$qtextsplits = explode($regs1[0], $qtextremaining, 2);
! 			$qtext =$qtext.$qtextsplits[0];
! 			$qtextremaining = $qtextsplits[1];
! 			if (!empty($regs1[1]) && $formulaerrors = qtype_calculated_find_formula_errors($regs1[1])) {
! 				if(!isset($errors['questiontext'])){
! 					$errors['questiontext'] = $formulaerrors.':'.$regs1[1] ;
! 				}else {
! 					$errors['questiontext'] .= '<br/>'.$formulaerrors.':'.$regs1[1];
! 				}
! 			}
! 		}
! 		$answers = $data['answer'];
! 		$answercount = 0;
! 		$maxgrade = false;
! 		$possibledatasets = $this->qtypeobj->find_dataset_names($data['questiontext']['text']);
! 		$mandatorydatasets = array();
! 		foreach ($answers as $key => $answer){
! 			$mandatorydatasets += $this->qtypeobj->find_dataset_names($answer);
! 		}
! 		if ( count($mandatorydatasets )==0){
! 			//  $errors['questiontext']=get_string('atleastonewildcard', 'qtype_datasetdependent');
! 			foreach ($answers as $key => $answer){
! 				$errors['answer['.$key.']'] = get_string('atleastonewildcard', 'qtype_datasetdependent');
! 			}
! 		}
! 		if ($data['multichoice']== 1 ){
! 			foreach ($answers as $key => $answer){
! 				$trimmedanswer = trim($answer);
! 				if (($trimmedanswer!='')||$answercount==0){
! 					//verifying for errors in {=...} in answer text;
! 					$qanswer = "";
! 					$qanswerremaining =  $trimmedanswer ;
! 					$possibledatasets = $this->qtypeobj->find_dataset_names($trimmedanswer);
! 					foreach ($possibledatasets as $name => $value) {
! 						$qanswerremaining = str_replace('{'.$name.'}', '1', $qanswerremaining);
! 					}
! 					//     echo "numericalquestion qanswerremaining <pre>";print_r($possibledatasets);
! 					while  (preg_match('~\{=([^[:space:]}]*)}~', $qanswerremaining, $regs1)) {
! 						$qanswersplits = explode($regs1[0], $qanswerremaining, 2);
! 						$qanswer =$qanswer.$qanswersplits[0];
! 						$qanswerremaining = $qanswersplits[1];
! 						if (!empty($regs1[1]) && $formulaerrors = qtype_calculated_find_formula_errors($regs1[1])) {
! 							if(!isset($errors['answer['.$key.']'])){
! 								$errors['answer['.$key.']'] = $formulaerrors.':'.$regs1[1] ;
! 							}else {
! 								$errors['answer['.$key.']'] .= '<br/>'.$formulaerrors.':'.$regs1[1];
! 							}
! 						}
! 					}
! 				}
! 				if ($trimmedanswer!=''){
! 					if ('2' == $data['correctanswerformat'][$key]
! 					&& '0' == $data['correctanswerlength'][$key]) {
! 						$errors['correctanswerlength['.$key.']'] = get_string('zerosignificantfiguresnotallowed','quiz');
! 					}
! 					if (!is_numeric($data['tolerance'][$key])){
! 						$errors['tolerance['.$key.']'] = get_string('mustbenumeric', 'qtype_calculated');
! 					}
! 					if ($data['fraction'][$key] == 1) {
! 						$maxgrade = true;
! 					}
! 
! 					$answercount++;
! 				}
! 				//check grades
! 				$totalfraction = 0 ;
! 				$maxfraction = 0 ;
! 				if ($answer != '') {
! 					if ($data['fraction'][$key] > 0) {
! 						$totalfraction += $data['fraction'][$key];
! 					}
! 					if ($data['fraction'][$key] > $maxfraction) {
! 						$maxfraction = $data['fraction'][$key];
! 					}
! 				}
! 			}
! 			if ($answercount==0){
! 				$errors['answer[0]'] = get_string('notenoughanswers', 'qtype_multichoice', 2);
! 				$errors['answer[1]'] = get_string('notenoughanswers', 'qtype_multichoice', 2);
! 			} elseif ($answercount==1){
! 				$errors['answer[1]'] = get_string('notenoughanswers', 'qtype_multichoice', 2);
! 
! 			}
! 
! 			/// Perform sanity checks on fractional grades
! 			if ($data['single']) {
! 				if ($maxfraction > 0.999 ) {
! 					$maxfraction = $maxfraction * 100;
! 					$errors['fraction[0]'] = get_string('errfractionsnomax', 'qtype_multichoice', $maxfraction);
! 				}
! 			} else {
! 				$totalfraction = round($totalfraction,2);
! 				if ($totalfraction != 1) {
! 					$totalfraction = $totalfraction * 100;
! 					$errors['fraction[0]'] = get_string('errfractionsaddwrong', 'qtype_multichoice', $totalfraction);
! 				}
! 			}
! 
! 			if ($answercount==0){
! 				$errors['answer[0]'] = get_string('atleastoneanswer', 'qtype_calculated');
! 			}
! 			if ($maxgrade == false) {
! 				$errors['fraction[0]'] = get_string('fractionsnomax', 'question');
! 			}
! 
! 		}
! 		return $errors;
! 	}
  }
diff -crB questionorg/type/calculatedmulti/lib.php questionupd/type/calculatedmulti/lib.php
*** questionorg/type/calculatedmulti/lib.php	2012-04-13 12:31:14.209178301 +0500
--- questionupd/type/calculatedmulti/lib.php	2012-04-13 09:42:56.000000000 +0500
***************
*** 25,31 ****
   * @license   http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
   */
  function qtype_calculatedmulti_pluginfile($course, $cm, $context, $filearea, $args, $forcedownload) {
!     global $DB, $CFG;
!     require_once($CFG->libdir . '/questionlib.php');
!     question_pluginfile($course, $context, 'qtype_calculatedmulti', $filearea, $args, $forcedownload);
  }
--- 25,31 ----
   * @license   http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
   */
  function qtype_calculatedmulti_pluginfile($course, $cm, $context, $filearea, $args, $forcedownload) {
! 	global $DB, $CFG;
! 	require_once($CFG->libdir . '/questionlib.php');
! 	question_pluginfile($course, $context, 'qtype_calculatedmulti', $filearea, $args, $forcedownload);
  }
diff -crB questionorg/type/calculatedmulti/questiontype.php questionupd/type/calculatedmulti/questiontype.php
*** questionorg/type/calculatedmulti/questiontype.php	2012-04-13 12:31:14.208178301 +0500
--- questionupd/type/calculatedmulti/questiontype.php	2012-04-13 09:42:56.000000000 +0500
***************
*** 24,609 ****
  class question_calculatedmulti_qtype extends question_calculated_qtype {
  
  
!     // Used by the function custom_generator_tools:
!     public $calcgenerateidhasbeenadded = false;
!     public $virtualqtype = false;
! 
!     function name() {
!         return 'calculatedmulti';
!     }
! 
!     function has_wildcards_in_responses($question, $subqid) {
!         return true;
!     }
! 
!     function requires_qtypes() {
!         return array('multichoice');
!     }
! 
! 
!     function save_question_options($question) {
!         global $CFG, $DB, $QTYPES ;
!         $context = $question->context;
!         if (isset($question->answer) && !isset($question->answers)) {
!             $question->answers = $question->answer;
!         }
!         // calculated options
!         $update = true ;
!         $options = $DB->get_record("question_calculated_options", array("question" => $question->id));
!         if (!$options) {
!             $update = false;
!             $options = new stdClass;
!             $options->question = $question->id;
!         }
!         $options->synchronize = $question->synchronize;
!         $options->single = $question->single;
!         $options->answernumbering = $question->answernumbering;
!         $options->shuffleanswers = $question->shuffleanswers;
! 
!         // save question feedback files
!         foreach (array('correct', 'partiallycorrect', 'incorrect') as $feedbacktype) {
!             $feedbackname = $feedbacktype . 'feedback';
!             $feedbackformat = $feedbackname . 'format';
!             $feedback = $question->$feedbackname;
!             $options->$feedbackformat = $feedback['format'];
!             if (isset($feedback['files'])) {
!                 $options->$feedbackname = trim($feedback['text']);
!                 $files = $feedback['files'];
!                 foreach ($files as $file) {
!                     $this->import_file($question->context, 'qtype_calculatedmulti', $feedbackname, $question->id, $file);
!                 }
!             } else {
!                 $options->$feedbackname = file_save_draft_area_files($feedback['itemid'], $context->id, 'qtype_calculatedmulti', $feedbackname, $question->id, $this->fileoptionsa , trim($feedback['text']));
!             }
!         }
! 
!         if ($update) {
!             $DB->update_record("question_calculated_options", $options);
!         } else {
!             $DB->insert_record("question_calculated_options", $options);
!         }
! 
!         // Get old versions of the objects
!         if (!$oldanswers = $DB->get_records('question_answers', array('question' => $question->id), 'id ASC')) {
!             $oldanswers = array();
!         }
! 
!         if (!$oldoptions = $DB->get_records('question_calculated', array('question' => $question->id), 'answer ASC')) {
!             $oldoptions = array();
!         }
! 
!         // Save the units.
!         $virtualqtype = $this->get_virtual_qtype($question);
!         // TODO: What is this?
!         // $result = $virtualqtype->save_numerical_units($question);
!         if (isset($result->error)) {
!             return $result;
!         } else {
!             $units = &$result->units;
!         }
!         // Insert all the new answers
!         if (isset($question->answer) && !isset($question->answers)) {
!             $question->answers = $question->answer;
!         }
!         foreach ($question->answers as $key => $dataanswer) {
!             if (is_array($dataanswer)) {
!                 $dataanswer = $dataanswer['text'];
!             }
!             if ( trim($dataanswer) != '' ) {
!                 $answer = new stdClass;
!                 $answer->question = $question->id;
!                 $answer->answer = trim($dataanswer);
!                 $answer->fraction = $question->fraction[$key];
!                 $answer->feedback = trim($question->feedback[$key]['text']);
!                 $answer->feedbackformat = $question->feedback[$key]['format'];
!                 if (isset($question->feedback[$key]['files'])) {
!                     $files = $question->feedback[$key]['files'];
!                 }
! 
!                 if ($oldanswer = array_shift($oldanswers)) {  // Existing answer, so reuse it
!                     $answer->id = $oldanswer->id;
!                     $answer->feedback = file_save_draft_area_files($question->feedback[$key]['itemid'], $context->id, 'question', 'answerfeedback', $answer->id, $this->fileoptionsa, $answer->feedback);
!                     $DB->update_record("question_answers", $answer);
!                 } else { // This is a completely new answer
!                     $answer->id = $DB->insert_record("question_answers", $answer);
!                     if (isset($files)) {
!                         $feedbacktext = $answer->feedback;
!                         foreach ($files as $file) {
!                             $this->import_file($context, 'question', 'answerfeedback', $answer->id, $file);
!                         }
!                     } else {
!                         $feedbacktext = file_save_draft_area_files($question->feedback[$key]['itemid'], $context->id, 'question', 'answerfeedback', $answer->id, $this->fileoptionsa, $answer->feedback);
!                     }
!                     $DB->set_field('question_answers', 'feedback', $feedbacktext, array('id'=>$answer->id));
!                 }
! 
!                 // Set up the options object
!                 if (!$options = array_shift($oldoptions)) {
!                     $options = new stdClass;
!                 }
!                 $options->question  = $question->id;
!                 $options->answer    = $answer->id;
!                 $options->tolerance = trim($question->tolerance[$key]);
!                 $options->tolerancetype  = trim($question->tolerancetype[$key]);
!                 $options->correctanswerlength  = trim($question->correctanswerlength[$key]);
!                 $options->correctanswerformat  = trim($question->correctanswerformat[$key]);
! 
!                 // Save options
!                 if (isset($options->id)) { // reusing existing record
!                     $DB->update_record('question_calculated', $options);
!                 } else { // new options
!                     $DB->insert_record('question_calculated', $options);
!                 }
!             }
!         }
!         // delete old answer records
!         if (!empty($oldanswers)) {
!             foreach($oldanswers as $oa) {
!                 $DB->delete_records('question_answers', array('id' => $oa->id));
!             }
!         }
! 
!         // delete old answer records
!         if (!empty($oldoptions)) {
!             foreach($oldoptions as $oo) {
!                 $DB->delete_records('question_calculated', array('id' => $oo->id));
!             }
!         }
! 
! 
!         if( isset($question->import_process)&&$question->import_process){
!             $this->import_datasets($question);
!         }
!         // Report any problems.
!         if (!empty($result->notice)) {
!             return $result;
!         }
!         return true;
!     }
! 
!     function create_session_and_responses(&$question, &$state, $cmoptions, $attempt) {
!         // Find out how many datasets are available
!         global $CFG, $DB, $QTYPES, $OUTPUT ;
!         $maxnumber = (int)$DB->get_field_sql(
              "SELECT MIN(a.itemcount)
                 FROM {question_dataset_definitions} a, {question_datasets} b
                WHERE b.question = ? AND a.id = b.datasetdefinition", array($question->id));
!         if (!$maxnumber) {
!             print_error('cannotgetdsforquestion', 'question', '', $question->id);
!         }
!         $sql = "SELECT i.*
                    FROM {question_datasets} d, {question_dataset_definitions} i
                   WHERE d.question = ? AND d.datasetdefinition = i.id AND i.category != 0";
!         if (!$question->options->synchronize || !$records = $DB->get_records_sql($sql, array($question->id))) {
!             $synchronize_calculated  =  false ;
!         } else {
!             // i.e records is true so test coherence
!             $coherence = true ;
!             $a = new stdClass ;
!             $a->qid = $question->id ;
!             $a->qcat = $question->category ;
!             foreach($records as $def ){
!                 if ($def->category != $question->category){
!                     $a->name = $def->name;
!                     $a->sharedcat = $def->category ;
!                     $coherence = false ;
!                     break;
!                 }
!             }
!             if(!$coherence){
!                 echo $OUTPUT->notification(get_string('nocoherencequestionsdatyasetcategory','qtype_calculated',$a));
!             }
! 
!             $synchronize_calculated  = true ;
!         }
! 
!         // Choose a random dataset
!         // maxnumber sould not be breater than 100
!         if ($maxnumber > CALCULATEDQUESTIONMAXITEMNUMBER ){
!             $maxnumber = CALCULATEDQUESTIONMAXITEMNUMBER ;
!         }
!         if ( $synchronize_calculated === false ) {
!             $state->options->datasetitem = rand(1, $maxnumber);
!         }else{
!             $state->options->datasetitem = intval( $maxnumber * substr($attempt->timestart,-2) /100 ) ;
!             if ($state->options->datasetitem < 1) {
!                 $state->options->datasetitem =1 ;
!             } else if ($state->options->datasetitem > $maxnumber){
!                 $state->options->datasetitem = $maxnumber ;
!             }
! 
!         };
!         $state->options->dataset =
!             $this->pick_question_dataset($question,$state->options->datasetitem);
!         // create an array of answerids ??? why so complicated ???
!         $answerids = array_values(array_map(create_function('$val',
              'return $val->id;'), $question->options->answers));
!         // Shuffle the answers if required
!         if (!empty($cmoptions->shuffleanswers) and !empty($question->options->shuffleanswers)) {
!             $answerids = swapshuffle($answerids);
!         }
!         $state->options->order = $answerids;
!         // Create empty responses
!         if ($question->options->single) {
!             $state->responses = array('' => '');
!         } else {
!             $state->responses = array();
!         }
!         return true;
!     }
! 
!     function save_session_and_responses(&$question, &$state) {
!         global $DB;
!         $responses = 'dataset'.$state->options->datasetitem.'-' ;
!         $responses .= implode(',', $state->options->order) . ':';
!         $responses .= implode(',', $state->responses);
! 
!         // Set the legacy answer field
!         $DB->set_field('question_states', 'answer', $responses, array('id'=> $state->id));
!         return true;
!     }
! 
!     function create_runtime_question($question, $form) {
!         $question = default_questiontype::create_runtime_question($question, $form);
!         $question->options->answers = array();
!         foreach ($form->answers as $key => $answer) {
!             $a->answer              = trim($form->answer[$key]);
!             $a->fraction              = $form->fraction[$key];//new
!             $a->tolerance           = $form->tolerance[$key];
!             $a->tolerancetype       = $form->tolerancetype[$key];
!             $a->correctanswerlength = $form->correctanswerlength[$key];
!             $a->correctanswerformat = $form->correctanswerformat[$key];
!             $question->options->answers[] = clone($a);
!         }
! 
!         return $question;
!     }
! 
!     function convert_answers (&$question, &$state){
!         foreach ($question->options->answers as $key => $answer) {
!             $answer->answer = $this->substitute_variables($answer->answer, $state->options->dataset);
!             //evaluate the equations i.e {=5+4)
!             $qtext = "";
!             $qtextremaining = $answer->answer ;
!             //   while  (preg_match('~\{(=)|%[[:digit]]\.=([^[:space:]}]*)}~', $qtextremaining, $regs1)) {
!             while (preg_match('~\{=([^[:space:]}]*)}~', $qtextremaining, $regs1)) {
! 
!                 $qtextsplits = explode($regs1[0], $qtextremaining, 2);
!                 $qtext = $qtext.$qtextsplits[0];
!                 $qtextremaining = $qtextsplits[1];
!                 if (empty($regs1[1])) {
!                     $str = '';
!                 } else {
!                     if( $formulaerrors = qtype_calculated_find_formula_errors($regs1[1])){
!                         $str=$formulaerrors ;
!                     }else {
!                         eval('$str = '.$regs1[1].';');
!                         $texteval= qtype_calculated_calculate_answer(
!                             $str, $state->options->dataset, $answer->tolerance,
!                             $answer->tolerancetype, $answer->correctanswerlength,
!                             $answer->correctanswerformat, '');
!                         $str = $texteval->answer;
!                     }
!                 }
!                 $qtext = $qtext.$str ;
!             }
!             $answer->answer = $qtext.$qtextremaining ; ;
!         }
!     }
! 
!     function get_default_numerical_unit($question, $virtualqtype){
!         $unit = '';
!         return $unit ;
!     }
!     function grade_responses(&$question, &$state, $cmoptions) {
!         // Forward the grading to the virtual qtype
!         // We modify the question to look like a multichoice question
!         // for grading nothing to do
! /*        $numericalquestion = fullclone($question);
!        foreach ($numericalquestion->options->answers as $key => $answer) {
!             $answer = $numericalquestion->options->answers[$key]->answer; // for PHP 4.x
!           $numericalquestion->options->answers[$key]->answer = $this->substitute_variables_and_eval($answer,
!              $state->options->dataset);
! }*/
!         $virtualqtype = $this->get_virtual_qtype( $question);
!         return $virtualqtype->grade_responses($question, $state, $cmoptions) ;
!     }
! 
! 
! 
!     // ULPGC ecastro
!     function get_actual_response(&$question, &$state) {
!         // Substitute variables in questiontext before giving the data to the
!         // virtual type
!         $virtualqtype = $this->get_virtual_qtype( $question);
!         $unit = '' ;//$virtualqtype->get_default_numerical_unit($question);
! 
!         // We modify the question to look like a multichoice question
!         $numericalquestion = clone($question);
!         $this->convert_answers ($numericalquestion, $state);
!         $this->convert_questiontext ($numericalquestion, $state);
!      /*   $numericalquestion->questiontext = $this->substitute_variables_and_eval(
!      $numericalquestion->questiontext, $state->options->dataset);*/
!         $responses = $virtualqtype->get_all_responses($numericalquestion, $state);
!         $response = reset($responses->responses);
!         $correct = $response->answer.' : ';
! 
!         $responses = $virtualqtype->get_actual_response($numericalquestion, $state);
! 
!         foreach ($responses as $key=>$response){
!             $responses[$key] = $correct.$response;
!         }
! 
!         return $responses;
!     }
! 
!     function create_virtual_qtype() {
!         global $CFG;
!         require_once("$CFG->dirroot/question/type/multichoice/questiontype.php");
!         return new question_multichoice_qtype();
!     }
! 
! 
!     function comment_header($question) {
!         //$this->get_question_options($question);
!         $strheader = '';
!         $delimiter = '';
! 
!         $answers = $question->options->answers;
! 
!         foreach ($answers as $key => $answer) {
!             if (is_string($answer)) {
!                 $strheader .= $delimiter.$answer;
!             } else {
!                 $strheader .= $delimiter.$answer->answer;
!             }
!             $delimiter = '<br/>';
!         }
!         return $strheader;
!     }
! 
!     function comment_on_datasetitems($qtypeobj,$questionid,$questiontext, $answers,$data, $number) { //multichoice_
!         global $DB;
!         $comment = new stdClass;
!         $comment->stranswers = array();
!         $comment->outsidelimit = false ;
!         $comment->answers = array();
!         /// Find a default unit:
!     /*    if (!empty($questionid) && $unit = $DB->get_record('question_numerical_units', array('question'=> $questionid, 'multiplier' => 1.0))) {
!             $unit = $unit->unit;
!         } else {
!             $unit = '';
!     }*/
! 
!         $answers = fullclone($answers);
!         $strmin = get_string('min', 'quiz');
!         $strmax = get_string('max', 'quiz');
!         $errors = '';
!         $delimiter = ': ';
!         foreach ($answers as $key => $answer) {
!             $answer->answer = $this->substitute_variables($answer->answer, $data);
!             //evaluate the equations i.e {=5+4)
!             $qtext = "";
!             $qtextremaining = $answer->answer ;
!             while  (preg_match('~\{=([^[:space:]}]*)}~', $qtextremaining, $regs1)) {
!                 $qtextsplits = explode($regs1[0], $qtextremaining, 2);
!                 $qtext =$qtext.$qtextsplits[0];
!                 $qtextremaining = $qtextsplits[1];
!                 if (empty($regs1[1])) {
!                     $str = '';
!                 } else {
!                     if( $formulaerrors = qtype_calculated_find_formula_errors($regs1[1])){
!                         $str=$formulaerrors ;
!                     }else {
!                         eval('$str = '.$regs1[1].';');
!                     }
!                 }
!                 $qtext = $qtext.$str ;
!             }
!             $answer->answer = $qtext.$qtextremaining;
!             $comment->stranswers[$key] = $answer->answer;
! 
! 
!           /*  $formula = $this->substitute_variables($answer->answer,$data);
!             $formattedanswer = qtype_calculated_calculate_answer(
!                     $answer->answer, $data, $answer->tolerance,
!                     $answer->tolerancetype, $answer->correctanswerlength,
!                     $answer->correctanswerformat, $unit);
!                     if ( $formula === '*'){
!                         $answer->min = ' ';
!                         $formattedanswer->answer = $answer->answer ;
!                     }else {
!                         eval('$answer->answer = '.$formula.';') ;
!                         $virtualqtype->get_tolerance_interval($answer);
!                     }
!             if ($answer->min === '') {
!                 // This should mean that something is wrong
!                 $comment->stranswers[$key] = " $formattedanswer->answer".'<br/><br/>';
!             } else if ($formula === '*'){
!                 $comment->stranswers[$key] = $formula.' = '.get_string('anyvalue','qtype_calculated').'<br/><br/><br/>';
!             }else{
!                 $comment->stranswers[$key]= $formula.' = '.$formattedanswer->answer.'<br/>' ;
!                 $comment->stranswers[$key] .= $strmin. $delimiter.$answer->min.'---';
!                 $comment->stranswers[$key] .= $strmax.$delimiter.$answer->max;
!                 $comment->stranswers[$key] .='<br/>';
!                 $correcttrue->correct = $formattedanswer->answer ;
!                 $correcttrue->true = $answer->answer ;
!                 if ($formattedanswer->answer < $answer->min || $formattedanswer->answer > $answer->max){
!                     $comment->outsidelimit = true ;
!                     $comment->answers[$key] = $key;
!                     $comment->stranswers[$key] .=get_string('trueansweroutsidelimits','qtype_calculated',$correcttrue);//<span class="error">ERROR True answer '..' outside limits</span>';
!                 }else {
!                     $comment->stranswers[$key] .=get_string('trueanswerinsidelimits','qtype_calculated',$correcttrue);//' True answer :'.$calculated->trueanswer.' inside limits';
!                 }
!                 $comment->stranswers[$key] .='';
!           }*/
!         }
!         return fullclone($comment);
!     }
! 
!     function get_correct_responses1(&$question, &$state) {
!         $virtualqtype = $this->get_virtual_qtype( $question);
!     /*    if ($question->options->multichoice != 1 ) {
!             if($unit = $virtualqtype->get_default_numerical_unit($question)){
!                  $unit = $unit->unit;
!             } else {
!                 $unit = '';
!             }
!             foreach ($question->options->answers as $answer) {
!                 if (((int) $answer->fraction) === 1) {
!                     $answernumerical = qtype_calculated_calculate_answer(
!                      $answer->answer, $state->options->dataset, $answer->tolerance,
!                      $answer->tolerancetype, $answer->correctanswerlength,
!                         $answer->correctanswerformat, ''); // remove unit
!                         $correct = array('' => $answernumerical->answer);
!                         $correct['answer']= $correct[''];
!                     if (isset($correct['']) && $correct[''] != '*' && $unit ) {
!                             $correct[''] .= ' '.$unit;
!                             $correct['unit']= $unit;
!                     }
!                     return $correct;
!                 }
!             }
!     }else{**/
!         return $virtualqtype->get_correct_responses($question, $state) ;
!         // }
!         return null;
!     }
! 
!     function get_virtual_qtype() {
!         global $QTYPES;
!         //    if ( isset($question->options->multichoice) && $question->options->multichoice == '1'){
!         $this->virtualqtype =& $QTYPES['multichoice'];
!         //   }else {
!         //       $this->virtualqtype =& $QTYPES['numerical'];
!         //   }
!         return $this->virtualqtype;
!     }
! 
! 
!     /**
!      * Runs all the code required to set up and save an essay question for testing purposes.
!      * Alternate DB table prefix may be used to facilitate data deletion.
!      */
!     function generate_test($name, $courseid = null) {
!         global $DB;
!         list($form, $question) = parent::generate_test($name, $courseid);
!         $form->feedback = 1;
!         $form->multiplier = array(1, 1);
!         $form->shuffleanswers = 1;
!         $form->noanswers = 1;
!         $form->qtype ='calculatedmulti';
!         $question->qtype ='calculatedmulti';
!         $form->answers = array('{a} + {b}');
!         $form->fraction = array(1);
!         $form->tolerance = array(0.01);
!         $form->tolerancetype = array(1);
!         $form->correctanswerlength = array(2);
!         $form->correctanswerformat = array(1);
!         $form->questiontext = "What is {a} + {b}?";
! 
!         if ($courseid) {
!             $course = $DB->get_record('course', array('id'=> $courseid));
!         }
! 
!         $new_question = $this->save_question($question, $form);
! 
!         $dataset_form = new stdClass();
!         $dataset_form->nextpageparam["forceregeneration"]= 1;
!         $dataset_form->calcmin = array(1 => 1.0, 2 => 1.0);
!         $dataset_form->calcmax = array(1 => 10.0, 2 => 10.0);
!         $dataset_form->calclength = array(1 => 1, 2 => 1);
!         $dataset_form->number = array(1 => 5.4 , 2 => 4.9);
!         $dataset_form->itemid = array(1 => '' , 2 => '');
!         $dataset_form->calcdistribution = array(1 => 'uniform', 2 => 'uniform');
!         $dataset_form->definition = array(1 => "1-0-a",
!             2 => "1-0-b");
!         $dataset_form->nextpageparam = array('forceregeneration' => false);
!         $dataset_form->addbutton = 1;
!         $dataset_form->selectadd = 1;
!         $dataset_form->courseid = $courseid;
!         $dataset_form->cmid = 0;
!         $dataset_form->id = $new_question->id;
!         $this->save_dataset_items($new_question, $dataset_form);
! 
!         return $new_question;
!     }
! 
!     function move_files($questionid, $oldcontextid, $newcontextid) {
!         $fs = get_file_storage();
! 
!         parent::move_files($questionid, $oldcontextid, $newcontextid);
!         $this->move_files_in_answers($questionid, $oldcontextid, $newcontextid, true);
! 
!         $fs->move_area_files_to_new_context($oldcontextid,
!                 $newcontextid, 'qtype_calculatedmulti', 'correctfeedback', $questionid);
!         $fs->move_area_files_to_new_context($oldcontextid,
!                 $newcontextid, 'qtype_calculatedmulti', 'partiallycorrectfeedback', $questionid);
!         $fs->move_area_files_to_new_context($oldcontextid,
!                 $newcontextid, 'qtype_calculatedmulti', 'incorrectfeedback', $questionid);
!     }
! 
!     protected function delete_files($questionid, $contextid) {
!         $fs = get_file_storage();
! 
!         parent::delete_files($questionid, $contextid);
!         $this->delete_files_in_answers($questionid, $contextid, true);
!         $fs->delete_area_files($contextid, 'qtype_calculatedmulti', 'correctfeedback', $questionid);
!         $fs->delete_area_files($contextid, 'qtype_calculatedmulti', 'partiallycorrectfeedback', $questionid);
!         $fs->delete_area_files($contextid, 'qtype_calculatedmulti', 'incorrectfeedback', $questionid);
!     }
! 
!     function check_file_access($question, $state, $options, $contextid, $component,
!             $filearea, $args) {
!         $itemid = reset($args);
! 
!         if (empty($question->maxgrade)) {
!             $question->maxgrade = $question->defaultgrade;
!         }
! 
!         if (in_array($filearea, array('correctfeedback', 'partiallycorrectfeedback', 'incorrectfeedback'))) {
!             $result = $options->feedback && ($itemid == $question->id);
!             if (!$result) {
!                 return false;
!             }
!             if ($state->raw_grade >= $question->maxgrade/1.01) {
!                 $feedbacktype = 'correctfeedback';
!             } else if ($state->raw_grade > 0) {
!                 $feedbacktype = 'partiallycorrectfeedback';
!             } else {
!                 $feedbacktype = 'incorrectfeedback';
!             }
!             if ($feedbacktype != $filearea) {
!                 return false;
!             }
!             return true;
!         } else if ($component == 'question' && $filearea == 'answerfeedback') {
!             return $options->feedback && (array_key_exists($itemid, $question->options->answers));
!         } else {
!             return parent::check_file_access($question, $state, $options, $contextid, $component,
!                     $filearea, $args);
!         }
!     }
  }
  
  //// END OF CLASS ////
--- 24,609 ----
  class question_calculatedmulti_qtype extends question_calculated_qtype {
  
  
! 	// Used by the function custom_generator_tools:
! 	public $calcgenerateidhasbeenadded = false;
! 	public $virtualqtype = false;
! 
! 	function name() {
! 		return 'calculatedmulti';
! 	}
! 
! 	function has_wildcards_in_responses($question, $subqid) {
! 		return true;
! 	}
! 
! 	function requires_qtypes() {
! 		return array('multichoice');
! 	}
! 
! 
! 	function save_question_options($question) {
! 		global $CFG, $DB, $QTYPES ;
! 		$context = $question->context;
! 		if (isset($question->answer) && !isset($question->answers)) {
! 			$question->answers = $question->answer;
! 		}
! 		// calculated options
! 		$update = true ;
! 		$options = $DB->get_record("question_calculated_options", array("question" => $question->id));
! 		if (!$options) {
! 			$update = false;
! 			$options = new stdClass;
! 			$options->question = $question->id;
! 		}
! 		$options->synchronize = $question->synchronize;
! 		$options->single = $question->single;
! 		$options->answernumbering = $question->answernumbering;
! 		$options->shuffleanswers = $question->shuffleanswers;
! 
! 		// save question feedback files
! 		foreach (array('correct', 'partiallycorrect', 'incorrect') as $feedbacktype) {
! 			$feedbackname = $feedbacktype . 'feedback';
! 			$feedbackformat = $feedbackname . 'format';
! 			$feedback = $question->$feedbackname;
! 			$options->$feedbackformat = $feedback['format'];
! 			if (isset($feedback['files'])) {
! 				$options->$feedbackname = trim($feedback['text']);
! 				$files = $feedback['files'];
! 				foreach ($files as $file) {
! 					$this->import_file($question->context, 'qtype_calculatedmulti', $feedbackname, $question->id, $file);
! 				}
! 			} else {
! 				$options->$feedbackname = file_save_draft_area_files($feedback['itemid'], $context->id, 'qtype_calculatedmulti', $feedbackname, $question->id, $this->fileoptionsa , trim($feedback['text']));
! 			}
! 		}
! 
! 		if ($update) {
! 			$DB->update_record("question_calculated_options", $options);
! 		} else {
! 			$DB->insert_record("question_calculated_options", $options);
! 		}
! 
! 		// Get old versions of the objects
! 		if (!$oldanswers = $DB->get_records('question_answers', array('question' => $question->id), 'id ASC')) {
! 			$oldanswers = array();
! 		}
! 
! 		if (!$oldoptions = $DB->get_records('question_calculated', array('question' => $question->id), 'answer ASC')) {
! 			$oldoptions = array();
! 		}
! 
! 		// Save the units.
! 		$virtualqtype = $this->get_virtual_qtype($question);
! 		// TODO: What is this?
! 		// $result = $virtualqtype->save_numerical_units($question);
! 		if (isset($result->error)) {
! 			return $result;
! 		} else {
! 			$units = &$result->units;
! 		}
! 		// Insert all the new answers
! 		if (isset($question->answer) && !isset($question->answers)) {
! 			$question->answers = $question->answer;
! 		}
! 		foreach ($question->answers as $key => $dataanswer) {
! 			if (is_array($dataanswer)) {
! 				$dataanswer = $dataanswer['text'];
! 			}
! 			if ( trim($dataanswer) != '' ) {
! 				$answer = new stdClass;
! 				$answer->question = $question->id;
! 				$answer->answer = trim($dataanswer);
! 				$answer->fraction = $question->fraction[$key];
! 				$answer->feedback = trim($question->feedback[$key]['text']);
! 				$answer->feedbackformat = $question->feedback[$key]['format'];
! 				if (isset($question->feedback[$key]['files'])) {
! 					$files = $question->feedback[$key]['files'];
! 				}
! 
! 				if ($oldanswer = array_shift($oldanswers)) {  // Existing answer, so reuse it
! 					$answer->id = $oldanswer->id;
! 					$answer->feedback = file_save_draft_area_files($question->feedback[$key]['itemid'], $context->id, 'question', 'answerfeedback', $answer->id, $this->fileoptionsa, $answer->feedback);
! 					$DB->update_record("question_answers", $answer);
! 				} else { // This is a completely new answer
! 					$answer->id = $DB->insert_record("question_answers", $answer);
! 					if (isset($files)) {
! 						$feedbacktext = $answer->feedback;
! 						foreach ($files as $file) {
! 							$this->import_file($context, 'question', 'answerfeedback', $answer->id, $file);
! 						}
! 					} else {
! 						$feedbacktext = file_save_draft_area_files($question->feedback[$key]['itemid'], $context->id, 'question', 'answerfeedback', $answer->id, $this->fileoptionsa, $answer->feedback);
! 					}
! 					$DB->set_field('question_answers', 'feedback', $feedbacktext, array('id'=>$answer->id));
! 				}
! 
! 				// Set up the options object
! 				if (!$options = array_shift($oldoptions)) {
! 					$options = new stdClass;
! 				}
! 				$options->question  = $question->id;
! 				$options->answer    = $answer->id;
! 				$options->tolerance = trim($question->tolerance[$key]);
! 				$options->tolerancetype  = trim($question->tolerancetype[$key]);
! 				$options->correctanswerlength  = trim($question->correctanswerlength[$key]);
! 				$options->correctanswerformat  = trim($question->correctanswerformat[$key]);
! 
! 				// Save options
! 				if (isset($options->id)) { // reusing existing record
! 					$DB->update_record('question_calculated', $options);
! 				} else { // new options
! 					$DB->insert_record('question_calculated', $options);
! 				}
! 			}
! 		}
! 		// delete old answer records
! 		if (!empty($oldanswers)) {
! 			foreach($oldanswers as $oa) {
! 				$DB->delete_records('question_answers', array('id' => $oa->id));
! 			}
! 		}
! 
! 		// delete old answer records
! 		if (!empty($oldoptions)) {
! 			foreach($oldoptions as $oo) {
! 				$DB->delete_records('question_calculated', array('id' => $oo->id));
! 			}
! 		}
! 
! 
! 		if( isset($question->import_process)&&$question->import_process){
! 			$this->import_datasets($question);
! 		}
! 		// Report any problems.
! 		if (!empty($result->notice)) {
! 			return $result;
! 		}
! 		return true;
! 	}
! 
! 	function create_session_and_responses(&$question, &$state, $cmoptions, $attempt) {
! 		// Find out how many datasets are available
! 		global $CFG, $DB, $QTYPES, $OUTPUT ;
! 		$maxnumber = (int)$DB->get_field_sql(
              "SELECT MIN(a.itemcount)
                 FROM {question_dataset_definitions} a, {question_datasets} b
                WHERE b.question = ? AND a.id = b.datasetdefinition", array($question->id));
! 		if (!$maxnumber) {
! 			print_error('cannotgetdsforquestion', 'question', '', $question->id);
! 		}
! 		$sql = "SELECT i.*
                    FROM {question_datasets} d, {question_dataset_definitions} i
                   WHERE d.question = ? AND d.datasetdefinition = i.id AND i.category != 0";
! 		if (!$question->options->synchronize || !$records = $DB->get_records_sql($sql, array($question->id))) {
! 			$synchronize_calculated  =  false ;
! 		} else {
! 			// i.e records is true so test coherence
! 			$coherence = true ;
! 			$a = new stdClass ;
! 			$a->qid = $question->id ;
! 			$a->qcat = $question->category ;
! 			foreach($records as $def ){
! 				if ($def->category != $question->category){
! 					$a->name = $def->name;
! 					$a->sharedcat = $def->category ;
! 					$coherence = false ;
! 					break;
! 				}
! 			}
! 			if(!$coherence){
! 				echo $OUTPUT->notification(get_string('nocoherencequestionsdatyasetcategory','qtype_calculated',$a));
! 			}
! 
! 			$synchronize_calculated  = true ;
! 		}
! 
! 		// Choose a random dataset
! 		// maxnumber sould not be breater than 100
! 		if ($maxnumber > CALCULATEDQUESTIONMAXITEMNUMBER ){
! 			$maxnumber = CALCULATEDQUESTIONMAXITEMNUMBER ;
! 		}
! 		if ( $synchronize_calculated === false ) {
! 			$state->options->datasetitem = rand(1, $maxnumber);
! 		}else{
! 			$state->options->datasetitem = intval( $maxnumber * substr($attempt->timestart,-2) /100 ) ;
! 			if ($state->options->datasetitem < 1) {
! 				$state->options->datasetitem =1 ;
! 			} else if ($state->options->datasetitem > $maxnumber){
! 				$state->options->datasetitem = $maxnumber ;
! 			}
! 
! 		};
! 		$state->options->dataset =
! 		$this->pick_question_dataset($question,$state->options->datasetitem);
! 		// create an array of answerids ??? why so complicated ???
! 		$answerids = array_values(array_map(create_function('$val',
              'return $val->id;'), $question->options->answers));
! 		// Shuffle the answers if required
! 		if (!empty($cmoptions->shuffleanswers) and !empty($question->options->shuffleanswers)) {
! 			$answerids = swapshuffle($answerids);
! 		}
! 		$state->options->order = $answerids;
! 		// Create empty responses
! 		if ($question->options->single) {
! 			$state->responses = array('' => '');
! 		} else {
! 			$state->responses = array();
! 		}
! 		return true;
! 	}
! 
! 	function save_session_and_responses(&$question, &$state) {
! 		global $DB;
! 		$responses = 'dataset'.$state->options->datasetitem.'-' ;
! 		$responses .= implode(',', $state->options->order) . ':';
! 		$responses .= implode(',', $state->responses);
! 
! 		// Set the legacy answer field
! 		$DB->set_field('question_states', 'answer', $responses, array('id'=> $state->id));
! 		return true;
! 	}
! 
! 	function create_runtime_question($question, $form) {
! 		$question = default_questiontype::create_runtime_question($question, $form);
! 		$question->options->answers = array();
! 		foreach ($form->answers as $key => $answer) {
! 			$a->answer              = trim($form->answer[$key]);
! 			$a->fraction              = $form->fraction[$key];//new
! 			$a->tolerance           = $form->tolerance[$key];
! 			$a->tolerancetype       = $form->tolerancetype[$key];
! 			$a->correctanswerlength = $form->correctanswerlength[$key];
! 			$a->correctanswerformat = $form->correctanswerformat[$key];
! 			$question->options->answers[] = clone($a);
! 		}
! 
! 		return $question;
! 	}
! 
! 	function convert_answers (&$question, &$state){
! 		foreach ($question->options->answers as $key => $answer) {
! 			$answer->answer = $this->substitute_variables($answer->answer, $state->options->dataset);
! 			//evaluate the equations i.e {=5+4)
! 			$qtext = "";
! 			$qtextremaining = $answer->answer ;
! 			//   while  (preg_match('~\{(=)|%[[:digit]]\.=([^[:space:]}]*)}~', $qtextremaining, $regs1)) {
! 			while (preg_match('~\{=([^[:space:]}]*)}~', $qtextremaining, $regs1)) {
! 
! 				$qtextsplits = explode($regs1[0], $qtextremaining, 2);
! 				$qtext = $qtext.$qtextsplits[0];
! 				$qtextremaining = $qtextsplits[1];
! 				if (empty($regs1[1])) {
! 					$str = '';
! 				} else {
! 					if( $formulaerrors = qtype_calculated_find_formula_errors($regs1[1])){
! 						$str=$formulaerrors ;
! 					}else {
! 						eval('$str = '.$regs1[1].';');
! 						$texteval= qtype_calculated_calculate_answer(
! 						$str, $state->options->dataset, $answer->tolerance,
! 						$answer->tolerancetype, $answer->correctanswerlength,
! 						$answer->correctanswerformat, '');
! 						$str = $texteval->answer;
! 					}
! 				}
! 				$qtext = $qtext.$str ;
! 			}
! 			$answer->answer = $qtext.$qtextremaining ; ;
! 		}
! 	}
! 
! 	function get_default_numerical_unit($question, $virtualqtype){
! 		$unit = '';
! 		return $unit ;
! 	}
! 	function grade_responses(&$question, &$state, $cmoptions) {
! 		// Forward the grading to the virtual qtype
! 		// We modify the question to look like a multichoice question
! 		// for grading nothing to do
! 		/*        $numericalquestion = fullclone($question);
! 		foreach ($numericalquestion->options->answers as $key => $answer) {
! 		$answer = $numericalquestion->options->answers[$key]->answer; // for PHP 4.x
! 		$numericalquestion->options->answers[$key]->answer = $this->substitute_variables_and_eval($answer,
! 		$state->options->dataset);
! 		}*/
! 		$virtualqtype = $this->get_virtual_qtype( $question);
! 		return $virtualqtype->grade_responses($question, $state, $cmoptions) ;
! 	}
! 
! 
! 
! 	// ULPGC ecastro
! 	function get_actual_response(&$question, &$state) {
! 		// Substitute variables in questiontext before giving the data to the
! 		// virtual type
! 		$virtualqtype = $this->get_virtual_qtype( $question);
! 		$unit = '' ;//$virtualqtype->get_default_numerical_unit($question);
! 
! 		// We modify the question to look like a multichoice question
! 		$numericalquestion = clone($question);
! 		$this->convert_answers ($numericalquestion, $state);
! 		$this->convert_questiontext ($numericalquestion, $state);
! 		/*   $numericalquestion->questiontext = $this->substitute_variables_and_eval(
! 		 $numericalquestion->questiontext, $state->options->dataset);*/
! 		$responses = $virtualqtype->get_all_responses($numericalquestion, $state);
! 		$response = reset($responses->responses);
! 		$correct = $response->answer.' : ';
! 
! 		$responses = $virtualqtype->get_actual_response($numericalquestion, $state);
! 
! 		foreach ($responses as $key=>$response){
! 			$responses[$key] = $correct.$response;
! 		}
! 
! 		return $responses;
! 	}
! 
! 	function create_virtual_qtype() {
! 		global $CFG;
! 		require_once("$CFG->dirroot/question/type/multichoice/questiontype.php");
! 		return new question_multichoice_qtype();
! 	}
! 
! 
! 	function comment_header($question) {
! 		//$this->get_question_options($question);
! 		$strheader = '';
! 		$delimiter = '';
! 
! 		$answers = $question->options->answers;
! 
! 		foreach ($answers as $key => $answer) {
! 			if (is_string($answer)) {
! 				$strheader .= $delimiter.$answer;
! 			} else {
! 				$strheader .= $delimiter.$answer->answer;
! 			}
! 			$delimiter = '<br/>';
! 		}
! 		return $strheader;
! 	}
! 
! 	function comment_on_datasetitems($qtypeobj,$questionid,$questiontext, $answers,$data, $number) { //multichoice_
! 		global $DB;
! 		$comment = new stdClass;
! 		$comment->stranswers = array();
! 		$comment->outsidelimit = false ;
! 		$comment->answers = array();
! 		/// Find a default unit:
! 		/*    if (!empty($questionid) && $unit = $DB->get_record('question_numerical_units', array('question'=> $questionid, 'multiplier' => 1.0))) {
! 		$unit = $unit->unit;
! 		} else {
! 		$unit = '';
! 		}*/
! 
! 		$answers = fullclone($answers);
! 		$strmin = get_string('min', 'quiz');
! 		$strmax = get_string('max', 'quiz');
! 		$errors = '';
! 		$delimiter = ': ';
! 		foreach ($answers as $key => $answer) {
! 			$answer->answer = $this->substitute_variables($answer->answer, $data);
! 			//evaluate the equations i.e {=5+4)
! 			$qtext = "";
! 			$qtextremaining = $answer->answer ;
! 			while  (preg_match('~\{=([^[:space:]}]*)}~', $qtextremaining, $regs1)) {
! 				$qtextsplits = explode($regs1[0], $qtextremaining, 2);
! 				$qtext =$qtext.$qtextsplits[0];
! 				$qtextremaining = $qtextsplits[1];
! 				if (empty($regs1[1])) {
! 					$str = '';
! 				} else {
! 					if( $formulaerrors = qtype_calculated_find_formula_errors($regs1[1])){
! 						$str=$formulaerrors ;
! 					}else {
! 						eval('$str = '.$regs1[1].';');
! 					}
! 				}
! 				$qtext = $qtext.$str ;
! 			}
! 			$answer->answer = $qtext.$qtextremaining;
! 			$comment->stranswers[$key] = $answer->answer;
! 
! 
! 			/*  $formula = $this->substitute_variables($answer->answer,$data);
! 			 $formattedanswer = qtype_calculated_calculate_answer(
! 			 $answer->answer, $data, $answer->tolerance,
! 			 $answer->tolerancetype, $answer->correctanswerlength,
! 			 $answer->correctanswerformat, $unit);
! 			 if ( $formula === '*'){
! 			 $answer->min = ' ';
! 			 $formattedanswer->answer = $answer->answer ;
! 			 }else {
! 			 eval('$answer->answer = '.$formula.';') ;
! 			 $virtualqtype->get_tolerance_interval($answer);
! 			 }
! 			 if ($answer->min === '') {
! 			 // This should mean that something is wrong
! 			 $comment->stranswers[$key] = " $formattedanswer->answer".'<br/><br/>';
! 			 } else if ($formula === '*'){
! 			 $comment->stranswers[$key] = $formula.' = '.get_string('anyvalue','qtype_calculated').'<br/><br/><br/>';
! 			 }else{
! 			 $comment->stranswers[$key]= $formula.' = '.$formattedanswer->answer.'<br/>' ;
! 			 $comment->stranswers[$key] .= $strmin. $delimiter.$answer->min.'---';
! 			 $comment->stranswers[$key] .= $strmax.$delimiter.$answer->max;
! 			 $comment->stranswers[$key] .='<br/>';
! 			 $correcttrue->correct = $formattedanswer->answer ;
! 			 $correcttrue->true = $answer->answer ;
! 			 if ($formattedanswer->answer < $answer->min || $formattedanswer->answer > $answer->max){
! 			 $comment->outsidelimit = true ;
! 			 $comment->answers[$key] = $key;
! 			 $comment->stranswers[$key] .=get_string('trueansweroutsidelimits','qtype_calculated',$correcttrue);//<span class="error">ERROR True answer '..' outside limits</span>';
! 			 }else {
! 			 $comment->stranswers[$key] .=get_string('trueanswerinsidelimits','qtype_calculated',$correcttrue);//' True answer :'.$calculated->trueanswer.' inside limits';
! 			 }
! 			 $comment->stranswers[$key] .='';
! 			 }*/
! 		}
! 		return fullclone($comment);
! 	}
! 
! 	function get_correct_responses1(&$question, &$state) {
! 		$virtualqtype = $this->get_virtual_qtype( $question);
! 		/*    if ($question->options->multichoice != 1 ) {
! 		 if($unit = $virtualqtype->get_default_numerical_unit($question)){
! 		 $unit = $unit->unit;
! 		 } else {
! 		 $unit = '';
! 		 }
! 		 foreach ($question->options->answers as $answer) {
! 		 if (((int) $answer->fraction) === 1) {
! 		 $answernumerical = qtype_calculated_calculate_answer(
! 		 $answer->answer, $state->options->dataset, $answer->tolerance,
! 		 $answer->tolerancetype, $answer->correctanswerlength,
! 		 $answer->correctanswerformat, ''); // remove unit
! 		 $correct = array('' => $answernumerical->answer);
! 		 $correct['answer']= $correct[''];
! 		 if (isset($correct['']) && $correct[''] != '*' && $unit ) {
! 		 $correct[''] .= ' '.$unit;
! 		 $correct['unit']= $unit;
! 		 }
! 		 return $correct;
! 		 }
! 		 }
! 		 }else{**/
! 		return $virtualqtype->get_correct_responses($question, $state) ;
! 		// }
! 		return null;
! 	}
! 
! 	function get_virtual_qtype() {
! 		global $QTYPES;
! 		//    if ( isset($question->options->multichoice) && $question->options->multichoice == '1'){
! 		$this->virtualqtype =& $QTYPES['multichoice'];
! 		//   }else {
! 		//       $this->virtualqtype =& $QTYPES['numerical'];
! 		//   }
! 		return $this->virtualqtype;
! 	}
! 
! 
! 	/**
! 	 * Runs all the code required to set up and save an essay question for testing purposes.
! 	 * Alternate DB table prefix may be used to facilitate data deletion.
! 	 */
! 	function generate_test($name, $courseid = null) {
! 		global $DB;
! 		list($form, $question) = parent::generate_test($name, $courseid);
! 		$form->feedback = 1;
! 		$form->multiplier = array(1, 1);
! 		$form->shuffleanswers = 1;
! 		$form->noanswers = 1;
! 		$form->qtype ='calculatedmulti';
! 		$question->qtype ='calculatedmulti';
! 		$form->answers = array('{a} + {b}');
! 		$form->fraction = array(1);
! 		$form->tolerance = array(0.01);
! 		$form->tolerancetype = array(1);
! 		$form->correctanswerlength = array(2);
! 		$form->correctanswerformat = array(1);
! 		$form->questiontext = "What is {a} + {b}?";
! 
! 		if ($courseid) {
! 			$course = $DB->get_record('course', array('id'=> $courseid));
! 		}
! 
! 		$new_question = $this->save_question($question, $form);
! 
! 		$dataset_form = new stdClass();
! 		$dataset_form->nextpageparam["forceregeneration"]= 1;
! 		$dataset_form->calcmin = array(1 => 1.0, 2 => 1.0);
! 		$dataset_form->calcmax = array(1 => 10.0, 2 => 10.0);
! 		$dataset_form->calclength = array(1 => 1, 2 => 1);
! 		$dataset_form->number = array(1 => 5.4 , 2 => 4.9);
! 		$dataset_form->itemid = array(1 => '' , 2 => '');
! 		$dataset_form->calcdistribution = array(1 => 'uniform', 2 => 'uniform');
! 		$dataset_form->definition = array(1 => "1-0-a",
! 		2 => "1-0-b");
! 		$dataset_form->nextpageparam = array('forceregeneration' => false);
! 		$dataset_form->addbutton = 1;
! 		$dataset_form->selectadd = 1;
! 		$dataset_form->courseid = $courseid;
! 		$dataset_form->cmid = 0;
! 		$dataset_form->id = $new_question->id;
! 		$this->save_dataset_items($new_question, $dataset_form);
! 
! 		return $new_question;
! 	}
! 
! 	function move_files($questionid, $oldcontextid, $newcontextid) {
! 		$fs = get_file_storage();
! 
! 		parent::move_files($questionid, $oldcontextid, $newcontextid);
! 		$this->move_files_in_answers($questionid, $oldcontextid, $newcontextid, true);
! 
! 		$fs->move_area_files_to_new_context($oldcontextid,
! 		$newcontextid, 'qtype_calculatedmulti', 'correctfeedback', $questionid);
! 		$fs->move_area_files_to_new_context($oldcontextid,
! 		$newcontextid, 'qtype_calculatedmulti', 'partiallycorrectfeedback', $questionid);
! 		$fs->move_area_files_to_new_context($oldcontextid,
! 		$newcontextid, 'qtype_calculatedmulti', 'incorrectfeedback', $questionid);
! 	}
! 
! 	protected function delete_files($questionid, $contextid) {
! 		$fs = get_file_storage();
! 
! 		parent::delete_files($questionid, $contextid);
! 		$this->delete_files_in_answers($questionid, $contextid, true);
! 		$fs->delete_area_files($contextid, 'qtype_calculatedmulti', 'correctfeedback', $questionid);
! 		$fs->delete_area_files($contextid, 'qtype_calculatedmulti', 'partiallycorrectfeedback', $questionid);
! 		$fs->delete_area_files($contextid, 'qtype_calculatedmulti', 'incorrectfeedback', $questionid);
! 	}
! 
! 	function check_file_access($question, $state, $options, $contextid, $component,
! 	$filearea, $args) {
! 		$itemid = reset($args);
! 
! 		if (empty($question->maxgrade)) {
! 			$question->maxgrade = $question->defaultgrade;
! 		}
! 
! 		if (in_array($filearea, array('correctfeedback', 'partiallycorrectfeedback', 'incorrectfeedback'))) {
! 			$result = $options->feedback && ($itemid == $question->id);
! 			if (!$result) {
! 				return false;
! 			}
! 			if ($state->raw_grade >= $question->maxgrade/1.01) {
! 				$feedbacktype = 'correctfeedback';
! 			} else if ($state->raw_grade > 0) {
! 				$feedbacktype = 'partiallycorrectfeedback';
! 			} else {
! 				$feedbacktype = 'incorrectfeedback';
! 			}
! 			if ($feedbacktype != $filearea) {
! 				return false;
! 			}
! 			return true;
! 		} else if ($component == 'question' && $filearea == 'answerfeedback') {
! 			return $options->feedback && (array_key_exists($itemid, $question->options->answers));
! 		} else {
! 			return parent::check_file_access($question, $state, $options, $contextid, $component,
! 			$filearea, $args);
! 		}
! 	}
  }
  
  //// END OF CLASS ////
***************
*** 614,618 ****
  question_register_questiontype(new question_calculatedmulti_qtype());
  
  if ( ! defined ("CALCULATEDMULTI")) {
!     define("CALCULATEDMULTI",    "calculatedmulti");
  }
--- 614,618 ----
  question_register_questiontype(new question_calculatedmulti_qtype());
  
  if ( ! defined ("CALCULATEDMULTI")) {
! 	define("CALCULATEDMULTI",    "calculatedmulti");
  }
diff -crB questionorg/type/calculatedsimple/edit_calculatedsimple_form.php questionupd/type/calculatedsimple/edit_calculatedsimple_form.php
*** questionorg/type/calculatedsimple/edit_calculatedsimple_form.php	2012-04-13 12:31:13.871178296 +0500
--- questionupd/type/calculatedsimple/edit_calculatedsimple_form.php	2012-04-13 09:42:57.000000000 +0500
***************
*** 25,827 ****
   * @subpackage questiontypes
   */
  class question_edit_calculatedsimple_form extends question_edit_form {
!     /**
!      * Handle to the question type for this question.
!      *
!      * @var question_calculatedsimple_qtype
!      */
!     public $qtypeobj;
! 
!     public $wildcarddisplay ;
! 
!     public $questiondisplay ;
! 
!     public $datasetdefs;
! 
!     public $reload = false ;
! 
!     public $maxnumber = -1;
! 
!     public $regenerate = true;
! 
!     public $noofitems;
! 
!     public $outsidelimit = false ;
! 
!     public $commentanswer = array();
! 
!     public $answer = array();
! 
!     public $nonemptyanswer = array();
! 
!     public $numbererrors = array();
! 
!     public $formdata = array();
! 
!     function question_edit_calculatedsimple_form(&$submiturl, &$question, &$category, &$contexts, $formeditable = true){
!         global $QTYPES, $SESSION, $CFG, $DB;
!         $this->regenerate = true;
!         $this->question = $question;
! 
!         $this->qtypeobj =& $QTYPES[$this->question->qtype];
!         //get the dataset definitions for this question
!         //coming here everytime even when using a NoSubmitButton
!         //so this will only set the values to the actual question database content which is not what we want
!         //so this should be removed from here
!         // get priority to paramdatasets
! 
!         if ("1" == optional_param('reload','', PARAM_INT )) {
!             $this->reload = true;
!         }else {
!             $this->reload = false;
!         }
!         if (!$this->reload) { // use database data as this is first pass
!             // question->id == 0 so no stored datasets
!             // else get datasets
!             //   echo "<p>question  <pre>";print_r($question);echo "</pre></p>";
!             if (!empty($question->id)) {
! 
!               /*  if (empty($question->options)) {
!                     $this->get_question_options($question);
!                 }*/
!                 $this->datasetdefs = $this->qtypeobj->get_dataset_definitions($question->id, array());
! 
!                 if(!empty($this->datasetdefs)){
!                     foreach ($this->datasetdefs as $defid => $datasetdef) {
!                         // first get the items in case their number does not correspond to itemcount
!                         if (isset($datasetdef->id)) {
!                             $this->datasetdefs[$defid]->items = $this->qtypeobj->get_database_dataset_items($datasetdef->id);
!                             if ( $this->datasetdefs[$defid]->items != '') {
!                                 $datasetdef->itemcount = count($this->datasetdefs[$defid]->items);
!                             } else {
!                                 $datasetdef->itemcount = 0 ;
!                             }
!                         }
!                         // Get maxnumber
!                         if ($this->maxnumber == -1 || $datasetdef->itemcount < $this->maxnumber) {
!                             $this->maxnumber = $datasetdef->itemcount;
!                         }
!                     }
!                 }
! 
!                 $i = 0 ;
!                 foreach($this->question->options->answers as $answer){
!                      $this->answer[$i] = $answer ;
!                      $i++;
!                 }
!                 $this->nonemptyanswer = $this->answer ;
!             }
!             $datasettoremove = false;
!             $newdatasetvalues = false ;
!             $newdataset = false ;
!         }else {
!             // handle reload to get values from the form-elements
!             // answers, datasetdefs and data_items
!             // In any case the validation step will warn the user of any error in settings the values.
!             // Verification for the specific dataset values as the other parameters
!             // unints, feeedback etc are handled elsewhere
!             // handle request buttons :
!             //    'analyzequestion' (Identify the wild cards {x..} present in answers)
!             //    'addbutton' (create new set of datatitems)
!             //    'updatedatasets' is handled automatically on each reload
!             // The analyzequestion is done every time on reload
!             // to detect any new wild cards so that the current display reflects
!             // the mandatory (i.e. in answers) datasets
!             //  to implement : don't do any changes if the question is used in a quiz.
!             // If new datadef, new properties should erase items.
!             // Most of the data
!             $datasettoremove = false;
!             $newdatasetvalues = false ;
!             $newdataset = false ;
!             $dummyform = new stdClass();
!             $mandatorydatasets = array();
!             // should not test on adding a new answer
!             // should test if there are already olddatasets or if the 'analyzequestion' submit button has been clicked
!             if ('' != optional_param('datasetdef', '', PARAM_RAW) || '' != optional_param('analyzequestion', '', PARAM_RAW)){
! 
!                 if  (  $dummyform->answer = optional_param('answer', '', PARAM_NOTAGS)) { // there is always at least one answer...
!                     $fraction = optional_param('fraction', '', PARAM_NUMBER);
!                     $tolerance = optional_param('tolerance', '', PARAM_NUMBER);
!                     $tolerancetype = optional_param('tolerancetype', '', PARAM_NUMBER);
!                     $correctanswerlength = optional_param('correctanswerlength', '', PARAM_INT);
!                     $correctanswerformat = optional_param('correctanswerformat', '', PARAM_INT);
! 
!                     foreach( $dummyform->answer as $key => $answer ) {
!                         if(trim($answer) != ''){  // just look for non-empty
!                             $this->answer[$key]=new stdClass();
!                             $this->answer[$key]->answer = $answer;
!                             $this->answer[$key]->fraction = $fraction[$key];
!                             $this->answer[$key]->tolerance = $tolerance[$key];
!                             $this->answer[$key]->tolerancetype = $tolerancetype[$key];
!                             $this->answer[$key]->correctanswerlength = $correctanswerlength[$key];
!                             $this->answer[$key]->correctanswerformat = $correctanswerformat[$key];
!                             $this->nonemptyanswer[]= $this->answer[$key];
!                             $mandatorydatasets +=$this->qtypeobj->find_dataset_names($answer);
!                         }
!                     }
!                 }
!                 $this->datasetdefs = array();
!                 // rebuild datasetdefs from old values
!                 if ($olddef  = optional_param('datasetdef', '', PARAM_RAW)){
!                     $calcmin = optional_param('calcmin', '', PARAM_NUMBER);
!                     $calclength = optional_param('calclength', '', PARAM_INT);
!                     $calcmax = optional_param('calcmax', '', PARAM_NUMBER);
!                     $oldoptions  = optional_param('defoptions', '', PARAM_RAW);
!                     $newdatasetvalues = false ;
!                     $sizeofolddef = sizeof($olddef);
!                     for($key = 1; $key <= $sizeofolddef; $key++) {
!                         $def = $olddef[$key] ;
!                         $this->datasetdefs[$def]= new stdClass ;
!                         $this->datasetdefs[$def]->type = 1;
!                         $this->datasetdefs[$def]->category = 0;
!                       //  $this->datasets[$key]->name = $datasetname;
!                         $this->datasetdefs[$def]->options = $oldoptions[$key] ;
!                         $this->datasetdefs[$def]->calcmin = $calcmin[$key] ;
!                         $this->datasetdefs[$def]->calcmax = $calcmax[$key] ;
!                         $this->datasetdefs[$def]->calclength = $calclength[$key] ;
!                         //then compare with new values
!                         if (preg_match('~^(uniform|loguniform):([^:]*):([^:]*):([0-9]*)$~', $this->datasetdefs[$def]->options, $regs)) {
!                            if( $this->datasetdefs[$def]->calcmin != $regs[2]||
!                             $this->datasetdefs[$def]->calcmax != $regs[3] ||
!                             $this->datasetdefs[$def]->calclength != $regs[4]){
!                                  $newdatasetvalues = true ;
!                             }
!                         }
!                         $this->datasetdefs[$def]->options="uniform:".$this->datasetdefs[$def]->calcmin.":".$this->datasetdefs[$def]->calcmax.":".$this->datasetdefs[$def]->calclength;
!                     }
!                 }// if (olddef...
!                 // detect new datasets
!             $newdataset = false ;
!             foreach ($mandatorydatasets as $datasetname) {
!                 if (!isset($this->datasetdefs["1-0-$datasetname"])) {
!                     $key = "1-0-$datasetname";
!                     $this->datasetdefs[$key]=new stdClass ;//"1-0-$datasetname";
!                     $this->datasetdefs[$key]->type = 1;
!                     $this->datasetdefs[$key]->category = 0;
!                     $this->datasetdefs[$key]->name = $datasetname;
!                     $this->datasetdefs[$key]->options = "uniform:1.0:10.0:1";
!                     $newdataset = true ;
!                 }else {
!                     $this->datasetdefs["1-0-$datasetname"]->name = $datasetname ;
!                 }
!             }
!             // remove obsolete datasets
!             $datasettoremove = false;
!             foreach ($this->datasetdefs as $defkey => $datasetdef){
!                 if(!isset($datasetdef->name )){
!                     $datasettoremove = true;
!                     unset($this->datasetdefs[$defkey]);
!                 }
!             }
!         }
!         } // handle reload
!         // create items if  $newdataset and noofitems > 0 and !$newdatasetvalues
!         // eliminate any items if $newdatasetvalues
!         // eliminate any items if $datasettoremove, $newdataset, $newdatasetvalues
!         if ($datasettoremove ||$newdataset ||$newdatasetvalues ) {
!             foreach ($this->datasetdefs as $defkey => $datasetdef){
!                 $datasetdef->itemcount = 0;
!                 unset($datasetdef->items);
!             }
!         }
!         $maxnumber = -1 ;
!         if  (  "" !=optional_param('addbutton', '', PARAM_TEXT)){
!             $maxnumber = optional_param('selectadd', '', PARAM_INT); //FIXME: sloppy coding
!             foreach ($this->datasetdefs as $defid => $datasetdef) {
!                 $datasetdef->itemcount = $maxnumber;
!                 unset($datasetdef->items);
!                 for ($numberadded =1 ; $numberadded <= $maxnumber; $numberadded++){
!                     $datasetitem = new stdClass;
!                     $datasetitem->itemnumber = $numberadded;
!                     $datasetitem->id = 0;
!                     $datasetitem->value = $this->qtypeobj->generate_dataset_item($datasetdef->options);
!                     $this->datasetdefs[$defid]->items[$numberadded]=$datasetitem ;
!                 }//for number added
!             }// datasetsdefs end
!             $this->maxnumber = $maxnumber ;
!         }else {
!             // Handle reload dataset items
!             if  (  "" !=optional_param('definition','', PARAM_NOTAGS)&& !($datasettoremove ||$newdataset ||$newdatasetvalues )){
!                 $i = 1;
!                 $fromformdefinition = optional_param('definition', '', PARAM_NOTAGS);
!                 $fromformnumber = optional_param('number', '', PARAM_INT);
!                 $fromformitemid = optional_param('itemid', '', PARAM_INT);
!                 ksort($fromformdefinition);
! 
!                 foreach($fromformdefinition as $key => $defid) {
!                     $addeditem = new stdClass();
!                     $addeditem->id = $fromformitemid[$i]  ;
!                     $addeditem->value = $fromformnumber[$i];
!                     $addeditem->itemnumber = ceil($i / count($this->datasetdefs));
!                     $this->datasetdefs[$defid]->items[$addeditem->itemnumber]=$addeditem ;
!                     $this->datasetdefs[$defid]->itemcount = $i ;
!                     $i++;
!                 }
!             }
!             if (isset($addeditem->itemnumber) && $this->maxnumber < $addeditem->itemnumber){
!                 $this->maxnumber = $addeditem->itemnumber;
!                 if(!empty($this->datasetdefs)){
!                     foreach ($this->datasetdefs as $datasetdef) {
!                             $datasetdef->itemcount = $this->maxnumber ;
!                     }
!                 }
!             }
!         }
! 
!         parent::question_edit_form($submiturl, $question, $category, $contexts, $formeditable);
!     }
! 
!     function get_per_answer_fields(&$mform, $label, $gradeoptions, &$repeatedoptions, &$answersoption) {
!         $repeated = parent::get_per_answer_fields($mform, $label, $gradeoptions, $repeatedoptions, $answersoption);
!         $mform->setType('answer', PARAM_NOTAGS);
!         $addrepeated = array();
!         $addrepeated[] =& $mform->createElement('text', 'tolerance', get_string('tolerance', 'qtype_calculated'));
!         $repeatedoptions['tolerance']['type'] = PARAM_NUMBER;
!         $repeatedoptions['tolerance']['default'] = 0.01;
!         $addrepeated[] =& $mform->createElement('select', 'tolerancetype', get_string('tolerancetype', 'quiz'), $this->qtypeobj->tolerance_types());
!         $addrepeated[] =&  $mform->createElement('select', 'correctanswerlength', get_string('correctanswershows', 'qtype_calculated'), range(0, 9));
!         $repeatedoptions['correctanswerlength']['default'] = 2;
! 
!         $answerlengthformats = array('1' => get_string('decimalformat', 'quiz'), '2' => get_string('significantfiguresformat', 'quiz'));
!         $addrepeated[] =&  $mform->createElement('select', 'correctanswerformat', get_string('correctanswershowsformat', 'qtype_calculated'), $answerlengthformats);
!         array_splice($repeated, 3, 0, $addrepeated);
!         $repeated[1]->setLabel(get_string('correctanswerformula', 'quiz').'=');
! 
!         return $repeated;
!     }
! 
!     /**
!      * Add question-type specific form fields.
!      *
!      * @param MoodleQuickForm $mform the form being built.
!      */
!     function definition_inner(&$mform) {
!         global $QTYPES;
!         $this->qtypeobj =& $QTYPES[$this->qtype()];
!         $strquestionlabel = $this->qtypeobj->comment_header($this->nonemptyanswer);
!         $label = get_string("sharedwildcards", "qtype_calculated");
!         $mform->addElement('hidden', 'synchronize', 0);
!         $mform->addElement('hidden', 'initialcategory', 1);
!         $mform->setType('initialcategory', PARAM_INT);
!         $mform->addElement('hidden', 'reload', 1);
!         $mform->setType('reload', PARAM_INT);
!         $addfieldsname='updatequestion value';
!         $addstring=get_string("updatecategory", "qtype_calculated");
!         $mform->registerNoSubmitButton($addfieldsname);
!         // put a submit button to stop supplementary answers on update answers parameters
!         // $mform->insertElementBefore($mform->createElement('submit', $addfieldsname, $addstring), 'listcategory');
! 
!         $creategrades = get_grade_options();
!         $this->add_per_answer_fields($mform, get_string('answerhdr', 'qtype_calculated', '{no}'),
!             $creategrades->gradeoptions, 1, 1);
! 
!         $QTYPES['numerical']->add_units_options($mform,$this);
! 
!         $QTYPES['numerical']->add_units_elements($mform,$this);
!         $label = "<div class='mdl-align'></div><div class='mdl-align'>".get_string('wildcardrole', 'qtype_calculatedsimple')."</div>";
!         $mform->addElement('html', "<div class='mdl-align'>&nbsp;</div>");
!         $mform->addElement('html', $label);// explaining the role of datasets so other strings can be shortened
! 
!         $mform->addElement('submit', 'analyzequestion', get_string('findwildcards','qtype_calculatedsimple'));
!         $mform->registerNoSubmitButton('analyzequestion');
!         $mform->closeHeaderBefore('analyzequestion');
!         if  (  "" != optional_param('analyzequestion','', PARAM_RAW)) {
! 
!             $this->wizarddisplay = true;
! 
!         }else {
!             $this->wizwarddisplay = false;
!         }
!         if ($this->maxnumber != -1){
!             $this->noofitems = $this->maxnumber;
!         } else {
!             $this->noofitems = 0;
!         }
!         if(!empty($this->datasetdefs)){//So there are some datadefs
!             // we put them on the page
!             $key = 0;
!             $mform->addElement('header', 'additemhdr', get_string('wildcardparam', 'qtype_calculatedsimple'));
!             $idx = 1;
!             if(!empty($this->datasetdefs)){// unnecessary test
!                 $j = (($this->noofitems) * count($this->datasetdefs))+1;//
!                 foreach ($this->datasetdefs as $defkey => $datasetdef){
!                     $mform->addElement('static', "na[$j]", get_string('param', 'qtype_calculated', $datasetdef->name));
!                     $this->qtypeobj->custom_generator_tools_part($mform, $idx, $j);
!                     $mform->addElement('hidden', "datasetdef[$idx]");
!                     $mform->setType("datasetdef[$idx]", PARAM_RAW);
!                     $mform->addElement('hidden', "defoptions[$idx]");
!                     $mform->setType("defoptions[$idx]", PARAM_RAW);
!                     $idx++;
!                     $mform->addElement('static', "divider[$j]", '', '<hr />');
!                     $j++;
!                 }
!             }
!             //this should be done before the elements are created and stored as $this->formdata ;
!             //fill out all data sets and also the fields for the next item to add.
!             /*Here we do already the values error analysis so that
!              * we could force all wild cards values display if there is an error in values.
!              * as using a , in a number */
!             $this->numbererrors = array();
!             if(!empty($this->datasetdefs)){
!                 $j = $this->noofitems * count($this->datasetdefs);
!                 for ($itemnumber = $this->noofitems; $itemnumber >= 1; $itemnumber--){
!                     $data = array();
!                     $numbererrors = array() ;
!                     $comment = new stdClass;
!                     $comment->stranswers = array();
!                     $comment->outsidelimit = false ;
!                     $comment->answers = array();
! 
!                     foreach ($this->datasetdefs as $defid => $datasetdef){
!                         if (isset($datasetdef->items[$itemnumber])){
!                             $this->formdata["definition[$j]"] = $defid;
!                             $this->formdata["itemid[$j]"] = $datasetdef->items[$itemnumber]->id;
!                             $data[$datasetdef->name] = $datasetdef->items[$itemnumber]->value;
!                             $this->formdata["number[$j]"] = $number = $datasetdef->items[$itemnumber]->value;
!                             if(! is_numeric($number)){
!                                 $a = new stdClass;
!                                 $a->name = '{'.$datasetdef->name.'}' ;
!                                 $a->value = $datasetdef->items[$itemnumber]->value ;
!                                 if (stristr($number,',')){
!                                     $this->numbererrors["number[$j]"]=get_string('nocommaallowed', 'qtype_calculated');
!                                     $numbererrors .= $this->numbererrors['number['.$j.']']."<br />";
! 
!                                 }else {
!                                     $this->numbererrors["number[$j]"]= get_string('notvalidnumber','qtype_calculated',$a);
!                                     $numbererrors .= $this->numbererrors['number['.$j.']']."<br />";
!                                     //$comment->outsidelimit = false ;
!                                 }
!                             }else if( stristr($number,'x')){ // hexa will pass the test
!                                 $a = new stdClass;
!                                 $a->name = '{'.$datasetdef->name.'}' ;
!                                 $a->value = $datasetdef->items[$itemnumber]->value ;
!                                 $this->numbererrors['number['.$j.']']= get_string('hexanotallowed','qtype_calculated',$a);
!                                 $numbererrors .= $this->numbererrors['number['.$j.']']."<br />";
!                             } else if( is_nan($number)){
!                                 $a = new stdClass;
!                                 $a->name = '{'.$datasetdef->name.'}' ;
!                                 $a->value = $datasetdef->items[$itemnumber]->value ;
!                                 $this->numbererrors["number[$j]"]= get_string('notvalidnumber','qtype_calculated',$a);
!                                 $numbererrors .= $this->numbererrors['number['.$j.']']."<br />";
!                                 //   $val = 1.0 ;
!                             }
!                         }
!                         $j--;
!                     }
!                     if($this->noofitems != 0 ) {
!                         if (empty($numbererrors)) {
!                             if (!isset($this->question->id)) {
!                                 $this->question->id = 0 ;
!                             }
!                             $this->question->questiontext = !empty($this->question->questiontext)?$this->question->questiontext:'';
!                             $comment = $this->qtypeobj->comment_on_datasetitems($this->qtypeobj, $this->question->id, $this->question->questiontext, $this->nonemptyanswer, $data, $itemnumber);
!                             if ($comment->outsidelimit) {
!                                 $this->outsidelimit=$comment->outsidelimit ;
!                             }
!                             $totalcomment='';
! 
!                             foreach ($this->nonemptyanswer as $key => $answer) {
!                                 $totalcomment .= $comment->stranswers[$key].'<br/>';
!                             }
! 
!                             $this->formdata['answercomment['.$itemnumber.']'] = $totalcomment ;
!                         }
!                     }
!                 }
!                 $this->formdata['selectdelete'] = '1';
!                 $this->formdata['selectadd'] = '1';
!                 $j = $this->noofitems * count($this->datasetdefs)+1;
!                 $data = array(); // data for comment_on_datasetitems later
!                 $idx =1 ;
!                 foreach ($this->datasetdefs as $defid => $datasetdef){
!                     $this->formdata["datasetdef[$idx]"] = $defid;
!                     $idx++;
!                 }
!                 $this->formdata = $this->qtypeobj->custom_generator_set_data($this->datasetdefs, $this->formdata);
!             }
! 
! 
!             $addoptions = Array();
!             $addoptions['1']='1';
!             for ($i=10; $i<=100 ; $i+=10){
!                 $addoptions["$i"]="$i";
!             }
!             $showoptions = Array();
!             $showoptions['1']='1';
!             $showoptions['2']='2';
!             $showoptions['5']='5';
!             for ($i=10; $i<=100 ; $i+=10){
!                 $showoptions["$i"]="$i";
!             }
!             $mform->closeHeaderBefore('additemhdr');
!             $addgrp = array();
!             $addgrp[] =& $mform->createElement('submit', 'addbutton', get_string('generatenewitemsset', 'qtype_calculatedsimple'));
!             $addgrp[] =& $mform->createElement('select', "selectadd", '', $addoptions);
!             $addgrp[] = & $mform->createElement('static',"stat",'',get_string('newsetwildcardvalues', 'qtype_calculatedsimple'));
!             $mform->addGroup($addgrp, 'addgrp', '', '   ', false);
!             $mform->registerNoSubmitButton('addbutton');
!             $mform->closeHeaderBefore('addgrp');
!             $addgrp1 = array();
!             $addgrp1[] =& $mform->createElement('submit', 'showbutton', get_string('showitems', 'qtype_calculatedsimple'));
!             $addgrp1[] =& $mform->createElement('select', "selectshow",'' , $showoptions);
!             $addgrp1[] = & $mform->createElement('static',"stat",'',get_string('setwildcardvalues', 'qtype_calculatedsimple'));
!             $mform->addGroup($addgrp1, 'addgrp1', '', '   ', false);
!             $mform->registerNoSubmitButton('showbutton');
!             $mform->closeHeaderBefore('addgrp1');
!             $mform->addElement('static', "divideradd", '', '');
!             if ($this->noofitems == 0) {
!                 $mform->addElement('static','warningnoitems','','<span class="error">'.get_string('youmustaddatleastonevalue', 'qtype_calculatedsimple').'</span>');
!                 $mform->closeHeaderBefore('warningnoitems');
!             }else {
!                 $mform->addElement('header', 'additemhdr1', get_string('wildcardvalues', 'qtype_calculatedsimple'));
!                 $mform->closeHeaderBefore('additemhdr1');
!                 //   $mform->addElement('header', '', get_string('itemno', 'qtype_calculated', ""));
!                 if( !empty($this->numbererrors) || $this->outsidelimit) {
!                     $mform->addElement('static', "alert", '', '<span class="error">'.get_string('useadvance', 'qtype_calculatedsimple').'</span>');
!                 }
! 
!                 $mform->addElement('submit', 'updatedatasets', get_string('updatewildcardvalues', 'qtype_calculatedsimple'));
!                 $mform->registerNoSubmitButton('updatedatasets');
!                 $mform->setAdvanced("updatedatasets",true);
! 
!                 //------------------------------------------------------------------------------------------------------------------------------
!                 $j = $this->noofitems * count($this->datasetdefs);
!                 $k = 1 ;
!                 if ("" != optional_param('selectshow', '', PARAM_INT)){
!                     $k = optional_param('selectshow', '', PARAM_INT);
!                 }
! 
!                 for ($i = $this->noofitems; $i >= 1 ; $i--){
!                     foreach ($this->datasetdefs as $defkey => $datasetdef){
!                         if($k > 0 ||  $this->outsidelimit || !empty($this->numbererrors ) ){
!                             $mform->addElement('text',"number[$j]" , get_string('wildcard', 'qtype_calculatedsimple', $datasetdef->name));
!                             $mform->setAdvanced("number[$j]",true);
!                             if(!empty($this->numbererrors['number['.$j.']']) ){
!                                 $mform->addElement('static', "numbercomment[$j]",'','<span class="error">'.$this->numbererrors['number['.$j.']'].'</span>');
!                                 $mform->setAdvanced("numbercomment[$j]",true);
!                             }
!                         }else {
!                             $mform->addElement('hidden',"number[$j]" , get_string('wildcard', 'qtype_calculatedsimple', $datasetdef->name));
!                         }
!                         $mform->setType("number[$j]", PARAM_NUMBER);
! 
!                         $mform->addElement('hidden', "itemid[$j]");
!                         $mform->setType("itemid[$j]", PARAM_INT);
! 
!                         $mform->addElement('hidden', "definition[$j]");
!                         $mform->setType("definition[$j]", PARAM_NOTAGS);
! 
!                         $j--;
!                     }
!                     if (!empty( $strquestionlabel) && ($k > 0 ||  $this->outsidelimit || !empty($this->numbererrors ) ) ){
!                         //   $repeated[] =& $mform->addElement('static', "answercomment[$i]", $strquestionlabel);
!                         $mform->addElement('static', "answercomment[$i]", "<b>".get_string('setno', 'qtype_calculatedsimple', $i)."</b>&nbsp;&nbsp;".$strquestionlabel);
! 
!                     }
!                     if($k > 0 ||  $this->outsidelimit || !empty($this->numbererrors )){
!                         $mform->addElement('static', "divider1[$j]", '', '<hr />');
! 
!                     }
!                     $k-- ;
!                 }
!             }
!             //  if ($this->outsidelimit){
!             //   $mform->addElement('static','outsidelimit','','');
!             //  }
!         }else {
!             $mform->addElement('static','warningnowildcards','','<span class="error">'.get_string('atleastonewildcard', 'qtype_calculatedsimple').'</span>');
!             $mform->closeHeaderBefore('warningnowildcards');
!         }
! 
! 
!         //------------------------------------------------------------------------------------------------------------------------------
!         //non standard name for button element needed so not using add_action_buttons
!         //hidden elements
! 
!         $mform->addElement('hidden', 'id');
!         $mform->setType('id', PARAM_INT);
! 
!         $mform->addElement('hidden', 'courseid');
!         $mform->setType('courseid', PARAM_INT);
!         $mform->setDefault('courseid', 0);
! 
!         $mform->addElement('hidden', 'cmid');
!         $mform->setType('cmid', PARAM_INT);
!         $mform->setDefault('cmid', 0);
!         if (!empty($this->question->id)){
!             if ($this->question->formoptions->cansaveasnew){
!                 $mform->addElement('header', 'additemhdr', get_string('converttocalculated', 'qtype_calculatedsimple'));
!                 $mform->closeHeaderBefore('additemhdr');
! 
!                 $mform->addElement('checkbox', 'convert','' ,get_string('willconverttocalculated', 'qtype_calculatedsimple'));
!                 $mform->setDefault('convert', 0);
! 
!             }
!         }
!     }
! 
!     function data_preprocessing($question) {
!         global $QTYPES;
!         $answer = $this->answer;
!         $default_values = array();
!         if (count($answer)) {
!             $key = 0;
!             foreach ($answer as $answer){
!                 $default_values['answer['.$key.']'] = $answer->answer; //  is necessary ? to-do test it
!                 $default_values['fraction['.$key.']'] = $answer->fraction;
!                 $default_values['tolerance['.$key.']'] = $answer->tolerance;
!                 $default_values['tolerancetype['.$key.']'] = $answer->tolerancetype;
!                 $default_values['correctanswerlength['.$key.']'] = $answer->correctanswerlength;
!                 $default_values['correctanswerformat['.$key.']'] = $answer->correctanswerformat;
! 
!                 // prepare draft files
!                 $draftid = file_get_submitted_draft_itemid('feedback['.$key.']');
!                 $default_values['feedback['.$key.']']['text'] = file_prepare_draft_area(
!                     $draftid,       // draftid
!                     $this->context->id,    // context
                      'question', // component
                      'answerfeedback',             // filarea
!                     !empty($answer->id)?(int)$answer->id:null, // itemid
!                     $this->fileoptions,    // options
!                     !empty($answer->feedback)?$answer->feedback:''      // text
!                 );
!                 $default_values['feedback['.$key.']']['format'] = !empty($answer->feedbackformat)?$answer->feedbackformat:editors_get_preferred_format();
!                 $default_values['feedback['.$key.']']['itemid'] = $draftid;
! 
!                 $key++;
!             }
!         }
!         $default_values['synchronize'] = 0 ;
!         $QTYPES['numerical']->set_numerical_unit_data($this, $question, $default_values);
!         /*  if (isset($question->options)){
!                 $default_values['unitgradingtype'] = $question->options->unitgradingtype ;
!                 $default_values['unitpenalty'] = $question->options->unitpenalty ;
!                 switch ($question->options->showunits){
!                     case 'O' :
!                     case '1' :
!                         $default_values['showunits0'] = $question->options->showunits ;
!                         $default_values['unitrole'] = 0 ;
!                         break;
!                     case '2' :
!                     case '3' :
!                         $default_values['showunits1'] = $question->options->showunits ;
!                         $default_values['unitrole'] = 1 ;
!                         break;
!                 }
!                 $default_values['unitsleft'] = $question->options->unitsleft ;
!                 $default_values['instructions'] = $question->options->instructions  ;
! 
!                 if (isset($question->options->units)){
!                     $units  = array_values($question->options->units);
!                     if (!empty($units)) {
!                         foreach ($units as $key => $unit){
!                             $default_values['unit['.$key.']'] = $unit->unit;
!                             $default_values['multiplier['.$key.']'] = $unit->multiplier;
!                         }
!                     }
!                 }
!             }
!            */
!         $key = 0 ;
! 
!         $formdata = array();
!         $fromform = new stdClass();
!         //this should be done before the elements are created and stored as $this->formdata ;
!         //fill out all data sets and also the fields for the next item to add.
!         /* if(!empty($this->datasetdefs)){
!         $j = $this->noofitems * count($this->datasetdefs);
!         for ($itemnumber = $this->noofitems; $itemnumber >= 1; $itemnumber--){
!             $data = array();
!             foreach ($this->datasetdefs as $defid => $datasetdef){
!                 if (isset($datasetdef->items[$itemnumber])){
!                     $formdata["number[$j]"] = $datasetdef->items[$itemnumber]->value;
!                     $formdata["definition[$j]"] = $defid;
!                     $formdata["itemid[$j]"] = $datasetdef->items[$itemnumber]->id;
!                     $data[$datasetdef->name] = $datasetdef->items[$itemnumber]->value;
!                 }
!                 $j--;
!             }
!             // echo "<p>answers avant  comment <pre>";print_r($answer);echo"</pre></p>";
!             // echo "<p>data avant  comment <pre>";print_r($data);echo"</pre></p>";
! 
!             if($this->noofitems != 0 ) {
!                 if(!isset($question->id)) $question->id = 0 ;
!                 $comment = $this->qtypeobj->comment_on_datasetitems($question->id,$this->nonemptyanswer, $data, $itemnumber);//$this->
!                  if ($comment->outsidelimit) {
!                      $this->outsidelimit=$comment->outsidelimit ;
!                 }
!                 $totalcomment='';
!                 // echo "<p> comment <pre>";print_r($comment);echo"</pre></p>";
! 
!                 foreach ($this->nonemptyanswer as $key => $answer) {
!                     $totalcomment .= $comment->stranswers[$key].'<br/>';
!                 }
! 
!                 $formdata['answercomment['.$itemnumber.']'] = $totalcomment ;
!             }
!         }
!         // $formdata['reload'] = '1';
!         // $formdata['nextpageparam[forceregeneration]'] = $this->regenerate;
!         $formdata['selectdelete'] = '1';
!         $formdata['selectadd'] = '1';
!         $j = $this->noofitems * count($this->datasetdefs)+1;
!         $data = array(); // data for comment_on_datasetitems later
!            $idx =1 ;
!             foreach ($this->datasetdefs as $defid => $datasetdef){
!                $formdata["datasetdef[$idx]"] = $defid;
!                 $idx++;
!             }
!         $formdata = $this->qtypeobj->custom_generator_set_data($this->datasetdefs, $formdata);
!         }*/
!         $question = (object)((array)$question + $default_values+$this->formdata );
! 
!         return $question;
!     }
! 
!     function qtype() {
!         return 'calculatedsimple';
!     }
! 
!     function validation($data, $files) {
!         global $QTYPES;
!         $errors = parent::validation($data, $files);
!         //verifying for errors in {=...} in question text;
!         $qtext = "";
!         $qtextremaining = $data['questiontext']['text'];
!         $possibledatasets = $this->qtypeobj->find_dataset_names($data['questiontext']['text']);
!         foreach ($possibledatasets as $name => $value) {
!             $qtextremaining = str_replace('{'.$name.'}', '1', $qtextremaining);
!         }
!         while  (preg_match('~\{=([^[:space:]}]*)}~', $qtextremaining, $regs1)) {
!             $qtextsplits = explode($regs1[0], $qtextremaining, 2);
!             $qtext =$qtext.$qtextsplits[0];
!             $qtextremaining = $qtextsplits[1];
!             if (!empty($regs1[1]) && $formulaerrors = qtype_calculated_find_formula_errors($regs1[1])) {
!                 if(!isset($errors['questiontext'])){
!                     $errors['questiontext'] = $formulaerrors.':'.$regs1[1] ;
!                 }else {
!                     $errors['questiontext'] .= '<br/>'.$formulaerrors.':'.$regs1[1];
!                 }
!             }
!         }
!         $answers = $data['answer'];
!         $answercount = 0;
!         $maxgrade = false;
!         $possibledatasets = $this->qtypeobj->find_dataset_names($data['questiontext']['text']);
!         $mandatorydatasets = array();
!         foreach ($answers as $key => $answer){
!             $mandatorydatasets += $this->qtypeobj->find_dataset_names($answer);
!         }
!         if ( count($mandatorydatasets )==0){
!              foreach ($answers as $key => $answer){
!                 $errors['answer['.$key.']'] = get_string('atleastonewildcard', 'qtype_calculated');
!             }
!         }
!         foreach ($answers as $key => $answer){
!             //check no of choices
!             // the * for everykind of answer not actually implemented
!             $trimmedanswer = trim($answer);
!             if (($trimmedanswer!='')||$answercount==0){
!                 $eqerror = qtype_calculated_find_formula_errors($trimmedanswer);
!                 if (FALSE !== $eqerror){
!                     $errors['answer['.$key.']'] = $eqerror;
!                 }
!             }
!             if ($trimmedanswer!=''){
!                 if ('2' == $data['correctanswerformat'][$key]
!                         && '0' == $data['correctanswerlength'][$key]) {
!                     $errors['correctanswerlength['.$key.']'] = get_string('zerosignificantfiguresnotallowed','quiz');
!                 }
!                 if (!is_numeric($data['tolerance'][$key])){
!                     $errors['tolerance['.$key.']'] = get_string('mustbenumeric', 'qtype_calculated');
!                 }
!                 if ($data['fraction'][$key] == 1) {
!                    $maxgrade = true;
!                 }
! 
!                 $answercount++;
!             }
!             //check grades
! 
!             //TODO how should grade checking work here??
!             /*if ($answer != '') {
!                 if ($data['fraction'][$key] > 0) {
!                     $totalfraction += $data['fraction'][$key];
!                 }
!                 if ($data['fraction'][$key] > $maxfraction) {
!                     $maxfraction = $data['fraction'][$key];
!                 }
!             }*/
!         }
!         //grade checking :
!         /// Perform sanity checks on fractional grades
!         /*if ( ) {
!             if ($maxfraction != 1) {
!                 $maxfraction = $maxfraction * 100;
!                 $errors['fraction[0]'] = get_string('errfractionsnomax', 'qtype_multichoice', $maxfraction);
!             }
!         } else {
!             $totalfraction = round($totalfraction,2);
!             if ($totalfraction != 1) {
!                 $totalfraction = $totalfraction * 100;
!                 $errors['fraction[0]'] = get_string('errfractionsaddwrong', 'qtype_multichoice', $totalfraction);
!             }
!         }*/
!             $QTYPES['numerical']->validate_numerical_options($data, $errors) ;
!         $units  = $data['unit'];
!         if (count($units)) {
!             foreach ($units as $key => $unit){
!                 if (is_numeric($unit)){
!                     $errors['unit['.$key.']'] = get_string('mustnotbenumeric', 'qtype_calculated');
!                 }
!                 $trimmedunit = trim($unit);
!                 $trimmedmultiplier = trim($data['multiplier'][$key]);
!                 if (!empty($trimmedunit)){
!                     if (empty($trimmedmultiplier)){
!                         $errors['multiplier['.$key.']'] = get_string('youmustenteramultiplierhere', 'qtype_calculated');
!                     }
!                     if (!is_numeric($trimmedmultiplier)){
!                         $errors['multiplier['.$key.']'] = get_string('mustbenumeric', 'qtype_calculated');
!                     }
! 
!                 }
!             }
!         }
!         if ($answercount==0){
!             $errors['answer[0]'] = get_string('atleastoneanswer', 'qtype_calculated');
!         }
!         if ($maxgrade == false) {
!             $errors['fraction[0]'] = get_string('fractionsnomax', 'question');
!         }
!         if (isset($data['backtoquiz']) && ($this->noofitems==0) ){
!             $errors['warning'] = get_string('warning', 'mnet');
!         }
!         if ($this->outsidelimit){
!          //   if(!isset($errors['warning'])) $errors['warning']=' ';
!            $errors['outsidelimits'] = get_string('oneanswertrueansweroutsidelimits','qtype_calculated');
!         }
!                 /*Here we use the already done the error analysis so that
!         * we could force all wild cards values display if there is an error in values.
!         * as using a , in a number *//*
!         $numbers = $data['number'];
!         foreach ($numbers as $key => $number){
!             if(! is_numeric($number)){
!                 if (stristr($number,',')){
!                     $errors['number['.$key.']'] = get_string('notvalidnumber', 'qtype_calculated');
!                 }else {
!                     $errors['number['.$key.']'] = get_string('notvalidnumber', 'qtype_calculated');
!                 }
!             }else if( stristr($number,'x')){
!                 $errors['number['.$key.']'] = get_string('notvalidnumber', 'qtype_calculated');
!             } else if( is_nan($number)){
!                 $errors['number['.$key.']'] = get_string('notvalidnumber', 'qtype_calculated');
!             }
!         }
!         */
!         if ( $this->noofitems==0  ){
!             $errors['warning'] = get_string('warning', 'mnet');
!         }
  
!         return $errors;
!     }
  }
--- 25,827 ----
   * @subpackage questiontypes
   */
  class question_edit_calculatedsimple_form extends question_edit_form {
! 	/**
! 	 * Handle to the question type for this question.
! 	 *
! 	 * @var question_calculatedsimple_qtype
! 	 */
! 	public $qtypeobj;
! 
! 	public $wildcarddisplay ;
! 
! 	public $questiondisplay ;
! 
! 	public $datasetdefs;
! 
! 	public $reload = false ;
! 
! 	public $maxnumber = -1;
! 
! 	public $regenerate = true;
! 
! 	public $noofitems;
! 
! 	public $outsidelimit = false ;
! 
! 	public $commentanswer = array();
! 
! 	public $answer = array();
! 
! 	public $nonemptyanswer = array();
! 
! 	public $numbererrors = array();
! 
! 	public $formdata = array();
! 
! 	function question_edit_calculatedsimple_form(&$submiturl, &$question, &$category, &$contexts, $formeditable = true){
! 		global $QTYPES, $SESSION, $CFG, $DB;
! 		$this->regenerate = true;
! 		$this->question = $question;
! 
! 		$this->qtypeobj =& $QTYPES[$this->question->qtype];
! 		//get the dataset definitions for this question
! 		//coming here everytime even when using a NoSubmitButton
! 		//so this will only set the values to the actual question database content which is not what we want
! 		//so this should be removed from here
! 		// get priority to paramdatasets
! 
! 		if ("1" == optional_param('reload','', PARAM_INT )) {
! 			$this->reload = true;
! 		}else {
! 			$this->reload = false;
! 		}
! 		if (!$this->reload) { // use database data as this is first pass
! 			// question->id == 0 so no stored datasets
! 			// else get datasets
! 			//   echo "<p>question  <pre>";print_r($question);echo "</pre></p>";
! 			if (!empty($question->id)) {
! 
! 				/*  if (empty($question->options)) {
! 				 $this->get_question_options($question);
! 				 }*/
! 				$this->datasetdefs = $this->qtypeobj->get_dataset_definitions($question->id, array());
! 
! 				if(!empty($this->datasetdefs)){
! 					foreach ($this->datasetdefs as $defid => $datasetdef) {
! 						// first get the items in case their number does not correspond to itemcount
! 						if (isset($datasetdef->id)) {
! 							$this->datasetdefs[$defid]->items = $this->qtypeobj->get_database_dataset_items($datasetdef->id);
! 							if ( $this->datasetdefs[$defid]->items != '') {
! 								$datasetdef->itemcount = count($this->datasetdefs[$defid]->items);
! 							} else {
! 								$datasetdef->itemcount = 0 ;
! 							}
! 						}
! 						// Get maxnumber
! 						if ($this->maxnumber == -1 || $datasetdef->itemcount < $this->maxnumber) {
! 							$this->maxnumber = $datasetdef->itemcount;
! 						}
! 					}
! 				}
! 
! 				$i = 0 ;
! 				foreach($this->question->options->answers as $answer){
! 					$this->answer[$i] = $answer ;
! 					$i++;
! 				}
! 				$this->nonemptyanswer = $this->answer ;
! 			}
! 			$datasettoremove = false;
! 			$newdatasetvalues = false ;
! 			$newdataset = false ;
! 		}else {
! 			// handle reload to get values from the form-elements
! 			// answers, datasetdefs and data_items
! 			// In any case the validation step will warn the user of any error in settings the values.
! 			// Verification for the specific dataset values as the other parameters
! 			// unints, feeedback etc are handled elsewhere
! 			// handle request buttons :
! 			//    'analyzequestion' (Identify the wild cards {x..} present in answers)
! 			//    'addbutton' (create new set of datatitems)
! 			//    'updatedatasets' is handled automatically on each reload
! 			// The analyzequestion is done every time on reload
! 			// to detect any new wild cards so that the current display reflects
! 			// the mandatory (i.e. in answers) datasets
! 			//  to implement : don't do any changes if the question is used in a quiz.
! 			// If new datadef, new properties should erase items.
! 			// Most of the data
! 			$datasettoremove = false;
! 			$newdatasetvalues = false ;
! 			$newdataset = false ;
! 			$dummyform = new stdClass();
! 			$mandatorydatasets = array();
! 			// should not test on adding a new answer
! 			// should test if there are already olddatasets or if the 'analyzequestion' submit button has been clicked
! 			if ('' != optional_param('datasetdef', '', PARAM_RAW) || '' != optional_param('analyzequestion', '', PARAM_RAW)){
! 
! 				if  (  $dummyform->answer = optional_param('answer', '', PARAM_NOTAGS)) { // there is always at least one answer...
! 					$fraction = optional_param('fraction', '', PARAM_NUMBER);
! 					$tolerance = optional_param('tolerance', '', PARAM_NUMBER);
! 					$tolerancetype = optional_param('tolerancetype', '', PARAM_NUMBER);
! 					$correctanswerlength = optional_param('correctanswerlength', '', PARAM_INT);
! 					$correctanswerformat = optional_param('correctanswerformat', '', PARAM_INT);
! 
! 					foreach( $dummyform->answer as $key => $answer ) {
! 						if(trim($answer) != ''){  // just look for non-empty
! 							$this->answer[$key]=new stdClass();
! 							$this->answer[$key]->answer = $answer;
! 							$this->answer[$key]->fraction = $fraction[$key];
! 							$this->answer[$key]->tolerance = $tolerance[$key];
! 							$this->answer[$key]->tolerancetype = $tolerancetype[$key];
! 							$this->answer[$key]->correctanswerlength = $correctanswerlength[$key];
! 							$this->answer[$key]->correctanswerformat = $correctanswerformat[$key];
! 							$this->nonemptyanswer[]= $this->answer[$key];
! 							$mandatorydatasets +=$this->qtypeobj->find_dataset_names($answer);
! 						}
! 					}
! 				}
! 				$this->datasetdefs = array();
! 				// rebuild datasetdefs from old values
! 				if ($olddef  = optional_param('datasetdef', '', PARAM_RAW)){
! 					$calcmin = optional_param('calcmin', '', PARAM_NUMBER);
! 					$calclength = optional_param('calclength', '', PARAM_INT);
! 					$calcmax = optional_param('calcmax', '', PARAM_NUMBER);
! 					$oldoptions  = optional_param('defoptions', '', PARAM_RAW);
! 					$newdatasetvalues = false ;
! 					$sizeofolddef = sizeof($olddef);
! 					for($key = 1; $key <= $sizeofolddef; $key++) {
! 						$def = $olddef[$key] ;
! 						$this->datasetdefs[$def]= new stdClass ;
! 						$this->datasetdefs[$def]->type = 1;
! 						$this->datasetdefs[$def]->category = 0;
! 						//  $this->datasets[$key]->name = $datasetname;
! 						$this->datasetdefs[$def]->options = $oldoptions[$key] ;
! 						$this->datasetdefs[$def]->calcmin = $calcmin[$key] ;
! 						$this->datasetdefs[$def]->calcmax = $calcmax[$key] ;
! 						$this->datasetdefs[$def]->calclength = $calclength[$key] ;
! 						//then compare with new values
! 						if (preg_match('~^(uniform|loguniform):([^:]*):([^:]*):([0-9]*)$~', $this->datasetdefs[$def]->options, $regs)) {
! 							if( $this->datasetdefs[$def]->calcmin != $regs[2]||
! 							$this->datasetdefs[$def]->calcmax != $regs[3] ||
! 							$this->datasetdefs[$def]->calclength != $regs[4]){
! 								$newdatasetvalues = true ;
! 							}
! 						}
! 						$this->datasetdefs[$def]->options="uniform:".$this->datasetdefs[$def]->calcmin.":".$this->datasetdefs[$def]->calcmax.":".$this->datasetdefs[$def]->calclength;
! 					}
! 				}// if (olddef...
! 				// detect new datasets
! 				$newdataset = false ;
! 				foreach ($mandatorydatasets as $datasetname) {
! 					if (!isset($this->datasetdefs["1-0-$datasetname"])) {
! 						$key = "1-0-$datasetname";
! 						$this->datasetdefs[$key]=new stdClass ;//"1-0-$datasetname";
! 						$this->datasetdefs[$key]->type = 1;
! 						$this->datasetdefs[$key]->category = 0;
! 						$this->datasetdefs[$key]->name = $datasetname;
! 						$this->datasetdefs[$key]->options = "uniform:1.0:10.0:1";
! 						$newdataset = true ;
! 					}else {
! 						$this->datasetdefs["1-0-$datasetname"]->name = $datasetname ;
! 					}
! 				}
! 				// remove obsolete datasets
! 				$datasettoremove = false;
! 				foreach ($this->datasetdefs as $defkey => $datasetdef){
! 					if(!isset($datasetdef->name )){
! 						$datasettoremove = true;
! 						unset($this->datasetdefs[$defkey]);
! 					}
! 				}
! 			}
! 		} // handle reload
! 		// create items if  $newdataset and noofitems > 0 and !$newdatasetvalues
! 		// eliminate any items if $newdatasetvalues
! 		// eliminate any items if $datasettoremove, $newdataset, $newdatasetvalues
! 		if ($datasettoremove ||$newdataset ||$newdatasetvalues ) {
! 			foreach ($this->datasetdefs as $defkey => $datasetdef){
! 				$datasetdef->itemcount = 0;
! 				unset($datasetdef->items);
! 			}
! 		}
! 		$maxnumber = -1 ;
! 		if  (  "" !=optional_param('addbutton', '', PARAM_TEXT)){
! 			$maxnumber = optional_param('selectadd', '', PARAM_INT); //FIXME: sloppy coding
! 			foreach ($this->datasetdefs as $defid => $datasetdef) {
! 				$datasetdef->itemcount = $maxnumber;
! 				unset($datasetdef->items);
! 				for ($numberadded =1 ; $numberadded <= $maxnumber; $numberadded++){
! 					$datasetitem = new stdClass;
! 					$datasetitem->itemnumber = $numberadded;
! 					$datasetitem->id = 0;
! 					$datasetitem->value = $this->qtypeobj->generate_dataset_item($datasetdef->options);
! 					$this->datasetdefs[$defid]->items[$numberadded]=$datasetitem ;
! 				}//for number added
! 			}// datasetsdefs end
! 			$this->maxnumber = $maxnumber ;
! 		}else {
! 			// Handle reload dataset items
! 			if  (  "" !=optional_param('definition','', PARAM_NOTAGS)&& !($datasettoremove ||$newdataset ||$newdatasetvalues )){
! 				$i = 1;
! 				$fromformdefinition = optional_param('definition', '', PARAM_NOTAGS);
! 				$fromformnumber = optional_param('number', '', PARAM_INT);
! 				$fromformitemid = optional_param('itemid', '', PARAM_INT);
! 				ksort($fromformdefinition);
! 
! 				foreach($fromformdefinition as $key => $defid) {
! 					$addeditem = new stdClass();
! 					$addeditem->id = $fromformitemid[$i]  ;
! 					$addeditem->value = $fromformnumber[$i];
! 					$addeditem->itemnumber = ceil($i / count($this->datasetdefs));
! 					$this->datasetdefs[$defid]->items[$addeditem->itemnumber]=$addeditem ;
! 					$this->datasetdefs[$defid]->itemcount = $i ;
! 					$i++;
! 				}
! 			}
! 			if (isset($addeditem->itemnumber) && $this->maxnumber < $addeditem->itemnumber){
! 				$this->maxnumber = $addeditem->itemnumber;
! 				if(!empty($this->datasetdefs)){
! 					foreach ($this->datasetdefs as $datasetdef) {
! 						$datasetdef->itemcount = $this->maxnumber ;
! 					}
! 				}
! 			}
! 		}
! 
! 		parent::question_edit_form($submiturl, $question, $category, $contexts, $formeditable);
! 	}
! 
! 	function get_per_answer_fields(&$mform, $label, $gradeoptions, &$repeatedoptions, &$answersoption) {
! 		$repeated = parent::get_per_answer_fields($mform, $label, $gradeoptions, $repeatedoptions, $answersoption);
! 		$mform->setType('answer', PARAM_NOTAGS);
! 		$addrepeated = array();
! 		$addrepeated[] =& $mform->createElement('text', 'tolerance', get_string('tolerance', 'qtype_calculated'));
! 		$repeatedoptions['tolerance']['type'] = PARAM_NUMBER;
! 		$repeatedoptions['tolerance']['default'] = 0.01;
! 		$addrepeated[] =& $mform->createElement('select', 'tolerancetype', get_string('tolerancetype', 'quiz'), $this->qtypeobj->tolerance_types());
! 		$addrepeated[] =&  $mform->createElement('select', 'correctanswerlength', get_string('correctanswershows', 'qtype_calculated'), range(0, 9));
! 		$repeatedoptions['correctanswerlength']['default'] = 2;
! 
! 		$answerlengthformats = array('1' => get_string('decimalformat', 'quiz'), '2' => get_string('significantfiguresformat', 'quiz'));
! 		$addrepeated[] =&  $mform->createElement('select', 'correctanswerformat', get_string('correctanswershowsformat', 'qtype_calculated'), $answerlengthformats);
! 		array_splice($repeated, 3, 0, $addrepeated);
! 		$repeated[1]->setLabel(get_string('correctanswerformula', 'quiz').'=');
! 
! 		return $repeated;
! 	}
! 
! 	/**
! 	 * Add question-type specific form fields.
! 	 *
! 	 * @param MoodleQuickForm $mform the form being built.
! 	 */
! 	function definition_inner(&$mform) {
! 		global $QTYPES;
! 		$this->qtypeobj =& $QTYPES[$this->qtype()];
! 		$strquestionlabel = $this->qtypeobj->comment_header($this->nonemptyanswer);
! 		$label = get_string("sharedwildcards", "qtype_calculated");
! 		$mform->addElement('hidden', 'synchronize', 0);
! 		$mform->addElement('hidden', 'initialcategory', 1);
! 		$mform->setType('initialcategory', PARAM_INT);
! 		$mform->addElement('hidden', 'reload', 1);
! 		$mform->setType('reload', PARAM_INT);
! 		$addfieldsname='updatequestion value';
! 		$addstring=get_string("updatecategory", "qtype_calculated");
! 		$mform->registerNoSubmitButton($addfieldsname);
! 		// put a submit button to stop supplementary answers on update answers parameters
! 		// $mform->insertElementBefore($mform->createElement('submit', $addfieldsname, $addstring), 'listcategory');
! 
! 		$creategrades = get_grade_options();
! 		$this->add_per_answer_fields($mform, get_string('answerhdr', 'qtype_calculated', '{no}'),
! 		$creategrades->gradeoptions, 1, 1);
! 
! 		$QTYPES['numerical']->add_units_options($mform,$this);
! 
! 		$QTYPES['numerical']->add_units_elements($mform,$this);
! 		$label = "<div class='mdl-align'></div><div class='mdl-align'>".get_string('wildcardrole', 'qtype_calculatedsimple')."</div>";
! 		$mform->addElement('html', "<div class='mdl-align'>&nbsp;</div>");
! 		$mform->addElement('html', $label);// explaining the role of datasets so other strings can be shortened
! 
! 		$mform->addElement('submit', 'analyzequestion', get_string('findwildcards','qtype_calculatedsimple'));
! 		$mform->registerNoSubmitButton('analyzequestion');
! 		$mform->closeHeaderBefore('analyzequestion');
! 		if  (  "" != optional_param('analyzequestion','', PARAM_RAW)) {
! 
! 			$this->wizarddisplay = true;
! 
! 		}else {
! 			$this->wizwarddisplay = false;
! 		}
! 		if ($this->maxnumber != -1){
! 			$this->noofitems = $this->maxnumber;
! 		} else {
! 			$this->noofitems = 0;
! 		}
! 		if(!empty($this->datasetdefs)){//So there are some datadefs
! 			// we put them on the page
! 			$key = 0;
! 			$mform->addElement('header', 'additemhdr', get_string('wildcardparam', 'qtype_calculatedsimple'));
! 			$idx = 1;
! 			if(!empty($this->datasetdefs)){// unnecessary test
! 				$j = (($this->noofitems) * count($this->datasetdefs))+1;//
! 				foreach ($this->datasetdefs as $defkey => $datasetdef){
! 					$mform->addElement('static', "na[$j]", get_string('param', 'qtype_calculated', $datasetdef->name));
! 					$this->qtypeobj->custom_generator_tools_part($mform, $idx, $j);
! 					$mform->addElement('hidden', "datasetdef[$idx]");
! 					$mform->setType("datasetdef[$idx]", PARAM_RAW);
! 					$mform->addElement('hidden', "defoptions[$idx]");
! 					$mform->setType("defoptions[$idx]", PARAM_RAW);
! 					$idx++;
! 					$mform->addElement('static', "divider[$j]", '', '<hr />');
! 					$j++;
! 				}
! 			}
! 			//this should be done before the elements are created and stored as $this->formdata ;
! 			//fill out all data sets and also the fields for the next item to add.
! 			/*Here we do already the values error analysis so that
! 			 * we could force all wild cards values display if there is an error in values.
! 			 * as using a , in a number */
! 			$this->numbererrors = array();
! 			if(!empty($this->datasetdefs)){
! 				$j = $this->noofitems * count($this->datasetdefs);
! 				for ($itemnumber = $this->noofitems; $itemnumber >= 1; $itemnumber--){
! 					$data = array();
! 					$numbererrors = array() ;
! 					$comment = new stdClass;
! 					$comment->stranswers = array();
! 					$comment->outsidelimit = false ;
! 					$comment->answers = array();
! 
! 					foreach ($this->datasetdefs as $defid => $datasetdef){
! 						if (isset($datasetdef->items[$itemnumber])){
! 							$this->formdata["definition[$j]"] = $defid;
! 							$this->formdata["itemid[$j]"] = $datasetdef->items[$itemnumber]->id;
! 							$data[$datasetdef->name] = $datasetdef->items[$itemnumber]->value;
! 							$this->formdata["number[$j]"] = $number = $datasetdef->items[$itemnumber]->value;
! 							if(! is_numeric($number)){
! 								$a = new stdClass;
! 								$a->name = '{'.$datasetdef->name.'}' ;
! 								$a->value = $datasetdef->items[$itemnumber]->value ;
! 								if (stristr($number,',')){
! 									$this->numbererrors["number[$j]"]=get_string('nocommaallowed', 'qtype_calculated');
! 									$numbererrors .= $this->numbererrors['number['.$j.']']."<br />";
! 
! 								}else {
! 									$this->numbererrors["number[$j]"]= get_string('notvalidnumber','qtype_calculated',$a);
! 									$numbererrors .= $this->numbererrors['number['.$j.']']."<br />";
! 									//$comment->outsidelimit = false ;
! 								}
! 							}else if( stristr($number,'x')){ // hexa will pass the test
! 								$a = new stdClass;
! 								$a->name = '{'.$datasetdef->name.'}' ;
! 								$a->value = $datasetdef->items[$itemnumber]->value ;
! 								$this->numbererrors['number['.$j.']']= get_string('hexanotallowed','qtype_calculated',$a);
! 								$numbererrors .= $this->numbererrors['number['.$j.']']."<br />";
! 							} else if( is_nan($number)){
! 								$a = new stdClass;
! 								$a->name = '{'.$datasetdef->name.'}' ;
! 								$a->value = $datasetdef->items[$itemnumber]->value ;
! 								$this->numbererrors["number[$j]"]= get_string('notvalidnumber','qtype_calculated',$a);
! 								$numbererrors .= $this->numbererrors['number['.$j.']']."<br />";
! 								//   $val = 1.0 ;
! 							}
! 						}
! 						$j--;
! 					}
! 					if($this->noofitems != 0 ) {
! 						if (empty($numbererrors)) {
! 							if (!isset($this->question->id)) {
! 								$this->question->id = 0 ;
! 							}
! 							$this->question->questiontext = !empty($this->question->questiontext)?$this->question->questiontext:'';
! 							$comment = $this->qtypeobj->comment_on_datasetitems($this->qtypeobj, $this->question->id, $this->question->questiontext, $this->nonemptyanswer, $data, $itemnumber);
! 							if ($comment->outsidelimit) {
! 								$this->outsidelimit=$comment->outsidelimit ;
! 							}
! 							$totalcomment='';
! 
! 							foreach ($this->nonemptyanswer as $key => $answer) {
! 								$totalcomment .= $comment->stranswers[$key].'<br/>';
! 							}
! 
! 							$this->formdata['answercomment['.$itemnumber.']'] = $totalcomment ;
! 						}
! 					}
! 				}
! 				$this->formdata['selectdelete'] = '1';
! 				$this->formdata['selectadd'] = '1';
! 				$j = $this->noofitems * count($this->datasetdefs)+1;
! 				$data = array(); // data for comment_on_datasetitems later
! 				$idx =1 ;
! 				foreach ($this->datasetdefs as $defid => $datasetdef){
! 					$this->formdata["datasetdef[$idx]"] = $defid;
! 					$idx++;
! 				}
! 				$this->formdata = $this->qtypeobj->custom_generator_set_data($this->datasetdefs, $this->formdata);
! 			}
! 
! 
! 			$addoptions = Array();
! 			$addoptions['1']='1';
! 			for ($i=10; $i<=100 ; $i+=10){
! 				$addoptions["$i"]="$i";
! 			}
! 			$showoptions = Array();
! 			$showoptions['1']='1';
! 			$showoptions['2']='2';
! 			$showoptions['5']='5';
! 			for ($i=10; $i<=100 ; $i+=10){
! 				$showoptions["$i"]="$i";
! 			}
! 			$mform->closeHeaderBefore('additemhdr');
! 			$addgrp = array();
! 			$addgrp[] =& $mform->createElement('submit', 'addbutton', get_string('generatenewitemsset', 'qtype_calculatedsimple'));
! 			$addgrp[] =& $mform->createElement('select', "selectadd", '', $addoptions);
! 			$addgrp[] = & $mform->createElement('static',"stat",'',get_string('newsetwildcardvalues', 'qtype_calculatedsimple'));
! 			$mform->addGroup($addgrp, 'addgrp', '', '   ', false);
! 			$mform->registerNoSubmitButton('addbutton');
! 			$mform->closeHeaderBefore('addgrp');
! 			$addgrp1 = array();
! 			$addgrp1[] =& $mform->createElement('submit', 'showbutton', get_string('showitems', 'qtype_calculatedsimple'));
! 			$addgrp1[] =& $mform->createElement('select', "selectshow",'' , $showoptions);
! 			$addgrp1[] = & $mform->createElement('static',"stat",'',get_string('setwildcardvalues', 'qtype_calculatedsimple'));
! 			$mform->addGroup($addgrp1, 'addgrp1', '', '   ', false);
! 			$mform->registerNoSubmitButton('showbutton');
! 			$mform->closeHeaderBefore('addgrp1');
! 			$mform->addElement('static', "divideradd", '', '');
! 			if ($this->noofitems == 0) {
! 				$mform->addElement('static','warningnoitems','','<span class="error">'.get_string('youmustaddatleastonevalue', 'qtype_calculatedsimple').'</span>');
! 				$mform->closeHeaderBefore('warningnoitems');
! 			}else {
! 				$mform->addElement('header', 'additemhdr1', get_string('wildcardvalues', 'qtype_calculatedsimple'));
! 				$mform->closeHeaderBefore('additemhdr1');
! 				//   $mform->addElement('header', '', get_string('itemno', 'qtype_calculated', ""));
! 				if( !empty($this->numbererrors) || $this->outsidelimit) {
! 					$mform->addElement('static', "alert", '', '<span class="error">'.get_string('useadvance', 'qtype_calculatedsimple').'</span>');
! 				}
! 
! 				$mform->addElement('submit', 'updatedatasets', get_string('updatewildcardvalues', 'qtype_calculatedsimple'));
! 				$mform->registerNoSubmitButton('updatedatasets');
! 				$mform->setAdvanced("updatedatasets",true);
! 
! 				//------------------------------------------------------------------------------------------------------------------------------
! 				$j = $this->noofitems * count($this->datasetdefs);
! 				$k = 1 ;
! 				if ("" != optional_param('selectshow', '', PARAM_INT)){
! 					$k = optional_param('selectshow', '', PARAM_INT);
! 				}
! 
! 				for ($i = $this->noofitems; $i >= 1 ; $i--){
! 					foreach ($this->datasetdefs as $defkey => $datasetdef){
! 						if($k > 0 ||  $this->outsidelimit || !empty($this->numbererrors ) ){
! 							$mform->addElement('text',"number[$j]" , get_string('wildcard', 'qtype_calculatedsimple', $datasetdef->name));
! 							$mform->setAdvanced("number[$j]",true);
! 							if(!empty($this->numbererrors['number['.$j.']']) ){
! 								$mform->addElement('static', "numbercomment[$j]",'','<span class="error">'.$this->numbererrors['number['.$j.']'].'</span>');
! 								$mform->setAdvanced("numbercomment[$j]",true);
! 							}
! 						}else {
! 							$mform->addElement('hidden',"number[$j]" , get_string('wildcard', 'qtype_calculatedsimple', $datasetdef->name));
! 						}
! 						$mform->setType("number[$j]", PARAM_NUMBER);
! 
! 						$mform->addElement('hidden', "itemid[$j]");
! 						$mform->setType("itemid[$j]", PARAM_INT);
! 
! 						$mform->addElement('hidden', "definition[$j]");
! 						$mform->setType("definition[$j]", PARAM_NOTAGS);
! 
! 						$j--;
! 					}
! 					if (!empty( $strquestionlabel) && ($k > 0 ||  $this->outsidelimit || !empty($this->numbererrors ) ) ){
! 						//   $repeated[] =& $mform->addElement('static', "answercomment[$i]", $strquestionlabel);
! 						$mform->addElement('static', "answercomment[$i]", "<b>".get_string('setno', 'qtype_calculatedsimple', $i)."</b>&nbsp;&nbsp;".$strquestionlabel);
! 
! 					}
! 					if($k > 0 ||  $this->outsidelimit || !empty($this->numbererrors )){
! 						$mform->addElement('static', "divider1[$j]", '', '<hr />');
! 
! 					}
! 					$k-- ;
! 				}
! 			}
! 			//  if ($this->outsidelimit){
! 			//   $mform->addElement('static','outsidelimit','','');
! 			//  }
! 		}else {
! 			$mform->addElement('static','warningnowildcards','','<span class="error">'.get_string('atleastonewildcard', 'qtype_calculatedsimple').'</span>');
! 			$mform->closeHeaderBefore('warningnowildcards');
! 		}
! 
! 
! 		//------------------------------------------------------------------------------------------------------------------------------
! 		//non standard name for button element needed so not using add_action_buttons
! 		//hidden elements
! 
! 		$mform->addElement('hidden', 'id');
! 		$mform->setType('id', PARAM_INT);
! 
! 		$mform->addElement('hidden', 'courseid');
! 		$mform->setType('courseid', PARAM_INT);
! 		$mform->setDefault('courseid', 0);
! 
! 		$mform->addElement('hidden', 'cmid');
! 		$mform->setType('cmid', PARAM_INT);
! 		$mform->setDefault('cmid', 0);
! 		if (!empty($this->question->id)){
! 			if ($this->question->formoptions->cansaveasnew){
! 				$mform->addElement('header', 'additemhdr', get_string('converttocalculated', 'qtype_calculatedsimple'));
! 				$mform->closeHeaderBefore('additemhdr');
! 
! 				$mform->addElement('checkbox', 'convert','' ,get_string('willconverttocalculated', 'qtype_calculatedsimple'));
! 				$mform->setDefault('convert', 0);
! 
! 			}
! 		}
! 	}
! 
! 	function data_preprocessing($question) {
! 		global $QTYPES;
! 		$answer = $this->answer;
! 		$default_values = array();
! 		if (count($answer)) {
! 			$key = 0;
! 			foreach ($answer as $answer){
! 				$default_values['answer['.$key.']'] = $answer->answer; //  is necessary ? to-do test it
! 				$default_values['fraction['.$key.']'] = $answer->fraction;
! 				$default_values['tolerance['.$key.']'] = $answer->tolerance;
! 				$default_values['tolerancetype['.$key.']'] = $answer->tolerancetype;
! 				$default_values['correctanswerlength['.$key.']'] = $answer->correctanswerlength;
! 				$default_values['correctanswerformat['.$key.']'] = $answer->correctanswerformat;
! 
! 				// prepare draft files
! 				$draftid = file_get_submitted_draft_itemid('feedback['.$key.']');
! 				$default_values['feedback['.$key.']']['text'] = file_prepare_draft_area(
! 				$draftid,       // draftid
! 				$this->context->id,    // context
                      'question', // component
                      'answerfeedback',             // filarea
! 				!empty($answer->id)?(int)$answer->id:null, // itemid
! 				$this->fileoptions,    // options
! 				!empty($answer->feedback)?$answer->feedback:''      // text
! 				);
! 				$default_values['feedback['.$key.']']['format'] = !empty($answer->feedbackformat)?$answer->feedbackformat:editors_get_preferred_format();
! 				$default_values['feedback['.$key.']']['itemid'] = $draftid;
! 
! 				$key++;
! 			}
! 		}
! 		$default_values['synchronize'] = 0 ;
! 		$QTYPES['numerical']->set_numerical_unit_data($this, $question, $default_values);
! 		/*  if (isset($question->options)){
! 		 $default_values['unitgradingtype'] = $question->options->unitgradingtype ;
! 		 $default_values['unitpenalty'] = $question->options->unitpenalty ;
! 		 switch ($question->options->showunits){
! 		 case 'O' :
! 		 case '1' :
! 		 $default_values['showunits0'] = $question->options->showunits ;
! 		 $default_values['unitrole'] = 0 ;
! 		 break;
! 		 case '2' :
! 		 case '3' :
! 		 $default_values['showunits1'] = $question->options->showunits ;
! 		 $default_values['unitrole'] = 1 ;
! 		 break;
! 		 }
! 		 $default_values['unitsleft'] = $question->options->unitsleft ;
! 		 $default_values['instructions'] = $question->options->instructions  ;
! 
! 		 if (isset($question->options->units)){
! 		 $units  = array_values($question->options->units);
! 		 if (!empty($units)) {
! 		 foreach ($units as $key => $unit){
! 		 $default_values['unit['.$key.']'] = $unit->unit;
! 		 $default_values['multiplier['.$key.']'] = $unit->multiplier;
! 		 }
! 		 }
! 		 }
! 		 }
! 		 */
! 		$key = 0 ;
! 
! 		$formdata = array();
! 		$fromform = new stdClass();
! 		//this should be done before the elements are created and stored as $this->formdata ;
! 		//fill out all data sets and also the fields for the next item to add.
! 		/* if(!empty($this->datasetdefs)){
! 		 $j = $this->noofitems * count($this->datasetdefs);
! 		 for ($itemnumber = $this->noofitems; $itemnumber >= 1; $itemnumber--){
! 		 $data = array();
! 		 foreach ($this->datasetdefs as $defid => $datasetdef){
! 		 if (isset($datasetdef->items[$itemnumber])){
! 		 $formdata["number[$j]"] = $datasetdef->items[$itemnumber]->value;
! 		 $formdata["definition[$j]"] = $defid;
! 		 $formdata["itemid[$j]"] = $datasetdef->items[$itemnumber]->id;
! 		 $data[$datasetdef->name] = $datasetdef->items[$itemnumber]->value;
! 		 }
! 		 $j--;
! 		 }
! 		 // echo "<p>answers avant  comment <pre>";print_r($answer);echo"</pre></p>";
! 		 // echo "<p>data avant  comment <pre>";print_r($data);echo"</pre></p>";
! 
! 		 if($this->noofitems != 0 ) {
! 		 if(!isset($question->id)) $question->id = 0 ;
! 		 $comment = $this->qtypeobj->comment_on_datasetitems($question->id,$this->nonemptyanswer, $data, $itemnumber);//$this->
! 		 if ($comment->outsidelimit) {
! 		 $this->outsidelimit=$comment->outsidelimit ;
! 		 }
! 		 $totalcomment='';
! 		 // echo "<p> comment <pre>";print_r($comment);echo"</pre></p>";
! 
! 		 foreach ($this->nonemptyanswer as $key => $answer) {
! 		 $totalcomment .= $comment->stranswers[$key].'<br/>';
! 		 }
! 
! 		 $formdata['answercomment['.$itemnumber.']'] = $totalcomment ;
! 		 }
! 		 }
! 		 // $formdata['reload'] = '1';
! 		 // $formdata['nextpageparam[forceregeneration]'] = $this->regenerate;
! 		 $formdata['selectdelete'] = '1';
! 		 $formdata['selectadd'] = '1';
! 		 $j = $this->noofitems * count($this->datasetdefs)+1;
! 		 $data = array(); // data for comment_on_datasetitems later
! 		 $idx =1 ;
! 		 foreach ($this->datasetdefs as $defid => $datasetdef){
! 		 $formdata["datasetdef[$idx]"] = $defid;
! 		 $idx++;
! 		 }
! 		 $formdata = $this->qtypeobj->custom_generator_set_data($this->datasetdefs, $formdata);
! 		 }*/
! 		$question = (object)((array)$question + $default_values+$this->formdata );
! 
! 		return $question;
! 	}
! 
! 	function qtype() {
! 		return 'calculatedsimple';
! 	}
! 
! 	function validation($data, $files) {
! 		global $QTYPES;
! 		$errors = parent::validation($data, $files);
! 		//verifying for errors in {=...} in question text;
! 		$qtext = "";
! 		$qtextremaining = $data['questiontext']['text'];
! 		$possibledatasets = $this->qtypeobj->find_dataset_names($data['questiontext']['text']);
! 		foreach ($possibledatasets as $name => $value) {
! 			$qtextremaining = str_replace('{'.$name.'}', '1', $qtextremaining);
! 		}
! 		while  (preg_match('~\{=([^[:space:]}]*)}~', $qtextremaining, $regs1)) {
! 			$qtextsplits = explode($regs1[0], $qtextremaining, 2);
! 			$qtext =$qtext.$qtextsplits[0];
! 			$qtextremaining = $qtextsplits[1];
! 			if (!empty($regs1[1]) && $formulaerrors = qtype_calculated_find_formula_errors($regs1[1])) {
! 				if(!isset($errors['questiontext'])){
! 					$errors['questiontext'] = $formulaerrors.':'.$regs1[1] ;
! 				}else {
! 					$errors['questiontext'] .= '<br/>'.$formulaerrors.':'.$regs1[1];
! 				}
! 			}
! 		}
! 		$answers = $data['answer'];
! 		$answercount = 0;
! 		$maxgrade = false;
! 		$possibledatasets = $this->qtypeobj->find_dataset_names($data['questiontext']['text']);
! 		$mandatorydatasets = array();
! 		foreach ($answers as $key => $answer){
! 			$mandatorydatasets += $this->qtypeobj->find_dataset_names($answer);
! 		}
! 		if ( count($mandatorydatasets )==0){
! 			foreach ($answers as $key => $answer){
! 				$errors['answer['.$key.']'] = get_string('atleastonewildcard', 'qtype_calculated');
! 			}
! 		}
! 		foreach ($answers as $key => $answer){
! 			//check no of choices
! 			// the * for everykind of answer not actually implemented
! 			$trimmedanswer = trim($answer);
! 			if (($trimmedanswer!='')||$answercount==0){
! 				$eqerror = qtype_calculated_find_formula_errors($trimmedanswer);
! 				if (FALSE !== $eqerror){
! 					$errors['answer['.$key.']'] = $eqerror;
! 				}
! 			}
! 			if ($trimmedanswer!=''){
! 				if ('2' == $data['correctanswerformat'][$key]
! 				&& '0' == $data['correctanswerlength'][$key]) {
! 					$errors['correctanswerlength['.$key.']'] = get_string('zerosignificantfiguresnotallowed','quiz');
! 				}
! 				if (!is_numeric($data['tolerance'][$key])){
! 					$errors['tolerance['.$key.']'] = get_string('mustbenumeric', 'qtype_calculated');
! 				}
! 				if ($data['fraction'][$key] == 1) {
! 					$maxgrade = true;
! 				}
! 
! 				$answercount++;
! 			}
! 			//check grades
! 
! 			//TODO how should grade checking work here??
! 			/*if ($answer != '') {
! 			if ($data['fraction'][$key] > 0) {
! 			$totalfraction += $data['fraction'][$key];
! 			}
! 			if ($data['fraction'][$key] > $maxfraction) {
! 			$maxfraction = $data['fraction'][$key];
! 			}
! 			}*/
! 		}
! 		//grade checking :
! 		/// Perform sanity checks on fractional grades
! 		/*if ( ) {
! 		 if ($maxfraction != 1) {
! 		 $maxfraction = $maxfraction * 100;
! 		 $errors['fraction[0]'] = get_string('errfractionsnomax', 'qtype_multichoice', $maxfraction);
! 		 }
! 		 } else {
! 		 $totalfraction = round($totalfraction,2);
! 		 if ($totalfraction != 1) {
! 		 $totalfraction = $totalfraction * 100;
! 		 $errors['fraction[0]'] = get_string('errfractionsaddwrong', 'qtype_multichoice', $totalfraction);
! 		 }
! 		 }*/
! 		$QTYPES['numerical']->validate_numerical_options($data, $errors) ;
! 		$units  = $data['unit'];
! 		if (count($units)) {
! 			foreach ($units as $key => $unit){
! 				if (is_numeric($unit)){
! 					$errors['unit['.$key.']'] = get_string('mustnotbenumeric', 'qtype_calculated');
! 				}
! 				$trimmedunit = trim($unit);
! 				$trimmedmultiplier = trim($data['multiplier'][$key]);
! 				if (!empty($trimmedunit)){
! 					if (empty($trimmedmultiplier)){
! 						$errors['multiplier['.$key.']'] = get_string('youmustenteramultiplierhere', 'qtype_calculated');
! 					}
! 					if (!is_numeric($trimmedmultiplier)){
! 						$errors['multiplier['.$key.']'] = get_string('mustbenumeric', 'qtype_calculated');
! 					}
! 
! 				}
! 			}
! 		}
! 		if ($answercount==0){
! 			$errors['answer[0]'] = get_string('atleastoneanswer', 'qtype_calculated');
! 		}
! 		if ($maxgrade == false) {
! 			$errors['fraction[0]'] = get_string('fractionsnomax', 'question');
! 		}
! 		if (isset($data['backtoquiz']) && ($this->noofitems==0) ){
! 			$errors['warning'] = get_string('warning', 'mnet');
! 		}
! 		if ($this->outsidelimit){
! 			//   if(!isset($errors['warning'])) $errors['warning']=' ';
! 			$errors['outsidelimits'] = get_string('oneanswertrueansweroutsidelimits','qtype_calculated');
! 		}
! 		/*Here we use the already done the error analysis so that
! 		 * we could force all wild cards values display if there is an error in values.
! 		 * as using a , in a number *//*
! 		 $numbers = $data['number'];
! 		 foreach ($numbers as $key => $number){
! 		 if(! is_numeric($number)){
! 		 if (stristr($number,',')){
! 		 $errors['number['.$key.']'] = get_string('notvalidnumber', 'qtype_calculated');
! 		 }else {
! 		 $errors['number['.$key.']'] = get_string('notvalidnumber', 'qtype_calculated');
! 		 }
! 		 }else if( stristr($number,'x')){
! 		 $errors['number['.$key.']'] = get_string('notvalidnumber', 'qtype_calculated');
! 		 } else if( is_nan($number)){
! 		 $errors['number['.$key.']'] = get_string('notvalidnumber', 'qtype_calculated');
! 		 }
! 		 }
! 		 */
! 		if ( $this->noofitems==0  ){
! 			$errors['warning'] = get_string('warning', 'mnet');
! 		}
  
! 		return $errors;
! 	}
  }
diff -crB questionorg/type/calculatedsimple/lib.php questionupd/type/calculatedsimple/lib.php
*** questionorg/type/calculatedsimple/lib.php	2012-04-13 12:31:13.878178295 +0500
--- questionupd/type/calculatedsimple/lib.php	2012-04-13 09:42:57.000000000 +0500
***************
*** 25,31 ****
   * @license   http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
   */
  function qtype_calculatedsimple_pluginfile($course, $cm, $context, $filearea, $args, $forcedownload) {
!     global $CFG;
!     require_once($CFG->libdir . '/questionlib.php');
!     question_pluginfile($course, $context, 'qtype_calculatedsimple', $filearea, $args, $forcedownload);
  }
--- 25,31 ----
   * @license   http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
   */
  function qtype_calculatedsimple_pluginfile($course, $cm, $context, $filearea, $args, $forcedownload) {
! 	global $CFG;
! 	require_once($CFG->libdir . '/questionlib.php');
! 	question_pluginfile($course, $context, 'qtype_calculatedsimple', $filearea, $args, $forcedownload);
  }
diff -crB questionorg/type/calculatedsimple/questiontype.php questionupd/type/calculatedsimple/questiontype.php
*** questionorg/type/calculatedsimple/questiontype.php	2012-04-13 12:31:13.877178295 +0500
--- questionupd/type/calculatedsimple/questiontype.php	2012-04-13 09:42:57.000000000 +0500
***************
*** 25,396 ****
  
  
  
!     // Used by the function custom_generator_tools:
!     public $calcgenerateidhasbeenadded = false;
!     public $virtualqtype = false;
!     public $wizard_pages_number = 1 ;
! 
!     function name() {
!         return 'calculatedsimple';
!     }
! 
!     function save_question_options($question) {
!         global $CFG, $DB , $QTYPES;
!         $context = $question->context;
!         //$options = $question->subtypeoptions;
!         // Get old answers:
! 
!         if (isset($question->answer) && !isset($question->answers)) {
!             $question->answers = $question->answer;
!         }
! 
!         // Get old versions of the objects
!         if (!$oldanswers = $DB->get_records('question_answers', array('question' => $question->id), 'id ASC')) {
!             $oldanswers = array();
!         }
! 
!         if (!$oldoptions = $DB->get_records('question_calculated', array('question' => $question->id), 'answer ASC')) {
!             $oldoptions = array();
!         }
! 
!         // Save the units.
!         $virtualqtype = $this->get_virtual_qtype($question);
!         $result = $virtualqtype->save_numerical_units($question);
!         if (isset($result->error)) {
!             return $result;
!         } else {
!             $units = &$result->units;
!         }
!         // Insert all the new answers
!         if (isset($question->answer) && !isset($question->answers)) {
!             $question->answers=$question->answer;
!         }
!         foreach ($question->answers as $key => $dataanswer) {
!             if (is_array($dataanswer)) {
!                 $dataanswer = $dataanswer['text'];
!             }
!             if ( trim($dataanswer) != '' ) {
!                 $answer = new stdClass;
!                 $answer->question = $question->id;
!                 $answer->answer = trim($dataanswer);
!                 $answer->fraction = $question->fraction[$key];
!                 $answer->feedbackformat = $question->feedback[$key]['format'];
!                 if (isset($question->feedback[$key]['files'])) {
!                     $files = $question->feedback[$key]['files'];
!                 }
! 
!                 if ($oldanswer = array_shift($oldanswers)) {  // Existing answer, so reuse it
!                     $answer->id = $oldanswer->id;
!                     $answer->feedback = file_save_draft_area_files($question->feedback[$key]['itemid'], $context->id, 'question', 'answerfeedback', $answer->id, $this->fileoptionsa, trim($question->feedback[$key]['text']));
!                     $DB->update_record("question_answers", $answer);
!                 } else { // This is a completely new answer
!                     $answer->feedback = trim($question->feedback[$key]['text']);
!                     $answer->id = $DB->insert_record("question_answers", $answer);
!                     if (isset($files)) {
!                         foreach ($files as $file) {
!                             $this->import_file($context, 'question', 'answerfeedback', $answer->id, $file);
!                         }
!                     } else {
!                         $answer->feedback = file_save_draft_area_files($question->feedback[$key]['itemid'], $context->id, 'question', 'answerfeedback', $answer->id, $this->fileoptionsa, trim($question->feedback[$key]['text']));
!                     }
!                     $DB->set_field('question_answers', 'feedback', $answer->feedback, array('id'=>$answer->id));
!                 }
! 
!                 // Set up the options object
!                 if (!$options = array_shift($oldoptions)) {
!                     $options = new stdClass;
!                 }
!                 $options->question  = $question->id;
!                 $options->answer    = $answer->id;
!                 $options->tolerance = trim($question->tolerance[$key]);
!                 $options->tolerancetype  = trim($question->tolerancetype[$key]);
!                 $options->correctanswerlength  = trim($question->correctanswerlength[$key]);
!                 $options->correctanswerformat  = trim($question->correctanswerformat[$key]);
! 
!                 // Save options
!                 if (isset($options->id)) { // reusing existing record
!                     $DB->update_record('question_calculated', $options);
!                 } else { // new options
!                     $DB->insert_record('question_calculated', $options);
!                 }
!             }
!         }
!         // delete old answer records
!         if (!empty($oldanswers)) {
!             foreach($oldanswers as $oa) {
!                 $DB->delete_records('question_answers', array('id' => $oa->id));
!             }
!         }
! 
!         // delete old answer records
!         if (!empty($oldoptions)) {
!             foreach($oldoptions as $oo) {
!                 $DB->delete_records('question_calculated', array('id' => $oo->id));
!             }
!         }
! 
!         if(isset($question->import_process)&&$question->import_process) {
!             $this->import_datasets($question);
!         } else {
!             //save datasets and datatitems from form i.e in question
!             //  $datasetdefs = $this->get_dataset_definitions($question->id, array());
!             $question->dataset = $question->datasetdef ;
!             //       $this->save_dataset_definitions($question);
!             // Save datasets
!             $datasetdefinitions = $this->get_dataset_definitions($question->id, $question->dataset);
!             $tmpdatasets = array_flip($question->dataset);
!             $defids = array_keys($datasetdefinitions);
!             $datasetdefs = array();
!             foreach ($defids as $defid) {
!                 $datasetdef = &$datasetdefinitions[$defid];
!                 if (isset($datasetdef->id)) {
!                     if (!isset($tmpdatasets[$defid])) {
!                         // This dataset is not used any more, delete it
!                         $DB->delete_records('question_datasets', array('question' => $question->id, 'datasetdefinition' => $datasetdef->id));
!                         // if ($datasetdef->category == 0) { // Question local dataset
!                         $DB->delete_records('question_dataset_definitions', array('id' => $datasetdef->id));
!                         $DB->delete_records('question_dataset_items', array('definition' => $datasetdef->id));
!                         // }
!                     }
!                     // This has already been saved or just got deleted
!                     unset($datasetdefinitions[$defid]);
!                     continue;
!                 }
!                 $datasetdef->id = $DB->insert_record('question_dataset_definitions', $datasetdef);
!                 $datasetdefs[]= clone($datasetdef);
!                 $questiondataset = new stdClass;
!                 $questiondataset->question = $question->id;
!                 $questiondataset->datasetdefinition = $datasetdef->id;
!                 $DB->insert_record('question_datasets', $questiondataset);
!                 unset($datasetdefinitions[$defid]);
!             }
!             // Remove local obsolete datasets as well as relations
!             // to datasets in other categories:
!             if (!empty($datasetdefinitions)) {
!                 foreach ($datasetdefinitions as $def) {
!                     $DB->delete_records('question_datasets', array('question' => $question->id, 'datasetdefinition' => $def->id));
!                     if ($def->category == 0) { // Question local dataset
!                         $DB->delete_records('question_dataset_definitions', array('id' => $def->id));
!                         $DB->delete_records('question_dataset_items', array('definition' => $def->id));
!                     }
!                 }
!             }
!             $datasetdefs = $this->get_dataset_definitions($question->id, $question->dataset);
!             // Handle adding and removing of dataset items
!             $i = 1;
!             ksort($question->definition);
!             foreach ($question->definition as $key => $defid) {
!                 $addeditem = new stdClass();
!                 $addeditem->definition = $datasetdefs[$defid]->id;
!                 $addeditem->value = $question->number[$i];
!                 $addeditem->itemnumber = ceil($i / count($datasetdefs));
!                 if (empty($question->makecopy) && $question->itemid[$i]) {
!                     // Reuse any previously used record
!                     $addeditem->id = $question->itemid[$i];
!                     $DB->update_record('question_dataset_items', $addeditem);
!                 } else {
!                     $DB->insert_record('question_dataset_items', $addeditem);
!                 }
!                 $i++;
!             }
!             $maxnumber = -1;
!             if (isset($addeditem->itemnumber) && $maxnumber < $addeditem->itemnumber){
!                 $maxnumber = $addeditem->itemnumber;
!                 foreach ($datasetdefs as $key => $newdef) {
!                     if (isset($newdef->id) && $newdef->itemcount <= $maxnumber) {
!                         $newdef->itemcount = $maxnumber;
!                         // Save the new value for options
!                         $DB->update_record('question_dataset_definitions', $newdef);
!                     }
!                 }
!             }
!         }
!         // Report any problems.
!         //convert to calculated
!         if(!empty($question->makecopy) && !empty($question->convert)) {
!             $DB->set_field('question', 'qtype', 'calculated', array('id'=> $question->id));
!         }
!         $result = $QTYPES['numerical']->save_numerical_options($question);
!         if (isset($result->error)) {
!             return $result;
!         }
! 
!         if (!empty($result->notice)) {
!             return $result;
!         }
!         return true;
!     }
!     function finished_edit_wizard(&$form) {
!         return true ; //isset($form->backtoquiz);
!     }
!     function wizard_pages_number() {
!         return 1 ;
!     }
! 
! 
!     function custom_generator_tools_part(&$mform, $idx, $j){
! 
!         $minmaxgrp = array();
!         $minmaxgrp[] =& $mform->createElement('text', "calcmin[$idx]", get_string('calcmin', 'qtype_calculated'));
!         $minmaxgrp[] =& $mform->createElement('text', "calcmax[$idx]", get_string('calcmax', 'qtype_calculated'));
!         $mform->addGroup($minmaxgrp, 'minmaxgrp', get_string('minmax', 'qtype_calculated'), ' - ', false);
!         $mform->setType("calcmin[$idx]", PARAM_NUMBER);
!         $mform->setType("calcmax[$idx]", PARAM_NUMBER);
! 
!         $precisionoptions = range(0, 10);
!         $mform->addElement('select', "calclength[$idx]", get_string('calclength', 'qtype_calculated'), $precisionoptions);
! 
!         $distriboptions = array('uniform' => get_string('uniform', 'qtype_calculated'), 'loguniform' => get_string('loguniform', 'qtype_calculated'));
!         $mform->addElement('hidden', "calcdistribution[$idx]", 'uniform');
!         $mform->setType("calcdistribution[$idx]", PARAM_INT);
! 
! 
!     }
! 
!     function comment_header($answers) {
!         //$this->get_question_options($question);
!         $strheader = "";
!         $delimiter = '';
! 
!         // $answers = $question->options->answers;
! 
!         foreach ($answers as $key => $answer) {
!          /*   if (is_string($answer)) {
!                 $strheader .= $delimiter.$answer;
!          } else {*/
!             $strheader .= $delimiter.$answer->answer;
!             // }
!             $delimiter = '<br/><br/><br/>';
!         }
!         return $strheader;
!     }
  
!     function tolerance_types() {
!         return array('1'  => get_string('relative', 'quiz'),
              '2'  => get_string('nominal', 'quiz'),
!             //        '3'  => get_string('geometric', 'quiz')
!         );
!     }
! 
!     function dataset_options($form, $name, $mandatory=true,$renameabledatasets=false) {
!         // Takes datasets from the parent implementation but
!         // filters options that are currently not accepted by calculated
!         // It also determines a default selection...
!         //$renameabledatasets not implemented anmywhere
!         list($options, $selected) = $this->dataset_options_from_database($form, $name,'','qtype_calculated');
!         //  list($options, $selected) = $this->dataset_optionsa($form, $name);
! 
!         foreach ($options as $key => $whatever) {
!             if (!preg_match('~^1-~', $key) && $key != '0') {
!                 unset($options[$key]);
!             }
!         }
!         if (!$selected) {
!             if ($mandatory){
!                 $selected =  "1-0-$name"; // Default
!             }else {
!                 $selected = "0"; // Default
!             }
!         }
!         return array($options, $selected);
!     }
! 
! 
!     /**
!      * Runs all the code required to set up and save an essay question for testing purposes.
!      * Alternate DB table prefix may be used to facilitate data deletion.
!      */
!     function generate_test($name, $courseid = null) {
!         global $DB;
!         list($form, $question) = parent::generate_test($name, $courseid);
!         $form->feedback = 1;
!         $form->multiplier = array(1, 1);
!         $form->shuffleanswers = 1;
!         $form->noanswers = 1;
!         $form->qtype ='calculatedsimple';
!         $question->qtype ='calculatedsimple';
!         $form->answers = array('{a} + {b}');
!         $form->fraction = array(1);
!         $form->tolerance = array(0.01);
!         $form->tolerancetype = array(1);
!         $form->correctanswerlength = array(2);
!         $form->correctanswerformat = array(1);
!         $form->questiontext = "What is {a} + {b}?";
! 
!         if ($courseid) {
!             $course = $DB->get_record('course', array('id'=> $courseid));
!         }
! 
!         $new_question = $this->save_question($question, $form);
! 
!         $dataset_form = new stdClass();
!         $dataset_form->nextpageparam["forceregeneration"]= 1;
!         $dataset_form->calcmin = array(1 => 1.0, 2 => 1.0);
!         $dataset_form->calcmax = array(1 => 10.0, 2 => 10.0);
!         $dataset_form->calclength = array(1 => 1, 2 => 1);
!         $dataset_form->number = array(1 => 5.4 , 2 => 4.9);
!         $dataset_form->itemid = array(1 => '' , 2 => '');
!         $dataset_form->calcdistribution = array(1 => 'uniform', 2 => 'uniform');
!         $dataset_form->definition = array(1 => "1-0-a",
!             2 => "1-0-b");
!         $dataset_form->nextpageparam = array('forceregeneration' => false);
!         $dataset_form->addbutton = 1;
!         $dataset_form->selectadd = 1;
!         $dataset_form->courseid = $courseid;
!         $dataset_form->cmid = 0;
!         $dataset_form->id = $new_question->id;
!         $this->save_dataset_items($new_question, $dataset_form);
! 
!         return $new_question;
!     }
! 
!     function move_files($questionid, $oldcontextid, $newcontextid) {
!         $fs = get_file_storage();
! 
!         parent::move_files($questionid, $oldcontextid, $newcontextid);
!         $this->move_files_in_answers($questionid, $oldcontextid, $newcontextid);
! 
!         $fs->move_area_files_to_new_context($oldcontextid,
!                 $newcontextid, 'qtype_calculatedsimple', 'instruction', $questionid);
!     }
! 
!     protected function delete_files($questionid, $contextid) {
!         $fs = get_file_storage();
! 
!         parent::delete_files($questionid, $contextid);
!         $this->delete_files_in_answers($questionid, $contextid);
!         $fs->delete_area_files($contextid, 'qtype_calculatedsimple', 'instruction', $questionid);
!     }
! 
!     function check_file_access($question, $state, $options, $contextid, $component,
!             $filearea, $args) {
!         $itemid = reset($args);
!         if ($component == 'question' && $filearea == 'answerfeedback') {
! 
!             // check if answer id exists
!             $result = $options->feedback && array_key_exists($itemid, $question->options->answers);
!             if (!$result) {
!                 return false;
!             }
!             // check response
!             if (!$this->check_response($question, $state)) {
!                 return false;
!             }
!             return true;
!         } else if ($filearea == 'instruction') {
!             // TODO: should it be display all the time like questiontext?
!             // check if question id exists
!             if ($itemid != $question->id) {
!                 return false;
!             } else {
!                 return true;
!             }
!         } else {
!             return parent::check_file_access($question, $state, $options, $contextid, $component,
!                     $filearea, $args);
!         }
!         return true;
!     }
  }
  //// END OF CLASS ////
  
--- 25,396 ----
  
  
  
! 	// Used by the function custom_generator_tools:
! 	public $calcgenerateidhasbeenadded = false;
! 	public $virtualqtype = false;
! 	public $wizard_pages_number = 1 ;
! 
! 	function name() {
! 		return 'calculatedsimple';
! 	}
! 
! 	function save_question_options($question) {
! 		global $CFG, $DB , $QTYPES;
! 		$context = $question->context;
! 		//$options = $question->subtypeoptions;
! 		// Get old answers:
! 
! 		if (isset($question->answer) && !isset($question->answers)) {
! 			$question->answers = $question->answer;
! 		}
! 
! 		// Get old versions of the objects
! 		if (!$oldanswers = $DB->get_records('question_answers', array('question' => $question->id), 'id ASC')) {
! 			$oldanswers = array();
! 		}
! 
! 		if (!$oldoptions = $DB->get_records('question_calculated', array('question' => $question->id), 'answer ASC')) {
! 			$oldoptions = array();
! 		}
! 
! 		// Save the units.
! 		$virtualqtype = $this->get_virtual_qtype($question);
! 		$result = $virtualqtype->save_numerical_units($question);
! 		if (isset($result->error)) {
! 			return $result;
! 		} else {
! 			$units = &$result->units;
! 		}
! 		// Insert all the new answers
! 		if (isset($question->answer) && !isset($question->answers)) {
! 			$question->answers=$question->answer;
! 		}
! 		foreach ($question->answers as $key => $dataanswer) {
! 			if (is_array($dataanswer)) {
! 				$dataanswer = $dataanswer['text'];
! 			}
! 			if ( trim($dataanswer) != '' ) {
! 				$answer = new stdClass;
! 				$answer->question = $question->id;
! 				$answer->answer = trim($dataanswer);
! 				$answer->fraction = $question->fraction[$key];
! 				$answer->feedbackformat = $question->feedback[$key]['format'];
! 				if (isset($question->feedback[$key]['files'])) {
! 					$files = $question->feedback[$key]['files'];
! 				}
! 
! 				if ($oldanswer = array_shift($oldanswers)) {  // Existing answer, so reuse it
! 					$answer->id = $oldanswer->id;
! 					$answer->feedback = file_save_draft_area_files($question->feedback[$key]['itemid'], $context->id, 'question', 'answerfeedback', $answer->id, $this->fileoptionsa, trim($question->feedback[$key]['text']));
! 					$DB->update_record("question_answers", $answer);
! 				} else { // This is a completely new answer
! 					$answer->feedback = trim($question->feedback[$key]['text']);
! 					$answer->id = $DB->insert_record("question_answers", $answer);
! 					if (isset($files)) {
! 						foreach ($files as $file) {
! 							$this->import_file($context, 'question', 'answerfeedback', $answer->id, $file);
! 						}
! 					} else {
! 						$answer->feedback = file_save_draft_area_files($question->feedback[$key]['itemid'], $context->id, 'question', 'answerfeedback', $answer->id, $this->fileoptionsa, trim($question->feedback[$key]['text']));
! 					}
! 					$DB->set_field('question_answers', 'feedback', $answer->feedback, array('id'=>$answer->id));
! 				}
! 
! 				// Set up the options object
! 				if (!$options = array_shift($oldoptions)) {
! 					$options = new stdClass;
! 				}
! 				$options->question  = $question->id;
! 				$options->answer    = $answer->id;
! 				$options->tolerance = trim($question->tolerance[$key]);
! 				$options->tolerancetype  = trim($question->tolerancetype[$key]);
! 				$options->correctanswerlength  = trim($question->correctanswerlength[$key]);
! 				$options->correctanswerformat  = trim($question->correctanswerformat[$key]);
! 
! 				// Save options
! 				if (isset($options->id)) { // reusing existing record
! 					$DB->update_record('question_calculated', $options);
! 				} else { // new options
! 					$DB->insert_record('question_calculated', $options);
! 				}
! 			}
! 		}
! 		// delete old answer records
! 		if (!empty($oldanswers)) {
! 			foreach($oldanswers as $oa) {
! 				$DB->delete_records('question_answers', array('id' => $oa->id));
! 			}
! 		}
! 
! 		// delete old answer records
! 		if (!empty($oldoptions)) {
! 			foreach($oldoptions as $oo) {
! 				$DB->delete_records('question_calculated', array('id' => $oo->id));
! 			}
! 		}
! 
! 		if(isset($question->import_process)&&$question->import_process) {
! 			$this->import_datasets($question);
! 		} else {
! 			//save datasets and datatitems from form i.e in question
! 			//  $datasetdefs = $this->get_dataset_definitions($question->id, array());
! 			$question->dataset = $question->datasetdef ;
! 			//       $this->save_dataset_definitions($question);
! 			// Save datasets
! 			$datasetdefinitions = $this->get_dataset_definitions($question->id, $question->dataset);
! 			$tmpdatasets = array_flip($question->dataset);
! 			$defids = array_keys($datasetdefinitions);
! 			$datasetdefs = array();
! 			foreach ($defids as $defid) {
! 				$datasetdef = &$datasetdefinitions[$defid];
! 				if (isset($datasetdef->id)) {
! 					if (!isset($tmpdatasets[$defid])) {
! 						// This dataset is not used any more, delete it
! 						$DB->delete_records('question_datasets', array('question' => $question->id, 'datasetdefinition' => $datasetdef->id));
! 						// if ($datasetdef->category == 0) { // Question local dataset
! 						$DB->delete_records('question_dataset_definitions', array('id' => $datasetdef->id));
! 						$DB->delete_records('question_dataset_items', array('definition' => $datasetdef->id));
! 						// }
! 					}
! 					// This has already been saved or just got deleted
! 					unset($datasetdefinitions[$defid]);
! 					continue;
! 				}
! 				$datasetdef->id = $DB->insert_record('question_dataset_definitions', $datasetdef);
! 				$datasetdefs[]= clone($datasetdef);
! 				$questiondataset = new stdClass;
! 				$questiondataset->question = $question->id;
! 				$questiondataset->datasetdefinition = $datasetdef->id;
! 				$DB->insert_record('question_datasets', $questiondataset);
! 				unset($datasetdefinitions[$defid]);
! 			}
! 			// Remove local obsolete datasets as well as relations
! 			// to datasets in other categories:
! 			if (!empty($datasetdefinitions)) {
! 				foreach ($datasetdefinitions as $def) {
! 					$DB->delete_records('question_datasets', array('question' => $question->id, 'datasetdefinition' => $def->id));
! 					if ($def->category == 0) { // Question local dataset
! 						$DB->delete_records('question_dataset_definitions', array('id' => $def->id));
! 						$DB->delete_records('question_dataset_items', array('definition' => $def->id));
! 					}
! 				}
! 			}
! 			$datasetdefs = $this->get_dataset_definitions($question->id, $question->dataset);
! 			// Handle adding and removing of dataset items
! 			$i = 1;
! 			ksort($question->definition);
! 			foreach ($question->definition as $key => $defid) {
! 				$addeditem = new stdClass();
! 				$addeditem->definition = $datasetdefs[$defid]->id;
! 				$addeditem->value = $question->number[$i];
! 				$addeditem->itemnumber = ceil($i / count($datasetdefs));
! 				if (empty($question->makecopy) && $question->itemid[$i]) {
! 					// Reuse any previously used record
! 					$addeditem->id = $question->itemid[$i];
! 					$DB->update_record('question_dataset_items', $addeditem);
! 				} else {
! 					$DB->insert_record('question_dataset_items', $addeditem);
! 				}
! 				$i++;
! 			}
! 			$maxnumber = -1;
! 			if (isset($addeditem->itemnumber) && $maxnumber < $addeditem->itemnumber){
! 				$maxnumber = $addeditem->itemnumber;
! 				foreach ($datasetdefs as $key => $newdef) {
! 					if (isset($newdef->id) && $newdef->itemcount <= $maxnumber) {
! 						$newdef->itemcount = $maxnumber;
! 						// Save the new value for options
! 						$DB->update_record('question_dataset_definitions', $newdef);
! 					}
! 				}
! 			}
! 		}
! 		// Report any problems.
! 		//convert to calculated
! 		if(!empty($question->makecopy) && !empty($question->convert)) {
! 			$DB->set_field('question', 'qtype', 'calculated', array('id'=> $question->id));
! 		}
! 		$result = $QTYPES['numerical']->save_numerical_options($question);
! 		if (isset($result->error)) {
! 			return $result;
! 		}
! 
! 		if (!empty($result->notice)) {
! 			return $result;
! 		}
! 		return true;
! 	}
! 	function finished_edit_wizard(&$form) {
! 		return true ; //isset($form->backtoquiz);
! 	}
! 	function wizard_pages_number() {
! 		return 1 ;
! 	}
! 
! 
! 	function custom_generator_tools_part(&$mform, $idx, $j){
! 
! 		$minmaxgrp = array();
! 		$minmaxgrp[] =& $mform->createElement('text', "calcmin[$idx]", get_string('calcmin', 'qtype_calculated'));
! 		$minmaxgrp[] =& $mform->createElement('text', "calcmax[$idx]", get_string('calcmax', 'qtype_calculated'));
! 		$mform->addGroup($minmaxgrp, 'minmaxgrp', get_string('minmax', 'qtype_calculated'), ' - ', false);
! 		$mform->setType("calcmin[$idx]", PARAM_NUMBER);
! 		$mform->setType("calcmax[$idx]", PARAM_NUMBER);
! 
! 		$precisionoptions = range(0, 10);
! 		$mform->addElement('select', "calclength[$idx]", get_string('calclength', 'qtype_calculated'), $precisionoptions);
! 
! 		$distriboptions = array('uniform' => get_string('uniform', 'qtype_calculated'), 'loguniform' => get_string('loguniform', 'qtype_calculated'));
! 		$mform->addElement('hidden', "calcdistribution[$idx]", 'uniform');
! 		$mform->setType("calcdistribution[$idx]", PARAM_INT);
! 
! 
! 	}
! 
! 	function comment_header($answers) {
! 		//$this->get_question_options($question);
! 		$strheader = "";
! 		$delimiter = '';
! 
! 		// $answers = $question->options->answers;
! 
! 		foreach ($answers as $key => $answer) {
! 			/*   if (is_string($answer)) {
! 			 $strheader .= $delimiter.$answer;
! 			 } else {*/
! 			$strheader .= $delimiter.$answer->answer;
! 			// }
! 			$delimiter = '<br/><br/><br/>';
! 		}
! 		return $strheader;
! 	}
  
! 	function tolerance_types() {
! 		return array('1'  => get_string('relative', 'quiz'),
              '2'  => get_string('nominal', 'quiz'),
! 		//        '3'  => get_string('geometric', 'quiz')
! 		);
! 	}
! 
! 	function dataset_options($form, $name, $mandatory=true,$renameabledatasets=false) {
! 		// Takes datasets from the parent implementation but
! 		// filters options that are currently not accepted by calculated
! 		// It also determines a default selection...
! 		//$renameabledatasets not implemented anmywhere
! 		list($options, $selected) = $this->dataset_options_from_database($form, $name,'','qtype_calculated');
! 		//  list($options, $selected) = $this->dataset_optionsa($form, $name);
! 
! 		foreach ($options as $key => $whatever) {
! 			if (!preg_match('~^1-~', $key) && $key != '0') {
! 				unset($options[$key]);
! 			}
! 		}
! 		if (!$selected) {
! 			if ($mandatory){
! 				$selected =  "1-0-$name"; // Default
! 			}else {
! 				$selected = "0"; // Default
! 			}
! 		}
! 		return array($options, $selected);
! 	}
! 
! 
! 	/**
! 	 * Runs all the code required to set up and save an essay question for testing purposes.
! 	 * Alternate DB table prefix may be used to facilitate data deletion.
! 	 */
! 	function generate_test($name, $courseid = null) {
! 		global $DB;
! 		list($form, $question) = parent::generate_test($name, $courseid);
! 		$form->feedback = 1;
! 		$form->multiplier = array(1, 1);
! 		$form->shuffleanswers = 1;
! 		$form->noanswers = 1;
! 		$form->qtype ='calculatedsimple';
! 		$question->qtype ='calculatedsimple';
! 		$form->answers = array('{a} + {b}');
! 		$form->fraction = array(1);
! 		$form->tolerance = array(0.01);
! 		$form->tolerancetype = array(1);
! 		$form->correctanswerlength = array(2);
! 		$form->correctanswerformat = array(1);
! 		$form->questiontext = "What is {a} + {b}?";
! 
! 		if ($courseid) {
! 			$course = $DB->get_record('course', array('id'=> $courseid));
! 		}
! 
! 		$new_question = $this->save_question($question, $form);
! 
! 		$dataset_form = new stdClass();
! 		$dataset_form->nextpageparam["forceregeneration"]= 1;
! 		$dataset_form->calcmin = array(1 => 1.0, 2 => 1.0);
! 		$dataset_form->calcmax = array(1 => 10.0, 2 => 10.0);
! 		$dataset_form->calclength = array(1 => 1, 2 => 1);
! 		$dataset_form->number = array(1 => 5.4 , 2 => 4.9);
! 		$dataset_form->itemid = array(1 => '' , 2 => '');
! 		$dataset_form->calcdistribution = array(1 => 'uniform', 2 => 'uniform');
! 		$dataset_form->definition = array(1 => "1-0-a",
! 		2 => "1-0-b");
! 		$dataset_form->nextpageparam = array('forceregeneration' => false);
! 		$dataset_form->addbutton = 1;
! 		$dataset_form->selectadd = 1;
! 		$dataset_form->courseid = $courseid;
! 		$dataset_form->cmid = 0;
! 		$dataset_form->id = $new_question->id;
! 		$this->save_dataset_items($new_question, $dataset_form);
! 
! 		return $new_question;
! 	}
! 
! 	function move_files($questionid, $oldcontextid, $newcontextid) {
! 		$fs = get_file_storage();
! 
! 		parent::move_files($questionid, $oldcontextid, $newcontextid);
! 		$this->move_files_in_answers($questionid, $oldcontextid, $newcontextid);
! 
! 		$fs->move_area_files_to_new_context($oldcontextid,
! 		$newcontextid, 'qtype_calculatedsimple', 'instruction', $questionid);
! 	}
! 
! 	protected function delete_files($questionid, $contextid) {
! 		$fs = get_file_storage();
! 
! 		parent::delete_files($questionid, $contextid);
! 		$this->delete_files_in_answers($questionid, $contextid);
! 		$fs->delete_area_files($contextid, 'qtype_calculatedsimple', 'instruction', $questionid);
! 	}
! 
! 	function check_file_access($question, $state, $options, $contextid, $component,
! 	$filearea, $args) {
! 		$itemid = reset($args);
! 		if ($component == 'question' && $filearea == 'answerfeedback') {
! 
! 			// check if answer id exists
! 			$result = $options->feedback && array_key_exists($itemid, $question->options->answers);
! 			if (!$result) {
! 				return false;
! 			}
! 			// check response
! 			if (!$this->check_response($question, $state)) {
! 				return false;
! 			}
! 			return true;
! 		} else if ($filearea == 'instruction') {
! 			// TODO: should it be display all the time like questiontext?
! 			// check if question id exists
! 			if ($itemid != $question->id) {
! 				return false;
! 			} else {
! 				return true;
! 			}
! 		} else {
! 			return parent::check_file_access($question, $state, $options, $contextid, $component,
! 			$filearea, $args);
! 		}
! 		return true;
! 	}
  }
  //// END OF CLASS ////
  
***************
*** 400,404 ****
  question_register_questiontype(new question_calculatedsimple_qtype());
  
  if ( ! defined ("CALCULATEDSIMPLE")) {
!     define("CALCULATEDSIMPLE",    "calculatedsimple");
  }
--- 400,404 ----
  question_register_questiontype(new question_calculatedsimple_qtype());
  
  if ( ! defined ("CALCULATEDSIMPLE")) {
! 	define("CALCULATEDSIMPLE",    "calculatedsimple");
  }
diff -crB questionorg/type/description/edit_description_form.php questionupd/type/description/edit_description_form.php
*** questionorg/type/description/edit_description_form.php	2012-04-13 12:31:13.435178289 +0500
--- questionupd/type/description/edit_description_form.php	2012-04-13 09:42:57.000000000 +0500
***************
*** 29,49 ****
   * description editing form definition.
   */
  class question_edit_description_form extends question_edit_form {
!     /**
!      * Add question-type specific form fields.
!      *
!      * @param MoodleQuickForm $mform the form being built.
!      */
!     function definition_inner(&$mform) {
!         //don't need these default elements :
!         $mform->removeElement('defaultgrade');
!         $mform->removeElement('penalty');
  
!         $mform->addElement('hidden', 'defaultgrade', 0);
!         $mform->setType('defaultgrade', PARAM_RAW);
!     }
  
!     function qtype() {
!         return 'description';
!     }
  }
--- 29,49 ----
   * description editing form definition.
   */
  class question_edit_description_form extends question_edit_form {
! 	/**
! 	 * Add question-type specific form fields.
! 	 *
! 	 * @param MoodleQuickForm $mform the form being built.
! 	 */
! 	function definition_inner(&$mform) {
! 		//don't need these default elements :
! 		$mform->removeElement('defaultgrade');
! 		$mform->removeElement('penalty');
  
! 		$mform->addElement('hidden', 'defaultgrade', 0);
! 		$mform->setType('defaultgrade', PARAM_RAW);
! 	}
  
! 	function qtype() {
! 		return 'description';
! 	}
  }
diff -crB questionorg/type/description/question.html questionupd/type/description/question.html
*** questionorg/type/description/question.html	2012-04-13 12:31:13.477178288 +0500
--- questionupd/type/description/question.html	2012-04-13 09:42:57.000000000 +0500
***************
*** 1,15 ****
! <div id="q<?php echo $question->id; ?>" class="que <?php echo $question->qtype; ?> clearfix">
!   <div class="info">
!     <span class="edit"><?php echo $editlink; ?></span>
!   </div>
!   <div class="content">
!     <div class="qtext">
!       <?php echo $questiontext; ?>
!     </div>
!   </div>
!   <?php if ($generalfeedback) { ?>
!     <div class="generalfeedback">
!       <?php echo $generalfeedback ?>
!     </div>
!   <?php } ?>
  </div>
--- 1,18 ----
! <div id="q<?php echo $question->id; ?>"
! 	class="que <?php echo $question->qtype; ?> clearfix">
! 	<div class="info">
! 		<span class="edit">
! 			<?php echo $editlink; ?>
! 		</span>
! 	</div>
! 	<div class="content">
! 		<div class="qtext">
! 			<?php echo $questiontext; ?>
! 		</div>
! 	</div>
! 	<?php if ($generalfeedback) { ?>
! 	<div class="generalfeedback">
! 		<?php echo $generalfeedback ?>
! 	</div>
! 	<?php } ?>
  </div>
diff -crB questionorg/type/description/questiontype.php questionupd/type/description/questiontype.php
*** questionorg/type/description/questiontype.php	2012-04-13 12:31:13.561178291 +0500
--- questionupd/type/description/questiontype.php	2012-04-13 09:42:57.000000000 +0500
***************
*** 33,95 ****
   */
  class description_qtype extends default_questiontype {
  
!     function name() {
!         return 'description';
!     }
! 
!     function is_real_question_type() {
!         return false;
!     }
! 
!     function is_usable_by_random() {
!         return false;
!     }
! 
!     function save_question($question, $form) {
!         // Make very sure that descriptions can'e be created with a grade of
!         // anything other than 0.
!         $form->defaultgrade = 0;
!         return parent::save_question($question, $form);
!     }
! 
!     function get_question_options(&$question) {
!         return true;
!     }
! 
!     function save_question_options($question) {
!         return true;
!     }
! 
!     function print_question(&$question, &$state, $number, $cmoptions, $options) {
!         global $CFG;
!         $isfinished = question_state_is_graded($state->last_graded) || $state->event == QUESTION_EVENTCLOSE;
! 
!         // For editing teachers print a link to an editing popup window
!         $editlink = $this->get_question_edit_link($question, $cmoptions, $options);
! 
!         $context = $this->get_context_by_category_id($question->category);
!         $question->questiontext = quiz_rewrite_question_urls($question->questiontext, 'pluginfile.php', $context->id, 'question', 'questiontext', array($state->attempt, $state->question), $question->id);
!         $questiontext = $this->format_text($question->questiontext, $question->questiontextformat, $cmoptions);
! 
!         $generalfeedback = '';
!         if ($isfinished && $options->generalfeedback) {
!             $question->generalfeedback = quiz_rewrite_question_urls($question->generalfeedback, 'pluginfile.php', $context->id, 'question', 'generalfeedback', array($state->attempt, $state->question), $question->id);
!             $generalfeedback = $this->format_text($question->generalfeedback,
!                     $question->generalfeedbackformat, $cmoptions);
!         }
! 
!         include "$CFG->dirroot/question/type/description/question.html";
!     }
! 
!     function actual_number_of_questions($question) {
!         return 0;
!     }
! 
!     function grade_responses(&$question, &$state, $cmoptions) {
!         $state->raw_grade = 0;
!         $state->penalty = 0;
!         return true;
!     }
  }
  // Register this question type with questionlib.php.
  question_register_questiontype(new description_qtype());
--- 33,95 ----
   */
  class description_qtype extends default_questiontype {
  
! 	function name() {
! 		return 'description';
! 	}
! 
! 	function is_real_question_type() {
! 		return false;
! 	}
! 
! 	function is_usable_by_random() {
! 		return false;
! 	}
! 
! 	function save_question($question, $form) {
! 		// Make very sure that descriptions can'e be created with a grade of
! 		// anything other than 0.
! 		$form->defaultgrade = 0;
! 		return parent::save_question($question, $form);
! 	}
! 
! 	function get_question_options(&$question) {
! 		return true;
! 	}
! 
! 	function save_question_options($question) {
! 		return true;
! 	}
! 
! 	function print_question(&$question, &$state, $number, $cmoptions, $options) {
! 		global $CFG;
! 		$isfinished = question_state_is_graded($state->last_graded) || $state->event == QUESTION_EVENTCLOSE;
! 
! 		// For editing teachers print a link to an editing popup window
! 		$editlink = $this->get_question_edit_link($question, $cmoptions, $options);
! 
! 		$context = $this->get_context_by_category_id($question->category);
! 		$question->questiontext = quiz_rewrite_question_urls($question->questiontext, 'pluginfile.php', $context->id, 'question', 'questiontext', array($state->attempt, $state->question), $question->id);
! 		$questiontext = $this->format_text($question->questiontext, $question->questiontextformat, $cmoptions);
! 
! 		$generalfeedback = '';
! 		if ($isfinished && $options->generalfeedback) {
! 			$question->generalfeedback = quiz_rewrite_question_urls($question->generalfeedback, 'pluginfile.php', $context->id, 'question', 'generalfeedback', array($state->attempt, $state->question), $question->id);
! 			$generalfeedback = $this->format_text($question->generalfeedback,
! 			$question->generalfeedbackformat, $cmoptions);
! 		}
! 
! 		include "$CFG->dirroot/question/type/description/question.html";
! 	}
! 
! 	function actual_number_of_questions($question) {
! 		return 0;
! 	}
! 
! 	function grade_responses(&$question, &$state, $cmoptions) {
! 		$state->raw_grade = 0;
! 		$state->penalty = 0;
! 		return true;
! 	}
  }
  // Register this question type with questionlib.php.
  question_register_questiontype(new description_qtype());
diff -crB questionorg/type/edit_question_form.php questionupd/type/edit_question_form.php
*** questionorg/type/edit_question_form.php	2012-04-13 12:31:11.855178260 +0500
--- questionupd/type/edit_question_form.php	2012-04-13 09:42:57.000000000 +0500
***************
*** 35,385 ****
   * @subpackage questiontypes
   */
  class question_edit_form extends moodleform {
!     /**
!      * Question object with options and answers already loaded by get_question_options
!      * Be careful how you use this it is needed sometimes to set up the structure of the
!      * form in definition_inner but data is always loaded into the form with set_data.
!      *
!      * @var object
!      */
!     public $question;
!     public $contexts;
!     public $category;
!     public $categorycontext;
! 
!     /** @var object current context */
!     public $context;
!     /** @var array html editor options */
!     public $editoroptions;
!     /** @var array options to preapre draft area */
!     public $fileoptions;
!     /** @var object instance of question type */
!     public $instance;
! 
!     function question_edit_form($submiturl, $question, $category, $contexts, $formeditable = true){
!         global $DB;
! 
!         $this->question = $question;
! 
!         $this->contexts = $contexts;
! 
!         $record = $DB->get_record('question_categories', array('id' => $question->category), 'contextid');
!         $this->context = get_context_instance_by_id($record->contextid);
! 
!         $this->editoroptions = array('subdirs' => 1,'maxfiles' => EDITOR_UNLIMITED_FILES, 'context' => $this->context);
!         $this->fileoptions = array('subdirs' => 1, 'maxfiles' => -1, 'maxbytes' => -1);
! 
!         $this->category = $category;
!         $this->categorycontext = get_context_instance_by_id($category->contextid);
! 
!         if (!empty($question->id)) {
!             $question->id = (int) $question->id;
!         }
! 
!         parent::moodleform($submiturl, null, 'post', '', null, $formeditable);
!     }
! 
!     /**
!      * Build the form definition.
!      *
!      * This adds all the form fields that the default question type supports.
!      * If your question type does not support all these fields, then you can
!      * override this method and remove the ones you don't want with $mform->removeElement().
!      */
!     function definition() {
!         global $COURSE, $CFG, $DB;
! 
!         $qtype = $this->qtype();
!         $langfile = "qtype_$qtype";
! 
!         $mform =& $this->_form;
! 
!         // Standard fields at the start of the form.
!         $mform->addElement('header', 'generalheader', get_string("general", 'form'));
! 
!         if (!isset($this->question->id)){
!             // Adding question
!             $mform->addElement('questioncategory', 'category', get_string('category', 'quiz'),
!                     array('contexts' => $this->contexts->having_cap('moodle/question:add')));
!         } elseif (!($this->question->formoptions->canmove || $this->question->formoptions->cansaveasnew)){
!             // Editing question with no permission to move from category.
!             $mform->addElement('questioncategory', 'category', get_string('category', 'quiz'),
!                     array('contexts' => array($this->categorycontext)));
!         } elseif ($this->question->formoptions->movecontext){
!             // Moving question to another context.
!             $mform->addElement('questioncategory', 'categorymoveto', get_string('category', 'quiz'),
!                     array('contexts' => $this->contexts->having_cap('moodle/question:add')));
! 
!         } else {
!             // Editing question with permission to move from category or save as new q
!             $currentgrp = array();
!             $currentgrp[0] =& $mform->createElement('questioncategory', 'category', get_string('categorycurrent', 'question'),
!                     array('contexts' => array($this->categorycontext)));
!             if ($this->question->formoptions->canedit || $this->question->formoptions->cansaveasnew){
!                 //not move only form
!                 $currentgrp[1] =& $mform->createElement('checkbox', 'usecurrentcat', '', get_string('categorycurrentuse', 'question'));
!                 $mform->setDefault('usecurrentcat', 1);
!             }
!             $currentgrp[0]->freeze();
!             $currentgrp[0]->setPersistantFreeze(false);
!             $mform->addGroup($currentgrp, 'currentgrp', get_string('categorycurrent', 'question'), null, false);
! 
!             $mform->addElement('questioncategory', 'categorymoveto', get_string('categorymoveto', 'question'),
!                     array('contexts' => array($this->categorycontext)));
!             if ($this->question->formoptions->canedit || $this->question->formoptions->cansaveasnew){
!                 //not move only form
!                 $mform->disabledIf('categorymoveto', 'usecurrentcat', 'checked');
!             }
!         }
! 
!         $mform->addElement('text', 'name', get_string('questionname', 'quiz'), array('size' => 50));
!         $mform->setType('name', PARAM_TEXT);
!         $mform->addRule('name', null, 'required', null, 'client');
! 
!         $mform->addElement('editor', 'questiontext', get_string('questiontext', 'quiz'),
!                 array('rows' => 15), $this->editoroptions);
!         $mform->setType('questiontext', PARAM_RAW);
! 
!         $mform->addElement('text', 'defaultgrade', get_string('defaultgrade', 'quiz'),
!                 array('size' => 3));
!         $mform->setType('defaultgrade', PARAM_INT);
!         $mform->setDefault('defaultgrade', 1);
!         $mform->addRule('defaultgrade', null, 'required', null, 'client');
! 
!         $mform->addElement('text', 'penalty', get_string('penaltyfactor', 'question'),
!                 array('size' => 3));
!         $mform->setType('penalty', PARAM_NUMBER);
!         $mform->addRule('penalty', null, 'required', null, 'client');
!         $mform->addHelpButton('penalty', 'penaltyfactor', 'question');
!         $mform->setDefault('penalty', 0.1);
! 
!         $mform->addElement('editor', 'generalfeedback', get_string('generalfeedback', 'quiz'),
!                 array('rows' => 10), $this->editoroptions);
!         $mform->setType('generalfeedback', PARAM_RAW);
!         $mform->addHelpButton('generalfeedback', 'generalfeedback', 'quiz');
! 
!         // Any questiontype specific fields.
!         $this->definition_inner($mform);
! 
!         if (!empty($CFG->usetags)) {
!             $mform->addElement('header', 'tagsheader', get_string('tags'));
!             $mform->addElement('tags', 'tags', get_string('tags'));
!         }
! 
!         if (!empty($this->question->id)){
!             $mform->addElement('header', 'createdmodifiedheader', get_string('createdmodifiedheader', 'question'));
!             $a = new stdClass();
!             if (!empty($this->question->createdby)){
!                 $a->time = userdate($this->question->timecreated);
!                 $a->user = fullname($DB->get_record('user', array('id' => $this->question->createdby)));
!             } else {
!                 $a->time = get_string('unknown', 'question');
!                 $a->user = get_string('unknown', 'question');
!             }
!             $mform->addElement('static', 'created', get_string('created', 'question'), get_string('byandon', 'question', $a));
!             if (!empty($this->question->modifiedby)){
!                 $a = new stdClass();
!                 $a->time = userdate($this->question->timemodified);
!                 $a->user = fullname($DB->get_record('user', array('id' => $this->question->modifiedby)));
!                 $mform->addElement('static', 'modified', get_string('modified', 'question'), get_string('byandon', 'question', $a));
!             }
!         }
! 
!         // Standard fields at the end of the form.
!         $mform->addElement('hidden', 'id');
!         $mform->setType('id', PARAM_INT);
! 
!         $mform->addElement('hidden', 'qtype');
!         $mform->setType('qtype', PARAM_ALPHA);
! 
!         $mform->addElement('hidden', 'inpopup');
!         $mform->setType('inpopup', PARAM_INT);
! 
!         $mform->addElement('hidden', 'versioning');
!         $mform->setType('versioning', PARAM_BOOL);
! 
!         $mform->addElement('hidden', 'movecontext');
!         $mform->setType('movecontext', PARAM_BOOL);
! 
!         $mform->addElement('hidden', 'cmid');
!         $mform->setType('cmid', PARAM_INT);
!         $mform->setDefault('cmid', 0);
! 
!         $mform->addElement('hidden', 'courseid');
!         $mform->setType('courseid', PARAM_INT);
!         $mform->setDefault('courseid', 0);
! 
!         $mform->addElement('hidden', 'returnurl');
!         $mform->setType('returnurl', PARAM_LOCALURL);
!         $mform->setDefault('returnurl', 0);
! 
!         $mform->addElement('hidden', 'appendqnumstring');
!         $mform->setType('appendqnumstring', PARAM_ALPHA);
!         $mform->setDefault('appendqnumstring', 0);
! 
!         $buttonarray = array();
!         if (!empty($this->question->id)){
!             //editing / moving question
!             if ($this->question->formoptions->movecontext){
!                 $buttonarray[] = &$mform->createElement('submit', 'submitbutton', get_string('moveq', 'question'));
!             } elseif ($this->question->formoptions->canedit || $this->question->formoptions->canmove ||$this->question->formoptions->movecontext){
!                 $buttonarray[] = &$mform->createElement('submit', 'submitbutton', get_string('savechanges'));
!             }
!             if ($this->question->formoptions->cansaveasnew){
!                 $buttonarray[] = &$mform->createElement('submit', 'makecopy', get_string('makecopy', 'quiz'));
!             }
!             $buttonarray[] = &$mform->createElement('cancel');
!         } else {
!             // adding new question
!             $buttonarray[] = &$mform->createElement('submit', 'submitbutton', get_string('savechanges'));
!             $buttonarray[] = &$mform->createElement('cancel');
!         }
!         $mform->addGroup($buttonarray, 'buttonar', '', array(' '), false);
!         $mform->closeHeaderBefore('buttonar');
! 
!         if ($this->question->formoptions->movecontext) {
!             $mform->hardFreezeAllVisibleExcept(array('categorymoveto', 'buttonar'));
!         } else if ((!empty($this->question->id)) && (!($this->question->formoptions->canedit || $this->question->formoptions->cansaveasnew))){
!             $mform->hardFreezeAllVisibleExcept(array('categorymoveto', 'buttonar', 'currentgrp'));
!         }
!     }
! 
!     function validation($fromform, $files) {
!         $errors = parent::validation($fromform, $files);
!         if (empty($fromform->makecopy) && isset($this->question->id)
!                 && ($this->question->formoptions->canedit || $this->question->formoptions->cansaveasnew)
!                 && empty($fromform->usecurrentcat) && !$this->question->formoptions->canmove) {
!             $errors['currentgrp'] = get_string('nopermissionmove', 'question');
!         }
!         return $errors;
!     }
! 
!     /**
!      * Add any question-type specific form fields.
!      *
!      * @param object $mform the form being built.
!      */
!     function definition_inner(&$mform) {
!         // By default, do nothing.
!     }
! 
!     /**
!      * Get the list of form elements to repeat, one for each answer.
!      * @param object $mform the form being built.
!      * @param $label the label to use for each option.
!      * @param $gradeoptions the possible grades for each answer.
!      * @param $repeatedoptions reference to array of repeated options to fill
!      * @param $answersoption reference to return the name of $question->options field holding an array of answers
!      * @return array of form fields.
!      */
!     function get_per_answer_fields(&$mform, $label, $gradeoptions, &$repeatedoptions, &$answersoption) {
!         $repeated = array();
!         $repeated[] =& $mform->createElement('header', 'answerhdr', $label);
!         $repeated[] =& $mform->createElement('text', 'answer', get_string('answer', 'quiz'), array('size' => 80));
!         $repeated[] =& $mform->createElement('select', 'fraction', get_string('grade'), $gradeoptions);
!         $repeated[] =& $mform->createElement('editor', 'feedback', get_string('feedback', 'quiz'),
!                                 array('rows' => 5), $this->editoroptions);
!         $repeatedoptions['answer']['type'] = PARAM_RAW;
!         $repeatedoptions['fraction']['default'] = 0;
!         $answersoption = 'answers';
!         return $repeated;
!     }
! 
!     /**
!      * Add a set of form fields, obtained from get_per_answer_fields, to the form,
!      * one for each existing answer, with some blanks for some new ones.
!      * @param object $mform the form being built.
!      * @param $label the label to use for each option.
!      * @param $gradeoptions the possible grades for each answer.
!      * @param $minoptions the minimum number of answer blanks to display. Default QUESTION_NUMANS_START.
!      * @param $addoptions the number of answer blanks to add. Default QUESTION_NUMANS_ADD.
!      */
!     function add_per_answer_fields(&$mform, $label, $gradeoptions, $minoptions = QUESTION_NUMANS_START, $addoptions = QUESTION_NUMANS_ADD) {
!         $answersoption = '';
!         $repeatedoptions = array();
!         $repeated = $this->get_per_answer_fields($mform, $label, $gradeoptions, $repeatedoptions, $answersoption);
! 
!         if (isset($this->question->options)){
!             $countanswers = count($this->question->options->$answersoption);
!         } else {
!             $countanswers = 0;
!         }
!         if ($this->question->formoptions->repeatelements){
!             $repeatsatstart = max($minoptions, $countanswers + $addoptions);
!         } else {
!             $repeatsatstart = $countanswers;
!         }
! 
!         $this->repeat_elements($repeated, $repeatsatstart, $repeatedoptions, 'noanswers', 'addanswers', $addoptions, get_string('addmorechoiceblanks', 'qtype_multichoice'));
!     }
! 
!     function set_data($question) {
!         global $QTYPES;
!         // prepare question text
!         $draftid = file_get_submitted_draft_itemid('questiontext');
! 
!         if (!empty($question->questiontext)) {
!             $questiontext = $question->questiontext;
!         } else {
!             $questiontext = '';
!         }
!         $questiontext = file_prepare_draft_area($draftid, $this->context->id, 'question', 'questiontext', empty($question->id)?null:(int)$question->id, $this->fileoptions, $questiontext);
! 
!         $question->questiontext = array();
!         $question->questiontext['text'] = $questiontext;
!         $question->questiontext['format'] = empty($question->questiontextformat) ? editors_get_preferred_format() : $question->questiontextformat;
!         $question->questiontext['itemid'] = $draftid;
! 
!         // prepare general feedback
!         $draftid = file_get_submitted_draft_itemid('generalfeedback');
! 
!         if (empty($question->generalfeedback)) {
!             $question->generalfeedback = '';
!         }
! 
!         $feedback = file_prepare_draft_area($draftid, $this->context->id, 'question', 'generalfeedback', empty($question->id)?null:(int)$question->id, $this->fileoptions, $question->generalfeedback);
!         $question->generalfeedback = array();
!         $question->generalfeedback['text'] = $feedback;
!         $question->generalfeedback['format'] = empty($question->generalfeedbackformat) ? editors_get_preferred_format() : $question->generalfeedbackformat;
!         $question->generalfeedback['itemid'] = $draftid;
! 
!         // Remove unnecessary trailing 0s form grade fields.
!         if (isset($question->defaultgrade)) {
!             $question->defaultgrade = 0 + $question->defaultgrade;
!         }
!         if (isset($question->penalty)) {
!             $question->penalty = 0 + $question->penalty;
!         }
! 
!         // Set any options.
!         $extra_question_fields = $QTYPES[$question->qtype]->extra_question_fields();
!         if (is_array($extra_question_fields) && !empty($question->options)) {
!             array_shift($extra_question_fields);
!             foreach ($extra_question_fields as $field) {
!                 if (isset($question->options->$field)) {
!                     $question->$field = $question->options->$field;
!                 }
!             }
!         }
!         // subclass adds data_preprocessing code here
!         $question = $this->data_preprocessing($question);
!         parent::set_data($question);
!     }
! 
!     /**
!      * Any preprocessing needed for the settings form for the question type
!      *
!      * @param array $question - array to fill in with the default values
!      */
!     function data_preprocessing($question) {
!         return $question;
!     }
! 
!     /**
!      * Override this in the subclass to question type name.
!      * @return the question type name, should be the same as the name() method in the question type class.
!      */
!     function qtype() {
!         return '';
!     }
  }
--- 35,385 ----
   * @subpackage questiontypes
   */
  class question_edit_form extends moodleform {
! 	/**
! 	 * Question object with options and answers already loaded by get_question_options
! 	 * Be careful how you use this it is needed sometimes to set up the structure of the
! 	 * form in definition_inner but data is always loaded into the form with set_data.
! 	 *
! 	 * @var object
! 	 */
! 	public $question;
! 	public $contexts;
! 	public $category;
! 	public $categorycontext;
! 
! 	/** @var object current context */
! 	public $context;
! 	/** @var array html editor options */
! 	public $editoroptions;
! 	/** @var array options to preapre draft area */
! 	public $fileoptions;
! 	/** @var object instance of question type */
! 	public $instance;
! 
! 	function question_edit_form($submiturl, $question, $category, $contexts, $formeditable = true){
! 		global $DB;
! 
! 		$this->question = $question;
! 
! 		$this->contexts = $contexts;
! 
! 		$record = $DB->get_record('question_categories', array('id' => $question->category), 'contextid');
! 		$this->context = get_context_instance_by_id($record->contextid);
! 
! 		$this->editoroptions = array('subdirs' => 1,'maxfiles' => EDITOR_UNLIMITED_FILES, 'context' => $this->context);
! 		$this->fileoptions = array('subdirs' => 1, 'maxfiles' => -1, 'maxbytes' => -1);
! 
! 		$this->category = $category;
! 		$this->categorycontext = get_context_instance_by_id($category->contextid);
! 
! 		if (!empty($question->id)) {
! 			$question->id = (int) $question->id;
! 		}
! 
! 		parent::moodleform($submiturl, null, 'post', '', null, $formeditable);
! 	}
! 
! 	/**
! 	 * Build the form definition.
! 	 *
! 	 * This adds all the form fields that the default question type supports.
! 	 * If your question type does not support all these fields, then you can
! 	 * override this method and remove the ones you don't want with $mform->removeElement().
! 	 */
! 	function definition() {
! 		global $COURSE, $CFG, $DB;
! 
! 		$qtype = $this->qtype();
! 		$langfile = "qtype_$qtype";
! 
! 		$mform =& $this->_form;
! 
! 		// Standard fields at the start of the form.
! 		$mform->addElement('header', 'generalheader', get_string("general", 'form'));
! 
! 		if (!isset($this->question->id)){
! 			// Adding question
! 			$mform->addElement('questioncategory', 'category', get_string('category', 'quiz'),
! 			array('contexts' => $this->contexts->having_cap('moodle/question:add')));
! 		} elseif (!($this->question->formoptions->canmove || $this->question->formoptions->cansaveasnew)){
! 			// Editing question with no permission to move from category.
! 			$mform->addElement('questioncategory', 'category', get_string('category', 'quiz'),
! 			array('contexts' => array($this->categorycontext)));
! 		} elseif ($this->question->formoptions->movecontext){
! 			// Moving question to another context.
! 			$mform->addElement('questioncategory', 'categorymoveto', get_string('category', 'quiz'),
! 			array('contexts' => $this->contexts->having_cap('moodle/question:add')));
! 
! 		} else {
! 			// Editing question with permission to move from category or save as new q
! 			$currentgrp = array();
! 			$currentgrp[0] =& $mform->createElement('questioncategory', 'category', get_string('categorycurrent', 'question'),
! 			array('contexts' => array($this->categorycontext)));
! 			if ($this->question->formoptions->canedit || $this->question->formoptions->cansaveasnew){
! 				//not move only form
! 				$currentgrp[1] =& $mform->createElement('checkbox', 'usecurrentcat', '', get_string('categorycurrentuse', 'question'));
! 				$mform->setDefault('usecurrentcat', 1);
! 			}
! 			$currentgrp[0]->freeze();
! 			$currentgrp[0]->setPersistantFreeze(false);
! 			$mform->addGroup($currentgrp, 'currentgrp', get_string('categorycurrent', 'question'), null, false);
! 
! 			$mform->addElement('questioncategory', 'categorymoveto', get_string('categorymoveto', 'question'),
! 			array('contexts' => array($this->categorycontext)));
! 			if ($this->question->formoptions->canedit || $this->question->formoptions->cansaveasnew){
! 				//not move only form
! 				$mform->disabledIf('categorymoveto', 'usecurrentcat', 'checked');
! 			}
! 		}
! 
! 		$mform->addElement('text', 'name', get_string('questionname', 'quiz'), array('size' => 50));
! 		$mform->setType('name', PARAM_TEXT);
! 		$mform->addRule('name', null, 'required', null, 'client');
! 
! 		$mform->addElement('editor', 'questiontext', get_string('questiontext', 'quiz'),
! 		array('rows' => 15), $this->editoroptions);
! 		$mform->setType('questiontext', PARAM_RAW);
! 
! 		$mform->addElement('text', 'defaultgrade', get_string('defaultgrade', 'quiz'),
! 		array('size' => 3));
! 		$mform->setType('defaultgrade', PARAM_INT);
! 		$mform->setDefault('defaultgrade', 1);
! 		$mform->addRule('defaultgrade', null, 'required', null, 'client');
! 
! 		$mform->addElement('text', 'penalty', get_string('penaltyfactor', 'question'),
! 		array('size' => 3));
! 		$mform->setType('penalty', PARAM_NUMBER);
! 		$mform->addRule('penalty', null, 'required', null, 'client');
! 		$mform->addHelpButton('penalty', 'penaltyfactor', 'question');
! 		$mform->setDefault('penalty', 1);
! 
! 		$mform->addElement('editor', 'generalfeedback', get_string('generalfeedback', 'quiz'),
! 		array('rows' => 10), $this->editoroptions);
! 		$mform->setType('generalfeedback', PARAM_RAW);
! 		$mform->addHelpButton('generalfeedback', 'generalfeedback', 'quiz');
! 
! 		// Any questiontype specific fields.
! 		$this->definition_inner($mform);
! 
! 		if (!empty($CFG->usetags)) {
! 			$mform->addElement('header', 'tagsheader', get_string('tags'));
! 			$mform->addElement('tags', 'tags', get_string('tags'));
! 		}
! 
! 		if (!empty($this->question->id)){
! 			$mform->addElement('header', 'createdmodifiedheader', get_string('createdmodifiedheader', 'question'));
! 			$a = new stdClass();
! 			if (!empty($this->question->createdby)){
! 				$a->time = userdate($this->question->timecreated);
! 				$a->user = fullname($DB->get_record('user', array('id' => $this->question->createdby)));
! 			} else {
! 				$a->time = get_string('unknown', 'question');
! 				$a->user = get_string('unknown', 'question');
! 			}
! 			$mform->addElement('static', 'created', get_string('created', 'question'), get_string('byandon', 'question', $a));
! 			if (!empty($this->question->modifiedby)){
! 				$a = new stdClass();
! 				$a->time = userdate($this->question->timemodified);
! 				$a->user = fullname($DB->get_record('user', array('id' => $this->question->modifiedby)));
! 				$mform->addElement('static', 'modified', get_string('modified', 'question'), get_string('byandon', 'question', $a));
! 			}
! 		}
! 
! 		// Standard fields at the end of the form.
! 		$mform->addElement('hidden', 'id');
! 		$mform->setType('id', PARAM_INT);
! 
! 		$mform->addElement('hidden', 'qtype');
! 		$mform->setType('qtype', PARAM_ALPHA);
! 
! 		$mform->addElement('hidden', 'inpopup');
! 		$mform->setType('inpopup', PARAM_INT);
! 
! 		$mform->addElement('hidden', 'versioning');
! 		$mform->setType('versioning', PARAM_BOOL);
! 
! 		$mform->addElement('hidden', 'movecontext');
! 		$mform->setType('movecontext', PARAM_BOOL);
! 
! 		$mform->addElement('hidden', 'cmid');
! 		$mform->setType('cmid', PARAM_INT);
! 		$mform->setDefault('cmid', 0);
! 
! 		$mform->addElement('hidden', 'courseid');
! 		$mform->setType('courseid', PARAM_INT);
! 		$mform->setDefault('courseid', 0);
! 
! 		$mform->addElement('hidden', 'returnurl');
! 		$mform->setType('returnurl', PARAM_LOCALURL);
! 		$mform->setDefault('returnurl', 0);
! 
! 		$mform->addElement('hidden', 'appendqnumstring');
! 		$mform->setType('appendqnumstring', PARAM_ALPHA);
! 		$mform->setDefault('appendqnumstring', 0);
! 
! 		$buttonarray = array();
! 		if (!empty($this->question->id)){
! 			//editing / moving question
! 			if ($this->question->formoptions->movecontext){
! 				$buttonarray[] = &$mform->createElement('submit', 'submitbutton', get_string('moveq', 'question'));
! 			} elseif ($this->question->formoptions->canedit || $this->question->formoptions->canmove ||$this->question->formoptions->movecontext){
! 				$buttonarray[] = &$mform->createElement('submit', 'submitbutton', get_string('savechanges'));
! 			}
! 			if ($this->question->formoptions->cansaveasnew){
! 				$buttonarray[] = &$mform->createElement('submit', 'makecopy', get_string('makecopy', 'quiz'));
! 			}
! 			$buttonarray[] = &$mform->createElement('cancel');
! 		} else {
! 			// adding new question
! 			$buttonarray[] = &$mform->createElement('submit', 'submitbutton', get_string('savechanges'));
! 			$buttonarray[] = &$mform->createElement('cancel');
! 		}
! 		$mform->addGroup($buttonarray, 'buttonar', '', array(' '), false);
! 		$mform->closeHeaderBefore('buttonar');
! 
! 		if ($this->question->formoptions->movecontext) {
! 			$mform->hardFreezeAllVisibleExcept(array('categorymoveto', 'buttonar'));
! 		} else if ((!empty($this->question->id)) && (!($this->question->formoptions->canedit || $this->question->formoptions->cansaveasnew))){
! 			$mform->hardFreezeAllVisibleExcept(array('categorymoveto', 'buttonar', 'currentgrp'));
! 		}
! 	}
! 
! 	function validation($fromform, $files) {
! 		$errors = parent::validation($fromform, $files);
! 		if (empty($fromform->makecopy) && isset($this->question->id)
! 		&& ($this->question->formoptions->canedit || $this->question->formoptions->cansaveasnew)
! 		&& empty($fromform->usecurrentcat) && !$this->question->formoptions->canmove) {
! 			$errors['currentgrp'] = get_string('nopermissionmove', 'question');
! 		}
! 		return $errors;
! 	}
! 
! 	/**
! 	 * Add any question-type specific form fields.
! 	 *
! 	 * @param object $mform the form being built.
! 	 */
! 	function definition_inner(&$mform) {
! 		// By default, do nothing.
! 	}
! 
! 	/**
! 	 * Get the list of form elements to repeat, one for each answer.
! 	 * @param object $mform the form being built.
! 	 * @param $label the label to use for each option.
! 	 * @param $gradeoptions the possible grades for each answer.
! 	 * @param $repeatedoptions reference to array of repeated options to fill
! 	 * @param $answersoption reference to return the name of $question->options field holding an array of answers
! 	 * @return array of form fields.
! 	 */
! 	function get_per_answer_fields(&$mform, $label, $gradeoptions, &$repeatedoptions, &$answersoption) {
! 		$repeated = array();
! 		$repeated[] =& $mform->createElement('header', 'answerhdr', $label);
! 		$repeated[] =& $mform->createElement('text', 'answer', get_string('answer', 'quiz'), array('size' => 80));
! 		$repeated[] =& $mform->createElement('select', 'fraction', get_string('grade'), $gradeoptions);
! 		$repeated[] =& $mform->createElement('editor', 'feedback', get_string('feedback', 'quiz'),
! 		array('rows' => 5), $this->editoroptions);
! 		$repeatedoptions['answer']['type'] = PARAM_RAW;
! 		$repeatedoptions['fraction']['default'] = 0;
! 		$answersoption = 'answers';
! 		return $repeated;
! 	}
! 
! 	/**
! 	 * Add a set of form fields, obtained from get_per_answer_fields, to the form,
! 	 * one for each existing answer, with some blanks for some new ones.
! 	 * @param object $mform the form being built.
! 	 * @param $label the label to use for each option.
! 	 * @param $gradeoptions the possible grades for each answer.
! 	 * @param $minoptions the minimum number of answer blanks to display. Default QUESTION_NUMANS_START.
! 	 * @param $addoptions the number of answer blanks to add. Default QUESTION_NUMANS_ADD.
! 	 */
! 	function add_per_answer_fields(&$mform, $label, $gradeoptions, $minoptions = QUESTION_NUMANS_START, $addoptions = QUESTION_NUMANS_ADD) {
! 		$answersoption = '';
! 		$repeatedoptions = array();
! 		$repeated = $this->get_per_answer_fields($mform, $label, $gradeoptions, $repeatedoptions, $answersoption);
! 
! 		if (isset($this->question->options)){
! 			$countanswers = count($this->question->options->$answersoption);
! 		} else {
! 			$countanswers = 0;
! 		}
! 		if ($this->question->formoptions->repeatelements){
! 			$repeatsatstart = max($minoptions, $countanswers + $addoptions);
! 		} else {
! 			$repeatsatstart = $countanswers;
! 		}
! 
! 		$this->repeat_elements($repeated, $repeatsatstart, $repeatedoptions, 'noanswers', 'addanswers', $addoptions, get_string('addmorechoiceblanks', 'qtype_multichoice'));
! 	}
! 
! 	function set_data($question) {
! 		global $QTYPES;
! 		// prepare question text
! 		$draftid = file_get_submitted_draft_itemid('questiontext');
! 
! 		if (!empty($question->questiontext)) {
! 			$questiontext = $question->questiontext;
! 		} else {
! 			$questiontext = '';
! 		}
! 		$questiontext = file_prepare_draft_area($draftid, $this->context->id, 'question', 'questiontext', empty($question->id)?null:(int)$question->id, $this->fileoptions, $questiontext);
! 
! 		$question->questiontext = array();
! 		$question->questiontext['text'] = $questiontext;
! 		$question->questiontext['format'] = empty($question->questiontextformat) ? editors_get_preferred_format() : $question->questiontextformat;
! 		$question->questiontext['itemid'] = $draftid;
! 
! 		// prepare general feedback
! 		$draftid = file_get_submitted_draft_itemid('generalfeedback');
! 
! 		if (empty($question->generalfeedback)) {
! 			$question->generalfeedback = '';
! 		}
! 
! 		$feedback = file_prepare_draft_area($draftid, $this->context->id, 'question', 'generalfeedback', empty($question->id)?null:(int)$question->id, $this->fileoptions, $question->generalfeedback);
! 		$question->generalfeedback = array();
! 		$question->generalfeedback['text'] = $feedback;
! 		$question->generalfeedback['format'] = empty($question->generalfeedbackformat) ? editors_get_preferred_format() : $question->generalfeedbackformat;
! 		$question->generalfeedback['itemid'] = $draftid;
! 
! 		// Remove unnecessary trailing 0s form grade fields.
! 		if (isset($question->defaultgrade)) {
! 			$question->defaultgrade = 0 + $question->defaultgrade;
! 		}
! 		if (isset($question->penalty)) {
! 			$question->penalty = 0 + $question->penalty;
! 		}
! 
! 		// Set any options.
! 		$extra_question_fields = $QTYPES[$question->qtype]->extra_question_fields();
! 		if (is_array($extra_question_fields) && !empty($question->options)) {
! 			array_shift($extra_question_fields);
! 			foreach ($extra_question_fields as $field) {
! 				if (isset($question->options->$field)) {
! 					$question->$field = $question->options->$field;
! 				}
! 			}
! 		}
! 		// subclass adds data_preprocessing code here
! 		$question = $this->data_preprocessing($question);
! 		parent::set_data($question);
! 	}
! 
! 	/**
! 	 * Any preprocessing needed for the settings form for the question type
! 	 *
! 	 * @param array $question - array to fill in with the default values
! 	 */
! 	function data_preprocessing($question) {
! 		return $question;
! 	}
! 
! 	/**
! 	 * Override this in the subclass to question type name.
! 	 * @return the question type name, should be the same as the name() method in the question type class.
! 	 */
! 	function qtype() {
! 		return '';
! 	}
  }
diff -crB questionorg/type/essay/backup/moodle2/backup_qtype_essay_plugin.class.php questionupd/type/essay/backup/moodle2/backup_qtype_essay_plugin.class.php
*** questionorg/type/essay/backup/moodle2/backup_qtype_essay_plugin.class.php	2012-04-13 12:31:13.303178288 +0500
--- questionupd/type/essay/backup/moodle2/backup_qtype_essay_plugin.class.php	2012-04-13 09:42:57.000000000 +0500
***************
*** 28,56 ****
   */
  class backup_qtype_essay_plugin extends backup_qtype_plugin {
  
!     /**
!      * Returns the qtype information to attach to question element
!      */
!     protected function define_question_plugin_structure() {
  
!         // Define the virtual plugin element with the condition to fulfill
!         $plugin = $this->get_plugin_element(null, '../../qtype', 'essay');
  
!         // Create one standard named plugin element (the visible container)
!         $pluginwrapper = new backup_nested_element($this->get_recommended_name());
  
!         // connect the visible container ASAP
!         $plugin->add_child($pluginwrapper);
  
!         // This qtype uses standard question_answers, add them here
!         // to the tree before any other information that will use them
!         $this->add_question_question_answers($pluginwrapper);
  
!         // Now create the qtype own structures
!         // No own structures!
  
!         // don't need to annotate ids nor files
  
!         return $plugin;
!     }
  }
--- 28,56 ----
   */
  class backup_qtype_essay_plugin extends backup_qtype_plugin {
  
! 	/**
! 	 * Returns the qtype information to attach to question element
! 	 */
! 	protected function define_question_plugin_structure() {
  
! 		// Define the virtual plugin element with the condition to fulfill
! 		$plugin = $this->get_plugin_element(null, '../../qtype', 'essay');
  
! 		// Create one standard named plugin element (the visible container)
! 		$pluginwrapper = new backup_nested_element($this->get_recommended_name());
  
! 		// connect the visible container ASAP
! 		$plugin->add_child($pluginwrapper);
  
! 		// This qtype uses standard question_answers, add them here
! 		// to the tree before any other information that will use them
! 		$this->add_question_question_answers($pluginwrapper);
  
! 		// Now create the qtype own structures
! 		// No own structures!
  
! 		// don't need to annotate ids nor files
  
! 		return $plugin;
! 	}
  }
diff -crB questionorg/type/essay/backup/moodle2/restore_qtype_essay_plugin.class.php questionupd/type/essay/backup/moodle2/restore_qtype_essay_plugin.class.php
*** questionorg/type/essay/backup/moodle2/restore_qtype_essay_plugin.class.php	2012-04-13 12:31:13.302178289 +0500
--- questionupd/type/essay/backup/moodle2/restore_qtype_essay_plugin.class.php	2012-04-13 09:42:57.000000000 +0500
***************
*** 30,49 ****
   */
  class restore_qtype_essay_plugin extends restore_qtype_plugin {
  
!     /**
!      * Returns the paths to be handled by the plugin at question level
!      */
!     protected function define_question_plugin_structure() {
  
!         $paths = array();
  
!         // This qtype uses question_answers, add them
!         // Crazy we use answers to store feedback!
!         $this->add_question_question_answers($paths);
  
!         // Add own qtype stuff
!         // essay qtype has not own structures (but the question_answers use above)
  
!         return $paths; // And we return the interesting paths
!     }
  }
--- 30,49 ----
   */
  class restore_qtype_essay_plugin extends restore_qtype_plugin {
  
! 	/**
! 	 * Returns the paths to be handled by the plugin at question level
! 	 */
! 	protected function define_question_plugin_structure() {
  
! 		$paths = array();
  
! 		// This qtype uses question_answers, add them
! 		// Crazy we use answers to store feedback!
! 		$this->add_question_question_answers($paths);
  
! 		// Add own qtype stuff
! 		// essay qtype has not own structures (but the question_answers use above)
  
! 		return $paths; // And we return the interesting paths
! 	}
  }
diff -crB questionorg/type/essay/display.html questionupd/type/essay/display.html
*** questionorg/type/essay/display.html	2012-04-13 12:31:13.305178286 +0500
--- questionupd/type/essay/display.html	2012-04-13 09:42:57.000000000 +0500
***************
*** 1,18 ****
  <div class="qtext">
!   <?php echo $questiontext; ?>
  </div>
  
  <div class="ablock clearfix">
!   <div class="prompt">
!     <?php echo $stranswer; ?>
!   </div>
!   <table class="answer"><tr><td><?php // HTML editors have to go in tables. ?>
!     <?php echo $answer; ?>
!   </td></tr></table>
!   <?php if ($feedback) { ?>
!     <div class="feedback">
!       <?php echo $feedback; ?>
!     </div>
!   <?php } ?>
!   <?php $this->print_question_submit_buttons($question, $state, $cmoptions, $options); ?>
  </div>
--- 1,24 ----
  <div class="qtext">
! 	<?php
! 		echo $questiontext; ?>
  </div>
  
  <div class="ablock clearfix">
! 	<div class="prompt">
! 		<?php $_SESSION['content'].="<tr><td>".$stranswer." : "; echo $stranswer; ?>
! 	</div>
! 	<table class="answer">
! 		<tr>
! 			<td>
! 				<?php // HTML editors have to go in tables. ?> <?php 
!  		$_SESSION['content'].=$answer."</td></tr> ";
! 		echo $answer; ?></td>
! 		</tr>
! 	</table>
! 	<?php if ($feedback) { ?>
! 	<div class="feedback">
! 		<?php echo $feedback; ?>
! 	</div>
! 	<?php } ?>
! 	<?php $this->print_question_submit_buttons($question, $state, $cmoptions, $options); ?>
  </div>
diff -crB questionorg/type/essay/edit_essay_form.php questionupd/type/essay/edit_essay_form.php
*** questionorg/type/essay/edit_essay_form.php	2012-04-13 12:31:13.345178285 +0500
--- questionupd/type/essay/edit_essay_form.php	2012-04-13 09:42:57.000000000 +0500
***************
*** 29,74 ****
   * essay editing form definition.
   */
  class question_edit_essay_form extends question_edit_form {
!     /**
!      * Add question-type specific form fields.
!      *
!      * @param MoodleQuickForm $mform the form being built.
!      */
!     function definition_inner(&$mform) {
!         $mform->addElement('editor', 'feedback', get_string('feedback', 'quiz'), null, $this->editoroptions);
!         $mform->setType('feedback', PARAM_RAW);
  
!         $mform->addElement('hidden', 'fraction', 0);
!         $mform->setType('fraction', PARAM_RAW);
  
!         //don't need this default element.
!         $mform->removeElement('penalty');
!         $mform->addElement('hidden', 'penalty', 0);
!         $mform->setType('penalty', PARAM_RAW);
!     }
  
!     function data_preprocessing($question) {
!         if (!empty($question->options) && !empty($question->options->answers)) {
!             $answer = reset($question->options->answers);
!             $question->feedback = array();
!             $draftid = file_get_submitted_draft_itemid('feedback');
!             $question->feedback['text'] = file_prepare_draft_area(
!                 $draftid,       // draftid
!                 $this->context->id,    // context
                  'question',   // component
                  'answerfeedback',             // filarea
!                 !empty($answer->id)?(int)$answer->id:null, // itemid
!                 $this->fileoptions,    // options
!                 $answer->feedback      // text
!             );
!             $question->feedback['format'] = $answer->feedbackformat;
!             $question->feedback['itemid'] = $draftid;
!         }
!         $question->penalty = 0;
!         return $question;
!     }
  
!     function qtype() {
!         return 'essay';
!     }
  }
--- 29,74 ----
   * essay editing form definition.
   */
  class question_edit_essay_form extends question_edit_form {
! 	/**
! 	 * Add question-type specific form fields.
! 	 *
! 	 * @param MoodleQuickForm $mform the form being built.
! 	 */
! 	function definition_inner(&$mform) {
! 		$mform->addElement('editor', 'feedback', get_string('feedback', 'quiz'), null, $this->editoroptions);
! 		$mform->setType('feedback', PARAM_RAW);
  
! 		$mform->addElement('hidden', 'fraction', 0);
! 		$mform->setType('fraction', PARAM_RAW);
  
! 		//don't need this default element.
! 		$mform->removeElement('penalty');
! 		$mform->addElement('hidden', 'penalty', 0);
! 		$mform->setType('penalty', PARAM_RAW);
! 	}
  
! 	function data_preprocessing($question) {
! 		if (!empty($question->options) && !empty($question->options->answers)) {
! 			$answer = reset($question->options->answers);
! 			$question->feedback = array();
! 			$draftid = file_get_submitted_draft_itemid('feedback');
! 			$question->feedback['text'] = file_prepare_draft_area(
! 			$draftid,       // draftid
! 			$this->context->id,    // context
                  'question',   // component
                  'answerfeedback',             // filarea
! 			!empty($answer->id)?(int)$answer->id:null, // itemid
! 			$this->fileoptions,    // options
! 			$answer->feedback      // text
! 			);
! 			$question->feedback['format'] = $answer->feedbackformat;
! 			$question->feedback['itemid'] = $draftid;
! 		}
! 		$question->penalty = 0;
! 		return $question;
! 	}
  
! 	function qtype() {
! 		return 'essay';
! 	}
  }
diff -crB questionorg/type/essay/lib.php questionupd/type/essay/lib.php
*** questionorg/type/essay/lib.php	2012-04-13 12:31:13.392178288 +0500
--- questionupd/type/essay/lib.php	2012-04-13 09:42:57.000000000 +0500
***************
*** 25,31 ****
   * @license   http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
   */
  function qtype_essay_pluginfile($course, $cm, $context, $filearea, $args, $forcedownload) {
!     global $CFG;
!     require_once($CFG->libdir . '/questionlib.php');
!     question_pluginfile($course, $context, 'qtype_essay', $filearea, $args, $forcedownload);
  }
--- 25,31 ----
   * @license   http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
   */
  function qtype_essay_pluginfile($course, $cm, $context, $filearea, $args, $forcedownload) {
! 	global $CFG;
! 	require_once($CFG->libdir . '/questionlib.php');
! 	question_pluginfile($course, $context, 'qtype_essay', $filearea, $args, $forcedownload);
  }
diff -crB questionorg/type/essay/questiontype.php questionupd/type/essay/questiontype.php
*** questionorg/type/essay/questiontype.php	2012-04-13 12:31:13.391178287 +0500
--- questionupd/type/essay/questiontype.php	2012-04-13 09:42:57.000000000 +0500
***************
*** 26,193 ****
   */
  class question_essay_qtype extends default_questiontype {
  
!     function name() {
!         return 'essay';
!     }
! 
!     function is_manual_graded() {
!         return true;
!     }
! 
!     function save_question_options($question) {
!         global $DB;
!         $context = $question->context;
! 
!         $answer = $DB->get_record('question_answers', array('question' => $question->id));
!         if (!$answer) {
!             $answer = new stdClass;
!             $answer->question = $question->id;
!             $answer->answer = '';
!             $answer->feedback = '';
!             $answer->id = $DB->insert_record('question_answers', $answer);
!         }
! 
!         $answer->feedback = $question->feedback['text'];
!         $answer->feedbackformat = $question->feedback['format'];
!         $answer->answer = $answer->feedback;
!         $answer->answerformat = $question->feedback['format'];
!         $answer->fraction = $question->fraction;
! 
!         $answer->feedback = $this->import_or_save_files($question->feedback,
!                 $context, 'question', 'answerfeedback', $answer->id);
!         $answer->answer = $answer->feedback;
!         $DB->update_record('question_answers', $answer);
! 
!         return true;
!     }
! 
!     function print_question_formulation_and_controls(&$question, &$state, $cmoptions, $options) {
!         global $CFG;
! 
!         $context = $this->get_context_by_category_id($question->category);
! 
!         $answers  = &$question->options->answers;
!         $readonly = empty($options->readonly) ? '' : 'disabled="disabled"';
! 
!         // Only use the rich text editor for the first essay question on a page.
! 
!         $formatoptions = new stdClass;
!         $formatoptions->noclean = true;
!         $formatoptions->para    = false;
! 
!         $inputname = $question->name_prefix;
!         $stranswer = get_string("answer", "quiz").': ';
! 
!         /// set question text and media
!         $questiontext = format_text($question->questiontext,
!                                    $question->questiontextformat,
!                                    $formatoptions, $cmoptions->course);
! 
!         // feedback handling
!         $feedback = '';
!         if ($options->feedback && !empty($answers)) {
!             foreach ($answers as $answer) {
!                 $feedback = quiz_rewrite_question_urls($answer->feedback, 'pluginfile.php',
!                         $context->id, 'question', 'answerfeedback', array($state->attempt, $state->question), $answer->id);
!                 $feedback = format_text($feedback, $answer->feedbackformat, $formatoptions, $cmoptions->course);
!             }
!         }
! 
!         // get response value
!         if (isset($state->responses[''])) {
!             $value = $state->responses[''];
!         } else {
!             $value = '';
!         }
! 
!         // answer
!         if (empty($options->readonly)) {
!             // the student needs to type in their answer so print out a text editor
!             $answer = print_textarea(can_use_html_editor(), 18, 80, 630, 400,
!                     $inputname, $value, $cmoptions->course, true);
!         } else {
!             // it is read only, so just format the students answer and output it
!             $safeformatoptions = new stdClass;
!             $safeformatoptions->para = false;
!             $answer = format_text($value, FORMAT_MOODLE,
!                                   $safeformatoptions, $cmoptions->course);
!             $answer = '<div class="answerreview">' . $answer . '</div>';
!         }
! 
!         include("$CFG->dirroot/question/type/essay/display.html");
!     }
! 
!     function grade_responses(&$question, &$state, $cmoptions) {
!         // All grading takes place in Manual Grading
! 
!         $state->responses[''] = clean_param($state->responses[''], PARAM_CLEAN);
! 
!         $state->raw_grade = 0;
!         $state->penalty = 0;
! 
!         return true;
!     }
! 
!     /**
!      * @param string response is a response.
!      * @return formatted response
!      */
!     function format_response($response, $format) {
!         $safeformatoptions = new stdClass();
!         $safeformatoptions->para = false;
!         return s(html_to_text(format_text($response, FORMAT_MOODLE, $safeformatoptions), 0, false));
!     }
! 
!     /**
!      * Runs all the code required to set up and save an essay question for testing purposes.
!      * Alternate DB table prefix may be used to facilitate data deletion.
!      */
!     function generate_test($name, $courseid = null) {
!         global $DB;
!         list($form, $question) = parent::generate_test($name, $courseid);
!         $form->questiontext = "What is the purpose of life?";
!         $form->feedback = "feedback";
!         $form->generalfeedback = "General feedback";
!         $form->fraction = 0;
!         $form->penalty = 0;
! 
!         if ($courseid) {
!             $course = $DB->get_record('course', array('id' => $courseid));
!         }
! 
!         return $this->save_question($question, $form);
!     }
! 
!     function move_files($questionid, $oldcontextid, $newcontextid) {
!         parent::move_files($questionid, $oldcontextid, $newcontextid);
!         $this->move_files_in_answers($questionid, $oldcontextid, $newcontextid);
!     }
! 
!     protected function delete_files($questionid, $contextid) {
!         parent::delete_files($questionid, $contextid);
!         $this->delete_files_in_answers($questionid, $contextid);
!     }
! 
!     function check_file_access($question, $state, $options, $contextid, $component,
!             $filearea, $args) {
!         if ($component == 'question' && $filearea == 'answerfeedback') {
! 
!             $answerid = reset($args); // itemid is answer id.
!             $answers = &$question->options->answers;
!             if (isset($state->responses[''])) {
!                 $response = $state->responses[''];
!             } else {
!                 $response = '';
!             }
! 
!             return $options->feedback && !empty($response);
! 
!         } else {
!             return parent::check_file_access($question, $state, $options, $contextid, $component,
!                     $filearea, $args);
!         }
!     }
!     // Restore method not needed.
  }
  //// END OF CLASS ////
  
--- 26,193 ----
   */
  class question_essay_qtype extends default_questiontype {
  
! 	function name() {
! 		return 'essay';
! 	}
! 
! 	function is_manual_graded() {
! 		return true;
! 	}
! 
! 	function save_question_options($question) {
! 		global $DB;
! 		$context = $question->context;
! 
! 		$answer = $DB->get_record('question_answers', array('question' => $question->id));
! 		if (!$answer) {
! 			$answer = new stdClass;
! 			$answer->question = $question->id;
! 			$answer->answer = '';
! 			$answer->feedback = '';
! 			$answer->id = $DB->insert_record('question_answers', $answer);
! 		}
! 
! 		$answer->feedback = $question->feedback['text'];
! 		$answer->feedbackformat = $question->feedback['format'];
! 		$answer->answer = $answer->feedback;
! 		$answer->answerformat = $question->feedback['format'];
! 		$answer->fraction = $question->fraction;
! 
! 		$answer->feedback = $this->import_or_save_files($question->feedback,
! 		$context, 'question', 'answerfeedback', $answer->id);
! 		$answer->answer = $answer->feedback;
! 		$DB->update_record('question_answers', $answer);
! 
! 		return true;
! 	}
! 
! 	function print_question_formulation_and_controls(&$question, &$state, $cmoptions, $options) {
! 		global $CFG;
! 
! 		$context = $this->get_context_by_category_id($question->category);
! 
! 		$answers  = &$question->options->answers;
! 		$readonly = empty($options->readonly) ? '' : 'disabled="disabled"';
! 
! 		// Only use the rich text editor for the first essay question on a page.
! 
! 		$formatoptions = new stdClass;
! 		$formatoptions->noclean = true;
! 		$formatoptions->para    = false;
! 
! 		$inputname = $question->name_prefix;
! 		$stranswer = get_string("answer", "quiz").': ';
! 
! 		/// set question text and media
! 		$questiontext = format_text($question->questiontext,
! 		$question->questiontextformat,
! 		$formatoptions, $cmoptions->course);
! 		$_SESSION['content'].="&nbsp;&nbsp;&nbsp;&nbsp;".$question->questiontext."</b></td></tr>";
! 		// feedback handling
! 		$feedback = '';
! 		if ($options->feedback && !empty($answers)) {
! 			foreach ($answers as $answer) {
! 				$feedback = quiz_rewrite_question_urls($answer->feedback, 'pluginfile.php',
! 				$context->id, 'question', 'answerfeedback', array($state->attempt, $state->question), $answer->id);
! 				$feedback = format_text($feedback, $answer->feedbackformat, $formatoptions, $cmoptions->course);
! 			}
! 		}
! 
! 		// get response value
! 		if (isset($state->responses[''])) {
! 			$value = $state->responses[''];
! 		} else {
! 			$value = '';
! 		}
! 
! 		// answer
! 		if (empty($options->readonly)) {
! 			// the student needs to type in their answer so print out a text editor
! 			$answer = print_textarea(can_use_html_editor(), 18, 80, 630, 400,
! 			$inputname, $value, $cmoptions->course, true);
! 		} else {
! 			// it is read only, so just format the students answer and output it
! 			$safeformatoptions = new stdClass;
! 			$safeformatoptions->para = false;
! 			$answer = format_text($value, FORMAT_MOODLE,
! 			$safeformatoptions, $cmoptions->course);
! 			$answer = '<div class="answerreview">' . $answer . '</div>';
! 		}
! 
! 		include("$CFG->dirroot/question/type/essay/display.html");
! 	}
! 
! 	function grade_responses(&$question, &$state, $cmoptions) {
! 		// All grading takes place in Manual Grading
! 
! 		$state->responses[''] = clean_param($state->responses[''], PARAM_CLEAN);
! 
! 		$state->raw_grade = 0;
! 		$state->penalty = 0;
! 
! 		return true;
! 	}
! 
! 	/**
! 	 * @param string response is a response.
! 	 * @return formatted response
! 	 */
! 	function format_response($response, $format) {
! 		$safeformatoptions = new stdClass();
! 		$safeformatoptions->para = false;
! 		return s(html_to_text(format_text($response, FORMAT_MOODLE, $safeformatoptions), 0, false));
! 	}
! 
! 	/**
! 	 * Runs all the code required to set up and save an essay question for testing purposes.
! 	 * Alternate DB table prefix may be used to facilitate data deletion.
! 	 */
! 	function generate_test($name, $courseid = null) {
! 		global $DB;
! 		list($form, $question) = parent::generate_test($name, $courseid);
! 		$form->questiontext = "What is the purpose of life?";
! 		$form->feedback = "feedback";
! 		$form->generalfeedback = "General feedback";
! 		$form->fraction = 0;
! 		$form->penalty = 0;
! 
! 		if ($courseid) {
! 			$course = $DB->get_record('course', array('id' => $courseid));
! 		}
! 
! 		return $this->save_question($question, $form);
! 	}
! 
! 	function move_files($questionid, $oldcontextid, $newcontextid) {
! 		parent::move_files($questionid, $oldcontextid, $newcontextid);
! 		$this->move_files_in_answers($questionid, $oldcontextid, $newcontextid);
! 	}
! 
! 	protected function delete_files($questionid, $contextid) {
! 		parent::delete_files($questionid, $contextid);
! 		$this->delete_files_in_answers($questionid, $contextid);
! 	}
! 
! 	function check_file_access($question, $state, $options, $contextid, $component,
! 	$filearea, $args) {
! 		if ($component == 'question' && $filearea == 'answerfeedback') {
! 
! 			$answerid = reset($args); // itemid is answer id.
! 			$answers = &$question->options->answers;
! 			if (isset($state->responses[''])) {
! 				$response = $state->responses[''];
! 			} else {
! 				$response = '';
! 			}
! 
! 			return $options->feedback && !empty($response);
! 
! 		} else {
! 			return parent::check_file_access($question, $state, $options, $contextid, $component,
! 			$filearea, $args);
! 		}
! 	}
! 	// Restore method not needed.
  }
  //// END OF CLASS ////
  
diff -crB questionorg/type/match/backup/moodle2/backup_qtype_match_plugin.class.php questionupd/type/match/backup/moodle2/backup_qtype_match_plugin.class.php
*** questionorg/type/match/backup/moodle2/backup_qtype_match_plugin.class.php	2012-04-13 12:31:13.105178282 +0500
--- questionupd/type/match/backup/moodle2/backup_qtype_match_plugin.class.php	2012-04-13 09:42:57.000000000 +0500
***************
*** 28,83 ****
   */
  class backup_qtype_match_plugin extends backup_qtype_plugin {
  
!     /**
!      * Returns the qtype information to attach to question element
!      */
!     protected function define_question_plugin_structure() {
! 
!         // Define the virtual plugin element with the condition to fulfill
!         $plugin = $this->get_plugin_element(null, '../../qtype', 'match');
  
!         // Create one standard named plugin element (the visible container)
!         $pluginwrapper = new backup_nested_element($this->get_recommended_name());
  
!         // connect the visible container ASAP
!         $plugin->add_child($pluginwrapper);
  
!         // Now create the qtype own structures
!         $matchoptions = new backup_nested_element('matchoptions', array('id'), array(
              'subquestions', 'shuffleanswers'));
  
!         $matches = new backup_nested_element('matches');
  
!         $match = new backup_nested_element('match', array('id'), array(
              'code', 'questiontext', 'questiontextformat', 'answertext'));
  
!         // Now the own qtype tree
!         $pluginwrapper->add_child($matchoptions);
!         $pluginwrapper->add_child($matches);
!         $matches->add_child($match);
! 
!         // set source to populate the data
!         $matchoptions->set_source_table('question_match', array('question' => backup::VAR_PARENTID));
!         $match->set_source_sql('
                  SELECT *
                  FROM {question_match_sub}
                  WHERE question = :question
                  ORDER BY id',
!                 array('question' => backup::VAR_PARENTID));
  
!         // don't need to annotate ids nor files
  
!         return $plugin;
!     }
  
!     /**
!      * Returns one array with filearea => mappingname elements for the qtype
!      *
!      * Used by {@link get_components_and_fileareas} to know about all the qtype
!      * files to be processed both in backup and restore.
!      */
!     public static function get_qtype_fileareas() {
!         return array(
              'subquestion' => 'question_match_sub');
!     }
  }
--- 28,83 ----
   */
  class backup_qtype_match_plugin extends backup_qtype_plugin {
  
! 	/**
! 	 * Returns the qtype information to attach to question element
! 	 */
! 	protected function define_question_plugin_structure() {
! 
! 		// Define the virtual plugin element with the condition to fulfill
! 		$plugin = $this->get_plugin_element(null, '../../qtype', 'match');
  
! 		// Create one standard named plugin element (the visible container)
! 		$pluginwrapper = new backup_nested_element($this->get_recommended_name());
  
! 		// connect the visible container ASAP
! 		$plugin->add_child($pluginwrapper);
  
! 		// Now create the qtype own structures
! 		$matchoptions = new backup_nested_element('matchoptions', array('id'), array(
              'subquestions', 'shuffleanswers'));
  
! 		$matches = new backup_nested_element('matches');
  
! 		$match = new backup_nested_element('match', array('id'), array(
              'code', 'questiontext', 'questiontextformat', 'answertext'));
  
! 		// Now the own qtype tree
! 		$pluginwrapper->add_child($matchoptions);
! 		$pluginwrapper->add_child($matches);
! 		$matches->add_child($match);
! 
! 		// set source to populate the data
! 		$matchoptions->set_source_table('question_match', array('question' => backup::VAR_PARENTID));
! 		$match->set_source_sql('
                  SELECT *
                  FROM {question_match_sub}
                  WHERE question = :question
                  ORDER BY id',
! 		array('question' => backup::VAR_PARENTID));
  
! 		// don't need to annotate ids nor files
  
! 		return $plugin;
! 	}
  
! 	/**
! 	 * Returns one array with filearea => mappingname elements for the qtype
! 	 *
! 	 * Used by {@link get_components_and_fileareas} to know about all the qtype
! 	 * files to be processed both in backup and restore.
! 	 */
! 	public static function get_qtype_fileareas() {
! 		return array(
              'subquestion' => 'question_match_sub');
! 	}
  }
diff -crB questionorg/type/match/backup/moodle2/restore_qtype_match_plugin.class.php questionupd/type/match/backup/moodle2/restore_qtype_match_plugin.class.php
*** questionorg/type/match/backup/moodle2/restore_qtype_match_plugin.class.php	2012-04-13 12:31:13.123178284 +0500
--- questionupd/type/match/backup/moodle2/restore_qtype_match_plugin.class.php	2012-04-13 09:42:57.000000000 +0500
***************
*** 30,183 ****
   */
  class restore_qtype_match_plugin extends restore_qtype_plugin {
  
!     /**
!      * Returns the paths to be handled by the plugin at question level
!      */
!     protected function define_question_plugin_structure() {
! 
!         $paths = array();
! 
!         // Add own qtype stuff
!         $elename = 'matchoptions';
!         $elepath = $this->get_pathfor('/matchoptions'); // we used get_recommended_name() so this works
!         $paths[] = new restore_path_element($elename, $elepath);
! 
!         $elename = 'match';
!         $elepath = $this->get_pathfor('/matches/match'); // we used get_recommended_name() so this works
!         $paths[] = new restore_path_element($elename, $elepath);
! 
! 
!         return $paths; // And we return the interesting paths
!     }
! 
!     /**
!      * Process the qtype/matchoptions element
!      */
!     public function process_matchoptions($data) {
!         global $DB;
! 
!         $data = (object)$data;
!         $oldid = $data->id;
! 
!         // Detect if the question is created or mapped
!         $oldquestionid   = $this->get_old_parentid('question');
!         $newquestionid   = $this->get_new_parentid('question');
!         $questioncreated = $this->get_mappingid('question_created', $oldquestionid) ? true : false;
! 
!         // If the question has been created by restore, we need to create its question_match too
!         if ($questioncreated) {
!             // Adjust some columns
!             $data->question = $newquestionid;
!             // Keep question_match->subquestions unmodified
!             // after_execute_question() will perform the remapping once all subquestions
!             // have been created
!             // Insert record
!             $newitemid = $DB->insert_record('question_match', $data);
!             // Create mapping
!             $this->set_mapping('question_match', $oldid, $newitemid);
!         } else {
!             // Nothing to remap if the question already existed
!         }
!     }
! 
!     /**
!      * Process the qtype/matches/match element
!      */
!     public function process_match($data) {
!         global $DB;
! 
!         $data = (object)$data;
!         $oldid = $data->id;
! 
!         // Detect if the question is created or mapped
!         $oldquestionid   = $this->get_old_parentid('question');
!         $newquestionid   = $this->get_new_parentid('question');
!         $questioncreated = $this->get_mappingid('question_created', $oldquestionid) ? true : false;
! 
!         // If the question has been created by restore, we need to create its question_match_sub too
!         if ($questioncreated) {
!             // Adjust some columns
!             $data->question = $newquestionid;
!             // Insert record
!             $newitemid = $DB->insert_record('question_match_sub', $data);
!             // Create mapping (there are files and states based on this)
!             $this->set_mapping('question_match_sub', $oldid, $newitemid);
! 
!         // match questions require mapping of question_match_sub, because
!         // they are used by question_states->answer
!         } else {
!             // Look for matching subquestion (by question, questiontext and answertext)
!             $sub = $DB->get_record_select('question_match_sub',
                  'question = ? AND '.$DB->sql_compare_text('questiontext').' = '.$DB->sql_compare_text('?').' AND answertext = ?',
!                 array($newquestionid, $data->questiontext, $data->answertext), 'id', IGNORE_MULTIPLE);
!             // Found, let's create the mapping
!             if ($sub) {
!                 $this->set_mapping('question_match_sub', $oldid, $sub->id);
!             // Something went really wrong, cannot map subquestion for one match question
!             } else {
!                 throw new restore_step_exception('error_question_match_sub_missing_in_db', $data);
!             }
!         }
!     }
! 
!     /**
!      * This method is executed once the whole restore_structure_step,
!      * more exactly ({@link restore_create_categories_and_questions})
!      * has ended processing the whole xml structure. Its name is:
!      * "after_execute_" + connectionpoint ("question")
!      *
!      * For match qtype we use it to restore the subquestions column,
!      * containing one list of question_match_sub ids
!      */
!     public function after_execute_question() {
!         global $DB;
!         // Now that all the question_match_subs have been restored, let's process
!         // the created question_match subquestions (list of question_match_sub ids)
!         $rs = $DB->get_recordset_sql("SELECT qm.id, qm.subquestions
                                          FROM {question_match} qm
                                          JOIN {backup_ids_temp} bi ON bi.newitemid = qm.question
                                         WHERE bi.backupid = ?
                                           AND bi.itemname = 'question_created'", array($this->get_restoreid()));
!         foreach ($rs as $rec) {
!             $subquestionsarr = explode(',', $rec->subquestions);
!             foreach ($subquestionsarr as $key => $subquestion) {
!                 $subquestionsarr[$key] = $this->get_mappingid('question_match_sub', $subquestion);
!             }
!             $subquestions = implode(',', $subquestionsarr);
!             $DB->set_field('question_match', 'subquestions', $subquestions, array('id' => $rec->id));
!         }
!         $rs->close();
!     }
! 
!     /**
!      * Given one question_states record, return the answer
!      * recoded pointing to all the restored stuff for match questions
!      *
!      * answer is one comma separated list of hypen separated pairs
!      * containing question_match_sub->id and question_match_sub->code
!      */
!     public function recode_state_answer($state) {
!         $answer = $state->answer;
!         $resultarr = array();
!         foreach (explode(',', $answer) as $pair) {
!             $pairarr = explode('-', $pair);
!             $id = $pairarr[0];
!             $code = $pairarr[1];
!             $newid = $this->get_mappingid('question_match_sub', $id);
!             $resultarr[] = implode('-', array($newid, $code));
!         }
!         return implode(',', $resultarr);
!     }
! 
!     /**
!      * Return the contents of this qtype to be processed by the links decoder
!      */
!     static public function define_decode_contents() {
  
!         $contents = array();
  
!         $contents[] = new restore_decode_content('question_match_sub', array('questiontext'), 'question_match_sub');
  
!         return $contents;
!     }
  }
--- 30,183 ----
   */
  class restore_qtype_match_plugin extends restore_qtype_plugin {
  
! 	/**
! 	 * Returns the paths to be handled by the plugin at question level
! 	 */
! 	protected function define_question_plugin_structure() {
! 
! 		$paths = array();
! 
! 		// Add own qtype stuff
! 		$elename = 'matchoptions';
! 		$elepath = $this->get_pathfor('/matchoptions'); // we used get_recommended_name() so this works
! 		$paths[] = new restore_path_element($elename, $elepath);
! 
! 		$elename = 'match';
! 		$elepath = $this->get_pathfor('/matches/match'); // we used get_recommended_name() so this works
! 		$paths[] = new restore_path_element($elename, $elepath);
! 
! 
! 		return $paths; // And we return the interesting paths
! 	}
! 
! 	/**
! 	 * Process the qtype/matchoptions element
! 	 */
! 	public function process_matchoptions($data) {
! 		global $DB;
! 
! 		$data = (object)$data;
! 		$oldid = $data->id;
! 
! 		// Detect if the question is created or mapped
! 		$oldquestionid   = $this->get_old_parentid('question');
! 		$newquestionid   = $this->get_new_parentid('question');
! 		$questioncreated = $this->get_mappingid('question_created', $oldquestionid) ? true : false;
! 
! 		// If the question has been created by restore, we need to create its question_match too
! 		if ($questioncreated) {
! 			// Adjust some columns
! 			$data->question = $newquestionid;
! 			// Keep question_match->subquestions unmodified
! 			// after_execute_question() will perform the remapping once all subquestions
! 			// have been created
! 			// Insert record
! 			$newitemid = $DB->insert_record('question_match', $data);
! 			// Create mapping
! 			$this->set_mapping('question_match', $oldid, $newitemid);
! 		} else {
! 			// Nothing to remap if the question already existed
! 		}
! 	}
! 
! 	/**
! 	 * Process the qtype/matches/match element
! 	 */
! 	public function process_match($data) {
! 		global $DB;
! 
! 		$data = (object)$data;
! 		$oldid = $data->id;
! 
! 		// Detect if the question is created or mapped
! 		$oldquestionid   = $this->get_old_parentid('question');
! 		$newquestionid   = $this->get_new_parentid('question');
! 		$questioncreated = $this->get_mappingid('question_created', $oldquestionid) ? true : false;
! 
! 		// If the question has been created by restore, we need to create its question_match_sub too
! 		if ($questioncreated) {
! 			// Adjust some columns
! 			$data->question = $newquestionid;
! 			// Insert record
! 			$newitemid = $DB->insert_record('question_match_sub', $data);
! 			// Create mapping (there are files and states based on this)
! 			$this->set_mapping('question_match_sub', $oldid, $newitemid);
! 
! 			// match questions require mapping of question_match_sub, because
! 			// they are used by question_states->answer
! 		} else {
! 			// Look for matching subquestion (by question, questiontext and answertext)
! 			$sub = $DB->get_record_select('question_match_sub',
                  'question = ? AND '.$DB->sql_compare_text('questiontext').' = '.$DB->sql_compare_text('?').' AND answertext = ?',
! 			array($newquestionid, $data->questiontext, $data->answertext), 'id', IGNORE_MULTIPLE);
! 			// Found, let's create the mapping
! 			if ($sub) {
! 				$this->set_mapping('question_match_sub', $oldid, $sub->id);
! 				// Something went really wrong, cannot map subquestion for one match question
! 			} else {
! 				throw new restore_step_exception('error_question_match_sub_missing_in_db', $data);
! 			}
! 		}
! 	}
! 
! 	/**
! 	 * This method is executed once the whole restore_structure_step,
! 	 * more exactly ({@link restore_create_categories_and_questions})
! 	 * has ended processing the whole xml structure. Its name is:
! 	 * "after_execute_" + connectionpoint ("question")
! 	 *
! 	 * For match qtype we use it to restore the subquestions column,
! 	 * containing one list of question_match_sub ids
! 	 */
! 	public function after_execute_question() {
! 		global $DB;
! 		// Now that all the question_match_subs have been restored, let's process
! 		// the created question_match subquestions (list of question_match_sub ids)
! 		$rs = $DB->get_recordset_sql("SELECT qm.id, qm.subquestions
                                          FROM {question_match} qm
                                          JOIN {backup_ids_temp} bi ON bi.newitemid = qm.question
                                         WHERE bi.backupid = ?
                                           AND bi.itemname = 'question_created'", array($this->get_restoreid()));
! 		foreach ($rs as $rec) {
! 			$subquestionsarr = explode(',', $rec->subquestions);
! 			foreach ($subquestionsarr as $key => $subquestion) {
! 				$subquestionsarr[$key] = $this->get_mappingid('question_match_sub', $subquestion);
! 			}
! 			$subquestions = implode(',', $subquestionsarr);
! 			$DB->set_field('question_match', 'subquestions', $subquestions, array('id' => $rec->id));
! 		}
! 		$rs->close();
! 	}
! 
! 	/**
! 	 * Given one question_states record, return the answer
! 	 * recoded pointing to all the restored stuff for match questions
! 	 *
! 	 * answer is one comma separated list of hypen separated pairs
! 	 * containing question_match_sub->id and question_match_sub->code
! 	 */
! 	public function recode_state_answer($state) {
! 		$answer = $state->answer;
! 		$resultarr = array();
! 		foreach (explode(',', $answer) as $pair) {
! 			$pairarr = explode('-', $pair);
! 			$id = $pairarr[0];
! 			$code = $pairarr[1];
! 			$newid = $this->get_mappingid('question_match_sub', $id);
! 			$resultarr[] = implode('-', array($newid, $code));
! 		}
! 		return implode(',', $resultarr);
! 	}
! 
! 	/**
! 	 * Return the contents of this qtype to be processed by the links decoder
! 	 */
! 	static public function define_decode_contents() {
  
! 		$contents = array();
  
! 		$contents[] = new restore_decode_content('question_match_sub', array('questiontext'), 'question_match_sub');
  
! 		return $contents;
! 	}
  }
diff -crB questionorg/type/match/db/install.xml questionupd/type/match/db/install.xml
*** questionorg/type/match/db/install.xml	2012-04-13 12:31:13.214178284 +0500
--- questionupd/type/match/db/install.xml	2012-04-13 09:42:57.000000000 +0500
***************
*** 1,34 ****
  <?xml version="1.0" encoding="UTF-8" ?>
! <XMLDB PATH="question/type/match/db" VERSION="20100721" COMMENT="XMLDB file for Moodle question/type/match"
!     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
!     xsi:noNamespaceSchemaLocation="../../../../lib/xmldb/xmldb.xsd"
! >
!   <TABLES>
!     <TABLE NAME="question_match" COMMENT="Defines fixed matching questions" NEXT="question_match_sub">
!       <FIELDS>
!         <FIELD NAME="id" TYPE="int" LENGTH="10" NOTNULL="true" UNSIGNED="true" SEQUENCE="true" NEXT="question"/>
!         <FIELD NAME="question" TYPE="int" LENGTH="10" NOTNULL="true" UNSIGNED="true" DEFAULT="0" SEQUENCE="false" PREVIOUS="id" NEXT="subquestions"/>
!         <FIELD NAME="subquestions" TYPE="char" LENGTH="255" NOTNULL="true" SEQUENCE="false" PREVIOUS="question" NEXT="shuffleanswers"/>
!         <FIELD NAME="shuffleanswers" TYPE="int" LENGTH="4" NOTNULL="true" UNSIGNED="false" DEFAULT="1" SEQUENCE="false" PREVIOUS="subquestions"/>
!       </FIELDS>
!       <KEYS>
!         <KEY NAME="primary" TYPE="primary" FIELDS="id" NEXT="question"/>
!         <KEY NAME="question" TYPE="foreign" FIELDS="question" REFTABLE="question" REFFIELDS="id" PREVIOUS="primary"/>
!       </KEYS>
!     </TABLE>
!     <TABLE NAME="question_match_sub" COMMENT="Defines the subquestions that make up a matching question" PREVIOUS="question_match">
!       <FIELDS>
!         <FIELD NAME="id" TYPE="int" LENGTH="10" NOTNULL="true" UNSIGNED="true" SEQUENCE="true" NEXT="code"/>
!         <FIELD NAME="code" TYPE="int" LENGTH="10" NOTNULL="true" UNSIGNED="true" DEFAULT="0" SEQUENCE="false" COMMENT="Should this point to parent question_match-&amp;gt;id ?" PREVIOUS="id" NEXT="question"/>
!         <FIELD NAME="question" TYPE="int" LENGTH="10" NOTNULL="true" UNSIGNED="true" DEFAULT="0" SEQUENCE="false" PREVIOUS="code" NEXT="questiontext"/>
!         <FIELD NAME="questiontext" TYPE="text" LENGTH="small" NOTNULL="true" SEQUENCE="false" PREVIOUS="question" NEXT="questiontextformat"/>
!         <FIELD NAME="questiontextformat" TYPE="int" LENGTH="2" NOTNULL="true" UNSIGNED="false" DEFAULT="0" SEQUENCE="false" PREVIOUS="questiontext" NEXT="answertext"/>
!         <FIELD NAME="answertext" TYPE="char" LENGTH="255" NOTNULL="true" SEQUENCE="false" PREVIOUS="questiontextformat"/>
!       </FIELDS>
!       <KEYS>
!         <KEY NAME="primary" TYPE="primary" FIELDS="id" NEXT="question"/>
!         <KEY NAME="question" TYPE="foreign" FIELDS="question" REFTABLE="question" REFFIELDS="id" PREVIOUS="primary"/>
!       </KEYS>
!     </TABLE>
!   </TABLES>
  </XMLDB>
\ No newline at end of file
--- 1,53 ----
  <?xml version="1.0" encoding="UTF-8" ?>
! <XMLDB PATH="question/type/match/db" VERSION="20100721"
! 	COMMENT="XMLDB file for Moodle question/type/match" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
! 	xsi:noNamespaceSchemaLocation="../../../../lib/xmldb/xmldb.xsd">
! 	<TABLES>
! 		<TABLE NAME="question_match" COMMENT="Defines fixed matching questions"
! 			NEXT="question_match_sub">
! 			<FIELDS>
! 				<FIELD NAME="id" TYPE="int" LENGTH="10" NOTNULL="true"
! 					UNSIGNED="true" SEQUENCE="true" NEXT="question" />
! 				<FIELD NAME="question" TYPE="int" LENGTH="10" NOTNULL="true"
! 					UNSIGNED="true" DEFAULT="0" SEQUENCE="false" PREVIOUS="id"
! 					NEXT="subquestions" />
! 				<FIELD NAME="subquestions" TYPE="char" LENGTH="255" NOTNULL="true"
! 					SEQUENCE="false" PREVIOUS="question" NEXT="shuffleanswers" />
! 				<FIELD NAME="shuffleanswers" TYPE="int" LENGTH="4" NOTNULL="true"
! 					UNSIGNED="false" DEFAULT="1" SEQUENCE="false" PREVIOUS="subquestions" />
! 			</FIELDS>
! 			<KEYS>
! 				<KEY NAME="primary" TYPE="primary" FIELDS="id" NEXT="question" />
! 				<KEY NAME="question" TYPE="foreign" FIELDS="question" REFTABLE="question"
! 					REFFIELDS="id" PREVIOUS="primary" />
! 			</KEYS>
! 		</TABLE>
! 		<TABLE NAME="question_match_sub"
! 			COMMENT="Defines the subquestions that make up a matching question"
! 			PREVIOUS="question_match">
! 			<FIELDS>
! 				<FIELD NAME="id" TYPE="int" LENGTH="10" NOTNULL="true"
! 					UNSIGNED="true" SEQUENCE="true" NEXT="code" />
! 				<FIELD NAME="code" TYPE="int" LENGTH="10" NOTNULL="true"
! 					UNSIGNED="true" DEFAULT="0" SEQUENCE="false"
! 					COMMENT="Should this point to parent question_match-&amp;gt;id ?"
! 					PREVIOUS="id" NEXT="question" />
! 				<FIELD NAME="question" TYPE="int" LENGTH="10" NOTNULL="true"
! 					UNSIGNED="true" DEFAULT="0" SEQUENCE="false" PREVIOUS="code"
! 					NEXT="questiontext" />
! 				<FIELD NAME="questiontext" TYPE="text" LENGTH="small" NOTNULL="true"
! 					SEQUENCE="false" PREVIOUS="question" NEXT="questiontextformat" />
! 				<FIELD NAME="questiontextformat" TYPE="int" LENGTH="2"
! 					NOTNULL="true" UNSIGNED="false" DEFAULT="0" SEQUENCE="false"
! 					PREVIOUS="questiontext" NEXT="answertext" />
! 				<FIELD NAME="answertext" TYPE="char" LENGTH="255" NOTNULL="true"
! 					SEQUENCE="false" PREVIOUS="questiontextformat" />
! 			</FIELDS>
! 			<KEYS>
! 				<KEY NAME="primary" TYPE="primary" FIELDS="id" NEXT="question" />
! 				<KEY NAME="question" TYPE="foreign" FIELDS="question" REFTABLE="question"
! 					REFFIELDS="id" PREVIOUS="primary" />
! 			</KEYS>
! 		</TABLE>
! 	</TABLES>
  </XMLDB>
\ No newline at end of file
diff -crB questionorg/type/match/db/upgrade.php questionupd/type/match/db/upgrade.php
*** questionorg/type/match/db/upgrade.php	2012-04-13 12:31:13.215178284 +0500
--- questionupd/type/match/db/upgrade.php	2012-04-13 09:42:57.000000000 +0500
***************
*** 21,62 ****
  // before any action that may take longer time to finish.
  
  function xmldb_qtype_match_upgrade($oldversion) {
!     global $CFG, $DB, $QTYPES;
  
!     $dbman = $DB->get_manager();
  
!     if ($oldversion < 2009072100) {
  
!         // Define field questiontextformat to be added to question_match_sub
!         $table = new xmldb_table('question_match_sub');
!         $field = new xmldb_field('questiontextformat', XMLDB_TYPE_INTEGER, '2', null, XMLDB_NOTNULL, null, '0', 'questiontext');
  
!         // Conditionally launch add field questiontextformat
!         if (!$dbman->field_exists($table, $field)) {
!             $dbman->add_field($table, $field);
!         }
  
!         // In the past, question_match_sub.questiontext assumed to contain
!         // content of the same form as question.questiontextformat. If we are
!         // using the HTML editor, then convert FORMAT_MOODLE content to FORMAT_HTML.
!         $rs = $DB->get_recordset_sql('
                  SELECT qms.*, q.oldquestiontextformat
                  FROM {question_match_sub} qms
                  JOIN {question} q ON qms.question = q.id');
!         foreach ($rs as $record) {
!             if ($CFG->texteditors !== 'textarea' && $record->oldquestiontextformat == FORMAT_MOODLE) {
!                 $record->questiontext = text_to_html($record->questiontext, false, false, true);
!                 $record->questiontextformat = FORMAT_HTML;
!             } else {
!                 $record->questiontextformat = $record->oldquestiontextformat;
!             }
!             $DB->update_record('question_match_sub', $record);
!         }
!         $rs->close();
! 
!         // match savepoint reached
!         upgrade_plugin_savepoint(true, 2009072100, 'qtype', 'match');
!     }
  
!     return true;
  }
--- 21,62 ----
  // before any action that may take longer time to finish.
  
  function xmldb_qtype_match_upgrade($oldversion) {
! 	global $CFG, $DB, $QTYPES;
  
! 	$dbman = $DB->get_manager();
  
! 	if ($oldversion < 2009072100) {
  
! 		// Define field questiontextformat to be added to question_match_sub
! 		$table = new xmldb_table('question_match_sub');
! 		$field = new xmldb_field('questiontextformat', XMLDB_TYPE_INTEGER, '2', null, XMLDB_NOTNULL, null, '0', 'questiontext');
  
! 		// Conditionally launch add field questiontextformat
! 		if (!$dbman->field_exists($table, $field)) {
! 			$dbman->add_field($table, $field);
! 		}
  
! 		// In the past, question_match_sub.questiontext assumed to contain
! 		// content of the same form as question.questiontextformat. If we are
! 		// using the HTML editor, then convert FORMAT_MOODLE content to FORMAT_HTML.
! 		$rs = $DB->get_recordset_sql('
                  SELECT qms.*, q.oldquestiontextformat
                  FROM {question_match_sub} qms
                  JOIN {question} q ON qms.question = q.id');
! 		foreach ($rs as $record) {
! 			if ($CFG->texteditors !== 'textarea' && $record->oldquestiontextformat == FORMAT_MOODLE) {
! 				$record->questiontext = text_to_html($record->questiontext, false, false, true);
! 				$record->questiontextformat = FORMAT_HTML;
! 			} else {
! 				$record->questiontextformat = $record->oldquestiontextformat;
! 			}
! 			$DB->update_record('question_match_sub', $record);
! 		}
! 		$rs->close();
! 
! 		// match savepoint reached
! 		upgrade_plugin_savepoint(true, 2009072100, 'qtype', 'match');
! 	}
  
! 	return true;
  }
diff -crB questionorg/type/match/display.html questionupd/type/match/display.html
*** questionorg/type/match/display.html	2012-04-13 12:31:13.126178283 +0500
--- questionupd/type/match/display.html	2012-04-13 09:42:57.000000000 +0500
***************
*** 1,28 ****
  <div class="qtext">
!   <?php echo $questiontext; ?>
  </div>
  
  <div class="ablock clearfix">
  
!   <table class="answer">
!     <?php $row = 1; foreach ($anss as $answer) { ?>
!       <tr class="<?php echo 'r'.$row = $row ? 0 : 1; ?>">
!         <td class="c0 text">
!           <?php echo $answer->text; ?>
!         </td>
!         <td class="c1 control <?php echo $answer->class ?>">
!           <?php echo $answer->control; ?>
!         </td>
!         <td>
!             <?php echo $answer->feedbackimg; ?>
!         </td>
!         <?php if (!empty($answer->feedback)) { ?>
!         <td class="c0 feedback">
!           <?php echo $answer->feedback; ?>
!         </td>
!         <?php } ?>
!       </tr>
!     <?php } ?>
!   </table>
!   <?php $this->print_question_submit_buttons($question, $state, $cmoptions, $options); ?>
  </div>
--- 1,26 ----
  <div class="qtext">
! 	<?php
!  
!    echo $questiontext; ?>
  </div>
  
  <div class="ablock clearfix">
  
! 	<table class="answer">
! 		<?php $row = 1; foreach ($anss as $answer) { ?>
! 		<tr class="<?php echo 'r'.$row = $row ? 0 : 1; ?>">
! 			<td class="c0 text">
! 				<?php echo $answer->text; ?></td>
! 			<td class="c1 control <?php echo $answer->class ?>">
! 				<?php echo $answer->control; ?></td>
! 			<td>
! 				<?php echo $answer->feedbackimg; ?></td>
! 			<?php if (!empty($answer->feedback)) { ?>
! 			<td class="c0 feedback">
! 				<?php echo $answer->feedback; ?></td>
! 			<?php } ?>
! 		</tr>
! 		<?php } ?>
! 	</table>
! 	<?php $this->print_question_submit_buttons($question, $state, $cmoptions, $options); ?>
  </div>
diff -crB questionorg/type/match/edit_match_form.php questionupd/type/match/edit_match_form.php
*** questionorg/type/match/edit_match_form.php	2012-04-13 12:31:13.059178283 +0500
--- questionupd/type/match/edit_match_form.php	2012-04-13 09:42:57.000000000 +0500
***************
*** 14,112 ****
   */
  class question_edit_match_form extends question_edit_form {
  
!     function get_per_answer_fields(&$mform, $label, $gradeoptions, &$repeatedoptions, &$answersoption) {
!         $repeated = array();
!         $repeated[] =& $mform->createElement('header', 'answerhdr', $label);
!         $repeated[] =& $mform->createElement('editor', 'subquestions', get_string('question', 'quiz'), null, $this->editoroptions);
!         $repeated[] =& $mform->createElement('text', 'subanswers', get_string('answer', 'quiz'), array('size'=>50));
!         $repeatedoptions['subquestions']['type'] = PARAM_RAW;
!         $repeatedoptions['subanswers']['type'] = PARAM_TEXT;
!         $answersoption = 'subquestions';
!         return $repeated;
!     }
! 
!     /**
!      * Add question-type specific form fields.
!      *
!      * @param object $mform the form being built.
!      */
!     function definition_inner(&$mform) {
!         $mform->addElement('advcheckbox', 'shuffleanswers', get_string('shuffle', 'qtype_match'), null, null, array(0,1));
!         $mform->addHelpButton('shuffleanswers', 'shuffle', 'qtype_match');
!         $mform->setDefault('shuffleanswers', 1);
! 
!         $mform->addElement('static', 'answersinstruct', get_string('choices', 'quiz'), get_string('filloutthreeqsandtwoas', 'qtype_match'));
!         $mform->closeHeaderBefore('answersinstruct');
! 
!         $this->add_per_answer_fields($mform, get_string('questionno', 'quiz', '{no}'), 0);
!     }
! 
!     function data_preprocessing($question) {
!         if (isset($question->options)) {
!             $subquestions = $question->options->subquestions;
!             if (count($subquestions)) {
!                 $key = 0;
!                 foreach ($subquestions as $subquestion){
!                     $default_values['subanswers['.$key.']'] = $subquestion->answertext;
! 
!                     $draftid = file_get_submitted_draft_itemid('subquestions['.$key.']');
!                     $default_values['subquestions['.$key.']'] = array();
!                     $default_values['subquestions['.$key.']']['format'] = $subquestion->questiontextformat;
!                     $default_values['subquestions['.$key.']']['text'] = file_prepare_draft_area(
!                         $draftid, // draftid
!                         $this->context->id, // context
                          'qtype_match', // component
                          'subquestion', // filarea
!                         !empty($subquestion->id)?(int)$subquestion->id:null, // itemid
!                         $this->fileoptions, // options
!                         $subquestion->questiontext // text
!                     );
!                     $default_values['subquestions['.$key.']']['itemid'] = $draftid;
! 
!                     $key++;
!                 }
!             }
!             $default_values['shuffleanswers'] =  $question->options->shuffleanswers;
!             $question = (object)((array)$question + $default_values);
!         }
!         return $question;
!     }
! 
!     function qtype() {
!         return 'match';
!     }
! 
!     function validation($data, $files) {
!         $errors = parent::validation($data, $files);
!         $answers = $data['subanswers'];
!         $questions = $data['subquestions'];
!         $questioncount = 0;
!         $answercount = 0;
!         foreach ($questions as $key => $question){
!             $trimmedquestion = trim($question['text']);
!             $trimmedanswer = trim($answers[$key]);
!             if ($trimmedquestion != ''){
!                 $questioncount++;
!             }
!             if ($trimmedanswer != '' || $trimmedquestion != ''){
!                 $answercount++;
!             }
!             if ($trimmedquestion != '' && $trimmedanswer == ''){
!                 $errors['subanswers['.$key.']'] = get_string('nomatchinganswerforq', 'qtype_match', $trimmedquestion);
!             }
!         }
!         $numberqanda = new stdClass;
!         $numberqanda->q = 2;
!         $numberqanda->a = 3;
!         if ($questioncount < 1){
!             $errors['subquestions[0]'] = get_string('notenoughqsandas', 'qtype_match', $numberqanda);
!         }
!         if ($questioncount < 2){
!             $errors['subquestions[1]'] = get_string('notenoughqsandas', 'qtype_match', $numberqanda);
!         }
!         if ($answercount < 3){
!             $errors['subanswers[2]'] = get_string('notenoughqsandas', 'qtype_match', $numberqanda);
!         }
!         return $errors;
!     }
  }
--- 14,112 ----
   */
  class question_edit_match_form extends question_edit_form {
  
! 	function get_per_answer_fields(&$mform, $label, $gradeoptions, &$repeatedoptions, &$answersoption) {
! 		$repeated = array();
! 		$repeated[] =& $mform->createElement('header', 'answerhdr', $label);
! 		$repeated[] =& $mform->createElement('editor', 'subquestions', get_string('question', 'quiz'), null, $this->editoroptions);
! 		$repeated[] =& $mform->createElement('text', 'subanswers', get_string('answer', 'quiz'), array('size'=>50));
! 		$repeatedoptions['subquestions']['type'] = PARAM_RAW;
! 		$repeatedoptions['subanswers']['type'] = PARAM_TEXT;
! 		$answersoption = 'subquestions';
! 		return $repeated;
! 	}
! 
! 	/**
! 	 * Add question-type specific form fields.
! 	 *
! 	 * @param object $mform the form being built.
! 	 */
! 	function definition_inner(&$mform) {
! 		$mform->addElement('advcheckbox', 'shuffleanswers', get_string('shuffle', 'qtype_match'), null, null, array(0,1));
! 		$mform->addHelpButton('shuffleanswers', 'shuffle', 'qtype_match');
! 		$mform->setDefault('shuffleanswers', 1);
! 
! 		$mform->addElement('static', 'answersinstruct', get_string('choices', 'quiz'), get_string('filloutthreeqsandtwoas', 'qtype_match'));
! 		$mform->closeHeaderBefore('answersinstruct');
! 
! 		$this->add_per_answer_fields($mform, get_string('questionno', 'quiz', '{no}'), 0);
! 	}
! 
! 	function data_preprocessing($question) {
! 		if (isset($question->options)) {
! 			$subquestions = $question->options->subquestions;
! 			if (count($subquestions)) {
! 				$key = 0;
! 				foreach ($subquestions as $subquestion){
! 					$default_values['subanswers['.$key.']'] = $subquestion->answertext;
! 
! 					$draftid = file_get_submitted_draft_itemid('subquestions['.$key.']');
! 					$default_values['subquestions['.$key.']'] = array();
! 					$default_values['subquestions['.$key.']']['format'] = $subquestion->questiontextformat;
! 					$default_values['subquestions['.$key.']']['text'] = file_prepare_draft_area(
! 					$draftid, // draftid
! 					$this->context->id, // context
                          'qtype_match', // component
                          'subquestion', // filarea
! 					!empty($subquestion->id)?(int)$subquestion->id:null, // itemid
! 					$this->fileoptions, // options
! 					$subquestion->questiontext // text
! 					);
! 					$default_values['subquestions['.$key.']']['itemid'] = $draftid;
! 
! 					$key++;
! 				}
! 			}
! 			$default_values['shuffleanswers'] =  $question->options->shuffleanswers;
! 			$question = (object)((array)$question + $default_values);
! 		}
! 		return $question;
! 	}
! 
! 	function qtype() {
! 		return 'match';
! 	}
! 
! 	function validation($data, $files) {
! 		$errors = parent::validation($data, $files);
! 		$answers = $data['subanswers'];
! 		$questions = $data['subquestions'];
! 		$questioncount = 0;
! 		$answercount = 0;
! 		foreach ($questions as $key => $question){
! 			$trimmedquestion = trim($question['text']);
! 			$trimmedanswer = trim($answers[$key]);
! 			if ($trimmedquestion != ''){
! 				$questioncount++;
! 			}
! 			if ($trimmedanswer != '' || $trimmedquestion != ''){
! 				$answercount++;
! 			}
! 			if ($trimmedquestion != '' && $trimmedanswer == ''){
! 				$errors['subanswers['.$key.']'] = get_string('nomatchinganswerforq', 'qtype_match', $trimmedquestion);
! 			}
! 		}
! 		$numberqanda = new stdClass;
! 		$numberqanda->q = 2;
! 		$numberqanda->a = 3;
! 		if ($questioncount < 1){
! 			$errors['subquestions[0]'] = get_string('notenoughqsandas', 'qtype_match', $numberqanda);
! 		}
! 		if ($questioncount < 2){
! 			$errors['subquestions[1]'] = get_string('notenoughqsandas', 'qtype_match', $numberqanda);
! 		}
! 		if ($answercount < 3){
! 			$errors['subanswers[2]'] = get_string('notenoughqsandas', 'qtype_match', $numberqanda);
! 		}
! 		return $errors;
! 	}
  }
diff -crB questionorg/type/match/lib.php questionupd/type/match/lib.php
*** questionorg/type/match/lib.php	2012-04-13 12:31:13.218178283 +0500
--- questionupd/type/match/lib.php	2012-04-13 09:42:57.000000000 +0500
***************
*** 25,31 ****
   * @license   http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
   */
  function qtype_match_pluginfile($course, $cm, $context, $filearea, $args, $forcedownload) {
!     global $DB, $CFG;
!     require_once($CFG->libdir . '/questionlib.php');
!     question_pluginfile($course, $context, 'qtype_match', $filearea, $args, $forcedownload);
  }
--- 25,31 ----
   * @license   http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
   */
  function qtype_match_pluginfile($course, $cm, $context, $filearea, $args, $forcedownload) {
! 	global $DB, $CFG;
! 	require_once($CFG->libdir . '/questionlib.php');
! 	question_pluginfile($course, $context, 'qtype_match', $filearea, $args, $forcedownload);
  }
diff -crB questionorg/type/match/questiontype.php questionupd/type/match/questiontype.php
*** questionorg/type/match/questiontype.php	2012-04-13 12:31:13.212178284 +0500
--- questionupd/type/match/questiontype.php	2012-04-13 09:42:57.000000000 +0500
***************
*** 26,544 ****
   */
  class question_match_qtype extends default_questiontype {
  
!     function name() {
!         return 'match';
!     }
! 
!     function get_question_options(&$question) {
!         global $DB;
!         $question->options = $DB->get_record('question_match', array('question' => $question->id));
!         $question->options->subquestions = $DB->get_records('question_match_sub', array('question' => $question->id), 'id ASC');
!         return true;
!     }
! 
!     function save_question_options($question) {
!         global $DB;
!         $context = $question->context;
!         $result = new stdClass;
! 
!         $oldsubquestions = $DB->get_records('question_match_sub',
!                 array('question' => $question->id), 'id ASC');
! 
!         // $subquestions will be an array with subquestion ids
!         $subquestions = array();
! 
!         // Insert all the new question+answer pairs
!         foreach ($question->subquestions as $key => $questiontext) {
!             if ($questiontext['text'] == '' && trim($question->subanswers[$key]) == '') {
!                 continue;
!             }
!             if ($questiontext['text'] != '' && trim($question->subanswers[$key]) == '') {
!                 $result->notice = get_string('nomatchinganswer', 'quiz', $questiontext);
!             }
! 
!             // Update an existing subquestion if possible.
!             $subquestion = array_shift($oldsubquestions);
!             if (!$subquestion) {
!                 $subquestion = new stdClass;
!                 // Determine a unique random code
!                 $subquestion->code = rand(1, 999999999);
!                 while ($DB->record_exists('question_match_sub', array('code' => $subquestion->code, 'question' => $question->id))) {
!                     $subquestion->code = rand(1, 999999999);
!                 }
!                 $subquestion->question = $question->id;
!                 $subquestion->questiontext = '';
!                 $subquestion->answertext = '';
!                 $subquestion->id = $DB->insert_record('question_match_sub', $subquestion);
!             }
! 
!             $subquestion->questiontext = $this->import_or_save_files($questiontext,
!                     $context, 'qtype_match', 'subquestion', $subquestion->id);
!             $subquestion->questiontextformat = $questiontext['format'];
!             $subquestion->answertext = trim($question->subanswers[$key]);
! 
!             $DB->update_record('question_match_sub', $subquestion);
! 
!             $subquestions[] = $subquestion->id;
!         }
! 
!         // Delete old subquestions records
!         $fs = get_file_storage();
!         foreach($oldsubquestions as $oldsub) {
!             $fs->delete_area_files($context->id, 'qtype_match', 'subquestion', $oldsub->id);
!             $DB->delete_records('question_match_sub', array('id' => $oldsub->id));
!         }
! 
!         if ($options = $DB->get_record('question_match', array('question' => $question->id))) {
!             $options->subquestions = implode(',', $subquestions);
!             $options->shuffleanswers = $question->shuffleanswers;
!             $DB->update_record('question_match', $options);
!         } else {
!             unset($options);
!             $options->question = $question->id;
!             $options->subquestions = implode(',', $subquestions);
!             $options->shuffleanswers = $question->shuffleanswers;
!             $DB->insert_record('question_match', $options);
!         }
! 
!         if (!empty($result->notice)) {
!             return $result;
!         }
! 
!         if (count($subquestions) < 3) {
!             $result->notice = get_string('notenoughanswers', 'quiz', 3);
!             return $result;
!         }
! 
!         return true;
!     }
! 
!     function delete_question($questionid, $contextid) {
!         global $DB;
!         $DB->delete_records('question_match', array('question' => $questionid));
!         $DB->delete_records('question_match_sub', array('question' => $questionid));
! 
!         parent::delete_question($questionid, $contextid);
!     }
! 
!     function create_session_and_responses(&$question, &$state, $cmoptions, $attempt) {
!         global $DB, $OUTPUT;
!         if (!$state->options->subquestions = $DB->get_records('question_match_sub', array('question' => $question->id), 'id ASC')) {
!             echo $OUTPUT->notification('Error: Missing subquestions!');
!             return false;
!         }
! 
!         foreach ($state->options->subquestions as $key => $subquestion) {
!             // This seems rather over complicated, but it is useful for the
!             // randomsamatch questiontype, which can then inherit the print
!             // and grading functions. This way it is possible to define multiple
!             // answers per question, each with different marks and feedback.
!             $answer = new stdClass();
!             $answer->id       = $subquestion->code;
!             $answer->answer   = $subquestion->answertext;
!             $answer->fraction = 1.0;
!             $state->options->subquestions[$key]->options->answers[$subquestion->code] = clone($answer);
! 
!             $state->responses[$key] = '';
!         }
! 
!         // Shuffle the answers if required
!         if ($cmoptions->shuffleanswers and $question->options->shuffleanswers) {
!            $state->options->subquestions = swapshuffle_assoc($state->options->subquestions);
!         }
! 
!         return true;
!     }
! 
!     function restore_session_and_responses(&$question, &$state) {
!         global $DB, $OUTPUT;
!         static $subquestions = array();
!         if (!isset($subquestions[$question->id])){
!             if (!$subquestions[$question->id] = $DB->get_records('question_match_sub', array('question' => $question->id), 'id ASC')) {
!                echo $OUTPUT->notification('Error: Missing subquestions!');
!                return false;
!             }
!         }
! 
!         // The serialized format for matching questions is a comma separated
!         // list of question answer pairs (e.g. 1-1,2-3,3-2), where the ids of
!         // both refer to the id in the table question_match_sub.
!         $responses = explode(',', $state->responses['']);
!         $responses = array_map(create_function('$val', 'return explode("-", $val);'), $responses);
! 
!         // Restore the previous responses and place the questions into the state options
!         $state->responses = array();
!         $state->options->subquestions = array();
!         foreach ($responses as $response) {
!             $state->responses[$response[0]] = $response[1];
!             $state->options->subquestions[$response[0]] = clone($subquestions[$question->id][$response[0]]);
!         }
! 
!         foreach ($state->options->subquestions as $key => $subquestion) {
!             // This seems rather over complicated, but it is useful for the
!             // randomsamatch questiontype, which can then inherit the print
!             // and grading functions. This way it is possible to define multiple
!             // answers per question, each with different marks and feedback.
!             $answer = new stdClass();
!             $answer->id       = $subquestion->code;
!             $answer->answer   = $subquestion->answertext;
!             $answer->fraction = 1.0;
!             $state->options->subquestions[$key]->options->answers[$subquestion->code] = clone($answer);
!         }
! 
!         return true;
!     }
! 
!     function save_session_and_responses(&$question, &$state) {
!         global $DB;
!          $subquestions = &$state->options->subquestions;
! 
!         // Prepare an array to help when disambiguating equal answers.
!         $answertexts = array();
!         foreach ($subquestions as $subquestion) {
!             $ans = reset($subquestion->options->answers);
!             $answertexts[$ans->id] = $ans->answer;
!         }
! 
!         // Serialize responses
!         $responses = array();
!         foreach ($subquestions as $key => $subquestion) {
!             $response = 0;
!             if ($subquestion->questiontext !== '' && !is_null($subquestion->questiontext)) {
!                 if ($state->responses[$key]) {
!                     $response = $state->responses[$key];
!                     if (!array_key_exists($response, $subquestion->options->answers)) {
!                         // If student's answer did not match by id, but there may be
!                         // two answers with the same text, but different ids,
!                         // so we need to try matching the answer text.
!                         $expected_answer = reset($subquestion->options->answers);
!                         if ($answertexts[$response] == $expected_answer->answer) {
!                             $response = $expected_answer->id;
!                             $state->responses[$key] = $response;
!                         }
!                     }
!                 }
!             }
!             $responses[] = $key.'-'.$response;
!         }
!         $responses = implode(',', $responses);
! 
!         // Set the legacy answer field
!         $DB->set_field('question_states', 'answer', $responses, array('id' => $state->id));
!         return true;
!     }
! 
!     function get_correct_responses(&$question, &$state) {
!         $responses = array();
!         foreach ($state->options->subquestions as $sub) {
!             foreach ($sub->options->answers as $answer) {
!                 if (1 == $answer->fraction && $sub->questiontext != '' && !is_null($sub->questiontext)) {
!                     $responses[$sub->id] = $answer->id;
!                 }
!             }
!         }
!         return empty($responses) ? null : $responses;
!     }
! 
!     function print_question_formulation_and_controls(&$question, &$state, $cmoptions, $options) {
!         global $CFG, $OUTPUT;
!         $context        = $this->get_context_by_category_id($question->category);
!         $subquestions   = $state->options->subquestions;
!         $correctanswers = $this->get_correct_responses($question, $state);
!         $nameprefix     = $question->name_prefix;
!         $answers        = array(); // Answer choices formatted ready for output.
!         $allanswers     = array(); // This and the next used to detect identical answers
!         $answerids      = array(); // and adjust ids.
!         $responses      = &$state->responses;
! 
!         // Prepare a list of answers, removing duplicates.
!         foreach ($subquestions as $subquestion) {
!             foreach ($subquestion->options->answers as $ans) {
!                 $allanswers[$ans->id] = $ans->answer;
!                 if (!in_array($ans->answer, $answers)) {
!                     $answers[$ans->id] = strip_tags(format_string($ans->answer, false));
!                     $answerids[$ans->answer] = $ans->id;
!                 }
!             }
!         }
! 
!         // Fix up the ids of any responses that point the the eliminated duplicates.
!         foreach ($responses as $subquestionid => $ignored) {
!             if ($responses[$subquestionid]) {
!                 $responses[$subquestionid] = $answerids[$allanswers[$responses[$subquestionid]]];
!             }
!         }
!         foreach ($correctanswers as $subquestionid => $ignored) {
!             $correctanswers[$subquestionid] = $answerids[$allanswers[$correctanswers[$subquestionid]]];
!         }
! 
!         // Shuffle the answers
!         $answers = draw_rand_array($answers, count($answers));
! 
!         // Print formulation
!         $questiontext = $this->format_text($question->questiontext,
!                 $question->questiontextformat, $cmoptions);
! 
!         // Print the input controls
!         foreach ($subquestions as $key => $subquestion) {
!             if ($subquestion->questiontext !== '' && !is_null($subquestion->questiontext)) {
!                 // Subquestion text:
!                 $a = new stdClass;
!                 $text = quiz_rewrite_question_urls($subquestion->questiontext, 'pluginfile.php', $context->id, 'qtype_match', 'subquestion', array($state->attempt, $state->question), $subquestion->id);
!                 $a->text = $this->format_text($text, $subquestion->questiontextformat, $cmoptions);
! 
!                 // Drop-down list:
!                 $menuname = $nameprefix.$subquestion->id;
!                 $response = isset($state->responses[$subquestion->id])
!                             ? $state->responses[$subquestion->id] : '0';
! 
!                 $a->class = ' ';
!                 $a->feedbackimg = ' ';
! 
!                 if ($options->readonly and $options->correct_responses) {
!                     if (isset($correctanswers[$subquestion->id])
!                             and ($correctanswers[$subquestion->id] == $response)) {
!                         $correctresponse = 1;
!                     } else {
!                         $correctresponse = 0;
!                     }
! 
!                     if ($options->feedback && $response) {
!                         $a->class = question_get_feedback_class($correctresponse);
!                         $a->feedbackimg = question_get_feedback_image($correctresponse);
!                     }
!                 }
! 
!                 $attributes = array();
!                 $attributes['disabled'] = $options->readonly ? 'disabled' : null;
!                 $a->control = html_writer::select($answers, $menuname, $response, array(''=>'choosedots'), $attributes);
! 
!                 // Neither the editing interface or the database allow to provide
!                 // fedback for this question type.
!                 // However (as was pointed out in bug bug 3294) the randomsamatch
!                 // type which reuses this method can have feedback defined for
!                 // the wrapped shortanswer questions.
!                 //if ($options->feedback
!                 // && !empty($subquestion->options->answers[$responses[$key]]->feedback)) {
!                 //    print_comment($subquestion->options->answers[$responses[$key]]->feedback);
!                 //}
! 
!                 $anss[] = $a;
!             }
!         }
!         include("$CFG->dirroot/question/type/match/display.html");
!     }
! 
!     function grade_responses(&$question, &$state, $cmoptions) {
!         $subquestions = &$state->options->subquestions;
!         $responses    = &$state->responses;
! 
!         // Prepare an array to help when disambiguating equal answers.
!         $answertexts = array();
!         foreach ($subquestions as $subquestion) {
!             $ans = reset($subquestion->options->answers);
!             $answertexts[$ans->id] = $ans->answer;
!         }
! 
!         // Add up the grades from each subquestion.
!         $sumgrade = 0;
!         $totalgrade = 0;
!         foreach ($subquestions as $key => $sub) {
!             if ($sub->questiontext !== '' && !is_null($sub->questiontext)) {
!                 $totalgrade += 1;
!                 $response = $responses[$key];
!                 if ($response && !array_key_exists($response, $sub->options->answers)) {
!                     // If studen's answer did not match by id, but there may be
!                     // two answers with the same text, but different ids,
!                     // so we need to try matching the answer text.
!                     $expected_answer = reset($sub->options->answers);
!                     if ($answertexts[$response] == $expected_answer->answer) {
!                         $response = $expected_answer->id;
!                     }
!                 }
!                 if (array_key_exists($response, $sub->options->answers)) {
!                     $sumgrade += $sub->options->answers[$response]->fraction;
!                 }
!             }
!         }
! 
!         $state->raw_grade = $sumgrade/$totalgrade;
!         if (empty($state->raw_grade)) {
!             $state->raw_grade = 0;
!         }
! 
!         // Make sure we don't assign negative or too high marks
!         $state->raw_grade = min(max((float) $state->raw_grade,
!                             0.0), 1.0) * $question->maxgrade;
!         $state->penalty = $question->penalty * $question->maxgrade;
! 
!         // mark the state as graded
!         $state->event = ($state->event ==  QUESTION_EVENTCLOSE) ? QUESTION_EVENTCLOSEANDGRADE : QUESTION_EVENTGRADE;
! 
!         return true;
!     }
! 
!     function compare_responses($question, $state, $teststate) {
!         foreach ($state->responses as $i=>$sr) {
!             if (empty($teststate->responses[$i])) {
!                 if (!empty($state->responses[$i])) {
!                     return false;
!                 }
!             } else if ($state->responses[$i] != $teststate->responses[$i]) {
!                 return false;
!             }
!         }
!         return true;
!     }
! 
!     // ULPGC ecastro for stats report
!     function get_all_responses($question, $state) {
!         $answers = array();
!         if (is_array($question->options->subquestions)) {
!             foreach ($question->options->subquestions as $aid => $answer) {
!                 if ($answer->questiontext !== '' && !is_null($answer->questiontext)) {
!                     $r = new stdClass;
!                     $r->answer = $answer->questiontext . ": " . $answer->answertext;
!                     $r->credit = 1;
!                     $answers[$aid] = $r;
!                 }
!             }
!         }
!         $result = new stdClass;
!         $result->id = $question->id;
!         $result->responses = $answers;
!         return $result;
!     }
! 
!     function get_possible_responses(&$question) {
!         $answers = array();
!         if (is_array($question->options->subquestions)) {
!             foreach ($question->options->subquestions as $subqid => $answer) {
!                 if ($answer->questiontext) {
!                     $r = new stdClass;
!                     $r->answer = $answer->questiontext . ": " . $answer->answertext;
!                     $r->credit = 1;
!                     $answers[$subqid] = array($answer->id =>$r);
!                 }
!             }
!         }
!         return $answers;
!     }
! 
!     // ULPGC ecastro
!     function get_actual_response($question, $state) {
!         $subquestions = &$state->options->subquestions;
!         $responses    = &$state->responses;
!         $results=array();
!         foreach ($responses as $ind => $code) {
!             foreach ($subquestions as $key => $sub) {
!                 if (isset($sub->options->answers[$code])) {
!                     $results[$ind] =  $subquestions[$ind]->questiontext . ": " . $sub->options->answers[$code]->answer;
!                 }
!             }
!         }
!         return $results;
!     }
! 
!    function get_actual_response_details($question, $state) {
!         $responses = $this->get_actual_response($question, $state);
!         $teacherresponses = $this->get_possible_responses($question, $state);
!         //only one response
!         $responsedetails =array();
!         foreach ($responses as $tsubqid => $response){
!             $responsedetail = new stdClass();
!             $responsedetail->subqid = $tsubqid;
!             $responsedetail->response = $response;
!             foreach ($teacherresponses[$tsubqid] as $aid => $tresponse){
!                 if ($tresponse->answer == $response){
!                     $responsedetail->aid = $aid;
!                     break;
!                 }
!             }
!             if (isset($responsedetail->aid)){
!                 $responsedetail->credit = $teacherresponses[$tsubqid][$aid]->credit;
!             } else {
!                 $responsedetail->aid = 0;
!                 $responsedetail->credit = 0;
!             }
!             $responsedetails[] = $responsedetail;
!         }
!         return $responsedetails;
!     }
! 
! 
!     /**
!      * @param object $question
!      * @return mixed either a integer score out of 1 that the average random
!      * guess by a student might give or an empty string which means will not
!      * calculate.
!      */
!     function get_random_guess_score($question) {
!         return 1 / count($question->options->subquestions);
!     }
! 
!     /**
!      * Runs all the code required to set up and save an essay question for testing purposes.
!      * Alternate DB table prefix may be used to facilitate data deletion.
!      */
!     function generate_test($name, $courseid = null) {
!         global $DB;
!         list($form, $question) = parent::generate_test($name, $courseid);
!         $form->shuffleanswers = 1;
!         $form->noanswers = 3;
!         $form->subquestions = array('cat', 'dog', 'cow');
!         $form->subanswers = array('feline', 'canine', 'bovine');
! 
!         if ($courseid) {
!             $course = $DB->get_record('course', array('id' => $courseid));
!         }
! 
!         return $this->save_question($question, $form);
!     }
! 
!     function move_files($questionid, $oldcontextid, $newcontextid) {
!         global $DB;
!         $fs = get_file_storage();
! 
!         parent::move_files($questionid, $oldcontextid, $newcontextid);
! 
!         $subquestionids = $DB->get_records_menu('question_match_sub',
!                 array('question' => $questionid), 'id', 'id,1');
!         foreach ($subquestionids as $subquestionid => $notused) {
!             $fs->move_area_files_to_new_context($oldcontextid,
!                     $newcontextid, 'qtype_match', 'subquestion', $subquestionid);
!         }
!     }
! 
!     protected function delete_files($questionid, $contextid) {
!         global $DB;
!         $fs = get_file_storage();
! 
!         parent::delete_files($questionid, $contextid);
! 
!         $subquestionids = $DB->get_records_menu('question_match_sub',
!                 array('question' => $questionid), 'id', 'id,1');
!         foreach ($subquestionids as $subquestionid => $notused) {
!             $fs->delete_area_files($contextid, 'qtype_match', 'subquestion', $subquestionid);
!         }
!     }
! 
!     function check_file_access($question, $state, $options, $contextid, $component,
!             $filearea, $args) {
! 
!         $itemid = reset($args);
!         if ($filearea == 'subquestion') {
!             // itemid is sub question id
!             if (!array_key_exists($itemid, $question->options->subquestions)) {
!                 return false;
!             }
! 
!             return true;
!         } else {
!             return parent::check_file_access($question, $state, $options, $contextid, $component,
!                     $filearea, $args);
!         }
!     }
  }
  //// END OF CLASS ////
  
--- 26,548 ----
   */
  class question_match_qtype extends default_questiontype {
  
! 	function name() {
! 		return 'match';
! 	}
! 
! 	function get_question_options(&$question) {
! 		global $DB;
! 		$question->options = $DB->get_record('question_match', array('question' => $question->id));
! 		$question->options->subquestions = $DB->get_records('question_match_sub', array('question' => $question->id), 'id ASC');
! 		return true;
! 	}
! 
! 	function save_question_options($question) {
! 		global $DB;
! 		$context = $question->context;
! 		$result = new stdClass;
! 
! 		$oldsubquestions = $DB->get_records('question_match_sub',
! 		array('question' => $question->id), 'id ASC');
! 
! 		// $subquestions will be an array with subquestion ids
! 		$subquestions = array();
! 
! 		// Insert all the new question+answer pairs
! 		foreach ($question->subquestions as $key => $questiontext) {
! 			if ($questiontext['text'] == '' && trim($question->subanswers[$key]) == '') {
! 				continue;
! 			}
! 			if ($questiontext['text'] != '' && trim($question->subanswers[$key]) == '') {
! 				$result->notice = get_string('nomatchinganswer', 'quiz', $questiontext);
! 			}
! 
! 			// Update an existing subquestion if possible.
! 			$subquestion = array_shift($oldsubquestions);
! 			if (!$subquestion) {
! 				$subquestion = new stdClass;
! 				// Determine a unique random code
! 				$subquestion->code = rand(1, 999999999);
! 				while ($DB->record_exists('question_match_sub', array('code' => $subquestion->code, 'question' => $question->id))) {
! 					$subquestion->code = rand(1, 999999999);
! 				}
! 				$subquestion->question = $question->id;
! 				$subquestion->questiontext = '';
! 				$subquestion->answertext = '';
! 				$subquestion->id = $DB->insert_record('question_match_sub', $subquestion);
! 			}
! 
! 			$subquestion->questiontext = $this->import_or_save_files($questiontext,
! 			$context, 'qtype_match', 'subquestion', $subquestion->id);
! 			$subquestion->questiontextformat = $questiontext['format'];
! 			$subquestion->answertext = trim($question->subanswers[$key]);
! 
! 			$DB->update_record('question_match_sub', $subquestion);
! 
! 			$subquestions[] = $subquestion->id;
! 		}
! 
! 		// Delete old subquestions records
! 		$fs = get_file_storage();
! 		foreach($oldsubquestions as $oldsub) {
! 			$fs->delete_area_files($context->id, 'qtype_match', 'subquestion', $oldsub->id);
! 			$DB->delete_records('question_match_sub', array('id' => $oldsub->id));
! 		}
! 
! 		if ($options = $DB->get_record('question_match', array('question' => $question->id))) {
! 			$options->subquestions = implode(',', $subquestions);
! 			$options->shuffleanswers = $question->shuffleanswers;
! 			$DB->update_record('question_match', $options);
! 		} else {
! 			unset($options);
! 			$options->question = $question->id;
! 			$options->subquestions = implode(',', $subquestions);
! 			$options->shuffleanswers = $question->shuffleanswers;
! 			$DB->insert_record('question_match', $options);
! 		}
! 
! 		if (!empty($result->notice)) {
! 			return $result;
! 		}
! 
! 		if (count($subquestions) < 3) {
! 			$result->notice = get_string('notenoughanswers', 'quiz', 3);
! 			return $result;
! 		}
! 
! 		return true;
! 	}
! 
! 	function delete_question($questionid, $contextid) {
! 		global $DB;
! 		$DB->delete_records('question_match', array('question' => $questionid));
! 		$DB->delete_records('question_match_sub', array('question' => $questionid));
! 
! 		parent::delete_question($questionid, $contextid);
! 	}
! 
! 	function create_session_and_responses(&$question, &$state, $cmoptions, $attempt) {
! 		global $DB, $OUTPUT;
! 		if (!$state->options->subquestions = $DB->get_records('question_match_sub', array('question' => $question->id), 'id ASC')) {
! 			echo $OUTPUT->notification('Error: Missing subquestions!');
! 			return false;
! 		}
! 
! 		foreach ($state->options->subquestions as $key => $subquestion) {
! 			// This seems rather over complicated, but it is useful for the
! 			// randomsamatch questiontype, which can then inherit the print
! 			// and grading functions. This way it is possible to define multiple
! 			// answers per question, each with different marks and feedback.
! 			$answer = new stdClass();
! 			$answer->id       = $subquestion->code;
! 			$answer->answer   = $subquestion->answertext;
! 			$answer->fraction = 1.0;
! 			$state->options->subquestions[$key]->options->answers[$subquestion->code] = clone($answer);
! 
! 			$state->responses[$key] = '';
! 		}
! 
! 		// Shuffle the answers if required
! 		if ($cmoptions->shuffleanswers and $question->options->shuffleanswers) {
! 			$state->options->subquestions = swapshuffle_assoc($state->options->subquestions);
! 		}
! 
! 		return true;
! 	}
! 
! 	function restore_session_and_responses(&$question, &$state) {
! 		global $DB, $OUTPUT;
! 		static $subquestions = array();
! 		if (!isset($subquestions[$question->id])){
! 			if (!$subquestions[$question->id] = $DB->get_records('question_match_sub', array('question' => $question->id), 'id ASC')) {
! 				echo $OUTPUT->notification('Error: Missing subquestions!');
! 				return false;
! 			}
! 		}
! 
! 		// The serialized format for matching questions is a comma separated
! 		// list of question answer pairs (e.g. 1-1,2-3,3-2), where the ids of
! 		// both refer to the id in the table question_match_sub.
! 		$responses = explode(',', $state->responses['']);
! 		$responses = array_map(create_function('$val', 'return explode("-", $val);'), $responses);
! 
! 		// Restore the previous responses and place the questions into the state options
! 		$state->responses = array();
! 		$state->options->subquestions = array();
! 		foreach ($responses as $response) {
! 			$state->responses[$response[0]] = $response[1];
! 			$state->options->subquestions[$response[0]] = clone($subquestions[$question->id][$response[0]]);
! 		}
! 
! 		foreach ($state->options->subquestions as $key => $subquestion) {
! 			// This seems rather over complicated, but it is useful for the
! 			// randomsamatch questiontype, which can then inherit the print
! 			// and grading functions. This way it is possible to define multiple
! 			// answers per question, each with different marks and feedback.
! 			$answer = new stdClass();
! 			$answer->id       = $subquestion->code;
! 			$answer->answer   = $subquestion->answertext;
! 			$answer->fraction = 1.0;
! 			$state->options->subquestions[$key]->options->answers[$subquestion->code] = clone($answer);
! 		}
! 
! 		return true;
! 	}
! 
! 	function save_session_and_responses(&$question, &$state) {
! 		global $DB;
! 		$subquestions = &$state->options->subquestions;
! 
! 		// Prepare an array to help when disambiguating equal answers.
! 		$answertexts = array();
! 		foreach ($subquestions as $subquestion) {
! 			$ans = reset($subquestion->options->answers);
! 			$answertexts[$ans->id] = $ans->answer;
! 		}
! 
! 		// Serialize responses
! 		$responses = array();
! 		foreach ($subquestions as $key => $subquestion) {
! 			$response = 0;
! 			if ($subquestion->questiontext !== '' && !is_null($subquestion->questiontext)) {
! 				if ($state->responses[$key]) {
! 					$response = $state->responses[$key];
! 					if (!array_key_exists($response, $subquestion->options->answers)) {
! 						// If student's answer did not match by id, but there may be
! 						// two answers with the same text, but different ids,
! 						// so we need to try matching the answer text.
! 						$expected_answer = reset($subquestion->options->answers);
! 						if ($answertexts[$response] == $expected_answer->answer) {
! 							$response = $expected_answer->id;
! 							$state->responses[$key] = $response;
! 						}
! 					}
! 				}
! 			}
! 			$responses[] = $key.'-'.$response;
! 		}
! 		$responses = implode(',', $responses);
! 
! 		// Set the legacy answer field
! 		$DB->set_field('question_states', 'answer', $responses, array('id' => $state->id));
! 		return true;
! 	}
! 
! 	function get_correct_responses(&$question, &$state) {
! 		$responses = array();
! 		foreach ($state->options->subquestions as $sub) {
! 			foreach ($sub->options->answers as $answer) {
! 				if (1 == $answer->fraction && $sub->questiontext != '' && !is_null($sub->questiontext)) {
! 					$responses[$sub->id] = $answer->id;
! 				}
! 			}
! 		}
! 		return empty($responses) ? null : $responses;
! 	}
! 
! 	function print_question_formulation_and_controls(&$question, &$state, $cmoptions, $options) {
! 		global $CFG, $OUTPUT;
! 		$context        = $this->get_context_by_category_id($question->category);
! 		$subquestions   = $state->options->subquestions;
! 		$correctanswers = $this->get_correct_responses($question, $state);
! 		$nameprefix     = $question->name_prefix;
! 		$answers        = array(); // Answer choices formatted ready for output.
! 		$allanswers     = array(); // This and the next used to detect identical answers
! 		$answerids      = array(); // and adjust ids.
! 		$responses      = &$state->responses;
! 
! 		// Prepare a list of answers, removing duplicates.
! 		foreach ($subquestions as $subquestion) {
! 			foreach ($subquestion->options->answers as $ans) {
! 				$allanswers[$ans->id] = $ans->answer;
! 				if (!in_array($ans->answer, $answers)) {
! 					$answers[$ans->id] = strip_tags(format_string($ans->answer, false));
! 					$answerids[$ans->answer] = $ans->id;
! 					//echo $ans->answer;
! 				}
! 			}
! 		}
! 
! 		// Fix up the ids of any responses that point the the eliminated duplicates.
! 		foreach ($responses as $subquestionid => $ignored) {
! 			if ($responses[$subquestionid]) {
! 				$responses[$subquestionid] = $answerids[$allanswers[$responses[$subquestionid]]];
! 			}
! 		}
! 		foreach ($correctanswers as $subquestionid => $ignored) {
! 			$correctanswers[$subquestionid] = $answerids[$allanswers[$correctanswers[$subquestionid]]];
! 		}
! 
! 		// Shuffle the answers
! 		$answers = draw_rand_array($answers, count($answers));
! 
! 		// Print formulation
! 		$questiontext = $this->format_text($question->questiontext,
! 		$question->questiontextformat, $cmoptions);
! 		$_SESSION['content'].="&nbsp;&nbsp;&nbsp;&nbsp;".$questiontext."</b></td></tr>";
! 
! 		// Print the input controls
! 		foreach ($subquestions as $key => $subquestion) {
! 			if ($subquestion->questiontext !== '' && !is_null($subquestion->questiontext)) {
! 				// Subquestion text:
! 				$a = new stdClass;
! 				$text = quiz_rewrite_question_urls($subquestion->questiontext, 'pluginfile.php', $context->id, 'qtype_match', 'subquestion', array($state->attempt, $state->question), $subquestion->id);
! 				$a->text = $this->format_text($text, $subquestion->questiontextformat, $cmoptions);
! 
! 				// Drop-down list:
! 				$menuname = $nameprefix.$subquestion->id;
! 				$response = isset($state->responses[$subquestion->id])
! 				? $state->responses[$subquestion->id] : '0';
! 
! 				$a->class = ' ';
! 				$a->feedbackimg = ' ';
! 
! 				if ($options->readonly and $options->correct_responses) {
! 					if (isset($correctanswers[$subquestion->id])
! 					and ($correctanswers[$subquestion->id] == $response)) {
! 						$correctresponse = 1;
! 					} else {
! 						$correctresponse = 0;
! 					}
! 
! 					if ($options->feedback && $response) {
! 						$a->class = question_get_feedback_class($correctresponse);
! 						$a->feedbackimg = question_get_feedback_image($correctresponse);
! 					}
! 				}
! 
! 				$attributes = array();
! 				$attributes['disabled'] = $options->readonly ? 'disabled' : null;
! 				$a->control = html_writer::select($answers, $menuname, $response, array(''=>'choosedots'), $attributes);
! 				$_SESSION['content'].="<tr><td><table><tr><td>".$subquestion->questiontext."</td><td>".$answers[$response]."</td></tr></table></td></tr>";
! 
! 
! 				// Neither the editing interface or the database allow to provide
! 				// fedback for this question type.
! 				// However (as was pointed out in bug bug 3294) the randomsamatch
! 				// type which reuses this method can have feedback defined for
! 				// the wrapped shortanswer questions.
! 				//if ($options->feedback
! 				// && !empty($subquestion->options->answers[$responses[$key]]->feedback)) {
! 				//    print_comment($subquestion->options->answers[$responses[$key]]->feedback);
! 				//}
! 
! 				$anss[] = $a;
! 			}
! 		}
! 		include("$CFG->dirroot/question/type/match/display.html");
! 	}
! 
! 	function grade_responses(&$question, &$state, $cmoptions) {
! 		$subquestions = &$state->options->subquestions;
! 		$responses    = &$state->responses;
! 
! 		// Prepare an array to help when disambiguating equal answers.
! 		$answertexts = array();
! 		foreach ($subquestions as $subquestion) {
! 			$ans = reset($subquestion->options->answers);
! 			$answertexts[$ans->id] = $ans->answer;
! 		}
! 
! 		// Add up the grades from each subquestion.
! 		$sumgrade = 0;
! 		$totalgrade = 0;
! 		foreach ($subquestions as $key => $sub) {
! 			if ($sub->questiontext !== '' && !is_null($sub->questiontext)) {
! 				$totalgrade += 1;
! 				$response = $responses[$key];
! 				if ($response && !array_key_exists($response, $sub->options->answers)) {
! 					// If studen's answer did not match by id, but there may be
! 					// two answers with the same text, but different ids,
! 					// so we need to try matching the answer text.
! 					$expected_answer = reset($sub->options->answers);
! 					if ($answertexts[$response] == $expected_answer->answer) {
! 						$response = $expected_answer->id;
! 					}
! 				}
! 				if (array_key_exists($response, $sub->options->answers)) {
! 					$sumgrade += $sub->options->answers[$response]->fraction;
! 				}
! 			}
! 		}
! 
! 		$state->raw_grade = $sumgrade/$totalgrade;
! 		if (empty($state->raw_grade)) {
! 			$state->raw_grade = 0;
! 		}
! 
! 		// Make sure we don't assign negative or too high marks
! 		$state->raw_grade = min(max((float) $state->raw_grade,
! 		0.0), 1.0) * $question->maxgrade;
! 		$state->penalty = $question->penalty * $question->maxgrade;
! 
! 		// mark the state as graded
! 		$state->event = ($state->event ==  QUESTION_EVENTCLOSE) ? QUESTION_EVENTCLOSEANDGRADE : QUESTION_EVENTGRADE;
! 
! 		return true;
! 	}
! 
! 	function compare_responses($question, $state, $teststate) {
! 		foreach ($state->responses as $i=>$sr) {
! 			if (empty($teststate->responses[$i])) {
! 				if (!empty($state->responses[$i])) {
! 					return false;
! 				}
! 			} else if ($state->responses[$i] != $teststate->responses[$i]) {
! 				return false;
! 			}
! 		}
! 		return true;
! 	}
! 
! 	// ULPGC ecastro for stats report
! 	function get_all_responses($question, $state) {
! 		$answers = array();
! 		if (is_array($question->options->subquestions)) {
! 			foreach ($question->options->subquestions as $aid => $answer) {
! 				if ($answer->questiontext !== '' && !is_null($answer->questiontext)) {
! 					$r = new stdClass;
! 					$r->answer = $answer->questiontext . ": " . $answer->answertext;
! 					$r->credit = 1;
! 					$answers[$aid] = $r;
! 				}
! 			}
! 		}
! 		$result = new stdClass;
! 		$result->id = $question->id;
! 		$result->responses = $answers;
! 		return $result;
! 	}
! 
! 	function get_possible_responses(&$question) {
! 		$answers = array();
! 		if (is_array($question->options->subquestions)) {
! 			foreach ($question->options->subquestions as $subqid => $answer) {
! 				if ($answer->questiontext) {
! 					$r = new stdClass;
! 					$r->answer = $answer->questiontext . ": " . $answer->answertext;
! 					$r->credit = 1;
! 					$answers[$subqid] = array($answer->id =>$r);
! 				}
! 			}
! 		}
! 		return $answers;
! 	}
! 
! 	// ULPGC ecastro
! 	function get_actual_response($question, $state) {
! 		$subquestions = &$state->options->subquestions;
! 		$responses    = &$state->responses;
! 		$results=array();
! 		foreach ($responses as $ind => $code) {
! 			foreach ($subquestions as $key => $sub) {
! 				if (isset($sub->options->answers[$code])) {
! 					$results[$ind] =  $subquestions[$ind]->questiontext . ": " . $sub->options->answers[$code]->answer;
! 				}
! 			}
! 		}
! 		return $results;
! 	}
! 
! 	function get_actual_response_details($question, $state) {
! 		$responses = $this->get_actual_response($question, $state);
! 		$teacherresponses = $this->get_possible_responses($question, $state);
! 		//only one response
! 		$responsedetails =array();
! 		foreach ($responses as $tsubqid => $response){
! 			$responsedetail = new stdClass();
! 			$responsedetail->subqid = $tsubqid;
! 			$responsedetail->response = $response;
! 			foreach ($teacherresponses[$tsubqid] as $aid => $tresponse){
! 				if ($tresponse->answer == $response){
! 					$responsedetail->aid = $aid;
! 					break;
! 				}
! 			}
! 			if (isset($responsedetail->aid)){
! 				$responsedetail->credit = $teacherresponses[$tsubqid][$aid]->credit;
! 			} else {
! 				$responsedetail->aid = 0;
! 				$responsedetail->credit = 0;
! 			}
! 			$responsedetails[] = $responsedetail;
! 		}
! 		return $responsedetails;
! 	}
! 
! 
! 	/**
! 	 * @param object $question
! 	 * @return mixed either a integer score out of 1 that the average random
! 	 * guess by a student might give or an empty string which means will not
! 	 * calculate.
! 	 */
! 	function get_random_guess_score($question) {
! 		return 1 / count($question->options->subquestions);
! 	}
! 
! 	/**
! 	 * Runs all the code required to set up and save an essay question for testing purposes.
! 	 * Alternate DB table prefix may be used to facilitate data deletion.
! 	 */
! 	function generate_test($name, $courseid = null) {
! 		global $DB;
! 		list($form, $question) = parent::generate_test($name, $courseid);
! 		$form->shuffleanswers = 1;
! 		$form->noanswers = 3;
! 		$form->subquestions = array('cat', 'dog', 'cow');
! 		$form->subanswers = array('feline', 'canine', 'bovine');
! 
! 		if ($courseid) {
! 			$course = $DB->get_record('course', array('id' => $courseid));
! 		}
! 
! 		return $this->save_question($question, $form);
! 	}
! 
! 	function move_files($questionid, $oldcontextid, $newcontextid) {
! 		global $DB;
! 		$fs = get_file_storage();
! 
! 		parent::move_files($questionid, $oldcontextid, $newcontextid);
! 
! 		$subquestionids = $DB->get_records_menu('question_match_sub',
! 		array('question' => $questionid), 'id', 'id,1');
! 		foreach ($subquestionids as $subquestionid => $notused) {
! 			$fs->move_area_files_to_new_context($oldcontextid,
! 			$newcontextid, 'qtype_match', 'subquestion', $subquestionid);
! 		}
! 	}
! 
! 	protected function delete_files($questionid, $contextid) {
! 		global $DB;
! 		$fs = get_file_storage();
! 
! 		parent::delete_files($questionid, $contextid);
! 
! 		$subquestionids = $DB->get_records_menu('question_match_sub',
! 		array('question' => $questionid), 'id', 'id,1');
! 		foreach ($subquestionids as $subquestionid => $notused) {
! 			$fs->delete_area_files($contextid, 'qtype_match', 'subquestion', $subquestionid);
! 		}
! 	}
! 
! 	function check_file_access($question, $state, $options, $contextid, $component,
! 	$filearea, $args) {
! 
! 		$itemid = reset($args);
! 		if ($filearea == 'subquestion') {
! 			// itemid is sub question id
! 			if (!array_key_exists($itemid, $question->options->subquestions)) {
! 				return false;
! 			}
! 
! 			return true;
! 		} else {
! 			return parent::check_file_access($question, $state, $options, $contextid, $component,
! 			$filearea, $args);
! 		}
! 	}
  }
  //// END OF CLASS ////
  
diff -crB questionorg/type/missingtype/display.html questionupd/type/missingtype/display.html
*** questionorg/type/missingtype/display.html	2012-04-13 12:31:12.095178264 +0500
--- questionupd/type/missingtype/display.html	2012-04-13 09:42:57.000000000 +0500
***************
*** 1,20 ****
  <div class="qtext">
!   <?php echo $questiontext; ?>
  </div>
  
  <?php if ($anss) { ?>
!   <div class="ablock clearfix">
!     <div class="prompt">
!       <?php print_string('answers', 'quiz'); ?>
!     </div>
!     <table class="answer">
!       <?php $row = 1; foreach ($anss as $answer) { ?>
!         <tr class="<?php echo 'r'.$row = $row ? 0 : 1; ?>">
!           <td class="c1 text">
!             <?php echo $answer->text; ?>
!           </td>
!         </tr>
!       <?php } ?>
!     </table>
!   </div>
  <?php } ?>
--- 1,19 ----
  <div class="qtext">
! 	<?php echo $questiontext; ?>
  </div>
  
  <?php if ($anss) { ?>
! <div class="ablock clearfix">
! 	<div class="prompt">
! 		<?php print_string('answers', 'quiz'); ?>
! 	</div>
! 	<table class="answer">
! 		<?php $row = 1; foreach ($anss as $answer) { ?>
! 		<tr class="<?php echo 'r'.$row = $row ? 0 : 1; ?>">
! 			<td class="c1 text">
! 				<?php echo $answer->text; ?></td>
! 		</tr>
! 		<?php } ?>
! 	</table>
! </div>
  <?php } ?>
diff -crB questionorg/type/missingtype/edit_missingtype_form.php questionupd/type/missingtype/edit_missingtype_form.php
*** questionorg/type/missingtype/edit_missingtype_form.php	2012-04-13 12:31:12.193178270 +0500
--- questionupd/type/missingtype/edit_missingtype_form.php	2012-04-13 09:42:57.000000000 +0500
***************
*** 13,88 ****
   * missingtype editing form definition.
   */
  class question_edit_missingtype_form extends question_edit_form {
!     /**
!      * Add question-type specific form fields.
!      *
!      * @param object $mform the form being built.
!      */
!     function definition_inner(&$mform) {
!         $creategrades = get_grade_options();
!         $this->add_per_answer_fields($mform, get_string('choiceno', 'qtype_multichoice', '{no}'),
!                 $creategrades->gradeoptionsfull);
!     }
! 
!     function set_data($question) {
!         if (isset($question->options)){
!             $answers = $question->options->answers;
!             $default_values = array();
!             if (is_array($answers) && count($answers)) {
!                 $key = 0;
!                 foreach ($answers as $answer){
!                     $default_values['answer['.$key.']'] = $answer->answer;
!                     $default_values['fraction['.$key.']'] = $answer->fraction;
!                     $default_values['feedback['.$key.']'] = $answer->feedback;
!                     $key++;
!                 }
!             }
!             $question = (object)((array)$question + $default_values);
!         }
!         parent::set_data($question);
!     }
! 
!     function qtype() {
!         return 'missingtype';
!     }
! 
!     function validation($data, $files) {
!         $errors = parent::validation($data, $files);
!         $answers = $data['answer'];
!         $answercount = 0;
! 
!         $totalfraction = 0;
!         $maxfraction = -1;
! 
!         foreach ($answers as $key => $answer){
!             //check no of choices
!             $trimmedanswer = trim($answer);
!             if (!empty($trimmedanswer)){
!                 $answercount++;
!             }
!             //check grades
!             if ($answer != '') {
!                 if ($data['fraction'][$key] > 0) {
!                     $totalfraction += $data['fraction'][$key];
!                 }
!                 if ($data['fraction'][$key] > $maxfraction) {
!                     $maxfraction = $data['fraction'][$key];
!                 }
!             }
!         }
! 
!         if ($answercount==0){
!             $errors['answer[0]'] = get_string('notenoughanswers', 'qtype_multichoice', 1);
!         }
! 
! 
!         $totalfraction = round($totalfraction, 2);
!         if ($totalfraction != 1) {
!             $totalfraction = $totalfraction * 100;
!             $errors['fraction[0]'] = get_string('errfractionsaddwrong', 'qtype_multichoice', $totalfraction);
!         }
  
!         return $errors;
!     }
  }
  
--- 13,88 ----
   * missingtype editing form definition.
   */
  class question_edit_missingtype_form extends question_edit_form {
! 	/**
! 	 * Add question-type specific form fields.
! 	 *
! 	 * @param object $mform the form being built.
! 	 */
! 	function definition_inner(&$mform) {
! 		$creategrades = get_grade_options();
! 		$this->add_per_answer_fields($mform, get_string('choiceno', 'qtype_multichoice', '{no}'),
! 		$creategrades->gradeoptionsfull);
! 	}
! 
! 	function set_data($question) {
! 		if (isset($question->options)){
! 			$answers = $question->options->answers;
! 			$default_values = array();
! 			if (is_array($answers) && count($answers)) {
! 				$key = 0;
! 				foreach ($answers as $answer){
! 					$default_values['answer['.$key.']'] = $answer->answer;
! 					$default_values['fraction['.$key.']'] = $answer->fraction;
! 					$default_values['feedback['.$key.']'] = $answer->feedback;
! 					$key++;
! 				}
! 			}
! 			$question = (object)((array)$question + $default_values);
! 		}
! 		parent::set_data($question);
! 	}
! 
! 	function qtype() {
! 		return 'missingtype';
! 	}
! 
! 	function validation($data, $files) {
! 		$errors = parent::validation($data, $files);
! 		$answers = $data['answer'];
! 		$answercount = 0;
! 
! 		$totalfraction = 0;
! 		$maxfraction = -1;
! 
! 		foreach ($answers as $key => $answer){
! 			//check no of choices
! 			$trimmedanswer = trim($answer);
! 			if (!empty($trimmedanswer)){
! 				$answercount++;
! 			}
! 			//check grades
! 			if ($answer != '') {
! 				if ($data['fraction'][$key] > 0) {
! 					$totalfraction += $data['fraction'][$key];
! 				}
! 				if ($data['fraction'][$key] > $maxfraction) {
! 					$maxfraction = $data['fraction'][$key];
! 				}
! 			}
! 		}
! 
! 		if ($answercount==0){
! 			$errors['answer[0]'] = get_string('notenoughanswers', 'qtype_multichoice', 1);
! 		}
! 
! 
! 		$totalfraction = round($totalfraction, 2);
! 		if ($totalfraction != 1) {
! 			$totalfraction = $totalfraction * 100;
! 			$errors['fraction[0]'] = get_string('errfractionsaddwrong', 'qtype_multichoice', $totalfraction);
! 		}
  
! 		return $errors;
! 	}
  }
  
diff -crB questionorg/type/missingtype/questiontype.php questionupd/type/missingtype/questiontype.php
*** questionorg/type/missingtype/questiontype.php	2012-04-13 12:31:12.194178272 +0500
--- questionupd/type/missingtype/questiontype.php	2012-04-13 09:42:57.000000000 +0500
***************
*** 17,72 ****
   */
  class question_missingtype_qtype extends default_questiontype {
  
!     function name() {
!         return 'missingtype';
!     }
! 
!     function menu_name() {
!         return false;
!     }
! 
!     function is_usable_by_random() {
!         return false;
!     }
! 
!     function print_question_formulation_and_controls(&$question, &$state, $cmoptions, $options) {
!         global $CFG;
! 
!         $answers = &$question->options->answers;
! 
!         $formatoptions = new stdClass;
!         $formatoptions->noclean = true;
!         $formatoptions->para = false;
! 
!         // Print formulation
!         $questiontext = format_text($question->questiontext,
!                          $question->questiontextformat,
!                          $formatoptions, $cmoptions->course);
! 
!         // Print each answer in a separate row if there are any
!         $anss = array();
!         if ($answers) {
!             foreach ($answers as $answer) {
!                 $a = new stdClass;
!                 $a->text = format_text($answer->answer, $answer->answerformat, $formatoptions, $cmoptions->course);
! 
!                 $anss[] = clone($a);
!             }
!         }
!         include("$CFG->dirroot/question/type/missingtype/display.html");
!     }
! 
!     function grade_responses(&$question, &$state, $cmoptions) {
!         return true;
!     }
! 
!     function display_question_editing_page(&$mform, $question, $wizardnow){
!         global $OUTPUT;
!         echo $OUTPUT->heading(get_string('warningmissingtype', 'qtype_missingtype'));
  
!         $mform->display();
  
!     }
  }
  //// END OF CLASS ////
  
--- 17,72 ----
   */
  class question_missingtype_qtype extends default_questiontype {
  
! 	function name() {
! 		return 'missingtype';
! 	}
! 
! 	function menu_name() {
! 		return false;
! 	}
! 
! 	function is_usable_by_random() {
! 		return false;
! 	}
! 
! 	function print_question_formulation_and_controls(&$question, &$state, $cmoptions, $options) {
! 		global $CFG;
! 
! 		$answers = &$question->options->answers;
! 
! 		$formatoptions = new stdClass;
! 		$formatoptions->noclean = true;
! 		$formatoptions->para = false;
! 
! 		// Print formulation
! 		$questiontext = format_text($question->questiontext,
! 		$question->questiontextformat,
! 		$formatoptions, $cmoptions->course);
! 
! 		// Print each answer in a separate row if there are any
! 		$anss = array();
! 		if ($answers) {
! 			foreach ($answers as $answer) {
! 				$a = new stdClass;
! 				$a->text = format_text($answer->answer, $answer->answerformat, $formatoptions, $cmoptions->course);
! 
! 				$anss[] = clone($a);
! 			}
! 		}
! 		include("$CFG->dirroot/question/type/missingtype/display.html");
! 	}
! 
! 	function grade_responses(&$question, &$state, $cmoptions) {
! 		return true;
! 	}
! 
! 	function display_question_editing_page(&$mform, $question, $wizardnow){
! 		global $OUTPUT;
! 		echo $OUTPUT->heading(get_string('warningmissingtype', 'qtype_missingtype'));
  
! 		$mform->display();
  
! 	}
  }
  //// END OF CLASS ////
  
diff -crB questionorg/type/multianswer/backup/moodle2/backup_qtype_multianswer_plugin.class.php questionupd/type/multianswer/backup/moodle2/backup_qtype_multianswer_plugin.class.php
*** questionorg/type/multianswer/backup/moodle2/backup_qtype_multianswer_plugin.class.php	2012-04-13 12:31:12.293178271 +0500
--- questionupd/type/multianswer/backup/moodle2/backup_qtype_multianswer_plugin.class.php	2012-04-13 09:42:57.000000000 +0500
***************
*** 28,63 ****
   */
  class backup_qtype_multianswer_plugin extends backup_qtype_plugin {
  
!     /**
!      * Returns the qtype information to attach to question element
!      */
!     protected function define_question_plugin_structure() {
! 
!         // Define the virtual plugin element with the condition to fulfill
!         $plugin = $this->get_plugin_element(null, '../../qtype', 'multianswer');
! 
!         // Create one standard named plugin element (the visible container)
!         $pluginwrapper = new backup_nested_element($this->get_recommended_name());
! 
!         // connect the visible container ASAP
!         $plugin->add_child($pluginwrapper);
! 
!         // This qtype uses standard question_answers, add them here
!         // to the tree before any other information that will use them
!         $this->add_question_question_answers($pluginwrapper);
  
!         // Now create the qtype own structures
!         $multianswer = new backup_nested_element('multianswer', array('id'), array(
              'question', 'sequence'));
  
!         // Now the own qtype tree
!         $pluginwrapper->add_child($multianswer);
  
!         // set source to populate the data
!         $multianswer->set_source_table('question_multianswer', array('question' => backup::VAR_PARENTID));
  
!         // don't need to annotate ids nor files
  
!         return $plugin;
!     }
  }
--- 28,63 ----
   */
  class backup_qtype_multianswer_plugin extends backup_qtype_plugin {
  
! 	/**
! 	 * Returns the qtype information to attach to question element
! 	 */
! 	protected function define_question_plugin_structure() {
! 
! 		// Define the virtual plugin element with the condition to fulfill
! 		$plugin = $this->get_plugin_element(null, '../../qtype', 'multianswer');
! 
! 		// Create one standard named plugin element (the visible container)
! 		$pluginwrapper = new backup_nested_element($this->get_recommended_name());
! 
! 		// connect the visible container ASAP
! 		$plugin->add_child($pluginwrapper);
! 
! 		// This qtype uses standard question_answers, add them here
! 		// to the tree before any other information that will use them
! 		$this->add_question_question_answers($pluginwrapper);
  
! 		// Now create the qtype own structures
! 		$multianswer = new backup_nested_element('multianswer', array('id'), array(
              'question', 'sequence'));
  
! 		// Now the own qtype tree
! 		$pluginwrapper->add_child($multianswer);
  
! 		// set source to populate the data
! 		$multianswer->set_source_table('question_multianswer', array('question' => backup::VAR_PARENTID));
  
! 		// don't need to annotate ids nor files
  
! 		return $plugin;
! 	}
  }
diff -crB questionorg/type/multianswer/backup/moodle2/restore_qtype_multianswer_plugin.class.php questionupd/type/multianswer/backup/moodle2/restore_qtype_multianswer_plugin.class.php
*** questionorg/type/multianswer/backup/moodle2/restore_qtype_multianswer_plugin.class.php	2012-04-13 12:31:12.295178269 +0500
--- questionupd/type/multianswer/backup/moodle2/restore_qtype_multianswer_plugin.class.php	2012-04-13 09:42:57.000000000 +0500
***************
*** 30,148 ****
   */
  class restore_qtype_multianswer_plugin extends restore_qtype_plugin {
  
!     /**
!      * Returns the paths to be handled by the plugin at question level
!      */
!     protected function define_question_plugin_structure() {
! 
!         $paths = array();
! 
!         // This qtype uses question_answers, add them
!         $this->add_question_question_answers($paths);
! 
!         // Add own qtype stuff
!         $elename = 'multianswer';
!         $elepath = $this->get_pathfor('/multianswer'); // we used get_recommended_name() so this works
!         $paths[] = new restore_path_element($elename, $elepath);
! 
! 
!         return $paths; // And we return the interesting paths
!     }
! 
!     /**
!      * Process the qtype/multianswer element
!      */
!     public function process_multianswer($data) {
!         global $DB;
! 
!         $data = (object)$data;
!         $oldid = $data->id;
! 
!         // Detect if the question is created or mapped
!         $oldquestionid   = $this->get_old_parentid('question');
!         $newquestionid   = $this->get_new_parentid('question');
!         $questioncreated = $this->get_mappingid('question_created', $oldquestionid) ? true : false;
! 
!         // If the question has been created by restore, we need to create its question_multianswer too
!         if ($questioncreated) {
!             // Adjust some columns
!             $data->question = $newquestionid;
!             // Note: multianswer->sequence is a list of question->id values. We aren't
!             // recoding them here (because some questions can be missing yet). Instead
!             // we'll perform the recode in the {@link after_execute} method of the plugin
!             // that gets executed once all questions have been created
!             // Insert record
!             $newitemid = $DB->insert_record('question_multianswer', $data);
!             // Create mapping (need it for after_execute recode of sequence)
!             $this->set_mapping('question_multianswer', $oldid, $newitemid);
!         } else {
!             // Nothing to remap if the question already existed
!         }
!     }
! 
!     /**
!      * This method is executed once the whole restore_structure_step
!      * this step is part of ({@link restore_create_categories_and_questions})
!      * has ended processing the whole xml structure. Its name is:
!      * "after_execute_" + connectionpoint ("question")
!      *
!      * For multianswer qtype we use it to restore the sequence column,
!      * containing one list of question ids
!      */
!     public function after_execute_question() {
!         global $DB;
!         // Now that all the questions have been restored, let's process
!         // the created question_multianswer sequences (list of question ids)
!         $rs = $DB->get_recordset_sql("SELECT qma.id, qma.sequence
                                          FROM {question_multianswer} qma
                                          JOIN {backup_ids_temp} bi ON bi.newitemid = qma.question
                                         WHERE bi.backupid = ?
                                           AND bi.itemname = 'question_created'", array($this->get_restoreid()));
!         foreach ($rs as $rec) {
!             $sequencearr = explode(',', $rec->sequence);
!             foreach ($sequencearr as $key => $question) {
!                 $sequencearr[$key] = $this->get_mappingid('question', $question);
!             }
!             $sequence = implode(',', $sequencearr);
!             $DB->set_field('question_multianswer', 'sequence', $sequence, array('id' => $rec->id));
!         }
!         $rs->close();
!     }
! 
!     /**
!      * Given one question_states record, return the answer
!      * recoded pointing to all the restored stuff for multianswer questions
!      *
!      * answer is one comma separated list of hypen separated pairs
!      * containing sequence (pointing to questions sequence in question_multianswer)
!      * and mixed answers. We'll delegate
!      * the recoding of answers to the proper qtype
!      */
!     public function recode_state_answer($state) {
!         global $DB;
!         $answer = $state->answer;
!         $resultarr = array();
!         // Get sequence of questions
!         $sequence = $DB->get_field('question_multianswer', 'sequence', array('question' => $state->question));
!         $sequencearr = explode(',', $sequence);
!         // Let's process each pair
!         foreach (explode(',', $answer) as $pair) {
!             $pairarr = explode('-', $pair);
!             $sequenceid = $pairarr[0];
!             $subanswer = $pairarr[1];
!             // Calculate the questionid based on sequenceid
!             // Note it is already one *new* questionid that doesn't need mapping
!             $questionid = $sequencearr[$sequenceid-1];
!             // Fetch qtype of the question (needed for delegation)
!             $questionqtype = $DB->get_field('question', 'qtype', array('id' => $questionid));
!             // Delegate subanswer recode to proper qtype, faking one question_states record
!             $substate = new stdClass();
!             $substate->question = $questionid;
!             $substate->answer = $subanswer;
!             $newanswer = $this->step->restore_recode_answer($substate, $questionqtype);
!             $resultarr[] = implode('-', array($sequenceid, $newanswer));
!         }
!         return implode(',', $resultarr);
!     }
  
  }
--- 30,148 ----
   */
  class restore_qtype_multianswer_plugin extends restore_qtype_plugin {
  
! 	/**
! 	 * Returns the paths to be handled by the plugin at question level
! 	 */
! 	protected function define_question_plugin_structure() {
! 
! 		$paths = array();
! 
! 		// This qtype uses question_answers, add them
! 		$this->add_question_question_answers($paths);
! 
! 		// Add own qtype stuff
! 		$elename = 'multianswer';
! 		$elepath = $this->get_pathfor('/multianswer'); // we used get_recommended_name() so this works
! 		$paths[] = new restore_path_element($elename, $elepath);
! 
! 
! 		return $paths; // And we return the interesting paths
! 	}
! 
! 	/**
! 	 * Process the qtype/multianswer element
! 	 */
! 	public function process_multianswer($data) {
! 		global $DB;
! 
! 		$data = (object)$data;
! 		$oldid = $data->id;
! 
! 		// Detect if the question is created or mapped
! 		$oldquestionid   = $this->get_old_parentid('question');
! 		$newquestionid   = $this->get_new_parentid('question');
! 		$questioncreated = $this->get_mappingid('question_created', $oldquestionid) ? true : false;
! 
! 		// If the question has been created by restore, we need to create its question_multianswer too
! 		if ($questioncreated) {
! 			// Adjust some columns
! 			$data->question = $newquestionid;
! 			// Note: multianswer->sequence is a list of question->id values. We aren't
! 			// recoding them here (because some questions can be missing yet). Instead
! 			// we'll perform the recode in the {@link after_execute} method of the plugin
! 			// that gets executed once all questions have been created
! 			// Insert record
! 			$newitemid = $DB->insert_record('question_multianswer', $data);
! 			// Create mapping (need it for after_execute recode of sequence)
! 			$this->set_mapping('question_multianswer', $oldid, $newitemid);
! 		} else {
! 			// Nothing to remap if the question already existed
! 		}
! 	}
! 
! 	/**
! 	 * This method is executed once the whole restore_structure_step
! 	 * this step is part of ({@link restore_create_categories_and_questions})
! 	 * has ended processing the whole xml structure. Its name is:
! 	 * "after_execute_" + connectionpoint ("question")
! 	 *
! 	 * For multianswer qtype we use it to restore the sequence column,
! 	 * containing one list of question ids
! 	 */
! 	public function after_execute_question() {
! 		global $DB;
! 		// Now that all the questions have been restored, let's process
! 		// the created question_multianswer sequences (list of question ids)
! 		$rs = $DB->get_recordset_sql("SELECT qma.id, qma.sequence
                                          FROM {question_multianswer} qma
                                          JOIN {backup_ids_temp} bi ON bi.newitemid = qma.question
                                         WHERE bi.backupid = ?
                                           AND bi.itemname = 'question_created'", array($this->get_restoreid()));
! 		foreach ($rs as $rec) {
! 			$sequencearr = explode(',', $rec->sequence);
! 			foreach ($sequencearr as $key => $question) {
! 				$sequencearr[$key] = $this->get_mappingid('question', $question);
! 			}
! 			$sequence = implode(',', $sequencearr);
! 			$DB->set_field('question_multianswer', 'sequence', $sequence, array('id' => $rec->id));
! 		}
! 		$rs->close();
! 	}
! 
! 	/**
! 	 * Given one question_states record, return the answer
! 	 * recoded pointing to all the restored stuff for multianswer questions
! 	 *
! 	 * answer is one comma separated list of hypen separated pairs
! 	 * containing sequence (pointing to questions sequence in question_multianswer)
! 	 * and mixed answers. We'll delegate
! 	 * the recoding of answers to the proper qtype
! 	 */
! 	public function recode_state_answer($state) {
! 		global $DB;
! 		$answer = $state->answer;
! 		$resultarr = array();
! 		// Get sequence of questions
! 		$sequence = $DB->get_field('question_multianswer', 'sequence', array('question' => $state->question));
! 		$sequencearr = explode(',', $sequence);
! 		// Let's process each pair
! 		foreach (explode(',', $answer) as $pair) {
! 			$pairarr = explode('-', $pair);
! 			$sequenceid = $pairarr[0];
! 			$subanswer = $pairarr[1];
! 			// Calculate the questionid based on sequenceid
! 			// Note it is already one *new* questionid that doesn't need mapping
! 			$questionid = $sequencearr[$sequenceid-1];
! 			// Fetch qtype of the question (needed for delegation)
! 			$questionqtype = $DB->get_field('question', 'qtype', array('id' => $questionid));
! 			// Delegate subanswer recode to proper qtype, faking one question_states record
! 			$substate = new stdClass();
! 			$substate->question = $questionid;
! 			$substate->answer = $subanswer;
! 			$newanswer = $this->step->restore_recode_answer($substate, $questionqtype);
! 			$resultarr[] = implode('-', array($sequenceid, $newanswer));
! 		}
! 		return implode(',', $resultarr);
! 	}
  
  }
diff -crB questionorg/type/multianswer/db/install.xml questionupd/type/multianswer/db/install.xml
*** questionorg/type/multianswer/db/install.xml	2012-04-13 12:31:12.386178269 +0500
--- questionupd/type/multianswer/db/install.xml	2012-04-13 09:42:57.000000000 +0500
***************
*** 1,16 ****
  <?xml version="1.0" encoding="UTF-8" ?>
! <XMLDB PATH="question/type/multianswer/db" VERSION="20060812" COMMENT="XMLDB file for Moodle question/type/multianswer">
!   <TABLES>
!     <TABLE NAME="question_multianswer" COMMENT="Options for multianswer questions">
!       <FIELDS>
!         <FIELD NAME="id" TYPE="int" LENGTH="10" NOTNULL="true" UNSIGNED="true" SEQUENCE="true" NEXT="question"/>
!         <FIELD NAME="question" TYPE="int" LENGTH="10" NOTNULL="true" UNSIGNED="true" DEFAULT="0" SEQUENCE="false" PREVIOUS="id" NEXT="sequence"/>
!         <FIELD NAME="sequence" TYPE="text" LENGTH="small" NOTNULL="true" SEQUENCE="false" PREVIOUS="question"/>
!       </FIELDS>
!       <KEYS>
!         <KEY NAME="primary" TYPE="primary" FIELDS="id" NEXT="question"/>
!         <KEY NAME="question" TYPE="foreign" FIELDS="question" REFTABLE="question" REFFIELDS="id" PREVIOUS="primary"/>
!       </KEYS>
!     </TABLE>
!   </TABLES>
  </XMLDB>
--- 1,21 ----
  <?xml version="1.0" encoding="UTF-8" ?>
! <XMLDB PATH="question/type/multianswer/db" VERSION="20060812"
! 	COMMENT="XMLDB file for Moodle question/type/multianswer">
! 	<TABLES>
! 		<TABLE NAME="question_multianswer" COMMENT="Options for multianswer questions">
! 			<FIELDS>
! 				<FIELD NAME="id" TYPE="int" LENGTH="10" NOTNULL="true"
! 					UNSIGNED="true" SEQUENCE="true" NEXT="question" />
! 				<FIELD NAME="question" TYPE="int" LENGTH="10" NOTNULL="true"
! 					UNSIGNED="true" DEFAULT="0" SEQUENCE="false" PREVIOUS="id" NEXT="sequence" />
! 				<FIELD NAME="sequence" TYPE="text" LENGTH="small" NOTNULL="true"
! 					SEQUENCE="false" PREVIOUS="question" />
! 			</FIELDS>
! 			<KEYS>
! 				<KEY NAME="primary" TYPE="primary" FIELDS="id" NEXT="question" />
! 				<KEY NAME="question" TYPE="foreign" FIELDS="question" REFTABLE="question"
! 					REFFIELDS="id" PREVIOUS="primary" />
! 			</KEYS>
! 		</TABLE>
! 	</TABLES>
  </XMLDB>
diff -crB questionorg/type/multianswer/db/upgrade.php questionupd/type/multianswer/db/upgrade.php
*** questionorg/type/multianswer/db/upgrade.php	2012-04-13 12:31:12.427178267 +0500
--- questionupd/type/multianswer/db/upgrade.php	2012-04-13 09:42:57.000000000 +0500
***************
*** 21,49 ****
  // before any action that may take longer time to finish.
  
  function xmldb_qtype_multianswer_upgrade($oldversion) {
!     global $CFG, $DB;
  
!     $dbman = $DB->get_manager();
  
!     if ($oldversion < 2008050800) {
!         //hey - no functions here in this file !!!!!!!
  
!         $rs = $DB->get_recordset_sql("SELECT q.id, q.category, qma.sequence
                                          FROM {question} q
                                          JOIN {question_multianswer} qma ON q.id = qma.question");
!         foreach ($rs as $q) {
!             if (!empty($q->sequence)) {
!                 $DB->execute("UPDATE {question}
                                   SET parent = ?, category = ?
                                 WHERE id IN ($q->sequence) AND parent <> 0",
!                              array($q->id, $q->category));
!             }
!         }
!         $rs->close();
! 
!         /// multianswer savepoint reached
!         upgrade_plugin_savepoint(true, 2008050800, 'qtype', 'multianswer');
!     }
  
!     return true;
  }
--- 21,49 ----
  // before any action that may take longer time to finish.
  
  function xmldb_qtype_multianswer_upgrade($oldversion) {
! 	global $CFG, $DB;
  
! 	$dbman = $DB->get_manager();
  
! 	if ($oldversion < 2008050800) {
! 		//hey - no functions here in this file !!!!!!!
  
! 		$rs = $DB->get_recordset_sql("SELECT q.id, q.category, qma.sequence
                                          FROM {question} q
                                          JOIN {question_multianswer} qma ON q.id = qma.question");
! 		foreach ($rs as $q) {
! 			if (!empty($q->sequence)) {
! 				$DB->execute("UPDATE {question}
                                   SET parent = ?, category = ?
                                 WHERE id IN ($q->sequence) AND parent <> 0",
! 				array($q->id, $q->category));
! 			}
! 		}
! 		$rs->close();
! 
! 		/// multianswer savepoint reached
! 		upgrade_plugin_savepoint(true, 2008050800, 'qtype', 'multianswer');
! 	}
  
! 	return true;
  }
diff -crB questionorg/type/multianswer/edit_multianswer_form.php questionupd/type/multianswer/edit_multianswer_form.php
*** questionorg/type/multianswer/edit_multianswer_form.php	2012-04-13 12:31:12.430178274 +0500
--- questionupd/type/multianswer/edit_multianswer_form.php	2012-04-13 09:42:57.000000000 +0500
***************
*** 14,416 ****
   */
  class question_edit_multianswer_form extends question_edit_form {
  
!     //  $questiondisplay will contain the qtype_multianswer_extract_question from the questiontext
!     public $questiondisplay ;
!     //  $savedquestiondisplay will contain the qtype_multianswer_extract_question from the questiontext in database
!     public $savedquestion ;
!     public $savedquestiondisplay ;
!     public $used_in_quiz = false ;
!     public $qtype_change = false ;
!     public $negative_diff = 0 ;
!     public $nb_of_quiz = 0;
!     public $nb_of_attempts = 0;
!     public $confirm = 0 ;
!     public $reload = false ;
! 
!     function question_edit_multianswer_form(&$submiturl, &$question, &$category, &$contexts, $formeditable = true){
!         global $QTYPES, $SESSION, $CFG, $DB;
!         $this->regenerate = true;
!         if  (  "1" == optional_param('reload','', PARAM_INT )) {
!             $this->reload = true ;
!         }else {
!             $this->reload = false ;
!         }
!         // $this->question = $question;
!         $this->used_in_quiz =false;
!         //  echo "<p> question <pre>";print_r($question);echo "</pre></p>";
!         if(isset($question->id) && $question->id != 0 ){
!             $this->savedquestiondisplay =fullclone($question ) ;
!             if ($list = $DB->get_records('quiz_question_instances', array( 'question'=> $question->id))){
!                 foreach($list as $key => $li){
!                     $this->nb_of_quiz ++;
!                     if($att = $DB->get_records('quiz_attempts',array( 'quiz'=> $li->quiz, 'preview'=> '0'))){
!                         $this->nb_of_attempts+= count($att);
!                         $this->used_in_quiz = true;
!                     }
!                 }
!             }
!         }
! 
!         parent::question_edit_form($submiturl, $question, $category, $contexts, $formeditable);
!     }
! 
!     function definition_inner(&$mform) {
!         $mform->addElement('hidden', 'reload', 1);
!    //     $mform->addElement('hidden', 'generalfeedback','');
!         $mform->setType('reload', PARAM_INT);
!         $question_type_names = question_type_menu();
! 
!         // Remove meaningless defaultgrade field.
!         $mform->removeElement('defaultgrade');
!         $this->confirm = optional_param('confirm','0', PARAM_RAW);
! 
!         // display the questions from questiontext;
!         if  (  "" != optional_param('questiontext','', PARAM_RAW)) {
!                 //   echo "<p> optional_param('questiontext' <pre>";print_r(optional_param('questiontext','', PARAM_RAW));echo "</pre></p>";
! 
!             $this->questiondisplay = fullclone(qtype_multianswer_extract_question(optional_param('questiontext','', PARAM_RAW))) ;
! 
!         }else {
!             if(!$this->reload && !empty($this->savedquestiondisplay->id)){
!                 // use database data as this is first pass
!                 // question->id == 0 so no stored datasets
!                 $this->questiondisplay = fullclone($this->savedquestiondisplay);
!                 foreach($this->questiondisplay->options->questions as $subquestion){
!                     if (!empty($subquestion)){
!                         $subquestion->answer = array('');
!                         foreach($subquestion->options->answers as $ans){
!                             $subquestion->answer[]=$ans->answer ;
!                         }
!                         //  $subquestion->answer = fullclone($subquestion->options->answers);
!                     }
!                 }
!             }else {
!                 $this->questiondisplay = "";
!             }
!         }
! 
!         if ( isset($this->savedquestiondisplay->options->questions) && is_array($this->savedquestiondisplay->options->questions) ) {
!             $countsavedsubquestions =0;
!             foreach($this->savedquestiondisplay->options->questions as $subquestion){
!                 if (!empty($subquestion)){
!                     $countsavedsubquestions++;
!                 }
!             }
!         } else {
!             $countsavedsubquestions =0;
!         }
!         if ($this->reload){
!             if ( isset($this->questiondisplay->options->questions) && is_array($this->questiondisplay->options->questions) ) {
!                 $countsubquestions =0;
!                 foreach($this->questiondisplay->options->questions as $subquestion){
!                     if (!empty($subquestion)){
!                         $countsubquestions++;
!                     }
!                 }
!             } else {
!                 $countsubquestions =0;
!             }
!         }else{
!             $countsubquestions =$countsavedsubquestions ;
!         }
!                  //  echo "<p> count subquestion $countsubquestions <pre>";print_r($this->savedquestiondisplay);echo "</pre></p>";
!         //       //     echo "<p> saved question $countsubquestions <pre>";print_r($this->questiondisplay);echo "</pre></p>";
! 
! 
!         $mform->addElement('submit', 'analyzequestion', get_string('decodeverifyquestiontext','qtype_multianswer'));
!         $mform->registerNoSubmitButton('analyzequestion');
!         if ( $this->reload ){
!             $mform->addElement('html', '<div class="ablock clearfix">');
!             $mform->addElement('html', '<div class=" clearfix">');
!             for ($sub =1;$sub <=$countsubquestions ;$sub++) {
! 
!                 $this->editas[$sub] =  'unknown type';
!                 if (isset( $this->questiondisplay->options->questions[$sub]->qtype) ) {
!                     $this->editas[$sub] =  $this->questiondisplay->options->questions[$sub]->qtype ;
!                 } else if (optional_param('sub_'.$sub."_".'qtype', '', PARAM_RAW) != '') {
!                     $this->editas[$sub] = optional_param('sub_'.$sub."_".'qtype', '', PARAM_RAW);
!                 }
!                 $storemess = '';
!                 if(isset($this->savedquestiondisplay->options->questions[$sub]->qtype) &&
!                     $this->savedquestiondisplay->options->questions[$sub]->qtype != $this->questiondisplay->options->questions[$sub]->qtype ){
!                         $this->qtype_change = true ;
!                         $storemess = "<font class=\"error\"> STORED QTYPE ".$question_type_names[$this->savedquestiondisplay->options->questions[$sub]->qtype]."</font >";
!                     }
  
!                 $mform->addElement('header', 'subhdr'.$sub, get_string('questionno', 'quiz',
                      '{#'.$sub.'}').'&nbsp;'.$question_type_names[$this->questiondisplay->options->questions[$sub]->qtype].$storemess);
  
!                 $mform->addElement('static', 'sub_'.$sub."_".'questiontext', get_string('questiondefinition','qtype_multianswer'),array('cols'=>60, 'rows'=>3));
  
!                 if (isset ( $this->questiondisplay->options->questions[$sub]->questiontext)) {
!                     $mform->setDefault('sub_'.$sub."_".'questiontext', $this->questiondisplay->options->questions[$sub]->questiontext['text']);
!                 }
! 
!                 $mform->addElement('static', 'sub_'.$sub."_".'defaultgrade', get_string('defaultgrade', 'quiz'));
!                 $mform->setDefault('sub_'.$sub."_".'defaultgrade',$this->questiondisplay->options->questions[$sub]->defaultgrade);
! 
!                 if ($this->questiondisplay->options->questions[$sub]->qtype =='shortanswer'   ) {
!                     $mform->addElement('static', 'sub_'.$sub."_".'usecase', get_string('casesensitive', 'quiz'));
!                 }
! 
!                 if ($this->questiondisplay->options->questions[$sub]->qtype =='multichoice'   ) {
!                     $mform->addElement('static', 'sub_'.$sub."_".'layout', get_string('layout', 'qtype_multianswer'),array('cols'=>60, 'rows'=>1)) ;//, $gradeoptions);
!                 }
!                 foreach ($this->questiondisplay->options->questions[$sub]->answer as $key =>$ans) {
! 
!                     $mform->addElement('static', 'sub_'.$sub."_".'answer['.$key.']', get_string('answer', 'quiz'), array('cols'=>60, 'rows'=>1));
! 
!                     if ($this->questiondisplay->options->questions[$sub]->qtype =='numerical' && $key == 0 ) {
!                         $mform->addElement('static', 'sub_'.$sub."_".'tolerance['.$key.']', get_string('acceptederror', 'quiz')) ;//, $gradeoptions);
!                     }
! 
!                     $mform->addElement('static', 'sub_'.$sub."_".'fraction['.$key.']', get_string('grade')) ;//, $gradeoptions);
! 
!                     $mform->addElement('static', 'sub_'.$sub."_".'feedback['.$key.']', get_string('feedback', 'quiz'));
!                 }
! 
!             }
!             $mform->addElement('html', '</div>');
!             $this->negative_diff =$countsavedsubquestions - $countsubquestions ;
!             if ( ($this->negative_diff > 0 ) ||$this->qtype_change || ($this->used_in_quiz && $this->negative_diff != 0)){
!                 $mform->addElement('header', 'additemhdr', get_string('warningquestionmodified','qtype_multianswer'));
!             }
!             if($this->negative_diff > 0) {
!                 //$this->used_in_quiz
!                 $mform->addElement('static', 'alert1', "<strong>".get_string('questiondeleted','qtype_multianswer')."</strong>",get_string('questionsless','qtype_multianswer',$this->negative_diff));
!             }
!             if($this->qtype_change ) {
!                 $mform->addElement('static', 'alert1', "<strong>".get_string('questiontypechanged','qtype_multianswer')."</strong>",get_string('questiontypechangedcomment','qtype_multianswer'));
!             }
!             $mform->addElement('html', '</div>');
!         }
!         if( $this->used_in_quiz){
!             if($this->negative_diff < 0) {
!                 $diff = $countsubquestions - $countsavedsubquestions;
!                 $mform->addElement('static', 'alert1', "<strong>".get_string('questionsadded','qtype_multianswer')."</strong>","<strong>".get_string('questionsmore','qtype_multianswer',$diff)."</strong>");
!             }
!             $a = new stdClass ;
!             $a->nb_of_quiz = $this->nb_of_quiz;
!             $a->nb_of_attempts = $this->nb_of_attempts;
!             $mform->addElement('header', 'additemhdr2', get_string('questionusedinquiz','qtype_multianswer',$a));
!             $mform->addElement('static', 'alertas', get_string('youshouldnot','qtype_multianswer'));
!         }
!         if ( ($this->negative_diff > 0 || $this->used_in_quiz && ($this->negative_diff > 0 ||$this->negative_diff < 0 || $this->qtype_change ) ) &&  $this->reload ){
!             $mform->addElement('header', 'additemhdr', get_string('questionsaveasedited', 'qtype_multianswer'));
!             $mform->addElement('checkbox', 'confirm','' ,get_string('confirmquestionsaveasedited', 'qtype_multianswer'));
!             $mform->setDefault('confirm', 0);
!         }else {
!             $mform->addElement('hidden', 'confirm',0);
!         }
! 
!     }
! 
! 
!     function set_data($question) {
!         global $DB;
!         $default_values =array();
!         if (isset($question->id) and $question->id and $question->qtype and $question->questiontext) {
! 
!             foreach ($question->options->questions as $key => $wrapped) {
!                 if(!empty($wrapped)){
!                     // The old way of restoring the definitions is kept to gradually
!                     // update all multianswer questions
!                     if (empty($wrapped->questiontext)) {
!                         $parsableanswerdef = '{' . $wrapped->defaultgrade . ':';
!                         switch ($wrapped->qtype) {
!                         case 'multichoice':
!                             $parsableanswerdef .= 'MULTICHOICE:';
!                             break;
!                         case 'shortanswer':
!                             $parsableanswerdef .= 'SHORTANSWER:';
!                             break;
!                         case 'numerical':
!                             $parsableanswerdef .= 'NUMERICAL:';
!                             break;
!                         default:
!                             print_error('unknownquestiontype', 'question', '', $wrapped->qtype);
!                         }
!                         $separator= '';
!                         foreach ($wrapped->options->answers as $subanswer) {
!                             $parsableanswerdef .= $separator
!                                 . '%' . round(100*$subanswer->fraction) . '%';
!                             $parsableanswerdef .= $subanswer->answer;
!                             if (!empty($wrapped->options->tolerance)) {
!                                 // Special for numerical answers:
!                                 $parsableanswerdef .= ":{$wrapped->options->tolerance}";
!                                 // We only want tolerance for the first alternative, it will
!                                 // be applied to all of the alternatives.
!                                 unset($wrapped->options->tolerance);
!                             }
!                             if ($subanswer->feedback) {
!                                 $parsableanswerdef .= "#$subanswer->feedback";
!                             }
!                             $separator = '~';
!                         }
!                         $parsableanswerdef .= '}';
!                         // Fix the questiontext fields of old questions
!                         $DB->set_field('question', 'questiontext', $parsableanswerdef, array('id' => $wrapped->id));
!                     } else {
!                         $parsableanswerdef = str_replace('&#', '&\#', $wrapped->questiontext);
!                     }
!                     $question->questiontext = str_replace("{#$key}", $parsableanswerdef, $question->questiontext);
!                 }
!             }
!         }
! 
!         // set default to $questiondisplay questions elements
!         if ( $this->reload ){
!             if (isset($this->questiondisplay->options->questions)) {
!                 $subquestions = fullclone($this->questiondisplay->options->questions) ;
!                 if (count($subquestions)) {
!                     $sub =1;
!                     foreach ($subquestions as $subquestion) {
!                         $prefix = 'sub_'.$sub.'_' ;
! 
!                         // validate parameters
!                         $answercount = 0;
!                         $maxgrade = false;
!                         $maxfraction = -1;
!                         if ($subquestion->qtype =='shortanswer'   ) {
!                             switch ($subquestion->usecase) {
!                             case '1':
!                                 $default_values[$prefix.'usecase']= get_string('caseyes', 'quiz');
!                                 break;
!                             case '0':
!                             default :
!                                 $default_values[$prefix.'usecase']= get_string('caseno', 'quiz');
!                             }
!                         }
! 
!                         if ($subquestion->qtype == 'multichoice' ) {
!                             $default_values[$prefix.'layout']  = $subquestion->layout ;
!                             switch ($subquestion->layout) {
!                             case '0':
!                                 $default_values[$prefix.'layout']= get_string('layoutselectinline', 'qtype_multianswer');
!                                 break;
!                             case '1':
!                                 $default_values[$prefix.'layout']= get_string('layoutvertical', 'qtype_multianswer');
!                                 break;
!                             case '2':
!                                 $default_values[$prefix.'layout']= get_string('layouthorizontal', 'qtype_multianswer');
!                                 break;
!                             default:
!                                 $default_values[$prefix.'layout']= get_string('layoutundefined', 'qtype_multianswer');
!                             }
!                         }
!                         foreach ($subquestion->answer as $key=>$answer) {
!                             if ( $subquestion->qtype == 'numerical' && $key == 0 ) {
!                                 $default_values[$prefix.'tolerance['.$key.']']  = $subquestion->tolerance[0] ;
!                             }
!                             $trimmedanswer = trim($answer);
!                             if ($trimmedanswer !== '') {
!                                 $answercount++;
!                                 if ($subquestion->qtype == 'numerical' && !(is_numeric($trimmedanswer) || $trimmedanswer == '*')) {
!                                     $this->_form->setElementError($prefix.'answer['.$key.']' , get_string('answermustbenumberorstar', 'qtype_numerical'));
!                                 }
!                                 if ($subquestion->fraction[$key] == 1) {
!                                     $maxgrade = true;
!                                 }
!                                 if ($subquestion->fraction[$key] > $maxfraction) {
!                                     $maxfraction = $subquestion->fraction[$key] ;
!                                 }
!                             }
! 
!                             $default_values[$prefix.'answer['.$key.']']  = htmlspecialchars ($answer);
!                         }
!                         if ($answercount == 0) {
!                             if ($subquestion->qtype == 'multichoice' ) {
!                                 $this->_form->setElementError($prefix.'answer[0]' ,  get_string('notenoughanswers', 'qtype_multichoice', 2));
!                             } else {
!                                 $this->_form->setElementError($prefix.'answer[0]' , get_string('notenoughanswers', 'quiz', 1));
!                             }
!                         }
!                         if ($maxgrade == false) {
!                             $this->_form->setElementError($prefix.'fraction[0]' ,get_string('fractionsnomax', 'question'));
!                         }
!                         foreach ($subquestion->feedback as $key=>$answer) {
! 
!                             $default_values[$prefix.'feedback['.$key.']']  = htmlspecialchars ($answer['text']);
!                         }
!                         foreach ( $subquestion->fraction as $key=>$answer) {
!                             $default_values[$prefix.'fraction['.$key.']']  = $answer;
!                         }
! 
! 
!                         $sub++;
!                     }
!                 }
!             }
!         }
!         $default_values['alertas']= "<strong>".get_string('questioninquiz','qtype_multianswer')."</strong>";
! 
!         if( $default_values != "")   {
!             $question = (object)((array)$question + $default_values);
!         }
!         parent::set_data($question);
!     }
! 
!     function validation($data, $files) {
!         $errors = parent::validation($data, $files);
! 
!         $questiondisplay = qtype_multianswer_extract_question($data['questiontext']);
! //                   echo "<p> questiondisplay ".$data['questiontext']['text']." <pre>";print_r($questiondisplay);echo "</pre></p>";
! 
!         if (isset($questiondisplay->options->questions)) {
!             $subquestions = fullclone($questiondisplay->options->questions) ;
!             if (count($subquestions)) {
!                 $sub =1;
!                 foreach ($subquestions as $subquestion) {
!                     $prefix = 'sub_'.$sub.'_' ;
!                     $answercount = 0;
!                     $maxgrade = false;
!                     $maxfraction = -1;
!                     if(isset($this->savedquestiondisplay->options->questions[$sub]->qtype) &&
!                         $this->savedquestiondisplay->options->questions[$sub]->qtype != $questiondisplay->options->questions[$sub]->qtype ){
!                             $storemess = " STORED QTYPE ".$question_type_names[$this->savedquestiondisplay->options->questions[$sub]->qtype];
!                         }
!                     foreach ( $subquestion->answer as $key=>$answer) {
!                         $trimmedanswer = trim($answer);
!                         if ($trimmedanswer !== '') {
!                             $answercount++;
!                             if ($subquestion->qtype =='numerical' && !(is_numeric($trimmedanswer) || $trimmedanswer == '*')) {
!                                 $errors[$prefix.'answer['.$key.']']=  get_string('answermustbenumberorstar', 'qtype_numerical');
!                             }
!                             if ($subquestion->fraction[$key] == 1) {
!                                 $maxgrade = true;
!                             }
!                             if ($subquestion->fraction[$key] > $maxfraction) {
!                                 $maxfraction = $subquestion->fraction[$key] ;
!                             }
!                         }
!                     }
!                     if ($answercount==0) {
!                         if ( $subquestion->qtype =='multichoice' ) {
!                             $errors[$prefix.'answer[0]']= get_string('notenoughanswers', 'qtype_multichoice', 2);
!                         }else {
!                             $errors[$prefix.'answer[0]'] = get_string('notenoughanswers', 'quiz', 1);
!                         }
!                     }
!                     if ($maxgrade == false) {
!                         $errors[$prefix.'fraction[0]']=get_string('fractionsnomax', 'question');
!                     }
!                     $sub++;
!                 }
!             } else {
!                 $errors['questiontext']=get_string('questionsmissing', 'qtype_multianswer');
!             }
!         }
!         // $question = qtype_multianswer_extract_question($data['questiontext']);
!         //  if (isset $question->options->questions
!         if (( $this->negative_diff > 0 || $this->used_in_quiz && ($this->negative_diff > 0 ||$this->negative_diff < 0 || $this->qtype_change ))&& $this->confirm == 0 ){
!             $errors['confirm']=get_string('confirmsave', 'qtype_multianswer',$this->negative_diff);
!         }
! 
! 
!         return $errors;
!     }
! 
!     function qtype() {
!         return 'multianswer';
!     }
  }
--- 14,416 ----
   */
  class question_edit_multianswer_form extends question_edit_form {
  
! 	//  $questiondisplay will contain the qtype_multianswer_extract_question from the questiontext
! 	public $questiondisplay ;
! 	//  $savedquestiondisplay will contain the qtype_multianswer_extract_question from the questiontext in database
! 	public $savedquestion ;
! 	public $savedquestiondisplay ;
! 	public $used_in_quiz = false ;
! 	public $qtype_change = false ;
! 	public $negative_diff = 0 ;
! 	public $nb_of_quiz = 0;
! 	public $nb_of_attempts = 0;
! 	public $confirm = 0 ;
! 	public $reload = false ;
! 
! 	function question_edit_multianswer_form(&$submiturl, &$question, &$category, &$contexts, $formeditable = true){
! 		global $QTYPES, $SESSION, $CFG, $DB;
! 		$this->regenerate = true;
! 		if  (  "1" == optional_param('reload','', PARAM_INT )) {
! 			$this->reload = true ;
! 		}else {
! 			$this->reload = false ;
! 		}
! 		// $this->question = $question;
! 		$this->used_in_quiz =false;
! 		//  echo "<p> question <pre>";print_r($question);echo "</pre></p>";
! 		if(isset($question->id) && $question->id != 0 ){
! 			$this->savedquestiondisplay =fullclone($question ) ;
! 			if ($list = $DB->get_records('quiz_question_instances', array( 'question'=> $question->id))){
! 				foreach($list as $key => $li){
! 					$this->nb_of_quiz ++;
! 					if($att = $DB->get_records('quiz_attempts',array( 'quiz'=> $li->quiz, 'preview'=> '0'))){
! 						$this->nb_of_attempts+= count($att);
! 						$this->used_in_quiz = true;
! 					}
! 				}
! 			}
! 		}
! 
! 		parent::question_edit_form($submiturl, $question, $category, $contexts, $formeditable);
! 	}
! 
! 	function definition_inner(&$mform) {
! 		$mform->addElement('hidden', 'reload', 1);
! 		//     $mform->addElement('hidden', 'generalfeedback','');
! 		$mform->setType('reload', PARAM_INT);
! 		$question_type_names = question_type_menu();
! 
! 		// Remove meaningless defaultgrade field.
! 		$mform->removeElement('defaultgrade');
! 		$this->confirm = optional_param('confirm','0', PARAM_RAW);
! 
! 		// display the questions from questiontext;
! 		if  (  "" != optional_param('questiontext','', PARAM_RAW)) {
! 			//   echo "<p> optional_param('questiontext' <pre>";print_r(optional_param('questiontext','', PARAM_RAW));echo "</pre></p>";
! 
! 			$this->questiondisplay = fullclone(qtype_multianswer_extract_question(optional_param('questiontext','', PARAM_RAW))) ;
! 
! 		}else {
! 			if(!$this->reload && !empty($this->savedquestiondisplay->id)){
! 				// use database data as this is first pass
! 				// question->id == 0 so no stored datasets
! 				$this->questiondisplay = fullclone($this->savedquestiondisplay);
! 				foreach($this->questiondisplay->options->questions as $subquestion){
! 					if (!empty($subquestion)){
! 						$subquestion->answer = array('');
! 						foreach($subquestion->options->answers as $ans){
! 							$subquestion->answer[]=$ans->answer ;
! 						}
! 						//  $subquestion->answer = fullclone($subquestion->options->answers);
! 					}
! 				}
! 			}else {
! 				$this->questiondisplay = "";
! 			}
! 		}
! 
! 		if ( isset($this->savedquestiondisplay->options->questions) && is_array($this->savedquestiondisplay->options->questions) ) {
! 			$countsavedsubquestions =0;
! 			foreach($this->savedquestiondisplay->options->questions as $subquestion){
! 				if (!empty($subquestion)){
! 					$countsavedsubquestions++;
! 				}
! 			}
! 		} else {
! 			$countsavedsubquestions =0;
! 		}
! 		if ($this->reload){
! 			if ( isset($this->questiondisplay->options->questions) && is_array($this->questiondisplay->options->questions) ) {
! 				$countsubquestions =0;
! 				foreach($this->questiondisplay->options->questions as $subquestion){
! 					if (!empty($subquestion)){
! 						$countsubquestions++;
! 					}
! 				}
! 			} else {
! 				$countsubquestions =0;
! 			}
! 		}else{
! 			$countsubquestions =$countsavedsubquestions ;
! 		}
! 		//  echo "<p> count subquestion $countsubquestions <pre>";print_r($this->savedquestiondisplay);echo "</pre></p>";
! 		//       //     echo "<p> saved question $countsubquestions <pre>";print_r($this->questiondisplay);echo "</pre></p>";
! 
! 
! 		$mform->addElement('submit', 'analyzequestion', get_string('decodeverifyquestiontext','qtype_multianswer'));
! 		$mform->registerNoSubmitButton('analyzequestion');
! 		if ( $this->reload ){
! 			$mform->addElement('html', '<div class="ablock clearfix">');
! 			$mform->addElement('html', '<div class=" clearfix">');
! 			for ($sub =1;$sub <=$countsubquestions ;$sub++) {
! 
! 				$this->editas[$sub] =  'unknown type';
! 				if (isset( $this->questiondisplay->options->questions[$sub]->qtype) ) {
! 					$this->editas[$sub] =  $this->questiondisplay->options->questions[$sub]->qtype ;
! 				} else if (optional_param('sub_'.$sub."_".'qtype', '', PARAM_RAW) != '') {
! 					$this->editas[$sub] = optional_param('sub_'.$sub."_".'qtype', '', PARAM_RAW);
! 				}
! 				$storemess = '';
! 				if(isset($this->savedquestiondisplay->options->questions[$sub]->qtype) &&
! 				$this->savedquestiondisplay->options->questions[$sub]->qtype != $this->questiondisplay->options->questions[$sub]->qtype ){
! 					$this->qtype_change = true ;
! 					$storemess = "<font class=\"error\"> STORED QTYPE ".$question_type_names[$this->savedquestiondisplay->options->questions[$sub]->qtype]."</font >";
! 				}
  
! 				$mform->addElement('header', 'subhdr'.$sub, get_string('questionno', 'quiz',
                      '{#'.$sub.'}').'&nbsp;'.$question_type_names[$this->questiondisplay->options->questions[$sub]->qtype].$storemess);
  
! 				$mform->addElement('static', 'sub_'.$sub."_".'questiontext', get_string('questiondefinition','qtype_multianswer'),array('cols'=>60, 'rows'=>3));
  
! 				if (isset ( $this->questiondisplay->options->questions[$sub]->questiontext)) {
! 					$mform->setDefault('sub_'.$sub."_".'questiontext', $this->questiondisplay->options->questions[$sub]->questiontext['text']);
! 				}
! 
! 				$mform->addElement('static', 'sub_'.$sub."_".'defaultgrade', get_string('defaultgrade', 'quiz'));
! 				$mform->setDefault('sub_'.$sub."_".'defaultgrade',$this->questiondisplay->options->questions[$sub]->defaultgrade);
! 
! 				if ($this->questiondisplay->options->questions[$sub]->qtype =='shortanswer'   ) {
! 					$mform->addElement('static', 'sub_'.$sub."_".'usecase', get_string('casesensitive', 'quiz'));
! 				}
! 
! 				if ($this->questiondisplay->options->questions[$sub]->qtype =='multichoice'   ) {
! 					$mform->addElement('static', 'sub_'.$sub."_".'layout', get_string('layout', 'qtype_multianswer'),array('cols'=>60, 'rows'=>1)) ;//, $gradeoptions);
! 				}
! 				foreach ($this->questiondisplay->options->questions[$sub]->answer as $key =>$ans) {
! 
! 					$mform->addElement('static', 'sub_'.$sub."_".'answer['.$key.']', get_string('answer', 'quiz'), array('cols'=>60, 'rows'=>1));
! 
! 					if ($this->questiondisplay->options->questions[$sub]->qtype =='numerical' && $key == 0 ) {
! 						$mform->addElement('static', 'sub_'.$sub."_".'tolerance['.$key.']', get_string('acceptederror', 'quiz')) ;//, $gradeoptions);
! 					}
! 
! 					$mform->addElement('static', 'sub_'.$sub."_".'fraction['.$key.']', get_string('grade')) ;//, $gradeoptions);
! 
! 					$mform->addElement('static', 'sub_'.$sub."_".'feedback['.$key.']', get_string('feedback', 'quiz'));
! 				}
! 
! 			}
! 			$mform->addElement('html', '</div>');
! 			$this->negative_diff =$countsavedsubquestions - $countsubquestions ;
! 			if ( ($this->negative_diff > 0 ) ||$this->qtype_change || ($this->used_in_quiz && $this->negative_diff != 0)){
! 				$mform->addElement('header', 'additemhdr', get_string('warningquestionmodified','qtype_multianswer'));
! 			}
! 			if($this->negative_diff > 0) {
! 				//$this->used_in_quiz
! 				$mform->addElement('static', 'alert1', "<strong>".get_string('questiondeleted','qtype_multianswer')."</strong>",get_string('questionsless','qtype_multianswer',$this->negative_diff));
! 			}
! 			if($this->qtype_change ) {
! 				$mform->addElement('static', 'alert1', "<strong>".get_string('questiontypechanged','qtype_multianswer')."</strong>",get_string('questiontypechangedcomment','qtype_multianswer'));
! 			}
! 			$mform->addElement('html', '</div>');
! 		}
! 		if( $this->used_in_quiz){
! 			if($this->negative_diff < 0) {
! 				$diff = $countsubquestions - $countsavedsubquestions;
! 				$mform->addElement('static', 'alert1', "<strong>".get_string('questionsadded','qtype_multianswer')."</strong>","<strong>".get_string('questionsmore','qtype_multianswer',$diff)."</strong>");
! 			}
! 			$a = new stdClass ;
! 			$a->nb_of_quiz = $this->nb_of_quiz;
! 			$a->nb_of_attempts = $this->nb_of_attempts;
! 			$mform->addElement('header', 'additemhdr2', get_string('questionusedinquiz','qtype_multianswer',$a));
! 			$mform->addElement('static', 'alertas', get_string('youshouldnot','qtype_multianswer'));
! 		}
! 		if ( ($this->negative_diff > 0 || $this->used_in_quiz && ($this->negative_diff > 0 ||$this->negative_diff < 0 || $this->qtype_change ) ) &&  $this->reload ){
! 			$mform->addElement('header', 'additemhdr', get_string('questionsaveasedited', 'qtype_multianswer'));
! 			$mform->addElement('checkbox', 'confirm','' ,get_string('confirmquestionsaveasedited', 'qtype_multianswer'));
! 			$mform->setDefault('confirm', 0);
! 		}else {
! 			$mform->addElement('hidden', 'confirm',0);
! 		}
! 
! 	}
! 
! 
! 	function set_data($question) {
! 		global $DB;
! 		$default_values =array();
! 		if (isset($question->id) and $question->id and $question->qtype and $question->questiontext) {
! 
! 			foreach ($question->options->questions as $key => $wrapped) {
! 				if(!empty($wrapped)){
! 					// The old way of restoring the definitions is kept to gradually
! 					// update all multianswer questions
! 					if (empty($wrapped->questiontext)) {
! 						$parsableanswerdef = '{' . $wrapped->defaultgrade . ':';
! 						switch ($wrapped->qtype) {
! 							case 'multichoice':
! 								$parsableanswerdef .= 'MULTICHOICE:';
! 								break;
! 							case 'shortanswer':
! 								$parsableanswerdef .= 'SHORTANSWER:';
! 								break;
! 							case 'numerical':
! 								$parsableanswerdef .= 'NUMERICAL:';
! 								break;
! 							default:
! 								print_error('unknownquestiontype', 'question', '', $wrapped->qtype);
! 						}
! 						$separator= '';
! 						foreach ($wrapped->options->answers as $subanswer) {
! 							$parsableanswerdef .= $separator
! 							. '%' . round(100*$subanswer->fraction) . '%';
! 							$parsableanswerdef .= $subanswer->answer;
! 							if (!empty($wrapped->options->tolerance)) {
! 								// Special for numerical answers:
! 								$parsableanswerdef .= ":{$wrapped->options->tolerance}";
! 								// We only want tolerance for the first alternative, it will
! 								// be applied to all of the alternatives.
! 								unset($wrapped->options->tolerance);
! 							}
! 							if ($subanswer->feedback) {
! 								$parsableanswerdef .= "#$subanswer->feedback";
! 							}
! 							$separator = '~';
! 						}
! 						$parsableanswerdef .= '}';
! 						// Fix the questiontext fields of old questions
! 						$DB->set_field('question', 'questiontext', $parsableanswerdef, array('id' => $wrapped->id));
! 					} else {
! 						$parsableanswerdef = str_replace('&#', '&\#', $wrapped->questiontext);
! 					}
! 					$question->questiontext = str_replace("{#$key}", $parsableanswerdef, $question->questiontext);
! 				}
! 			}
! 		}
! 
! 		// set default to $questiondisplay questions elements
! 		if ( $this->reload ){
! 			if (isset($this->questiondisplay->options->questions)) {
! 				$subquestions = fullclone($this->questiondisplay->options->questions) ;
! 				if (count($subquestions)) {
! 					$sub =1;
! 					foreach ($subquestions as $subquestion) {
! 						$prefix = 'sub_'.$sub.'_' ;
! 
! 						// validate parameters
! 						$answercount = 0;
! 						$maxgrade = false;
! 						$maxfraction = -1;
! 						if ($subquestion->qtype =='shortanswer'   ) {
! 							switch ($subquestion->usecase) {
! 								case '1':
! 									$default_values[$prefix.'usecase']= get_string('caseyes', 'quiz');
! 									break;
! 								case '0':
! 								default :
! 									$default_values[$prefix.'usecase']= get_string('caseno', 'quiz');
! 							}
! 						}
! 
! 						if ($subquestion->qtype == 'multichoice' ) {
! 							$default_values[$prefix.'layout']  = $subquestion->layout ;
! 							switch ($subquestion->layout) {
! 								case '0':
! 									$default_values[$prefix.'layout']= get_string('layoutselectinline', 'qtype_multianswer');
! 									break;
! 								case '1':
! 									$default_values[$prefix.'layout']= get_string('layoutvertical', 'qtype_multianswer');
! 									break;
! 								case '2':
! 									$default_values[$prefix.'layout']= get_string('layouthorizontal', 'qtype_multianswer');
! 									break;
! 								default:
! 									$default_values[$prefix.'layout']= get_string('layoutundefined', 'qtype_multianswer');
! 							}
! 						}
! 						foreach ($subquestion->answer as $key=>$answer) {
! 							if ( $subquestion->qtype == 'numerical' && $key == 0 ) {
! 								$default_values[$prefix.'tolerance['.$key.']']  = $subquestion->tolerance[0] ;
! 							}
! 							$trimmedanswer = trim($answer);
! 							if ($trimmedanswer !== '') {
! 								$answercount++;
! 								if ($subquestion->qtype == 'numerical' && !(is_numeric($trimmedanswer) || $trimmedanswer == '*')) {
! 									$this->_form->setElementError($prefix.'answer['.$key.']' , get_string('answermustbenumberorstar', 'qtype_numerical'));
! 								}
! 								if ($subquestion->fraction[$key] == 1) {
! 									$maxgrade = true;
! 								}
! 								if ($subquestion->fraction[$key] > $maxfraction) {
! 									$maxfraction = $subquestion->fraction[$key] ;
! 								}
! 							}
! 
! 							$default_values[$prefix.'answer['.$key.']']  = htmlspecialchars ($answer);
! 						}
! 						if ($answercount == 0) {
! 							if ($subquestion->qtype == 'multichoice' ) {
! 								$this->_form->setElementError($prefix.'answer[0]' ,  get_string('notenoughanswers', 'qtype_multichoice', 2));
! 							} else {
! 								$this->_form->setElementError($prefix.'answer[0]' , get_string('notenoughanswers', 'quiz', 1));
! 							}
! 						}
! 						if ($maxgrade == false) {
! 							$this->_form->setElementError($prefix.'fraction[0]' ,get_string('fractionsnomax', 'question'));
! 						}
! 						foreach ($subquestion->feedback as $key=>$answer) {
! 
! 							$default_values[$prefix.'feedback['.$key.']']  = htmlspecialchars ($answer['text']);
! 						}
! 						foreach ( $subquestion->fraction as $key=>$answer) {
! 							$default_values[$prefix.'fraction['.$key.']']  = $answer;
! 						}
! 
! 
! 						$sub++;
! 					}
! 				}
! 			}
! 		}
! 		$default_values['alertas']= "<strong>".get_string('questioninquiz','qtype_multianswer')."</strong>";
! 
! 		if( $default_values != "")   {
! 			$question = (object)((array)$question + $default_values);
! 		}
! 		parent::set_data($question);
! 	}
! 
! 	function validation($data, $files) {
! 		$errors = parent::validation($data, $files);
! 
! 		$questiondisplay = qtype_multianswer_extract_question($data['questiontext']);
! 		//                   echo "<p> questiondisplay ".$data['questiontext']['text']." <pre>";print_r($questiondisplay);echo "</pre></p>";
! 
! 		if (isset($questiondisplay->options->questions)) {
! 			$subquestions = fullclone($questiondisplay->options->questions) ;
! 			if (count($subquestions)) {
! 				$sub =1;
! 				foreach ($subquestions as $subquestion) {
! 					$prefix = 'sub_'.$sub.'_' ;
! 					$answercount = 0;
! 					$maxgrade = false;
! 					$maxfraction = -1;
! 					if(isset($this->savedquestiondisplay->options->questions[$sub]->qtype) &&
! 					$this->savedquestiondisplay->options->questions[$sub]->qtype != $questiondisplay->options->questions[$sub]->qtype ){
! 						$storemess = " STORED QTYPE ".$question_type_names[$this->savedquestiondisplay->options->questions[$sub]->qtype];
! 					}
! 					foreach ( $subquestion->answer as $key=>$answer) {
! 						$trimmedanswer = trim($answer);
! 						if ($trimmedanswer !== '') {
! 							$answercount++;
! 							if ($subquestion->qtype =='numerical' && !(is_numeric($trimmedanswer) || $trimmedanswer == '*')) {
! 								$errors[$prefix.'answer['.$key.']']=  get_string('answermustbenumberorstar', 'qtype_numerical');
! 							}
! 							if ($subquestion->fraction[$key] == 1) {
! 								$maxgrade = true;
! 							}
! 							if ($subquestion->fraction[$key] > $maxfraction) {
! 								$maxfraction = $subquestion->fraction[$key] ;
! 							}
! 						}
! 					}
! 					if ($answercount==0) {
! 						if ( $subquestion->qtype =='multichoice' ) {
! 							$errors[$prefix.'answer[0]']= get_string('notenoughanswers', 'qtype_multichoice', 2);
! 						}else {
! 							$errors[$prefix.'answer[0]'] = get_string('notenoughanswers', 'quiz', 1);
! 						}
! 					}
! 					if ($maxgrade == false) {
! 						$errors[$prefix.'fraction[0]']=get_string('fractionsnomax', 'question');
! 					}
! 					$sub++;
! 				}
! 			} else {
! 				$errors['questiontext']=get_string('questionsmissing', 'qtype_multianswer');
! 			}
! 		}
! 		// $question = qtype_multianswer_extract_question($data['questiontext']);
! 		//  if (isset $question->options->questions
! 		if (( $this->negative_diff > 0 || $this->used_in_quiz && ($this->negative_diff > 0 ||$this->negative_diff < 0 || $this->qtype_change ))&& $this->confirm == 0 ){
! 			$errors['confirm']=get_string('confirmsave', 'qtype_multianswer',$this->negative_diff);
! 		}
! 
! 
! 		return $errors;
! 	}
! 
! 	function qtype() {
! 		return 'multianswer';
! 	}
  }
diff -crB questionorg/type/multianswer/questiontype.php questionupd/type/multianswer/questiontype.php
*** questionorg/type/multianswer/questiontype.php	2012-04-13 12:31:12.384178271 +0500
--- questionupd/type/multianswer/questiontype.php	2012-04-13 09:42:57.000000000 +0500
***************
*** 19,710 ****
   */
  class embedded_cloze_qtype extends default_questiontype {
  
!     function name() {
!         return 'multianswer';
!     }
! 
!     function has_wildcards_in_responses($question, $subqid) {
!         global $QTYPES, $OUTPUT;
!         foreach ($question->options->questions as $subq){
!             if ($subq->id == $subqid){
!                 return $QTYPES[$subq->qtype]->has_wildcards_in_responses($subq, $subqid);
!             }
!         }
!         echo $OUTPUT->notification('Could not find sub question!');
!         return true;
!     }
! 
!     function requires_qtypes() {
!         return array('shortanswer', 'numerical', 'multichoice');
!     }
! 
!     function get_question_options(&$question) {
!         global $QTYPES, $DB, $OUTPUT;
! 
!         // Get relevant data indexed by positionkey from the multianswers table
!         if (!$sequence = $DB->get_field('question_multianswer', 'sequence', array('question' => $question->id))) {
!             echo $OUTPUT->notification(get_string('noquestions','qtype_multianswer',$question->name));
!             $question->options->questions['1']= '';
!             return true ;
!         }
! 
!         $wrappedquestions = $DB->get_records_list('question', 'id', explode(',', $sequence), 'id ASC');
! 
!         // We want an array with question ids as index and the positions as values
!         $sequence = array_flip(explode(',', $sequence));
!         array_walk($sequence, create_function('&$val', '$val++;'));
!         //If a question is lost, the corresponding index is null
!         // so this null convention is used to test $question->options->questions
!         // before using the values.
!         // first all possible questions from sequence are nulled
!         // then filled with the data if available in  $wrappedquestions
!         $nbvaliquestion = 0 ;
!         foreach($sequence as $seq){
!             $question->options->questions[$seq]= '';
!         }
!         if (isset($wrappedquestions) && is_array($wrappedquestions)){
!             foreach ($wrappedquestions as $wrapped) {
!                 if (!$QTYPES[$wrapped->qtype]->get_question_options($wrapped)) {
!                     echo $OUTPUT->notification("Unable to get options for questiontype {$wrapped->qtype} (id={$wrapped->id})");
!                 }else {
!                 // for wrapped questions the maxgrade is always equal to the defaultgrade,
!                 // there is no entry in the question_instances table for them
!                 $wrapped->maxgrade = $wrapped->defaultgrade;
!                     $nbvaliquestion++ ;
!                 $question->options->questions[$sequence[$wrapped->id]] = clone($wrapped); // ??? Why do we need a clone here?
!             }
!         }
!         }
!         if ($nbvaliquestion == 0 ) {
!             echo $OUTPUT->notification(get_string('noquestions','qtype_multianswer',$question->name));
!         }
! 
!         return true;
!     }
! 
!     function save_question_options($question) {
!         global $QTYPES, $DB;
!         $result = new stdClass;
! 
!         // This function needs to be able to handle the case where the existing set of wrapped
!         // questions does not match the new set of wrapped questions so that some need to be
!         // created, some modified and some deleted
!         // Unfortunately the code currently simply overwrites existing ones in sequence. This
!         // will make re-marking after a re-ordering of wrapped questions impossible and
!         // will also create difficulties if questiontype specific tables reference the id.
! 
!         // First we get all the existing wrapped questions
!         if (!$oldwrappedids = $DB->get_field('question_multianswer', 'sequence', array('question' => $question->id))) {
!             $oldwrappedquestions = array();
!         } else {
!             $oldwrappedquestions = $DB->get_records_list('question', 'id', explode(',', $oldwrappedids), 'id ASC');
!         }
!         $sequence = array();
!         foreach($question->options->questions as $wrapped) {
!             if (!empty($wrapped)){
!                 // if we still have some old wrapped question ids, reuse the next of them
! 
!                 if (is_array($oldwrappedquestions) && $oldwrappedquestion = array_shift($oldwrappedquestions)) {
!                     $wrapped->id = $oldwrappedquestion->id;
!                     if($oldwrappedquestion->qtype != $wrapped->qtype ) {
!                         switch ($oldwrappedquestion->qtype) {
!                                 case 'multichoice':
!                                  $DB->delete_records('question_multichoice', array('question' => $oldwrappedquestion->id));
!                                     break;
!                                 case 'shortanswer':
!                                  $DB->delete_records('question_shortanswer', array('question' => $oldwrappedquestion->id));
!                                     break;
!                                 case 'numerical':
!                                  $DB->delete_records('question_numerical', array('question' => $oldwrappedquestion->id));
!                                     break;
!                                 default:
!                                 print_error('qtypenotrecognized', 'qtype_multianswer','',$oldwrappedquestion->qtype);
!                                         $wrapped->id = 0 ;
!                         }
!                     }
!                 }else {
!                     $wrapped->id = 0 ;
!                 }
!             }
!             $wrapped->name = $question->name;
!             $wrapped->parent = $question->id;
!             $previousid = $wrapped->id ;
!             $wrapped->category = $question->category . ',1'; // save_question strips this extra bit off again.
!             $wrapped = $QTYPES[$wrapped->qtype]->save_question($wrapped, clone($wrapped));
!             $sequence[] = $wrapped->id;
!             if ($previousid != 0 && $previousid != $wrapped->id ) {
!                 // for some reasons a new question has been created
!                 // so delete the old one
!                 delete_question($previousid) ;
!             }
!         }
! 
!         // Delete redundant wrapped questions
!         if(is_array($oldwrappedquestions) && count($oldwrappedquestions)){
!             foreach ($oldwrappedquestions as $oldwrappedquestion) {
!                 delete_question($oldwrappedquestion->id) ;
!             }
!         }
! 
!         if (!empty($sequence)) {
!             $multianswer = new stdClass;
!             $multianswer->question = $question->id;
!             $multianswer->sequence = implode(',', $sequence);
!             if ($oldid = $DB->get_field('question_multianswer', 'id', array('question' => $question->id))) {
!                 $multianswer->id = $oldid;
!                 $DB->update_record("question_multianswer", $multianswer);
!             } else {
!                 $DB->insert_record("question_multianswer", $multianswer);
!             }
!         }
!     }
! 
!     function save_question($authorizedquestion, $form) {
!         $question = qtype_multianswer_extract_question($form->questiontext);
!         if (isset($authorizedquestion->id)) {
!             $question->id = $authorizedquestion->id;
!         }
! 
!         $question->category = $authorizedquestion->category;
!         $form->defaultgrade = $question->defaultgrade;
!         $form->questiontext = $question->questiontext;
!         $form->questiontextformat = 0;
!         $form->options = clone($question->options);
!         unset($question->options);
!         return parent::save_question($question, $form);
!     }
! 
!     function create_session_and_responses(&$question, &$state, $cmoptions, $attempt) {
!         $state->responses = array();
!         foreach ($question->options->questions as $key => $wrapped) {
!             $state->responses[$key] = '';
!         }
!         return true;
!     }
! 
!     function restore_session_and_responses(&$question, &$state) {
!         $responses = explode(',', $state->responses['']);
!         $state->responses = array();
!         foreach ($responses as $response) {
!             $tmp = explode("-", $response);
!             // restore encoded characters
!             $state->responses[$tmp[0]] = str_replace(array("&#0044;", "&#0045;"),
!                     array(",", "-"), $tmp[1]);
!         }
!         return true;
!     }
! 
!     function save_session_and_responses(&$question, &$state) {
!         global $DB;
!         $responses = $state->responses;
!         // encode - (hyphen) and , (comma) to &#0045; because they are used as
!         // delimiters
!         array_walk($responses, create_function('&$val, $key',
                  '$val = str_replace(array(",", "-"), array("&#0044;", "&#0045;"), $val);
                  $val = "$key-$val";'));
!         $responses = implode(',', $responses);
  
!         // Set the legacy answer field
!         $DB->set_field('question_states', 'answer', $responses, array('id' => $state->id));
!         return true;
!     }
! 
!     function delete_question($questionid, $contextid) {
!         global $DB;
!         $DB->delete_records("question_multianswer", array("question" => $questionid));
! 
!         parent::delete_question($questionid, $contextid);
!     }
! 
!     function get_correct_responses(&$question, &$state) {
!         global $QTYPES;
!         $responses = array();
!         foreach($question->options->questions as $key => $wrapped) {
!             if (!empty($wrapped)){
!                 if ($correct = $QTYPES[$wrapped->qtype]->get_correct_responses($wrapped, $state)) {
!                     $responses[$key] = $correct[''];
!                 } else {
!                     // if there is no correct answer to this subquestion then there
!                     // can not be a correct answer to the whole question either, so
!                     // we have to return null.
!                     return null;
!                 }
!             }
!         }
!         return $responses;
!     }
! 
!     function get_possible_responses(&$question) {
!         global $QTYPES;
!         $responses = array();
!         foreach($question->options->questions as $key => $wrapped) {
!             if (!empty($wrapped)){
!                 if ($correct = $QTYPES[$wrapped->qtype]->get_possible_responses($wrapped)) {
!                     $responses += $correct;
!                 } else {
!                     // if there is no correct answer to this subquestion then there
!                     // can not be a correct answer to the whole question either, so
!                     // we have to return null.
!                     return null;
!                 }
!             }
!         }
!         return $responses;
!     }
!     function get_actual_response_details($question, $state){
!         global $QTYPES;
!         $details = array();
!         foreach($question->options->questions as $key => $wrapped) {
!             if (!empty($wrapped)){
!                 $stateforquestion = clone($state);
!                 $stateforquestion->responses[''] = $state->responses[$key];
!                 $details = array_merge($details, $QTYPES[$wrapped->qtype]->get_actual_response_details($wrapped, $stateforquestion));
!             }
!         }
!         return $details;
!     }
! 
!     function get_html_head_contributions(&$question, &$state) {
!         global $PAGE;
!         parent::get_html_head_contributions($question, $state);
!         $PAGE->requires->js('/lib/overlib/overlib.js', true);
!         $PAGE->requires->js('/lib/overlib/overlib_cssstyle.js', true);
!     }
! 
!     function print_question_formulation_and_controls(&$question, &$state, $cmoptions, $options) {
!         global $QTYPES, $CFG, $USER, $OUTPUT, $PAGE;
! 
!         $readonly = empty($options->readonly) ? '' : 'readonly="readonly"';
!         $disabled = empty($options->readonly) ? '' : 'disabled="disabled"';
!         $formatoptions = new stdClass;
!         $formatoptions->noclean = true;
!         $formatoptions->para = false;
!         $nameprefix = $question->name_prefix;
! 
!         // adding an icon with alt to warn user this is a fill in the gap question
!         // MDL-7497
!         if (!empty($USER->screenreader)) {
!             echo "<img src=\"".$OUTPUT->pix_url('icon', 'qtype_'.$question->qtype)."\" ".
                  "class=\"icon\" alt=\"".get_string('clozeaid','qtype_multichoice')."\" />  ";
!         }
  
!         echo '<div class="ablock clearfix">';
  
!         $qtextremaining = format_text($question->questiontext,
!                 $question->questiontextformat, $formatoptions, $cmoptions->course);
! 
!         $strfeedback = get_string('feedback', 'quiz');
! 
!         // The regex will recognize text snippets of type {#X}
!         // where the X can be any text not containg } or white-space characters.
!         while (preg_match('~\{#([^[:space:]}]*)}~', $qtextremaining, $regs)) {
!             $qtextsplits = explode($regs[0], $qtextremaining, 2);
!             echo $qtextsplits[0];
!             echo "<label>"; // MDL-7497
!             $qtextremaining = $qtextsplits[1];
! 
!             $positionkey = $regs[1];
!             if (isset($question->options->questions[$positionkey]) && $question->options->questions[$positionkey] != ''){
!             $wrapped = &$question->options->questions[$positionkey];
!             $answers = &$wrapped->options->answers;
!            // $correctanswers = $QTYPES[$wrapped->qtype]->get_correct_responses($wrapped, $state);
! 
!             $inputname = $nameprefix.$positionkey;
!             if (isset($state->responses[$positionkey])) {
!                 $response = $state->responses[$positionkey];
!             } else {
!                 $response = null;
!             }
!             //   echo "<p> multianswer positionkey $positionkey response $response state  <pre>";print_r($state);echo "</pre></p>";
! 
!             // Determine feedback popup if any
!             $popup = '';
!             $style = '';
!             $feedbackimg = '';
!             $feedback = '' ;
!             $correctanswer = '';
!             $strfeedbackwrapped  = $strfeedback;
!                 $testedstate = clone($state);
!                 if ($correctanswers =  $QTYPES[$wrapped->qtype]->get_correct_responses($wrapped, $state)) {
!                     if ($options->readonly && $options->correct_responses) {
!                         $delimiter = '';
!                         if ($correctanswers) {
!                             foreach ($correctanswers as $ca) {
!                                 switch($wrapped->qtype){
!                                     case 'numerical':
!                                     case 'shortanswer':
!                                         $correctanswer .= $delimiter.$ca;
!                                         break ;
!                                     case 'multichoice':
!                                         if (isset($answers[$ca])){
!                                             $correctanswer .= $delimiter.$answers[$ca]->answer;
!                                         }
!                                         break ;
!                                 }
!                                 $delimiter = ', ';
!                             }
!                         }
!                     }
!                     if ($correctanswer != '' ) {
!                         $feedback = '<div class="correctness">';
!                         $feedback .= get_string('correctansweris', 'quiz', s($correctanswer));
!                         $feedback .= '</div>';
!                     }
!                 }
! 
!             if ($options->feedback) {
!                 $chosenanswer = null;
!                 switch ($wrapped->qtype) {
!                     case 'numerical':
!                     case 'shortanswer':
!                         $testedstate = clone($state);
!                         $testedstate->responses[''] = $response;
!                         foreach ($answers as $answer) {
!                             if($QTYPES[$wrapped->qtype]
!                                     ->test_response($wrapped, $testedstate, $answer)) {
!                                 $chosenanswer = clone($answer);
!                                 break;
!                             }
!                         }
!                         break;
!                     case 'multichoice':
!                         if (isset($answers[$response])) {
!                             $chosenanswer = clone($answers[$response]);
!                         }
!                         break;
!                     default:
!                         break;
!                 }
! 
!                 // Set up a default chosenanswer so that all non-empty wrong
!                 // answers are highlighted red
!                 if (empty($chosenanswer) && $response != '') {
!                     $chosenanswer = new stdClass;
!                     $chosenanswer->fraction = 0.0;
!                 }
! 
!                 if (!empty($chosenanswer->feedback)) {
!                     $feedback = s(str_replace(array("\\", "'"), array("\\\\", "\\'"), $feedback.$chosenanswer->feedback));
!                     if  ($options->readonly && $options->correct_responses) {
!                         $strfeedbackwrapped = get_string('correctanswerandfeedback', 'qtype_multianswer');
!                     }else {
!                         $strfeedbackwrapped = get_string('feedback', 'quiz');
!                     }
!                     $popup = " onmouseover=\"return overlib('$feedback', STICKY, MOUSEOFF, CAPTION, '$strfeedbackwrapped', FGCOLOR, '#FFFFFF');\" ".
                               " onmouseout=\"return nd();\" ";
!                 }
  
!                 /// Determine style
!                 if ($options->feedback && $response != '') {
!                     $style = 'class = "'.question_get_feedback_class($chosenanswer->fraction).'"';
!                     $feedbackimg = question_get_feedback_image($chosenanswer->fraction);
!                 } else {
!                     $style = '';
!                     $feedbackimg = '';
!                 }
!             }
!             if ($feedback !='' && $popup == ''){
!                 $strfeedbackwrapped = get_string('correctanswer', 'qtype_multianswer');
!                     $feedback = s(str_replace(array("\\", "'"), array("\\\\", "\\'"), $feedback));
!                     $popup = " onmouseover=\"return overlib('$feedback', STICKY, MOUSEOFF, CAPTION, '$strfeedbackwrapped', FGCOLOR, '#FFFFFF');\" ".
                               " onmouseout=\"return nd();\" ";
!             }
  
!             // Print the input control
!             switch ($wrapped->qtype) {
!                 case 'shortanswer':
!                 case 'numerical':
!                     $size = 1 ;
!                     foreach ($answers as $answer) {
!                         if (strlen(trim($answer->answer)) > $size ){
!                             $size = strlen(trim($answer->answer));
!                         }
!                     }
!                     if (strlen(trim($response))> $size ){
!                             $size = strlen(trim($response))+1;
!                     }
!                     $size = $size + rand(0,$size*0.15);
!                     $size > 60 ? $size = 60 : $size = $size;
!                     $styleinfo = "size=\"$size\"";
!                     /**
!                     * Uncomment the following lines if you want to limit for small sizes.
!                     * Results may vary with browsers see MDL-3274
!                     */
!                     /*
!                     if ($size < 2) {
!                         $styleinfo = 'style="width: 1.1em;"';
!                     }
!                     if ($size == 2) {
!                         $styleinfo = 'style="width: 1.9em;"';
!                     }
!                     if ($size == 3) {
!                         $styleinfo = 'style="width: 2.3em;"';
!                     }
!                     if ($size == 4) {
!                         $styleinfo = 'style="width: 2.8em;"';
!                     }
!                     */
! 
!                     echo "<input $style $readonly $popup name=\"$inputname\"";
!                     echo "  type=\"text\" value=\"".s($response)."\" ".$styleinfo." /> ";
!                     if (!empty($feedback) && !empty($USER->screenreader)) {
!                         echo "<img src=\"" . $OUTPUT->pix_url('i/feedback') . "\" alt=\"$feedback\" />";
!                     }
!                     echo $feedbackimg;
!                     break;
!                 case 'multichoice':
!                  if ($wrapped->options->layout == 0 ){
!                       $outputoptions = '<option></option>'; // Default empty option
!                       foreach ($answers as $mcanswer) {
!                         $selected = '';
!                         if ($response == $mcanswer->id) {
!                             $selected = ' selected="selected"';
!                         }
!                         $outputoptions .= "<option value=\"$mcanswer->id\"$selected>" .
!                                 s($mcanswer->answer) . '</option>';
!                         }
!                         // In the next line, $readonly is invalid HTML, but it works in
!                         // all browsers. $disabled would be valid, but then the JS for
!                         // displaying the feedback does not work. Of course, we should
!                         // not be relying on JS (for accessibility reasons), but that is
!                         // a bigger problem.
!                         //
!                         // The span is used for safari, which does not allow styling of
!                         // selects.
!                         echo "<span $style><select $popup $readonly $style name=\"$inputname\">";
!                         echo $outputoptions;
!                         echo '</select></span>';
!                         if (!empty($feedback) && !empty($USER->screenreader)) {
!                             echo "<img src=\"" . $OUTPUT->pix_url('i/feedback') . "\" alt=\"$feedback\" />";
!                         }
!                         echo $feedbackimg;
!                     }else if ($wrapped->options->layout == 1 || $wrapped->options->layout == 2){
!                         $ordernumber=0;
!                         $anss =  Array();
!                         foreach ($answers as $mcanswer) {
!                             $ordernumber++;
!                             $checked = '';
!                             $chosen = false;
!                             $type = 'type="radio"';
!                             $name   = "name=\"{$inputname}\"";
!                             if ($response == $mcanswer->id) {
!                                 $checked = 'checked="checked"';
!                                 $chosen = true;
!                             }
!                             $a = new stdClass;
!                             $a->id   = $question->name_prefix . $mcanswer->id;
!                             $a->class = '';
!                             $a->feedbackimg = '';
! 
!                     // Print the control
!                     $a->control = "<input $readonly id=\"$a->id\" $name $checked $type value=\"$mcanswer->id\" />";
!                 if ($options->correct_responses && $mcanswer->fraction > 0) {
!                     $a->class = question_get_feedback_class(1);
!                 }
!                 if (($options->feedback && $chosen) || $options->correct_responses) {
!                     if ($type == ' type="checkbox" ') {
!                         $a->feedbackimg = question_get_feedback_image($mcanswer->fraction > 0 ? 1 : 0, $chosen && $options->feedback);
!                     } else {
!                         $a->feedbackimg = question_get_feedback_image($mcanswer->fraction, $chosen && $options->feedback);
!                     }
!                 }
! 
!                 // Print the answer text: no automatic numbering
! 
!                 $a->text = format_text($mcanswer->answer, $mcanswer->answerformat, $formatoptions, $cmoptions->course);
! 
!                 // Print feedback if feedback is on
!                 if (($options->feedback || $options->correct_responses) && ($checked )) { //|| $options->readonly
!                     $a->feedback = format_text($mcanswer->feedback, $mcanswer->feedbackformat, $formatoptions, $cmoptions->course);
!                 } else {
!                     $a->feedback = '';
!                 }
! 
!                     $anss[] = clone($a);
!                 }
!                 ?>
!             <?php    if ($wrapped->options->layout == 1 ){
!             ?>
!                   <table class="answer">
!                     <?php $row = 1; foreach ($anss as $answer) { ?>
!                       <tr class="<?php echo 'r'.$row = $row ? 0 : 1; ?>">
!                         <td class="c0 control">
!                           <?php echo $answer->control; ?>
!                         </td>
!                         <td class="c1 text <?php echo $answer->class ?>">
!                           <label for="<?php echo $answer->id ?>">
!                             <?php echo $answer->text; ?>
!                             <?php echo $answer->feedbackimg; ?>
!                           </label>
!                         </td>
!                         <td class="c0 feedback">
!                           <?php echo $answer->feedback; ?>
!                         </td>
!                       </tr>
!                     <?php } ?>
!                   </table>
!                   <?php }else  if ($wrapped->options->layout == 2 ){
!                     ?>
! 
!                   <table class="answer">
!                       <tr class="<?php echo 'r'.$row = $row ? 0 : 1; ?>">
!                     <?php $row = 1; foreach ($anss as $answer) { ?>
!                         <td class="c0 control">
!                           <?php echo $answer->control; ?>
!                         </td>
!                         <td class="c1 text <?php echo $answer->class ?>">
!                           <label for="<?php echo $answer->id ?>">
!                             <?php echo $answer->text; ?>
!                             <?php echo $answer->feedbackimg; ?>
!                           </label>
!                         </td>
!                         <td class="c0 feedback">
!                           <?php echo $answer->feedback; ?>
!                         </td>
!                     <?php } ?>
!                       </tr>
!                   </table>
!                   <?php }
! 
!                     }else {
!                         echo "no valid layout";
!                     }
! 
!                     break;
!                 default:
!                     $a = new stdClass;
!                     $a->type = $wrapped->qtype ;
!                     $a->sub = $positionkey;
!                     print_error('unknownquestiontypeofsubquestion', 'qtype_multianswer','',$a);
!                     break;
!            }
!            echo "</label>"; // MDL-7497
!         }
!         else {
!             if(!  isset($question->options->questions[$positionkey])){
!                 echo $regs[0]."</label>";
!             }else {
!                 echo '</label><div class="error" >'.get_string('questionnotfound','qtype_multianswer',$positionkey).'</div>';
!             }
!        }
!     }
! 
!         // Print the final piece of question text:
!         echo $qtextremaining;
!         $this->print_question_submit_buttons($question, $state, $cmoptions, $options);
!         echo '</div>';
!     }
! 
!     public function compare_responses($question, $state, $teststate) {
!         global $QTYPES;
! 
!         foreach ($question->options->questions as $key => $wrapped) {
!             if (empty($wrapped)) {
!                 continue;
!             }
! 
!             $stateforquestion = clone($state);
!             if (isset($state->responses[$key])) {
!                 $stateforquestion->responses[''] = $state->responses[$key];
!             } else {
!                 $stateforquestion->responses[''] = '';
!             }
! 
!             $teststateforquestion = clone($teststate);
!             if (isset($teststate->responses[$key])) {
!                 $teststateforquestion->responses[''] = $teststate->responses[$key];
!             } else {
!                 $teststateforquestion->responses[''] = '';
!             }
! 
!             if ($wrapped->qtype == 'numerical') {
!                 // Use shortanswer
!                 if (!$QTYPES['shortanswer']->compare_responses($wrapped,
!                         $stateforquestion, $teststateforquestion)) {
!                     return false;
!                 }
!             } else {
!                 if (!$QTYPES[$wrapped->qtype]->compare_responses($wrapped,
!                         $stateforquestion, $teststateforquestion)) {
!                     return false;
!                 }
!             }
!         }
! 
!         return true;
!     }
! 
!     function grade_responses(&$question, &$state, $cmoptions) {
!         global $QTYPES;
!         $teststate = clone($state);
!         $state->raw_grade = 0;
!         foreach($question->options->questions as $key => $wrapped) {
!             if (!empty($wrapped)){
!                 if(isset($state->responses[$key])){
!                     $state->responses[$key] = $state->responses[$key];
!                 }else {
!                     $state->responses[$key] = '' ;
!                 }
!                 $teststate->responses = array('' => $state->responses[$key]);
!                 $teststate->raw_grade = 0;
!                 if (false === $QTYPES[$wrapped->qtype]
!                  ->grade_responses($wrapped, $teststate, $cmoptions)) {
!                     return false;
!                 }
!                 $state->raw_grade += $teststate->raw_grade;
!             }
!         }
!         $state->raw_grade /= $question->defaultgrade;
!         $state->raw_grade = min(max((float) $state->raw_grade, 0.0), 1.0)
!          * $question->maxgrade;
! 
!         if (empty($state->raw_grade)) {
!             $state->raw_grade = 0.0;
!         }
!         $state->penalty = $question->penalty * $question->maxgrade;
! 
!         // mark the state as graded
!         $state->event = ($state->event ==  QUESTION_EVENTCLOSE) ? QUESTION_EVENTCLOSEANDGRADE : QUESTION_EVENTGRADE;
! 
!         return true;
!     }
! 
!     function get_actual_response($question, $state) {
!         global $QTYPES;
!         $teststate = clone($state);
!         foreach($question->options->questions as $key => $wrapped) {
!             $state->responses[$key] = html_entity_decode($state->responses[$key]);
!             $teststate->responses = array('' => $state->responses[$key]);
!             $correct = $QTYPES[$wrapped->qtype]
!              ->get_actual_response($wrapped, $teststate);
!             $responses[$key] = implode(';', $correct);
!         }
!         return $responses;
!     }
! 
!     /**
!      * @param object $question
!      * @return mixed either a integer score out of 1 that the average random
!      * guess by a student might give or an empty string which means will not
!      * calculate.
!      */
!     function get_random_guess_score($question) {
!         $totalfraction = 0;
!         foreach (array_keys($question->options->questions) as $key){
!             $totalfraction += question_get_random_guess_score($question->options->questions[$key]);
!         }
!         return $totalfraction / count($question->options->questions);
!     }
! 
!     /**
!      * Runs all the code required to set up and save an essay question for testing purposes.
!      * Alternate DB table prefix may be used to facilitate data deletion.
!      */
!     function generate_test($name, $courseid = null) {
!         global $DB;
!         list($form, $question) = parent::generate_test($name, $courseid);
!         $question->category = $form->category;
!         $form->questiontext = "This question consists of some text with an answer embedded right here {1:MULTICHOICE:Wrong answer#Feedback for this wrong answer~Another wrong answer#Feedback for the other wrong answer~=Correct answer#Feedback for correct answer~%50%Answer that gives half the credit#Feedback for half credit answer} and right after that you will have to deal with this short answer {1:SHORTANSWER:Wrong answer#Feedback for this wrong answer~=Correct answer#Feedback for correct answer~%50%Answer that gives half the credit#Feedback for half credit answer} and finally we have a floating point number {2:NUMERICAL:=23.8:0.1#Feedback for correct answer 23.8~%50%23.8:2#Feedback for half credit answer in the nearby region of the correct answer}.
  
  Note that addresses like www.moodle.org and smileys :-) all work as normal:
   a) How good is this? {:MULTICHOICE:=Yes#Correct~No#We have a different opinion}
--- 19,727 ----
   */
  class embedded_cloze_qtype extends default_questiontype {
  
! 	function name() {
! 		return 'multianswer';
! 	}
! 
! 	function has_wildcards_in_responses($question, $subqid) {
! 		global $QTYPES, $OUTPUT;
! 		foreach ($question->options->questions as $subq){
! 			if ($subq->id == $subqid){
! 				return $QTYPES[$subq->qtype]->has_wildcards_in_responses($subq, $subqid);
! 			}
! 		}
! 		echo $OUTPUT->notification('Could not find sub question!');
! 		return true;
! 	}
! 
! 	function requires_qtypes() {
! 		return array('shortanswer', 'numerical', 'multichoice');
! 	}
! 
! 	function get_question_options(&$question) {
! 		global $QTYPES, $DB, $OUTPUT;
! 
! 		// Get relevant data indexed by positionkey from the multianswers table
! 		if (!$sequence = $DB->get_field('question_multianswer', 'sequence', array('question' => $question->id))) {
! 			echo $OUTPUT->notification(get_string('noquestions','qtype_multianswer',$question->name));
! 			$question->options->questions['1']= '';
! 			return true ;
! 		}
! 
! 		$wrappedquestions = $DB->get_records_list('question', 'id', explode(',', $sequence), 'id ASC');
! 
! 		// We want an array with question ids as index and the positions as values
! 		$sequence = array_flip(explode(',', $sequence));
! 		array_walk($sequence, create_function('&$val', '$val++;'));
! 		//If a question is lost, the corresponding index is null
! 		// so this null convention is used to test $question->options->questions
! 		// before using the values.
! 		// first all possible questions from sequence are nulled
! 		// then filled with the data if available in  $wrappedquestions
! 		$nbvaliquestion = 0 ;
! 		foreach($sequence as $seq){
! 			$question->options->questions[$seq]= '';
! 		}
! 		if (isset($wrappedquestions) && is_array($wrappedquestions)){
! 			foreach ($wrappedquestions as $wrapped) {
! 				if (!$QTYPES[$wrapped->qtype]->get_question_options($wrapped)) {
! 					echo $OUTPUT->notification("Unable to get options for questiontype {$wrapped->qtype} (id={$wrapped->id})");
! 				}else {
! 					// for wrapped questions the maxgrade is always equal to the defaultgrade,
! 					// there is no entry in the question_instances table for them
! 					$wrapped->maxgrade = $wrapped->defaultgrade;
! 					$nbvaliquestion++ ;
! 					$question->options->questions[$sequence[$wrapped->id]] = clone($wrapped); // ??? Why do we need a clone here?
! 				}
! 			}
! 		}
! 		if ($nbvaliquestion == 0 ) {
! 			echo $OUTPUT->notification(get_string('noquestions','qtype_multianswer',$question->name));
! 		}
! 
! 		return true;
! 	}
! 
! 	function save_question_options($question) {
! 		global $QTYPES, $DB;
! 		$result = new stdClass;
! 
! 		// This function needs to be able to handle the case where the existing set of wrapped
! 		// questions does not match the new set of wrapped questions so that some need to be
! 		// created, some modified and some deleted
! 		// Unfortunately the code currently simply overwrites existing ones in sequence. This
! 		// will make re-marking after a re-ordering of wrapped questions impossible and
! 		// will also create difficulties if questiontype specific tables reference the id.
! 
! 		// First we get all the existing wrapped questions
! 		if (!$oldwrappedids = $DB->get_field('question_multianswer', 'sequence', array('question' => $question->id))) {
! 			$oldwrappedquestions = array();
! 		} else {
! 			$oldwrappedquestions = $DB->get_records_list('question', 'id', explode(',', $oldwrappedids), 'id ASC');
! 		}
! 		$sequence = array();
! 		foreach($question->options->questions as $wrapped) {
! 			if (!empty($wrapped)){
! 				// if we still have some old wrapped question ids, reuse the next of them
! 
! 				if (is_array($oldwrappedquestions) && $oldwrappedquestion = array_shift($oldwrappedquestions)) {
! 					$wrapped->id = $oldwrappedquestion->id;
! 					if($oldwrappedquestion->qtype != $wrapped->qtype ) {
! 						switch ($oldwrappedquestion->qtype) {
! 							case 'multichoice':
! 								$DB->delete_records('question_multichoice', array('question' => $oldwrappedquestion->id));
! 								break;
! 							case 'shortanswer':
! 								$DB->delete_records('question_shortanswer', array('question' => $oldwrappedquestion->id));
! 								break;
! 							case 'numerical':
! 								$DB->delete_records('question_numerical', array('question' => $oldwrappedquestion->id));
! 								break;
! 							default:
! 								print_error('qtypenotrecognized', 'qtype_multianswer','',$oldwrappedquestion->qtype);
! 								$wrapped->id = 0 ;
! 						}
! 					}
! 				}else {
! 					$wrapped->id = 0 ;
! 				}
! 			}
! 			$wrapped->name = $question->name;
! 			$wrapped->parent = $question->id;
! 			$previousid = $wrapped->id ;
! 			$wrapped->category = $question->category . ',1'; // save_question strips this extra bit off again.
! 			$wrapped = $QTYPES[$wrapped->qtype]->save_question($wrapped, clone($wrapped));
! 			$sequence[] = $wrapped->id;
! 			if ($previousid != 0 && $previousid != $wrapped->id ) {
! 				// for some reasons a new question has been created
! 				// so delete the old one
! 				delete_question($previousid) ;
! 			}
! 		}
! 
! 		// Delete redundant wrapped questions
! 		if(is_array($oldwrappedquestions) && count($oldwrappedquestions)){
! 			foreach ($oldwrappedquestions as $oldwrappedquestion) {
! 				delete_question($oldwrappedquestion->id) ;
! 			}
! 		}
! 
! 		if (!empty($sequence)) {
! 			$multianswer = new stdClass;
! 			$multianswer->question = $question->id;
! 			$multianswer->sequence = implode(',', $sequence);
! 			if ($oldid = $DB->get_field('question_multianswer', 'id', array('question' => $question->id))) {
! 				$multianswer->id = $oldid;
! 				$DB->update_record("question_multianswer", $multianswer);
! 			} else {
! 				$DB->insert_record("question_multianswer", $multianswer);
! 			}
! 		}
! 	}
! 
! 	function save_question($authorizedquestion, $form) {
! 		$question = qtype_multianswer_extract_question($form->questiontext);
! 		if (isset($authorizedquestion->id)) {
! 			$question->id = $authorizedquestion->id;
! 		}
! 
! 		$question->category = $authorizedquestion->category;
! 		$form->defaultgrade = $question->defaultgrade;
! 		$form->questiontext = $question->questiontext;
! 		$form->questiontextformat = 0;
! 		$form->options = clone($question->options);
! 		unset($question->options);
! 		return parent::save_question($question, $form);
! 	}
! 
! 	function create_session_and_responses(&$question, &$state, $cmoptions, $attempt) {
! 		$state->responses = array();
! 		foreach ($question->options->questions as $key => $wrapped) {
! 			$state->responses[$key] = '';
! 		}
! 		return true;
! 	}
! 
! 	function restore_session_and_responses(&$question, &$state) {
! 		$responses = explode(',', $state->responses['']);
! 		$state->responses = array();
! 		foreach ($responses as $response) {
! 			$tmp = explode("-", $response);
! 			// restore encoded characters
! 			$state->responses[$tmp[0]] = str_replace(array("&#0044;", "&#0045;"),
! 			array(",", "-"), $tmp[1]);
! 		}
! 		return true;
! 	}
! 
! 	function save_session_and_responses(&$question, &$state) {
! 		global $DB;
! 		$responses = $state->responses;
! 		// encode - (hyphen) and , (comma) to &#0045; because they are used as
! 		// delimiters
! 		array_walk($responses, create_function('&$val, $key',
                  '$val = str_replace(array(",", "-"), array("&#0044;", "&#0045;"), $val);
                  $val = "$key-$val";'));
! 		$responses = implode(',', $responses);
  
! 		// Set the legacy answer field
! 		$DB->set_field('question_states', 'answer', $responses, array('id' => $state->id));
! 		return true;
! 	}
! 
! 	function delete_question($questionid, $contextid) {
! 		global $DB;
! 		$DB->delete_records("question_multianswer", array("question" => $questionid));
! 
! 		parent::delete_question($questionid, $contextid);
! 	}
! 
! 	function get_correct_responses(&$question, &$state) {
! 		global $QTYPES;
! 		$responses = array();
! 		foreach($question->options->questions as $key => $wrapped) {
! 			if (!empty($wrapped)){
! 				if ($correct = $QTYPES[$wrapped->qtype]->get_correct_responses($wrapped, $state)) {
! 					$responses[$key] = $correct[''];
! 				} else {
! 					// if there is no correct answer to this subquestion then there
! 					// can not be a correct answer to the whole question either, so
! 					// we have to return null.
! 					return null;
! 				}
! 			}
! 		}
! 		return $responses;
! 	}
! 
! 	function get_possible_responses(&$question) {
! 		global $QTYPES;
! 		$responses = array();
! 		foreach($question->options->questions as $key => $wrapped) {
! 			if (!empty($wrapped)){
! 				if ($correct = $QTYPES[$wrapped->qtype]->get_possible_responses($wrapped)) {
! 					$responses += $correct;
! 				} else {
! 					// if there is no correct answer to this subquestion then there
! 					// can not be a correct answer to the whole question either, so
! 					// we have to return null.
! 					return null;
! 				}
! 			}
! 		}
! 		return $responses;
! 	}
! 	function get_actual_response_details($question, $state){
! 		global $QTYPES;
! 		$details = array();
! 		foreach($question->options->questions as $key => $wrapped) {
! 			if (!empty($wrapped)){
! 				$stateforquestion = clone($state);
! 				$stateforquestion->responses[''] = $state->responses[$key];
! 				$details = array_merge($details, $QTYPES[$wrapped->qtype]->get_actual_response_details($wrapped, $stateforquestion));
! 			}
! 		}
! 		return $details;
! 	}
! 
! 	function get_html_head_contributions(&$question, &$state) {
! 		global $PAGE;
! 		parent::get_html_head_contributions($question, $state);
! 		$PAGE->requires->js('/lib/overlib/overlib.js', true);
! 		$PAGE->requires->js('/lib/overlib/overlib_cssstyle.js', true);
! 	}
! 
! 	function print_question_formulation_and_controls(&$question, &$state, $cmoptions, $options) {
! 		global $QTYPES, $CFG, $USER, $OUTPUT, $PAGE;
! 
! 		$readonly = empty($options->readonly) ? '' : 'readonly="readonly"';
! 		$disabled = empty($options->readonly) ? '' : 'disabled="disabled"';
! 		$formatoptions = new stdClass;
! 		$formatoptions->noclean = true;
! 		$formatoptions->para = false;
! 		$nameprefix = $question->name_prefix;
! 
! 		// adding an icon with alt to warn user this is a fill in the gap question
! 		// MDL-7497
! 		if (!empty($USER->screenreader)) {
! 			echo "<img src=\"".$OUTPUT->pix_url('icon', 'qtype_'.$question->qtype)."\" ".
                  "class=\"icon\" alt=\"".get_string('clozeaid','qtype_multichoice')."\" />  ";
! 		}
  
! 		echo '<div class="ablock clearfix">';
  
! 		$qtextremaining = format_text($question->questiontext,
! 		$question->questiontextformat, $formatoptions, $cmoptions->course);
! 		 
! 		$questiontext1 = $this->format_text($question->questiontext,
! 		0, $cmoptions);
! 		 
! 		$question_= explode(":", $questiontext1);
! 		echo $question1="MMMM";
! 		echo "nn".$question1;
! 		$_SESSION['content'].="&nbsp;&nbsp;&nbsp;&nbsp;aa$question1</b></td></tr>";
! 		$strfeedback = get_string('feedback', 'quiz');
! 
! 		// The regex will recognize text snippets of type {#X}
! 		// where the X can be any text not containg } or white-space characters.
! 		while (preg_match('~\{#([^[:space:]}]*)}~', $qtextremaining, $regs)) {
! 			$qtextsplits = explode($regs[0], $qtextremaining, 2);
! 			echo  $qtextsplits[0];
! 			$subQuest=$qtextsplits[0];
! 			$_SESSION['content'].="<tr><td><table><tr><td>". "hh"."</td>";
! 
! 			echo "<label>"; // MDL-7497
! 			$qtextremaining = $qtextsplits[1];
! 
! 			$positionkey = $regs[1];
! 			if (isset($question->options->questions[$positionkey]) && $question->options->questions[$positionkey] != ''){
! 				$wrapped = &$question->options->questions[$positionkey];
! 				$answers = &$wrapped->options->answers;
! 				// $correctanswers = $QTYPES[$wrapped->qtype]->get_correct_responses($wrapped, $state);
! 
! 				$inputname = $nameprefix.$positionkey;
! 				if (isset($state->responses[$positionkey])) {
! 					$response = $state->responses[$positionkey];
! 				} else {
! 					$response = null;
! 				}
! 				//   echo "<p> multianswer positionkey $positionkey response $response state  <pre>";print_r($state);echo "</pre></p>";
! 
! 				// Determine feedback popup if any
! 				$popup = '';
! 				$style = '';
! 				$feedbackimg = '';
! 				$feedback = '' ;
! 				$correctanswer = '';
! 				$strfeedbackwrapped  = $strfeedback;
! 				$testedstate = clone($state);
! 				if ($correctanswers =  $QTYPES[$wrapped->qtype]->get_correct_responses($wrapped, $state)) {
! 					if ($options->readonly && $options->correct_responses) {
! 						$delimiter = '';
! 						if ($correctanswers) {
! 							foreach ($correctanswers as $ca) {
! 								switch($wrapped->qtype){
! 									case 'numerical':
! 									case 'shortanswer':
! 										$correctanswer .= $delimiter.$ca;
! 										break ;
! 									case 'multichoice':
! 										if (isset($answers[$ca])){
! 											$correctanswer .= $delimiter.$answers[$ca]->answer;
! 										}
! 										break ;
! 								}
! 								$delimiter = ', ';
! 							}
! 						}
! 					}
! 					if ($correctanswer != '' ) {
! 						$feedback = '<div class="correctness">';
! 						$feedback .= get_string('correctansweris', 'quiz', s($correctanswer));
! 						$feedback .= '</div>';
! 
! 					}
! 				}
! 
! 				if ($options->feedback) {
! 					$chosenanswer = null;
! 					switch ($wrapped->qtype) {
! 						case 'numerical':
! 						case 'shortanswer':
! 							$testedstate = clone($state);
! 							$testedstate->responses[''] = $response;
! 							foreach ($answers as $answer) {
! 								if($QTYPES[$wrapped->qtype]
! 								->test_response($wrapped, $testedstate, $answer)) {
! 									$chosenanswer = clone($answer);
! 									break;
! 								}
! 							}
! 							break;
! 						case 'multichoice':
! 							if (isset($answers[$response])) {
! 								$chosenanswer = clone($answers[$response]);
! 							}
! 							break;
! 						default:
! 							break;
! 					}
! 
! 					// Set up a default chosenanswer so that all non-empty wrong
! 					// answers are highlighted red
! 					if (empty($chosenanswer) && $response != '') {
! 						$chosenanswer = new stdClass;
! 						$chosenanswer->fraction = 0.0;
! 					}
! 
! 					if (!empty($chosenanswer->feedback)) {
! 						$feedback = s(str_replace(array("\\", "'"), array("\\\\", "\\'"), $feedback.$chosenanswer->feedback));
! 						if  ($options->readonly && $options->correct_responses) {
! 							$strfeedbackwrapped = get_string('correctanswerandfeedback', 'qtype_multianswer');
! 						}else {
! 							$strfeedbackwrapped = get_string('feedback', 'quiz');
! 						}
! 						$popup = " onmouseover=\"return overlib('$feedback', STICKY, MOUSEOFF, CAPTION, '$strfeedbackwrapped', FGCOLOR, '#FFFFFF');\" ".
                               " onmouseout=\"return nd();\" ";
! 					}
  
! 					/// Determine style
! 					if ($options->feedback && $response != '') {
! 						$style = 'class = "'.question_get_feedback_class($chosenanswer->fraction).'"';
! 						$feedbackimg = question_get_feedback_image($chosenanswer->fraction);
! 					} else {
! 						$style = '';
! 						$feedbackimg = '';
! 					}
! 				}
! 				if ($feedback !='' && $popup == ''){
! 					$strfeedbackwrapped = get_string('correctanswer', 'qtype_multianswer');
! 					$feedback = s(str_replace(array("\\", "'"), array("\\\\", "\\'"), $feedback));
! 					$popup = " onmouseover=\"return overlib('$feedback', STICKY, MOUSEOFF, CAPTION, '$strfeedbackwrapped', FGCOLOR, '#FFFFFF');\" ".
                               " onmouseout=\"return nd();\" ";
! 				}
  
! 				// Print the input control
! 				switch ($wrapped->qtype) {
! 					//
! 					case 'shortanswer':
! 					case 'numerical':
! 						$size = 1 ;
! 						foreach ($answers as $answer) {
! 							 
! 							if (strlen(trim($answer->answer)) > $size ){
! 								$size = strlen(trim($answer->answer));
! 							}
! 						}
! 
! 						if (strlen(trim($response))> $size ){
! 							$size = strlen(trim($response))+1;
! 						}
! 						$size = $size + rand(0,$size*0.15);
! 						$size > 60 ? $size = 60 : $size = $size;
! 						$styleinfo = "size=\"$size\"";
! 						/**
! 						 * Uncomment the following lines if you want to limit for small sizes.
! 						 * Results may vary with browsers see MDL-3274
! 						 */
! 						/*
! 						 if ($size < 2) {
! 						 $styleinfo = 'style="width: 1.1em;"';
! 						 }
! 						 if ($size == 2) {
! 						 $styleinfo = 'style="width: 1.9em;"';
! 						 }
! 						 if ($size == 3) {
! 						 $styleinfo = 'style="width: 2.3em;"';
! 						 }
! 						 if ($size == 4) {
! 						 $styleinfo = 'style="width: 2.8em;"';
! 						 }
! 						 */
! 
! 						echo "<input $style $readonly $popup name=\"$inputname\"";
! 						echo "  type=\"text\" value=\"".s($response)."\" ".$styleinfo." /> ";
! 						if (!empty($feedback) && !empty($USER->screenreader)) {
! 							echo "<img src=\"" . $OUTPUT->pix_url('i/feedback') . "\" alt=\"$feedback\" />";
! 						}
! 						echo $feedbackimg;
! 						break;
! 					case 'multichoice':
! 
! 						if ($wrapped->options->layout == 0 ){
! 							$outputoptions = '<option></option>'; // Default empty option
! 							foreach ($answers as $mcanswer) {
! 								$selected = '';
! 								if ($response == $mcanswer->id) {
! 									$selected = ' selected="selected"';
! 									// echo $mcanswer->answer;
! 								}
! 								$outputoptions .= "<option value=\"$mcanswer->id\"$selected>" .
! 								s($mcanswer->answer) . '</option>';
! 							}
! 							// In the next line, $readonly is invalid HTML, but it works in
! 							// all browsers. $disabled would be valid, but then the JS for
! 							// displaying the feedback does not work. Of course, we should
! 							// not be relying on JS (for accessibility reasons), but that is
! 							// a bigger problem.
! 							//
! 							// The span is used for safari, which does not allow styling of
! 							// selects.
! 							echo "<span $style><select $popup $readonly $style name=\"$inputname\">";
! 							echo $outputoptions;
! 							echo '</select></span>';
! 							if (!empty($feedback) && !empty($USER->screenreader)) {
! 								echo "<img src=\"" . $OUTPUT->pix_url('i/feedback') . "\" alt=\"$feedback\" />";
! 							}
! 							echo $feedbackimg;
! 						}else if ($wrapped->options->layout == 1 || $wrapped->options->layout == 2){
! 							$ordernumber=0;
! 							$anss =  Array();
! 							foreach ($answers as $mcanswer) {
! 								$ordernumber++;
! 								$checked = '';
! 								$chosen = false;
! 								$type = 'type="radio"';
! 								$name   = "name=\"{$inputname}\"";
! 								if ($response == $mcanswer->id) {
! 									$checked = 'checked="checked"';
! 									$chosen = true;
! 								}
! 								$a = new stdClass;
! 								$a->id   = $question->name_prefix . $mcanswer->id;
! 								$a->class = '';
! 								$a->feedbackimg = '';
! 
! 								// Print the control
! 								$a->control = "<input $readonly id=\"$a->id\" $name $checked $type value=\"$mcanswer->id\" />";
! 								if ($options->correct_responses && $mcanswer->fraction > 0) {
! 									$a->class = question_get_feedback_class(1);
! 								}
! 								if (($options->feedback && $chosen) || $options->correct_responses) {
! 									if ($type == ' type="checkbox" ') {
! 										$a->feedbackimg = question_get_feedback_image($mcanswer->fraction > 0 ? 1 : 0, $chosen && $options->feedback);
! 									} else {
! 										$a->feedbackimg = question_get_feedback_image($mcanswer->fraction, $chosen && $options->feedback);
! 									}
! 								}
! 
! 								// Print the answer text: no automatic numbering
! 
! 								$a->text = format_text($mcanswer->answer, $mcanswer->answerformat, $formatoptions, $cmoptions->course);
! 
! 								// Print feedback if feedback is on
! 								if (($options->feedback || $options->correct_responses) && ($checked )) { //|| $options->readonly
! 									$a->feedback = format_text($mcanswer->feedback, $mcanswer->feedbackformat, $formatoptions, $cmoptions->course);
! 								} else {
! 									$a->feedback = '';
! 								}
! 
! 								$anss[] = clone($a);
! 							}
! 							?>
! 							<?php    if ($wrapped->options->layout == 1 ){
! 								?>
! <table class="answer">
! <?php $row = 1; foreach ($anss as $answer) { ?>
! 	<tr class="<?php echo 'r'.$row = $row ? 0 : 1; ?>">
! 		<td class="c0 control"><?php echo $answer->control; ?>
! 		</td>
! 		<td class="c1 text <?php echo $answer->class ?>"><label
! 			for="<?php echo $answer->id ?>"> <?php echo $answer->text; ?> <?php echo $answer->feedbackimg; ?>
! 		</label>
! 		</td>
! 		<td class="c0 feedback"><?php echo $answer->feedback; ?>
! 		</td>
! 	</tr>
! 	<?php } ?>
! </table>
! 	<?php }else  if ($wrapped->options->layout == 2 ){
! 		?>
! 
! <table class="answer">
! 	<tr class="<?php echo 'r'.$row = $row ? 0 : 1; ?>">
! 	<?php $row = 1; foreach ($anss as $answer) { ?>
! 		<td class="c0 control"><?php echo $answer->control; ?>
! 		</td>
! 		<td class="c1 text <?php echo $answer->class ?>"><label
! 			for="<?php echo $answer->id ?>"> <?php echo $answer->text; ?> <?php echo $answer->feedbackimg; ?>
! 		</label>
! 		</td>
! 		<td class="c0 feedback"><?php echo $answer->feedback; ?>
! 		</td>
! 		<?php } ?>
! 	</tr>
! </table>
! 		<?php }
! 
! 						}else {
! 							echo "no valid layout";
! 						}
! 
! 						break;
! default:
! 	$a = new stdClass;
! 	$a->type = $wrapped->qtype ;
! 	$a->sub = $positionkey;
! 	print_error('unknownquestiontypeofsubquestion', 'qtype_multianswer','',$a);
! 	break;
! 				}
! 				foreach ($answers as $mcanswer) {
! 					 
! 					if ($response == $mcanswer->id) {
! 						echo $mcanswer->answer; $_SESSION['content'].="<td>".$mcanswer->answer."</td></tr></table></td></tr>";
! 							
! 						 
! 					}
! 				}
! 
! 				echo "</label>"; // MDL-7497
! 			}
! 			else {
! 				if(!  isset($question->options->questions[$positionkey])){
! 					echo $regs[0]."</label>";
! 				}else {
! 					echo '</label><div class="error" >'.get_string('questionnotfound','qtype_multianswer',$positionkey).'</div>';
! 				}
! 			}
! 		}
! 
! 		// Print the final piece of question text:
! 		echo $qtextremaining;
! 		$this->print_question_submit_buttons($question, $state, $cmoptions, $options);
! 		echo '</div>';
! 	}
! 
! 	public function compare_responses($question, $state, $teststate) {
! 		global $QTYPES;
! 
! 		foreach ($question->options->questions as $key => $wrapped) {
! 			if (empty($wrapped)) {
! 				continue;
! 			}
! 
! 			$stateforquestion = clone($state);
! 			if (isset($state->responses[$key])) {
! 				$stateforquestion->responses[''] = $state->responses[$key];
! 			} else {
! 				$stateforquestion->responses[''] = '';
! 			}
! 
! 			$teststateforquestion = clone($teststate);
! 			if (isset($teststate->responses[$key])) {
! 				$teststateforquestion->responses[''] = $teststate->responses[$key];
! 			} else {
! 				$teststateforquestion->responses[''] = '';
! 			}
! 
! 			if ($wrapped->qtype == 'numerical') {
! 				// Use shortanswer
! 				if (!$QTYPES['shortanswer']->compare_responses($wrapped,
! 				$stateforquestion, $teststateforquestion)) {
! 					return false;
! 				}
! 			} else {
! 				if (!$QTYPES[$wrapped->qtype]->compare_responses($wrapped,
! 				$stateforquestion, $teststateforquestion)) {
! 					return false;
! 				}
! 			}
! 		}
! 
! 		return true;
! 	}
! 
! 	function grade_responses(&$question, &$state, $cmoptions) {
! 		global $QTYPES;
! 		$teststate = clone($state);
! 		$state->raw_grade = 0;
! 		foreach($question->options->questions as $key => $wrapped) {
! 			if (!empty($wrapped)){
! 				if(isset($state->responses[$key])){
! 					$state->responses[$key] = $state->responses[$key];
! 				}else {
! 					$state->responses[$key] = '' ;
! 				}
! 				$teststate->responses = array('' => $state->responses[$key]);
! 				$teststate->raw_grade = 0;
! 				if (false === $QTYPES[$wrapped->qtype]
! 				->grade_responses($wrapped, $teststate, $cmoptions)) {
! 					return false;
! 				}
! 				$state->raw_grade += $teststate->raw_grade;
! 			}
! 		}
! 		$state->raw_grade /= $question->defaultgrade;
! 		$state->raw_grade = min(max((float) $state->raw_grade, 0.0), 1.0)
! 		* $question->maxgrade;
! 
! 		if (empty($state->raw_grade)) {
! 			$state->raw_grade = 0.0;
! 		}
! 		$state->penalty = $question->penalty * $question->maxgrade;
! 
! 		// mark the state as graded
! 		$state->event = ($state->event ==  QUESTION_EVENTCLOSE) ? QUESTION_EVENTCLOSEANDGRADE : QUESTION_EVENTGRADE;
! 
! 		return true;
! 	}
! 
! 	function get_actual_response($question, $state) {
! 		global $QTYPES;
! 		$teststate = clone($state);
! 		foreach($question->options->questions as $key => $wrapped) {
! 			$state->responses[$key] = html_entity_decode($state->responses[$key]);
! 			$teststate->responses = array('' => $state->responses[$key]);
! 			$correct = $QTYPES[$wrapped->qtype]
! 			->get_actual_response($wrapped, $teststate);
! 			$responses[$key] = implode(';', $correct);
! 		}
! 		return $responses;
! 	}
! 
! 	/**
! 	 * @param object $question
! 	 * @return mixed either a integer score out of 1 that the average random
! 	 * guess by a student might give or an empty string which means will not
! 	 * calculate.
! 	 */
! 	function get_random_guess_score($question) {
! 		$totalfraction = 0;
! 		foreach (array_keys($question->options->questions) as $key){
! 			$totalfraction += question_get_random_guess_score($question->options->questions[$key]);
! 		}
! 		return $totalfraction / count($question->options->questions);
! 	}
! 
! 	/**
! 	 * Runs all the code required to set up and save an essay question for testing purposes.
! 	 * Alternate DB table prefix may be used to facilitate data deletion.
! 	 */
! 	function generate_test($name, $courseid = null) {
! 		global $DB;
! 		list($form, $question) = parent::generate_test($name, $courseid);
! 		$question->category = $form->category;
! 		$form->questiontext = "This question consists of some text with an answer embedded right here {1:MULTICHOICE:Wrong answer#Feedback for this wrong answer~Another wrong answer#Feedback for the other wrong answer~=Correct answer#Feedback for correct answer~%50%Answer that gives half the credit#Feedback for half credit answer} and right after that you will have to deal with this short answer {1:SHORTANSWER:Wrong answer#Feedback for this wrong answer~=Correct answer#Feedback for correct answer~%50%Answer that gives half the credit#Feedback for half credit answer} and finally we have a floating point number {2:NUMERICAL:=23.8:0.1#Feedback for correct answer 23.8~%50%23.8:2#Feedback for half credit answer in the nearby region of the correct answer}.
  
  Note that addresses like www.moodle.org and smileys :-) all work as normal:
   a) How good is this? {:MULTICHOICE:=Yes#Correct~No#We have a different opinion}
***************
*** 712,729 ****
  
  Good luck!
  ";
!         $form->feedback = "feedback";
!         $form->generalfeedback = "General feedback";
!         $form->fraction = 0;
!         $form->penalty = 0.1;
!         $form->versioning = 0;
! 
!         if ($courseid) {
!             $course = $DB->get_record('course', array('id' => $courseid));
!         }
  
!         return $this->save_question($question, $form);
!     }
  
  }
  //// END OF CLASS ////
--- 729,746 ----
  
  Good luck!
  ";
! 		$form->feedback = "feedback";
! 		$form->generalfeedback = "General feedback";
! 		$form->fraction = 0;
! 		$form->penalty = 0.1;
! 		$form->versioning = 0;
! 
! 		if ($courseid) {
! 			$course = $DB->get_record('course', array('id' => $courseid));
! 		}
  
! 		return $this->save_question($question, $form);
! 	}
  
  }
  //// END OF CLASS ////
***************
*** 780,790 ****
         '\{([0-9]*):(' . ANSWER_TYPE_DEF_REGEX . '):');
  
  define("ANSWER_REGEX",
!         ANSWER_START_REGEX
!         . '(' . ANSWER_ALTERNATIVE_REGEX
!         . '(~'
!         . ANSWER_ALTERNATIVE_REGEX
!         . ')*)\}' );
  
  // Parenthesis positions for singulars in ANSWER_REGEX
  define("ANSWER_REGEX_NORM", 1);
--- 797,807 ----
         '\{([0-9]*):(' . ANSWER_TYPE_DEF_REGEX . '):');
  
  define("ANSWER_REGEX",
! ANSWER_START_REGEX
! . '(' . ANSWER_ALTERNATIVE_REGEX
! . '(~'
! . ANSWER_ALTERNATIVE_REGEX
! . ')*)\}' );
  
  // Parenthesis positions for singulars in ANSWER_REGEX
  define("ANSWER_REGEX_NORM", 1);
***************
*** 797,944 ****
  define("ANSWER_REGEX_ALTERNATIVES", 9);
  
  function qtype_multianswer_extract_question($text) {
!     // $text is an array [text][format][itemid]
!     $question = new stdClass;
!     $question->qtype = 'multianswer';
!     $question->questiontext = $text;
!     $question->generalfeedback['text'] = '';
!     $question->generalfeedback['format'] = '1';
!     $question->generalfeedback['itemid'] = '';
!     
!     $question->options->questions = array();    
!     $question->defaultgrade = 0; // Will be increased for each answer norm
! 
!     for ($positionkey=1; preg_match('/'.ANSWER_REGEX.'/', $question->questiontext['text'], $answerregs); ++$positionkey ) {
!         $wrapped = new stdClass;
!         $wrapped->generalfeedback['text'] = '';
!         $wrapped->generalfeedback['format'] = '1';
!         $wrapped->generalfeedback['itemid'] = '';
!         if (isset($answerregs[ANSWER_REGEX_NORM])&& $answerregs[ANSWER_REGEX_NORM]!== ''){
!             $wrapped->defaultgrade = $answerregs[ANSWER_REGEX_NORM];
!         } else {
!             $wrapped->defaultgrade = '1';
!         }
!         if (!empty($answerregs[ANSWER_REGEX_ANSWER_TYPE_NUMERICAL])) {
!             $wrapped->qtype = 'numerical';
!             $wrapped->multiplier = array();
!             $wrapped->units      = array();
!             $wrapped->instructions['text'] = '';
!             $wrapped->instructions['format'] = '1';
!             $wrapped->instructions['itemid'] = '';
!         } else if(!empty($answerregs[ANSWER_REGEX_ANSWER_TYPE_SHORTANSWER])) {
!             $wrapped->qtype = 'shortanswer';
!             $wrapped->usecase = 0;
!         } else if(!empty($answerregs[ANSWER_REGEX_ANSWER_TYPE_SHORTANSWER_C])) {
!             $wrapped->qtype = 'shortanswer';
!             $wrapped->usecase = 1;
!         } else if(!empty($answerregs[ANSWER_REGEX_ANSWER_TYPE_MULTICHOICE])) {
!             $wrapped->qtype = 'multichoice';
!             $wrapped->single = 1;
!             $wrapped->answernumbering = 0;
!             $wrapped->correctfeedback['text'] = '';
!             $wrapped->correctfeedback['format'] = '1';
!             $wrapped->correctfeedback['itemid'] = '';
!             $wrapped->partiallycorrectfeedback['text'] = '';
!             $wrapped->partiallycorrectfeedback['format'] = '1';
!             $wrapped->partiallycorrectfeedback['itemid'] = '';
!             $wrapped->incorrectfeedback['text'] = '';
!             $wrapped->incorrectfeedback['format'] = '1';
!             $wrapped->incorrectfeedback['itemid'] = '';
!             $wrapped->layout = 0;
!         } else if(!empty($answerregs[ANSWER_REGEX_ANSWER_TYPE_MULTICHOICE_REGULAR])) {
!             $wrapped->qtype = 'multichoice';
!             $wrapped->single = 1;
!             $wrapped->answernumbering = 0;
!             $wrapped->correctfeedback['text'] = '';
!             $wrapped->correctfeedback['format'] = '1';
!             $wrapped->correctfeedback['itemid'] = '';
!             $wrapped->partiallycorrectfeedback['text'] = '';
!             $wrapped->partiallycorrectfeedback['format'] = '1';
!             $wrapped->partiallycorrectfeedback['itemid'] = '';
!             $wrapped->incorrectfeedback['text'] = '';
!             $wrapped->incorrectfeedback['format'] = '1';
!             $wrapped->incorrectfeedback['itemid'] = '';
!             $wrapped->layout = 1;
!         } else if(!empty($answerregs[ANSWER_REGEX_ANSWER_TYPE_MULTICHOICE_HORIZONTAL])) {
!             $wrapped->qtype = 'multichoice';
!             $wrapped->single = 1;
!             $wrapped->answernumbering = 0;
!             $wrapped->correctfeedback['text'] = '';
!             $wrapped->correctfeedback['format'] = '1';
!             $wrapped->correctfeedback['itemid'] = '';
!             $wrapped->partiallycorrectfeedback['text'] = '';
!             $wrapped->partiallycorrectfeedback['format'] = '1';
!             $wrapped->partiallycorrectfeedback['itemid'] = '';
!             $wrapped->incorrectfeedback['text'] = '';
!             $wrapped->incorrectfeedback['format'] = '1';
!             $wrapped->incorrectfeedback['itemid'] = '';
!             $wrapped->layout = 2;
!         } else {
!             print_error('unknownquestiontype', 'question', '', $answerregs[2]);
!             return false;
!         }
! 
!         // Each $wrapped simulates a $form that can be processed by the
!         // respective save_question and save_question_options methods of the
!         // wrapped questiontypes
!         $wrapped->answer   = array();
!         $wrapped->fraction = array();
!         $wrapped->feedback = array();
!         $wrapped->shuffleanswers = 1;
!         $wrapped->questiontext['text'] = $answerregs[0];
!         $wrapped->questiontext['format'] = 0 ;
!         $wrapped->questiontext['itemid'] = '' ;
!         $answerindex = 0 ;
! 
!         $remainingalts = $answerregs[ANSWER_REGEX_ALTERNATIVES];
!         while (preg_match('/~?'.ANSWER_ALTERNATIVE_REGEX.'/', $remainingalts, $altregs)) {
!             if ('=' == $altregs[ANSWER_ALTERNATIVE_REGEX_FRACTION]) {
!                 $wrapped->fraction["$answerindex"] = '1';
!             } else if ($percentile = $altregs[ANSWER_ALTERNATIVE_REGEX_PERCENTILE_FRACTION]){
!                 $wrapped->fraction["$answerindex"] = .01 * $percentile;
!             } else {
!                 $wrapped->fraction["$answerindex"] = '0';
!             }
!             if (isset($altregs[ANSWER_ALTERNATIVE_REGEX_FEEDBACK])) {
!                 $feedback = html_entity_decode($altregs[ANSWER_ALTERNATIVE_REGEX_FEEDBACK], ENT_QUOTES, 'UTF-8');
!                 $feedback = str_replace('\}', '}', $feedback);
!                 $wrapped->feedback["$answerindex"]['text'] = str_replace('\#', '#', $feedback);
!                 $wrapped->feedback["$answerindex"]['format'] = '1';
!                 $wrapped->feedback["$answerindex"]['itemid'] = '';
!             } else {
!                 $wrapped->feedback["$answerindex"]['text'] = '';
!                 $wrapped->feedback["$answerindex"]['format'] = '1';
!                 $wrapped->feedback["$answerindex"]['itemid'] = '1';
! 
!             }
!             if (!empty($answerregs[ANSWER_REGEX_ANSWER_TYPE_NUMERICAL])
!                     && preg_match('~'.NUMERICAL_ALTERNATIVE_REGEX.'~', $altregs[ANSWER_ALTERNATIVE_REGEX_ANSWER], $numregs)) {
!                 $wrapped->answer[] = $numregs[NUMERICAL_CORRECT_ANSWER];
!                 if ($numregs[NUMERICAL_ABS_ERROR_MARGIN]) {
!                     $wrapped->tolerance["$answerindex"] =
!                     $numregs[NUMERICAL_ABS_ERROR_MARGIN];
!                 } else {
!                     $wrapped->tolerance["$answerindex"] = 0;
!                 }
!             } else { // Tolerance can stay undefined for non numerical questions
!                 // Undo quoting done by the HTML editor.
!                 $answer = html_entity_decode($altregs[ANSWER_ALTERNATIVE_REGEX_ANSWER], ENT_QUOTES, 'UTF-8');
!                 $answer = str_replace('\}', '}', $answer);
!                 $wrapped->answer["$answerindex"] = str_replace('\#', '#', $answer);
!             }
!             $tmp = explode($altregs[0], $remainingalts, 2);
!             $remainingalts = $tmp[1];
!             $answerindex++ ;
!         }
! 
!         $question->defaultgrade += $wrapped->defaultgrade;
!         $question->options->questions[$positionkey] = clone($wrapped);
!         $question->questiontext['text'] = implode("{#$positionkey}",
!                     explode($answerregs[0], $question->questiontext['text'], 2));
! //    echo"<p>questiontext 2 <pre>";print_r($question->questiontext);echo"<pre></p>";
!     }
! //    echo"<p>questiontext<pre>";print_r($question->questiontext);echo"<pre></p>";
!     $question->questiontext = $question->questiontext;
! //    echo"<p>question<pre>";print_r($question);echo"<pre></p>";
!     return $question;
  }
--- 814,961 ----
  define("ANSWER_REGEX_ALTERNATIVES", 9);
  
  function qtype_multianswer_extract_question($text) {
! 	// $text is an array [text][format][itemid]
! 	$question = new stdClass;
! 	$question->qtype = 'multianswer';
! 	$question->questiontext = $text;
! 	$question->generalfeedback['text'] = '';
! 	$question->generalfeedback['format'] = '1';
! 	$question->generalfeedback['itemid'] = '';
! 
! 	$question->options->questions = array();
! 	$question->defaultgrade = 0; // Will be increased for each answer norm
! 
! 	for ($positionkey=1; preg_match('/'.ANSWER_REGEX.'/', $question->questiontext['text'], $answerregs); ++$positionkey ) {
! 		$wrapped = new stdClass;
! 		$wrapped->generalfeedback['text'] = '';
! 		$wrapped->generalfeedback['format'] = '1';
! 		$wrapped->generalfeedback['itemid'] = '';
! 		if (isset($answerregs[ANSWER_REGEX_NORM])&& $answerregs[ANSWER_REGEX_NORM]!== ''){
! 			$wrapped->defaultgrade = $answerregs[ANSWER_REGEX_NORM];
! 		} else {
! 			$wrapped->defaultgrade = '1';
! 		}
! 		if (!empty($answerregs[ANSWER_REGEX_ANSWER_TYPE_NUMERICAL])) {
! 			$wrapped->qtype = 'numerical';
! 			$wrapped->multiplier = array();
! 			$wrapped->units      = array();
! 			$wrapped->instructions['text'] = '';
! 			$wrapped->instructions['format'] = '1';
! 			$wrapped->instructions['itemid'] = '';
! 		} else if(!empty($answerregs[ANSWER_REGEX_ANSWER_TYPE_SHORTANSWER])) {
! 			$wrapped->qtype = 'shortanswer';
! 			$wrapped->usecase = 0;
! 		} else if(!empty($answerregs[ANSWER_REGEX_ANSWER_TYPE_SHORTANSWER_C])) {
! 			$wrapped->qtype = 'shortanswer';
! 			$wrapped->usecase = 1;
! 		} else if(!empty($answerregs[ANSWER_REGEX_ANSWER_TYPE_MULTICHOICE])) {
! 			$wrapped->qtype = 'multichoice';
! 			$wrapped->single = 1;
! 			$wrapped->answernumbering = 0;
! 			$wrapped->correctfeedback['text'] = '';
! 			$wrapped->correctfeedback['format'] = '1';
! 			$wrapped->correctfeedback['itemid'] = '';
! 			$wrapped->partiallycorrectfeedback['text'] = '';
! 			$wrapped->partiallycorrectfeedback['format'] = '1';
! 			$wrapped->partiallycorrectfeedback['itemid'] = '';
! 			$wrapped->incorrectfeedback['text'] = '';
! 			$wrapped->incorrectfeedback['format'] = '1';
! 			$wrapped->incorrectfeedback['itemid'] = '';
! 			$wrapped->layout = 0;
! 		} else if(!empty($answerregs[ANSWER_REGEX_ANSWER_TYPE_MULTICHOICE_REGULAR])) {
! 			$wrapped->qtype = 'multichoice';
! 			$wrapped->single = 1;
! 			$wrapped->answernumbering = 0;
! 			$wrapped->correctfeedback['text'] = '';
! 			$wrapped->correctfeedback['format'] = '1';
! 			$wrapped->correctfeedback['itemid'] = '';
! 			$wrapped->partiallycorrectfeedback['text'] = '';
! 			$wrapped->partiallycorrectfeedback['format'] = '1';
! 			$wrapped->partiallycorrectfeedback['itemid'] = '';
! 			$wrapped->incorrectfeedback['text'] = '';
! 			$wrapped->incorrectfeedback['format'] = '1';
! 			$wrapped->incorrectfeedback['itemid'] = '';
! 			$wrapped->layout = 1;
! 		} else if(!empty($answerregs[ANSWER_REGEX_ANSWER_TYPE_MULTICHOICE_HORIZONTAL])) {
! 			$wrapped->qtype = 'multichoice';
! 			$wrapped->single = 1;
! 			$wrapped->answernumbering = 0;
! 			$wrapped->correctfeedback['text'] = '';
! 			$wrapped->correctfeedback['format'] = '1';
! 			$wrapped->correctfeedback['itemid'] = '';
! 			$wrapped->partiallycorrectfeedback['text'] = '';
! 			$wrapped->partiallycorrectfeedback['format'] = '1';
! 			$wrapped->partiallycorrectfeedback['itemid'] = '';
! 			$wrapped->incorrectfeedback['text'] = '';
! 			$wrapped->incorrectfeedback['format'] = '1';
! 			$wrapped->incorrectfeedback['itemid'] = '';
! 			$wrapped->layout = 2;
! 		} else {
! 			print_error('unknownquestiontype', 'question', '', $answerregs[2]);
! 			return false;
! 		}
! 
! 		// Each $wrapped simulates a $form that can be processed by the
! 		// respective save_question and save_question_options methods of the
! 		// wrapped questiontypes
! 		$wrapped->answer   = array();
! 		$wrapped->fraction = array();
! 		$wrapped->feedback = array();
! 		$wrapped->shuffleanswers = 1;
! 		$wrapped->questiontext['text'] = $answerregs[0];
! 		$wrapped->questiontext['format'] = 0 ;
! 		$wrapped->questiontext['itemid'] = '' ;
! 		$answerindex = 0 ;
! 
! 		$remainingalts = $answerregs[ANSWER_REGEX_ALTERNATIVES];
! 		while (preg_match('/~?'.ANSWER_ALTERNATIVE_REGEX.'/', $remainingalts, $altregs)) {
! 			if ('=' == $altregs[ANSWER_ALTERNATIVE_REGEX_FRACTION]) {
! 				$wrapped->fraction["$answerindex"] = '1';
! 			} else if ($percentile = $altregs[ANSWER_ALTERNATIVE_REGEX_PERCENTILE_FRACTION]){
! 				$wrapped->fraction["$answerindex"] = .01 * $percentile;
! 			} else {
! 				$wrapped->fraction["$answerindex"] = '0';
! 			}
! 			if (isset($altregs[ANSWER_ALTERNATIVE_REGEX_FEEDBACK])) {
! 				$feedback = html_entity_decode($altregs[ANSWER_ALTERNATIVE_REGEX_FEEDBACK], ENT_QUOTES, 'UTF-8');
! 				$feedback = str_replace('\}', '}', $feedback);
! 				$wrapped->feedback["$answerindex"]['text'] = str_replace('\#', '#', $feedback);
! 				$wrapped->feedback["$answerindex"]['format'] = '1';
! 				$wrapped->feedback["$answerindex"]['itemid'] = '';
! 			} else {
! 				$wrapped->feedback["$answerindex"]['text'] = '';
! 				$wrapped->feedback["$answerindex"]['format'] = '1';
! 				$wrapped->feedback["$answerindex"]['itemid'] = '1';
! 
! 			}
! 			if (!empty($answerregs[ANSWER_REGEX_ANSWER_TYPE_NUMERICAL])
! 			&& preg_match('~'.NUMERICAL_ALTERNATIVE_REGEX.'~', $altregs[ANSWER_ALTERNATIVE_REGEX_ANSWER], $numregs)) {
! 				$wrapped->answer[] = $numregs[NUMERICAL_CORRECT_ANSWER];
! 				if ($numregs[NUMERICAL_ABS_ERROR_MARGIN]) {
! 					$wrapped->tolerance["$answerindex"] =
! 					$numregs[NUMERICAL_ABS_ERROR_MARGIN];
! 				} else {
! 					$wrapped->tolerance["$answerindex"] = 0;
! 				}
! 			} else { // Tolerance can stay undefined for non numerical questions
! 				// Undo quoting done by the HTML editor.
! 				$answer = html_entity_decode($altregs[ANSWER_ALTERNATIVE_REGEX_ANSWER], ENT_QUOTES, 'UTF-8');
! 				$answer = str_replace('\}', '}', $answer);
! 				$wrapped->answer["$answerindex"] = str_replace('\#', '#', $answer);
! 			}
! 			$tmp = explode($altregs[0], $remainingalts, 2);
! 			$remainingalts = $tmp[1];
! 			$answerindex++ ;
! 		}
! 
! 		$question->defaultgrade += $wrapped->defaultgrade;
! 		$question->options->questions[$positionkey] = clone($wrapped);
! 		$question->questiontext['text'] = implode("{#$positionkey}",
! 		explode($answerregs[0], $question->questiontext['text'], 2));
! 		//    echo"<p>questiontext 2 <pre>";print_r($question->questiontext);echo"<pre></p>";
! 	}
! 	//    echo"<p>questiontext<pre>";print_r($question->questiontext);echo"<pre></p>";
! 	$question->questiontext = $question->questiontext;
! 	//    echo"<p>question<pre>";print_r($question);echo"<pre></p>";
! 	return $question;
  }
diff -crB questionorg/type/multichoice/backup/moodle2/backup_qtype_multichoice_plugin.class.php questionupd/type/multichoice/backup/moodle2/backup_qtype_multichoice_plugin.class.php
*** questionorg/type/multichoice/backup/moodle2/backup_qtype_multichoice_plugin.class.php	2012-04-13 12:31:13.971178307 +0500
--- questionupd/type/multichoice/backup/moodle2/backup_qtype_multichoice_plugin.class.php	2012-04-13 09:42:57.000000000 +0500
***************
*** 28,85 ****
   */
  class backup_qtype_multichoice_plugin extends backup_qtype_plugin {
  
!     /**
!      * Returns the qtype information to attach to question element
!      */
!     protected function define_question_plugin_structure() {
! 
!         // Define the virtual plugin element with the condition to fulfill
!         $plugin = $this->get_plugin_element(null, '../../qtype', 'multichoice');
! 
!         // Create one standard named plugin element (the visible container)
!         $pluginwrapper = new backup_nested_element($this->get_recommended_name());
! 
!         // connect the visible container ASAP
!         $plugin->add_child($pluginwrapper);
! 
!         // This qtype uses standard question_answers, add them here
!         // to the tree before any other information that will use them
!         $this->add_question_question_answers($pluginwrapper);
  
!         // Now create the qtype own structures
!         $multichoice = new backup_nested_element('multichoice', array('id'), array(
              'layout', 'answers', 'single', 'shuffleanswers',
              'correctfeedback', 'correctfeedbackformat', 'partiallycorrectfeedback', 'partiallycorrectfeedbackformat',
              'incorrectfeedback', 'incorrectfeedbackformat', 'answernumbering'));
  
!         // Now the own qtype tree
!         $pluginwrapper->add_child($multichoice);
  
!         // set source to populate the data
!         $multichoice->set_source_table('question_multichoice', array('question' => backup::VAR_PARENTID));
  
!         // don't need to annotate ids nor files
  
!         return $plugin;
!     }
! 
!     /**
!      * Returns one array with filearea => mappingname elements for the qtype
!      *
!      * Used by {@link get_components_and_fileareas} to know about all the qtype
!      * files to be processed both in backup and restore.
!      */
!     public static function get_qtype_fileareas() {
!         // TODO: Discuss. Commented below are the "in theory" correct
!         // mappings for those fileareas. Instead we are using question for
!         // them, that will cause problems in the future if we want to change
!         // any of them to be 1..n (i.e. we should be always pointing to own id)
!         return array(
!             //'correctfeedback' => 'question_multichoice',
!             //'partiallycorrectfeedback' => 'question_multichoice',
!             //'incorrectfeedback' => 'question_multichoice');
              'correctfeedback' => 'question_created',
              'partiallycorrectfeedback' => 'question_created',
              'incorrectfeedback' => 'question_created');
!     }
  }
--- 28,85 ----
   */
  class backup_qtype_multichoice_plugin extends backup_qtype_plugin {
  
! 	/**
! 	 * Returns the qtype information to attach to question element
! 	 */
! 	protected function define_question_plugin_structure() {
! 
! 		// Define the virtual plugin element with the condition to fulfill
! 		$plugin = $this->get_plugin_element(null, '../../qtype', 'multichoice');
! 
! 		// Create one standard named plugin element (the visible container)
! 		$pluginwrapper = new backup_nested_element($this->get_recommended_name());
! 
! 		// connect the visible container ASAP
! 		$plugin->add_child($pluginwrapper);
! 
! 		// This qtype uses standard question_answers, add them here
! 		// to the tree before any other information that will use them
! 		$this->add_question_question_answers($pluginwrapper);
  
! 		// Now create the qtype own structures
! 		$multichoice = new backup_nested_element('multichoice', array('id'), array(
              'layout', 'answers', 'single', 'shuffleanswers',
              'correctfeedback', 'correctfeedbackformat', 'partiallycorrectfeedback', 'partiallycorrectfeedbackformat',
              'incorrectfeedback', 'incorrectfeedbackformat', 'answernumbering'));
  
! 		// Now the own qtype tree
! 		$pluginwrapper->add_child($multichoice);
  
! 		// set source to populate the data
! 		$multichoice->set_source_table('question_multichoice', array('question' => backup::VAR_PARENTID));
  
! 		// don't need to annotate ids nor files
  
! 		return $plugin;
! 	}
! 
! 	/**
! 	 * Returns one array with filearea => mappingname elements for the qtype
! 	 *
! 	 * Used by {@link get_components_and_fileareas} to know about all the qtype
! 	 * files to be processed both in backup and restore.
! 	 */
! 	public static function get_qtype_fileareas() {
! 		// TODO: Discuss. Commented below are the "in theory" correct
! 		// mappings for those fileareas. Instead we are using question for
! 		// them, that will cause problems in the future if we want to change
! 		// any of them to be 1..n (i.e. we should be always pointing to own id)
! 		return array(
! 		//'correctfeedback' => 'question_multichoice',
! 		//'partiallycorrectfeedback' => 'question_multichoice',
! 		//'incorrectfeedback' => 'question_multichoice');
              'correctfeedback' => 'question_created',
              'partiallycorrectfeedback' => 'question_created',
              'incorrectfeedback' => 'question_created');
! 	}
  }
diff -crB questionorg/type/multichoice/backup/moodle2/restore_qtype_multichoice_plugin.class.php questionupd/type/multichoice/backup/moodle2/restore_qtype_multichoice_plugin.class.php
*** questionorg/type/multichoice/backup/moodle2/restore_qtype_multichoice_plugin.class.php	2012-04-13 12:31:13.973178296 +0500
--- questionupd/type/multichoice/backup/moodle2/restore_qtype_multichoice_plugin.class.php	2012-04-13 09:42:57.000000000 +0500
***************
*** 30,137 ****
   */
  class restore_qtype_multichoice_plugin extends restore_qtype_plugin {
  
!     /**
!      * Returns the paths to be handled by the plugin at question level
!      */
!     protected function define_question_plugin_structure() {
! 
!         $paths = array();
! 
!         // This qtype uses question_answers, add them
!         $this->add_question_question_answers($paths);
! 
!         // Add own qtype stuff
!         $elename = 'multichoice';
!         $elepath = $this->get_pathfor('/multichoice'); // we used get_recommended_name() so this works
!         $paths[] = new restore_path_element($elename, $elepath);
! 
! 
!         return $paths; // And we return the interesting paths
!     }
! 
!     /**
!      * Process the qtype/multichoice element
!      */
!     public function process_multichoice($data) {
!         global $DB;
! 
!         $data = (object)$data;
!         $oldid = $data->id;
! 
!         // Detect if the question is created or mapped
!         $oldquestionid   = $this->get_old_parentid('question');
!         $newquestionid   = $this->get_new_parentid('question');
!         $questioncreated = $this->get_mappingid('question_created', $oldquestionid) ? true : false;
! 
!         // If the question has been created by restore, we need to create its question_multichoice too
!         if ($questioncreated) {
!             // Adjust some columns
!             $data->question = $newquestionid;
!             // Map sequence of question_answer ids
!             $answersarr = explode(',', $data->answers);
!             foreach ($answersarr as $key => $answer) {
!                 $answersarr[$key] = $this->get_mappingid('question_answer', $answer);
!             }
!             $data->answers = implode(',', $answersarr);
!             // Insert record
!             $newitemid = $DB->insert_record('question_multichoice', $data);
!             // Create mapping (needed for decoding links)
!             $this->set_mapping('question_multichoice', $oldid, $newitemid);
!         } else {
!             // Nothing to remap if the question already existed
!         }
!     }
! 
!     /**
!      * Given one question_states record, return the answer
!      * recoded pointing to all the restored stuff for multichoice questions
!      *
!      * answer are two (hypen speparated) lists of comma separated question_answers
!      * the first to specify the order of the answers and the second to specify the
!      * responses. Note the order list (the first one) can be optional
!      */
!     public function recode_state_answer($state) {
!         $answer = $state->answer;
!         $orderarr = array();
!         $responsesarr = array();
!         $lists = explode(':', $answer);
!         // if only 1 list, answer is missing the order list, adjust
!         if (count($lists) == 1) {
!             $lists[1] = $lists[0]; // here we have the responses
!             $lists[0] = '';        // here we have the order
!         }
!         // Map order
!         foreach (explode(',', $lists[0]) as $id) {
!             if (!empty($id) && $newid = $this->get_mappingid('question_answer', $id)) {
!                 $orderarr[] = $newid;
!             }
!         }
!         // Map responses
!         foreach (explode(',', $lists[1]) as $id) {
!             if (!empty($id) && $newid = $this->get_mappingid('question_answer', $id)) {
!                 $responsesarr[] = $newid;
!             }
!         }
!         // Build the final answer, if not order, only responses
!         $result = '';
!         if (empty($orderarr)) {
!             $result = implode(',', $responsesarr);
!         } else {
!             $result = implode(',', $orderarr) . ':' . implode(',', $responsesarr);
!         }
!         return $result;
!     }
! 
!     /**
!      * Return the contents of this qtype to be processed by the links decoder
!      */
!     static public function define_decode_contents() {
  
!         $contents = array();
  
!         $fields = array('correctfeedback', 'partiallycorrectfeedback', 'incorrectfeedback');
!         $contents[] = new restore_decode_content('question_multichoice', $fields, 'question_multichoice');
  
!         return $contents;
!     }
  }
--- 30,137 ----
   */
  class restore_qtype_multichoice_plugin extends restore_qtype_plugin {
  
! 	/**
! 	 * Returns the paths to be handled by the plugin at question level
! 	 */
! 	protected function define_question_plugin_structure() {
! 
! 		$paths = array();
! 
! 		// This qtype uses question_answers, add them
! 		$this->add_question_question_answers($paths);
! 
! 		// Add own qtype stuff
! 		$elename = 'multichoice';
! 		$elepath = $this->get_pathfor('/multichoice'); // we used get_recommended_name() so this works
! 		$paths[] = new restore_path_element($elename, $elepath);
! 
! 
! 		return $paths; // And we return the interesting paths
! 	}
! 
! 	/**
! 	 * Process the qtype/multichoice element
! 	 */
! 	public function process_multichoice($data) {
! 		global $DB;
! 
! 		$data = (object)$data;
! 		$oldid = $data->id;
! 
! 		// Detect if the question is created or mapped
! 		$oldquestionid   = $this->get_old_parentid('question');
! 		$newquestionid   = $this->get_new_parentid('question');
! 		$questioncreated = $this->get_mappingid('question_created', $oldquestionid) ? true : false;
! 
! 		// If the question has been created by restore, we need to create its question_multichoice too
! 		if ($questioncreated) {
! 			// Adjust some columns
! 			$data->question = $newquestionid;
! 			// Map sequence of question_answer ids
! 			$answersarr = explode(',', $data->answers);
! 			foreach ($answersarr as $key => $answer) {
! 				$answersarr[$key] = $this->get_mappingid('question_answer', $answer);
! 			}
! 			$data->answers = implode(',', $answersarr);
! 			// Insert record
! 			$newitemid = $DB->insert_record('question_multichoice', $data);
! 			// Create mapping (needed for decoding links)
! 			$this->set_mapping('question_multichoice', $oldid, $newitemid);
! 		} else {
! 			// Nothing to remap if the question already existed
! 		}
! 	}
! 
! 	/**
! 	 * Given one question_states record, return the answer
! 	 * recoded pointing to all the restored stuff for multichoice questions
! 	 *
! 	 * answer are two (hypen speparated) lists of comma separated question_answers
! 	 * the first to specify the order of the answers and the second to specify the
! 	 * responses. Note the order list (the first one) can be optional
! 	 */
! 	public function recode_state_answer($state) {
! 		$answer = $state->answer;
! 		$orderarr = array();
! 		$responsesarr = array();
! 		$lists = explode(':', $answer);
! 		// if only 1 list, answer is missing the order list, adjust
! 		if (count($lists) == 1) {
! 			$lists[1] = $lists[0]; // here we have the responses
! 			$lists[0] = '';        // here we have the order
! 		}
! 		// Map order
! 		foreach (explode(',', $lists[0]) as $id) {
! 			if (!empty($id) && $newid = $this->get_mappingid('question_answer', $id)) {
! 				$orderarr[] = $newid;
! 			}
! 		}
! 		// Map responses
! 		foreach (explode(',', $lists[1]) as $id) {
! 			if (!empty($id) && $newid = $this->get_mappingid('question_answer', $id)) {
! 				$responsesarr[] = $newid;
! 			}
! 		}
! 		// Build the final answer, if not order, only responses
! 		$result = '';
! 		if (empty($orderarr)) {
! 			$result = implode(',', $responsesarr);
! 		} else {
! 			$result = implode(',', $orderarr) . ':' . implode(',', $responsesarr);
! 		}
! 		return $result;
! 	}
! 
! 	/**
! 	 * Return the contents of this qtype to be processed by the links decoder
! 	 */
! 	static public function define_decode_contents() {
  
! 		$contents = array();
  
! 		$fields = array('correctfeedback', 'partiallycorrectfeedback', 'incorrectfeedback');
! 		$contents[] = new restore_decode_content('question_multichoice', $fields, 'question_multichoice');
  
! 		return $contents;
! 	}
  }
diff -crB questionorg/type/multichoice/db/install.xml questionupd/type/multichoice/db/install.xml
*** questionorg/type/multichoice/db/install.xml	2012-04-13 12:31:14.070178297 +0500
--- questionupd/type/multichoice/db/install.xml	2012-04-13 09:42:57.000000000 +0500
***************
*** 1,29 ****
  <?xml version="1.0" encoding="UTF-8" ?>
! <XMLDB PATH="question/type/multichoice/db" VERSION="20100716" COMMENT="XMLDB file for Moodle question/type/multichoice"
!     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
!     xsi:noNamespaceSchemaLocation="../../../../lib/xmldb/xmldb.xsd"
! >
!   <TABLES>
!     <TABLE NAME="question_multichoice" COMMENT="Options for multiple choice questions">
!       <FIELDS>
!         <FIELD NAME="id" TYPE="int" LENGTH="10" NOTNULL="true" UNSIGNED="true" SEQUENCE="true" NEXT="question"/>
!         <FIELD NAME="question" TYPE="int" LENGTH="10" NOTNULL="true" UNSIGNED="true" DEFAULT="0" SEQUENCE="false" COMMENT="Foreign key references question.id" PREVIOUS="id" NEXT="layout"/>
!         <FIELD NAME="layout" TYPE="int" LENGTH="4" NOTNULL="true" UNSIGNED="false" DEFAULT="0" SEQUENCE="false" COMMENT="Not used. Was intended for a vertical/horizontal layout option. See MDL-18445." PREVIOUS="question" NEXT="answers"/>
!         <FIELD NAME="answers" TYPE="char" LENGTH="255" NOTNULL="true" SEQUENCE="false" COMMENT="Redundant. Comma-separated list of question_answer ids. SELECT id FROM question_answers WHERE question = ? ORDER BY id." PREVIOUS="layout" NEXT="single"/>
!         <FIELD NAME="single" TYPE="int" LENGTH="4" NOTNULL="true" UNSIGNED="false" DEFAULT="0" SEQUENCE="false" COMMENT="If 0 it multiple response (checkboxes). Otherwise it is radio buttons." PREVIOUS="answers" NEXT="shuffleanswers"/>
!         <FIELD NAME="shuffleanswers" TYPE="int" LENGTH="4" NOTNULL="true" UNSIGNED="false" DEFAULT="1" SEQUENCE="false" COMMENT="Whether the choices can be randomly shuffled." PREVIOUS="single" NEXT="correctfeedback"/>
!         <FIELD NAME="correctfeedback" TYPE="text" LENGTH="small" NOTNULL="true" SEQUENCE="false" COMMENT="Feedback shown for any correct response." PREVIOUS="shuffleanswers" NEXT="correctfeedbackformat"/>
!         <FIELD NAME="correctfeedbackformat" TYPE="int" LENGTH="2" NOTNULL="true" UNSIGNED="false" DEFAULT="0" SEQUENCE="false" PREVIOUS="correctfeedback" NEXT="partiallycorrectfeedback"/>
!         <FIELD NAME="partiallycorrectfeedback" TYPE="text" LENGTH="small" NOTNULL="true" SEQUENCE="false" COMMENT="Feedback shown for any partially correct response." PREVIOUS="correctfeedbackformat" NEXT="partiallycorrectfeedbackformat"/>
!         <FIELD NAME="partiallycorrectfeedbackformat" TYPE="int" LENGTH="2" NOTNULL="true" UNSIGNED="false" DEFAULT="0" SEQUENCE="false" PREVIOUS="partiallycorrectfeedback" NEXT="incorrectfeedback"/>
!         <FIELD NAME="incorrectfeedback" TYPE="text" LENGTH="small" NOTNULL="true" SEQUENCE="false" COMMENT="Feedback shown for any incorrect response." PREVIOUS="partiallycorrectfeedbackformat" NEXT="incorrectfeedbackformat"/>
!         <FIELD NAME="incorrectfeedbackformat" TYPE="int" LENGTH="2" NOTNULL="true" UNSIGNED="false" DEFAULT="0" SEQUENCE="false" PREVIOUS="incorrectfeedback" NEXT="answernumbering"/>
!         <FIELD NAME="answernumbering" TYPE="char" LENGTH="10" NOTNULL="true" DEFAULT="abc" SEQUENCE="false" COMMENT="Indicates how and whether the choices should be numbered." PREVIOUS="incorrectfeedbackformat"/>
!       </FIELDS>
!       <KEYS>
!         <KEY NAME="primary" TYPE="primary" FIELDS="id" NEXT="question"/>
!         <KEY NAME="question" TYPE="foreign" FIELDS="question" REFTABLE="question" REFFIELDS="id" PREVIOUS="primary"/>
!       </KEYS>
!     </TABLE>
!   </TABLES>
  </XMLDB>
\ No newline at end of file
--- 1,61 ----
  <?xml version="1.0" encoding="UTF-8" ?>
! <XMLDB PATH="question/type/multichoice/db" VERSION="20100716"
! 	COMMENT="XMLDB file for Moodle question/type/multichoice" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
! 	xsi:noNamespaceSchemaLocation="../../../../lib/xmldb/xmldb.xsd">
! 	<TABLES>
! 		<TABLE NAME="question_multichoice" COMMENT="Options for multiple choice questions">
! 			<FIELDS>
! 				<FIELD NAME="id" TYPE="int" LENGTH="10" NOTNULL="true"
! 					UNSIGNED="true" SEQUENCE="true" NEXT="question" />
! 				<FIELD NAME="question" TYPE="int" LENGTH="10" NOTNULL="true"
! 					UNSIGNED="true" DEFAULT="0" SEQUENCE="false"
! 					COMMENT="Foreign key references question.id" PREVIOUS="id" NEXT="layout" />
! 				<FIELD NAME="layout" TYPE="int" LENGTH="4" NOTNULL="true"
! 					UNSIGNED="false" DEFAULT="0" SEQUENCE="false"
! 					COMMENT="Not used. Was intended for a vertical/horizontal layout option. See MDL-18445."
! 					PREVIOUS="question" NEXT="answers" />
! 				<FIELD NAME="answers" TYPE="char" LENGTH="255" NOTNULL="true"
! 					SEQUENCE="false"
! 					COMMENT="Redundant. Comma-separated list of question_answer ids. SELECT id FROM question_answers WHERE question = ? ORDER BY id."
! 					PREVIOUS="layout" NEXT="single" />
! 				<FIELD NAME="single" TYPE="int" LENGTH="4" NOTNULL="true"
! 					UNSIGNED="false" DEFAULT="0" SEQUENCE="false"
! 					COMMENT="If 0 it multiple response (checkboxes). Otherwise it is radio buttons."
! 					PREVIOUS="answers" NEXT="shuffleanswers" />
! 				<FIELD NAME="shuffleanswers" TYPE="int" LENGTH="4" NOTNULL="true"
! 					UNSIGNED="false" DEFAULT="1" SEQUENCE="false"
! 					COMMENT="Whether the choices can be randomly shuffled." PREVIOUS="single"
! 					NEXT="correctfeedback" />
! 				<FIELD NAME="correctfeedback" TYPE="text" LENGTH="small"
! 					NOTNULL="true" SEQUENCE="false" COMMENT="Feedback shown for any correct response."
! 					PREVIOUS="shuffleanswers" NEXT="correctfeedbackformat" />
! 				<FIELD NAME="correctfeedbackformat" TYPE="int" LENGTH="2"
! 					NOTNULL="true" UNSIGNED="false" DEFAULT="0" SEQUENCE="false"
! 					PREVIOUS="correctfeedback" NEXT="partiallycorrectfeedback" />
! 				<FIELD NAME="partiallycorrectfeedback" TYPE="text" LENGTH="small"
! 					NOTNULL="true" SEQUENCE="false"
! 					COMMENT="Feedback shown for any partially correct response."
! 					PREVIOUS="correctfeedbackformat" NEXT="partiallycorrectfeedbackformat" />
! 				<FIELD NAME="partiallycorrectfeedbackformat" TYPE="int"
! 					LENGTH="2" NOTNULL="true" UNSIGNED="false" DEFAULT="0" SEQUENCE="false"
! 					PREVIOUS="partiallycorrectfeedback" NEXT="incorrectfeedback" />
! 				<FIELD NAME="incorrectfeedback" TYPE="text" LENGTH="small"
! 					NOTNULL="true" SEQUENCE="false"
! 					COMMENT="Feedback shown for any incorrect response." PREVIOUS="partiallycorrectfeedbackformat"
! 					NEXT="incorrectfeedbackformat" />
! 				<FIELD NAME="incorrectfeedbackformat" TYPE="int" LENGTH="2"
! 					NOTNULL="true" UNSIGNED="false" DEFAULT="0" SEQUENCE="false"
! 					PREVIOUS="incorrectfeedback" NEXT="answernumbering" />
! 				<FIELD NAME="answernumbering" TYPE="char" LENGTH="10" NOTNULL="true"
! 					DEFAULT="abc" SEQUENCE="false"
! 					COMMENT="Indicates how and whether the choices should be numbered."
! 					PREVIOUS="incorrectfeedbackformat" />
! 			</FIELDS>
! 			<KEYS>
! 				<KEY NAME="primary" TYPE="primary" FIELDS="id" NEXT="question" />
! 				<KEY NAME="question" TYPE="foreign" FIELDS="question" REFTABLE="question"
! 					REFFIELDS="id" PREVIOUS="primary" />
! 			</KEYS>
! 		</TABLE>
! 	</TABLES>
  </XMLDB>
\ No newline at end of file
diff -crB questionorg/type/multichoice/db/upgrade.php questionupd/type/multichoice/db/upgrade.php
*** questionorg/type/multichoice/db/upgrade.php	2012-04-13 12:31:14.071178298 +0500
--- questionupd/type/multichoice/db/upgrade.php	2012-04-13 09:42:58.000000000 +0500
***************
*** 21,115 ****
  // before any action that may take longer time to finish.
  
  function xmldb_qtype_multichoice_upgrade($oldversion) {
!     global $CFG, $DB, $QTYPES;
  
!     $dbman = $DB->get_manager();
  
!     // This upgrade actually belongs to the random question type,
!     // but that does not have a DB upgrade script. Therefore, multichoice
!     // is doing it.
!     // Rename random questions to give them more helpful names.
!     if ($oldversion < 2008021800) {
!         require_once($CFG->libdir . '/questionlib.php');
!         // Get all categories containing random questions.
!         $categories = $DB->get_recordset_sql("
                  SELECT qc.id, qc.name
                  FROM {question_categories} qc
                  JOIN {question} q ON q.category = qc.id
                  WHERE q.qtype = 'random'
                  GROUP BY qc.id, qc.name");
  
!         // Rename the random qusetions in those categories.
!         $where = "qtype = 'random' AND category = ? AND " .
!                 $DB->sql_compare_text('questiontext') . " = " . $DB->sql_compare_text('?');
!         foreach ($categories as $cat) {
!             $randomqname = $QTYPES[RANDOM]->question_name($cat, false);
!             $DB->set_field_select('question', 'name', $randomqname, $where, array($cat->id, '0'));
! 
!             $randomqname = $QTYPES[RANDOM]->question_name($cat, true);
!             $DB->set_field_select('question', 'name', $randomqname, $where, array($cat->id, '1'));
!         }
! 
!         upgrade_plugin_savepoint(true, 2008021800, 'qtype', 'multichoice');
!     }
! 
!     if ($oldversion < 2009021801) {
! 
!     /// Define field correctfeedbackformat to be added to question_multichoice
!         $table = new xmldb_table('question_multichoice');
!         $field = new xmldb_field('correctfeedbackformat', XMLDB_TYPE_INTEGER, '2', null, XMLDB_NOTNULL, null, '0', 'correctfeedback');
! 
!     /// Conditionally launch add field correctfeedbackformat
!         if (!$dbman->field_exists($table, $field)) {
!             $dbman->add_field($table, $field);
!         }
! 
!     /// Define field partiallycorrectfeedbackformat to be added to question_multichoice
!         $field = new xmldb_field('partiallycorrectfeedbackformat', XMLDB_TYPE_INTEGER, '2', null, XMLDB_NOTNULL, null, '0', 'partiallycorrectfeedback');
! 
!     /// Conditionally launch add field partiallycorrectfeedbackformat
!         if (!$dbman->field_exists($table, $field)) {
!             $dbman->add_field($table, $field);
!         }
! 
!     /// Define field incorrectfeedbackformat to be added to question_multichoice
!         $field = new xmldb_field('incorrectfeedbackformat', XMLDB_TYPE_INTEGER, '2', null, XMLDB_NOTNULL, null, '0', 'incorrectfeedback');
! 
!     /// Conditionally launch add field incorrectfeedbackformat
!         if (!$dbman->field_exists($table, $field)) {
!             $dbman->add_field($table, $field);
!         }
! 
!         // In the past, the correctfeedback, partiallycorrectfeedback,
!         // incorrectfeedback columns were assumed to contain content of the same
!         // form as questiontextformat. If we are using the HTML editor, then
!         // convert FORMAT_MOODLE content to FORMAT_HTML.
!         $rs = $DB->get_recordset_sql('
                  SELECT qm.*, q.oldquestiontextformat
                  FROM {question_multichoice} qm
                  JOIN {question} q ON qm.question = q.id');
!         foreach ($rs as $record) {
!             if ($CFG->texteditors !== 'textarea' && $record->oldquestiontextformat == FORMAT_MOODLE) {
!                 $record->correctfeedback = text_to_html($record->correctfeedback, false, false, true);
!                 $record->correctfeedbackformat = FORMAT_HTML;
!                 $record->partiallycorrectfeedback = text_to_html($record->partiallycorrectfeedback, false, false, true);
!                 $record->partiallycorrectfeedbackformat = FORMAT_HTML;
!                 $record->incorrectfeedback = text_to_html($record->incorrectfeedback, false, false, true);
!                 $record->incorrectfeedbackformat = FORMAT_HTML;
!             } else {
!                 $record->correctfeedbackformat = $record->oldquestiontextformat;
!                 $record->partiallycorrectfeedback = $record->oldquestiontextformat;
!                 $record->incorrectfeedbackformat = $record->oldquestiontextformat;
!             }
!             $DB->update_record('question_multichoice', $record);
!         }
!         $rs->close();
! 
!     /// multichoice savepoint reached
!         upgrade_plugin_savepoint(true, 2009021801, 'qtype', 'multichoice');
!     }
  
!     return true;
  }
  
  
--- 21,115 ----
  // before any action that may take longer time to finish.
  
  function xmldb_qtype_multichoice_upgrade($oldversion) {
! 	global $CFG, $DB, $QTYPES;
  
! 	$dbman = $DB->get_manager();
  
! 	// This upgrade actually belongs to the random question type,
! 	// but that does not have a DB upgrade script. Therefore, multichoice
! 	// is doing it.
! 	// Rename random questions to give them more helpful names.
! 	if ($oldversion < 2008021800) {
! 		require_once($CFG->libdir . '/questionlib.php');
! 		// Get all categories containing random questions.
! 		$categories = $DB->get_recordset_sql("
                  SELECT qc.id, qc.name
                  FROM {question_categories} qc
                  JOIN {question} q ON q.category = qc.id
                  WHERE q.qtype = 'random'
                  GROUP BY qc.id, qc.name");
  
! 		// Rename the random qusetions in those categories.
! 		$where = "qtype = 'random' AND category = ? AND " .
! 		$DB->sql_compare_text('questiontext') . " = " . $DB->sql_compare_text('?');
! 		foreach ($categories as $cat) {
! 			$randomqname = $QTYPES[RANDOM]->question_name($cat, false);
! 			$DB->set_field_select('question', 'name', $randomqname, $where, array($cat->id, '0'));
! 
! 			$randomqname = $QTYPES[RANDOM]->question_name($cat, true);
! 			$DB->set_field_select('question', 'name', $randomqname, $where, array($cat->id, '1'));
! 		}
! 
! 		upgrade_plugin_savepoint(true, 2008021800, 'qtype', 'multichoice');
! 	}
! 
! 	if ($oldversion < 2009021801) {
! 
! 		/// Define field correctfeedbackformat to be added to question_multichoice
! 		$table = new xmldb_table('question_multichoice');
! 		$field = new xmldb_field('correctfeedbackformat', XMLDB_TYPE_INTEGER, '2', null, XMLDB_NOTNULL, null, '0', 'correctfeedback');
! 
! 		/// Conditionally launch add field correctfeedbackformat
! 		if (!$dbman->field_exists($table, $field)) {
! 			$dbman->add_field($table, $field);
! 		}
! 
! 		/// Define field partiallycorrectfeedbackformat to be added to question_multichoice
! 		$field = new xmldb_field('partiallycorrectfeedbackformat', XMLDB_TYPE_INTEGER, '2', null, XMLDB_NOTNULL, null, '0', 'partiallycorrectfeedback');
! 
! 		/// Conditionally launch add field partiallycorrectfeedbackformat
! 		if (!$dbman->field_exists($table, $field)) {
! 			$dbman->add_field($table, $field);
! 		}
! 
! 		/// Define field incorrectfeedbackformat to be added to question_multichoice
! 		$field = new xmldb_field('incorrectfeedbackformat', XMLDB_TYPE_INTEGER, '2', null, XMLDB_NOTNULL, null, '0', 'incorrectfeedback');
! 
! 		/// Conditionally launch add field incorrectfeedbackformat
! 		if (!$dbman->field_exists($table, $field)) {
! 			$dbman->add_field($table, $field);
! 		}
! 
! 		// In the past, the correctfeedback, partiallycorrectfeedback,
! 		// incorrectfeedback columns were assumed to contain content of the same
! 		// form as questiontextformat. If we are using the HTML editor, then
! 		// convert FORMAT_MOODLE content to FORMAT_HTML.
! 		$rs = $DB->get_recordset_sql('
                  SELECT qm.*, q.oldquestiontextformat
                  FROM {question_multichoice} qm
                  JOIN {question} q ON qm.question = q.id');
! 		foreach ($rs as $record) {
! 			if ($CFG->texteditors !== 'textarea' && $record->oldquestiontextformat == FORMAT_MOODLE) {
! 				$record->correctfeedback = text_to_html($record->correctfeedback, false, false, true);
! 				$record->correctfeedbackformat = FORMAT_HTML;
! 				$record->partiallycorrectfeedback = text_to_html($record->partiallycorrectfeedback, false, false, true);
! 				$record->partiallycorrectfeedbackformat = FORMAT_HTML;
! 				$record->incorrectfeedback = text_to_html($record->incorrectfeedback, false, false, true);
! 				$record->incorrectfeedbackformat = FORMAT_HTML;
! 			} else {
! 				$record->correctfeedbackformat = $record->oldquestiontextformat;
! 				$record->partiallycorrectfeedback = $record->oldquestiontextformat;
! 				$record->incorrectfeedbackformat = $record->oldquestiontextformat;
! 			}
! 			$DB->update_record('question_multichoice', $record);
! 		}
! 		$rs->close();
! 
! 		/// multichoice savepoint reached
! 		upgrade_plugin_savepoint(true, 2009021801, 'qtype', 'multichoice');
! 	}
  
! 	return true;
  }
  
  
diff -crB questionorg/type/multichoice/display.html questionupd/type/multichoice/display.html
*** questionorg/type/multichoice/display.html	2012-04-13 12:31:13.976178292 +0500
--- questionupd/type/multichoice/display.html	2012-04-13 09:42:58.000000000 +0500
***************
*** 1,34 ****
  <div class="qtext">
!   <?php echo $questiontext; ?>
  </div>
  
  <div class="ablock clearfix">
!   <div class="prompt">
!     <?php echo $answerprompt; ?>
!   </div>
! 
!   <table class="answer">
!     <?php $row = 1; foreach ($anss as $answer) { ?>
!       <tr class="<?php echo 'r'.$row = $row ? 0 : 1; ?>">
!         <td class="c0 control">
!           <?php echo $answer->control; ?>
!         </td>
!         <td class="c1 text <?php echo $answer->class ?>">
!           <label for="<?php echo $answer->id ?>">
!             <?php echo $answer->text; ?>
!             <?php echo $answer->feedbackimg; ?>
!           </label>
!         </td>
!         <td class="c0 feedback">
!           <?php echo $answer->feedback; ?>
!         </td>
!       </tr>
!     <?php } ?>
!   </table>
!   <?php if ($feedback) { ?>
!     <div class="feedback">
!       <?php echo $feedback ?>
!     </div>
!   <?php } ?>
!   <?php $this->print_question_submit_buttons($question, $state, $cmoptions, $options); ?>
  </div>
--- 1,35 ----
+ 
  <div class="qtext">
! 	<?php echo $questiontext; ?>
  </div>
  
  <div class="ablock clearfix">
! 	<div class="prompt">
! 		<?php echo $answerprompt; ?>
! 	</div>
! 
! 	<table class="answer">
! 		<?php $row = 1; foreach ($anss as $answer) { ?>
! 		<tr class="<?php echo 'r'.$row = $row ? 0 : 1; ?>">
! 			<td class="c0 control">
! 				<?php echo $answer->control; ?></td>
! 			<td class="c1 text <?php echo $answer->class ?>"><label
! 				for="<?php echo $answer->id ?>"> <?php echo $answer->text; ?>
! 					<?php echo $answer->feedbackimg; ?> </label></td>
! 			<td class="c0 feedback">
! 				<?php echo $answer->feedback; ?></td>
! 		</tr>
! 		<?php } ?>
! 	</table>
! 	<?php if ($feedback) { ?>
! 	<div class="feedback">
! 		<?php echo $feedback ?>
! 	</div>
! 	<?php } ?>
! 	<?php $this->print_question_submit_buttons($question, $state, $cmoptions, $options); ?>
  </div>
+ 
+ 
+ 
+ 
+ 
diff -crB questionorg/type/multichoice/edit_multichoice_form.php questionupd/type/multichoice/edit_multichoice_form.php
*** questionorg/type/multichoice/edit_multichoice_form.php	2012-04-13 12:31:14.017178287 +0500
--- questionupd/type/multichoice/edit_multichoice_form.php	2012-04-13 09:42:58.000000000 +0500
***************
*** 31,175 ****
   * multiple choice editing form definition.
   */
  class question_edit_multichoice_form extends question_edit_form {
!     /**
!      * Add question-type specific form fields.
!      *
!      * @param object $mform the form being built.
!      */
!     function definition_inner(&$mform) {
!         global $QTYPES;
! 
!         $menu = array(get_string('answersingleno', 'qtype_multichoice'), get_string('answersingleyes', 'qtype_multichoice'));
!         $mform->addElement('select', 'single', get_string('answerhowmany', 'qtype_multichoice'), $menu);
!         $mform->setDefault('single', 1);
! 
!         $mform->addElement('advcheckbox', 'shuffleanswers', get_string('shuffleanswers', 'qtype_multichoice'), null, null, array(0,1));
!         $mform->addHelpButton('shuffleanswers', 'shuffleanswers', 'qtype_multichoice');
!         $mform->setDefault('shuffleanswers', 1);
! 
!         $numberingoptions = $QTYPES[$this->qtype()]->get_numbering_styles();
!         $menu = array();
!         foreach ($numberingoptions as $numberingoption) {
!             $menu[$numberingoption] = get_string('answernumbering' . $numberingoption, 'qtype_multichoice');
!         }
!         $mform->addElement('select', 'answernumbering', get_string('answernumbering', 'qtype_multichoice'), $menu);
!         $mform->setDefault('answernumbering', 'abc');
! 
! /*        $mform->addElement('static', 'answersinstruct', get_string('choices', 'qtype_multichoice'), get_string('fillouttwochoices', 'qtype_multichoice'));
!         $mform->closeHeaderBefore('answersinstruct');
! */
!         $creategrades = get_grade_options();
!         $this->add_per_answer_fields($mform, get_string('choiceno', 'qtype_multichoice', '{no}'),
!                 $creategrades->gradeoptionsfull, max(5, QUESTION_NUMANS_START));
! 
!         $mform->addElement('header', 'overallfeedbackhdr', get_string('overallfeedback', 'qtype_multichoice'));
! 
!         foreach (array('correctfeedback', 'partiallycorrectfeedback', 'incorrectfeedback') as $feedbackname) {
!             $mform->addElement('editor', $feedbackname, get_string($feedbackname, 'qtype_multichoice'),
!                                 array('rows' => 10), $this->editoroptions);
!             $mform->setType($feedbackname, PARAM_RAW);
!         }
! 
!     }
! 
!     function data_preprocessing($question) {
!         if (isset($question->options)){
!             $answers = $question->options->answers;
!             if (count($answers)) {
!                 $key = 0;
!                 foreach ($answers as $answer){
!                     $default_values['answer['.$key.']'] = $answer->answer;
!                     $default_values['fraction['.$key.']'] = $answer->fraction;
! 
!                     // prepare question text
!                     $draftid = file_get_submitted_draft_itemid('feedback['.$key.']');
!                     $default_values['feedback['.$key.']'] = array();
!                     $default_values['feedback['.$key.']']['text'] = file_prepare_draft_area($draftid, $this->context->id, 'question', 'answerfeedback', empty($answer->id)?null:(int)$answer->id, $this->fileoptions, $answer->feedback);
!                     $default_values['feedback['.$key.']']['format'] = $answer->feedbackformat;
!                     $default_values['feedback['.$key.']']['itemid'] = $draftid;
!                     $key++;
!                 }
!             }
!             $default_values['single'] =  $question->options->single;
!             $default_values['answernumbering'] =  $question->options->answernumbering;
!             $default_values['shuffleanswers'] =  $question->options->shuffleanswers;
! 
!             // prepare feedback editor to display files in draft area
!             foreach (array('correctfeedback', 'partiallycorrectfeedback', 'incorrectfeedback') as $feedbackname) {
!                 $draftid = file_get_submitted_draft_itemid($feedbackname);
!                 $text = $question->options->$feedbackname;
!                 $feedbackformat = $feedbackname . 'format';
!                 $format = $question->options->$feedbackformat;
!                 $default_values[$feedbackname] = array();
!                 $default_values[$feedbackname]['text'] = file_prepare_draft_area(
!                     $draftid,       // draftid
!                     $this->context->id,    // context
                      'qtype_multichoice',   // component
!                     $feedbackname,         // filarea
!                     !empty($question->id)?(int)$question->id:null, // itemid
!                     $this->fileoptions,    // options
!                     $text      // text
!                 );
!                 $default_values[$feedbackname]['format'] = $format;
!                 $default_values[$feedbackname]['itemid'] = $draftid;
!             }
!             // prepare files code block ends
! 
!             $question = (object)((array)$question + $default_values);
!         }
!         return $question;
!     }
! 
!     function qtype() {
!         return 'multichoice';
!     }
! 
!     function validation($data, $files) {
!         $errors = parent::validation($data, $files);
!         $answers = $data['answer'];
!         $answercount = 0;
! 
!         $totalfraction = 0;
!         $maxfraction = -1;
! 
!         foreach ($answers as $key => $answer){
!             //check no of choices
!             $trimmedanswer = trim($answer);
!             if (!empty($trimmedanswer)){
!                 $answercount++;
!             }
!             //check grades
!             if ($answer != '') {
!                 if ($data['fraction'][$key] > 0) {
!                     $totalfraction += $data['fraction'][$key];
!                 }
!                 if ($data['fraction'][$key] > $maxfraction) {
!                     $maxfraction = $data['fraction'][$key];
!                 }
!             }
!         }
! 
!         if ($answercount==0){
!             $errors['answer[0]'] = get_string('notenoughanswers', 'qtype_multichoice', 2);
!             $errors['answer[1]'] = get_string('notenoughanswers', 'qtype_multichoice', 2);
!         } elseif ($answercount==1){
!             $errors['answer[1]'] = get_string('notenoughanswers', 'qtype_multichoice', 2);
! 
!         }
! 
!         /// Perform sanity checks on fractional grades
!         if ($data['single']) {
!             if ($maxfraction != 1) {
!                 $maxfraction = $maxfraction * 100;
!                 $errors['fraction[0]'] = get_string('errfractionsnomax', 'qtype_multichoice', $maxfraction);
!             }
!         } else {
!             $totalfraction = round($totalfraction,2);
!             if ($totalfraction != 1) {
!                 $totalfraction = $totalfraction * 100;
!                 $errors['fraction[0]'] = get_string('errfractionsaddwrong', 'qtype_multichoice', $totalfraction);
!             }
!         }
!         return $errors;
!     }
  }
--- 31,175 ----
   * multiple choice editing form definition.
   */
  class question_edit_multichoice_form extends question_edit_form {
! 	/**
! 	 * Add question-type specific form fields.
! 	 *
! 	 * @param object $mform the form being built.
! 	 */
! 	function definition_inner(&$mform) {
! 		global $QTYPES;
! 
! 		$menu = array(get_string('answersingleno', 'qtype_multichoice'), get_string('answersingleyes', 'qtype_multichoice'));
! 		$mform->addElement('select', 'single', get_string('answerhowmany', 'qtype_multichoice'), $menu);
! 		$mform->setDefault('single', 1);
! 
! 		$mform->addElement('advcheckbox', 'shuffleanswers', get_string('shuffleanswers', 'qtype_multichoice'), null, null, array(0,1));
! 		$mform->addHelpButton('shuffleanswers', 'shuffleanswers', 'qtype_multichoice');
! 		$mform->setDefault('shuffleanswers', 1);
! 
! 		$numberingoptions = $QTYPES[$this->qtype()]->get_numbering_styles();
! 		$menu = array();
! 		foreach ($numberingoptions as $numberingoption) {
! 			$menu[$numberingoption] = get_string('answernumbering' . $numberingoption, 'qtype_multichoice');
! 		}
! 		$mform->addElement('select', 'answernumbering', get_string('answernumbering', 'qtype_multichoice'), $menu);
! 		$mform->setDefault('answernumbering', 'abc');
! 
! 		/*        $mform->addElement('static', 'answersinstruct', get_string('choices', 'qtype_multichoice'), get_string('fillouttwochoices', 'qtype_multichoice'));
! 		 $mform->closeHeaderBefore('answersinstruct');
! 		 */
! 		$creategrades = get_grade_options();
! 		$this->add_per_answer_fields($mform, get_string('choiceno', 'qtype_multichoice', '{no}'),
! 		$creategrades->gradeoptionsfull, max(5, QUESTION_NUMANS_START));
! 
! 		$mform->addElement('header', 'overallfeedbackhdr', get_string('overallfeedback', 'qtype_multichoice'));
! 
! 		foreach (array('correctfeedback', 'partiallycorrectfeedback', 'incorrectfeedback') as $feedbackname) {
! 			$mform->addElement('editor', $feedbackname, get_string($feedbackname, 'qtype_multichoice'),
! 			array('rows' => 10), $this->editoroptions);
! 			$mform->setType($feedbackname, PARAM_RAW);
! 		}
! 
! 	}
! 
! 	function data_preprocessing($question) {
! 		if (isset($question->options)){
! 			$answers = $question->options->answers;
! 			if (count($answers)) {
! 				$key = 0;
! 				foreach ($answers as $answer){
! 					$default_values['answer['.$key.']'] = $answer->answer;
! 					$default_values['fraction['.$key.']'] = $answer->fraction;
! 
! 					// prepare question text
! 					$draftid = file_get_submitted_draft_itemid('feedback['.$key.']');
! 					$default_values['feedback['.$key.']'] = array();
! 					$default_values['feedback['.$key.']']['text'] = file_prepare_draft_area($draftid, $this->context->id, 'question', 'answerfeedback', empty($answer->id)?null:(int)$answer->id, $this->fileoptions, $answer->feedback);
! 					$default_values['feedback['.$key.']']['format'] = $answer->feedbackformat;
! 					$default_values['feedback['.$key.']']['itemid'] = $draftid;
! 					$key++;
! 				}
! 			}
! 			$default_values['single'] =  $question->options->single;
! 			$default_values['answernumbering'] =  $question->options->answernumbering;
! 			$default_values['shuffleanswers'] =  $question->options->shuffleanswers;
! 
! 			// prepare feedback editor to display files in draft area
! 			foreach (array('correctfeedback', 'partiallycorrectfeedback', 'incorrectfeedback') as $feedbackname) {
! 				$draftid = file_get_submitted_draft_itemid($feedbackname);
! 				$text = $question->options->$feedbackname;
! 				$feedbackformat = $feedbackname . 'format';
! 				$format = $question->options->$feedbackformat;
! 				$default_values[$feedbackname] = array();
! 				$default_values[$feedbackname]['text'] = file_prepare_draft_area(
! 				$draftid,       // draftid
! 				$this->context->id,    // context
                      'qtype_multichoice',   // component
! 				$feedbackname,         // filarea
! 				!empty($question->id)?(int)$question->id:null, // itemid
! 				$this->fileoptions,    // options
! 				$text      // text
! 				);
! 				$default_values[$feedbackname]['format'] = $format;
! 				$default_values[$feedbackname]['itemid'] = $draftid;
! 			}
! 			// prepare files code block ends
! 
! 			$question = (object)((array)$question + $default_values);
! 		}
! 		return $question;
! 	}
! 
! 	function qtype() {
! 		return 'multichoice';
! 	}
! 
! 	function validation($data, $files) {
! 		$errors = parent::validation($data, $files);
! 		$answers = $data['answer'];
! 		$answercount = 0;
! 
! 		$totalfraction = 0;
! 		$maxfraction = -1;
! 
! 		foreach ($answers as $key => $answer){
! 			//check no of choices
! 			$trimmedanswer = trim($answer);
! 			if (!empty($trimmedanswer)){
! 				$answercount++;
! 			}
! 			//check grades
! 			if ($answer != '') {
! 				if ($data['fraction'][$key] > 0) {
! 					$totalfraction += $data['fraction'][$key];
! 				}
! 				if ($data['fraction'][$key] > $maxfraction) {
! 					$maxfraction = $data['fraction'][$key];
! 				}
! 			}
! 		}
! 
! 		if ($answercount==0){
! 			$errors['answer[0]'] = get_string('notenoughanswers', 'qtype_multichoice', 2);
! 			$errors['answer[1]'] = get_string('notenoughanswers', 'qtype_multichoice', 2);
! 		} elseif ($answercount==1){
! 			$errors['answer[1]'] = get_string('notenoughanswers', 'qtype_multichoice', 2);
! 
! 		}
! 
! 		/// Perform sanity checks on fractional grades
! 		if ($data['single']) {
! 			if ($maxfraction != 1) {
! 				$maxfraction = $maxfraction * 100;
! 				$errors['fraction[0]'] = get_string('errfractionsnomax', 'qtype_multichoice', $maxfraction);
! 			}
! 		} else {
! 			$totalfraction = round($totalfraction,2);
! 			if ($totalfraction != 1) {
! 				$totalfraction = $totalfraction * 100;
! 				$errors['fraction[0]'] = get_string('errfractionsaddwrong', 'qtype_multichoice', $totalfraction);
! 			}
! 		}
! 		return $errors;
! 	}
  }
diff -crB questionorg/type/multichoice/lib.php questionupd/type/multichoice/lib.php
*** questionorg/type/multichoice/lib.php	2012-04-13 12:31:14.073178298 +0500
--- questionupd/type/multichoice/lib.php	2012-04-13 09:42:58.000000000 +0500
***************
*** 25,31 ****
   * @license   http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
   */
  function qtype_multichoice_pluginfile($course, $cm, $context, $filearea, $args, $forcedownload) {
!     global $CFG;
!     require_once($CFG->libdir . '/questionlib.php');
!     question_pluginfile($course, $context, 'qtype_multichoice', $filearea, $args, $forcedownload);
  }
--- 25,31 ----
   * @license   http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
   */
  function qtype_multichoice_pluginfile($course, $cm, $context, $filearea, $args, $forcedownload) {
! 	global $CFG;
! 	require_once($CFG->libdir . '/questionlib.php');
! 	question_pluginfile($course, $context, 'qtype_multichoice', $filearea, $args, $forcedownload);
  }
diff -crB questionorg/type/multichoice/questiontype.php questionupd/type/multichoice/questiontype.php
*** questionorg/type/multichoice/questiontype.php	2012-04-13 12:31:14.064178298 +0500
--- questionupd/type/multichoice/questiontype.php	2012-04-13 09:42:58.000000000 +0500
***************
*** 1,4 ****
--- 1,5 ----
  <?php
+ session_start();
  /**
   * The questiontype class for the multiple choice question type.
   *
***************
*** 10,551 ****
   */
  class question_multichoice_qtype extends default_questiontype {
  
!     function name() {
!         return 'multichoice';
!     }
! 
!     function get_question_options(&$question) {
!         global $DB, $OUTPUT;
!         // Get additional information from database
!         // and attach it to the question object
!         if (!$question->options = $DB->get_record('question_multichoice', array('question' => $question->id))) {
!             echo $OUTPUT->notification('Error: Missing question options for multichoice question'.$question->id.'!');
!             return false;
!         }
! 
!         list ($usql, $params) = $DB->get_in_or_equal(explode(',', $question->options->answers));
!         if (!$question->options->answers = $DB->get_records_select('question_answers', "id $usql", $params, 'id')) {
!             echo $OUTPUT->notification('Error: Missing question answers for multichoice question'.$question->id.'!');
!             return false;
!         }
! 
!         return true;
!     }
! 
!     function save_question_options($question) {
!         global $DB;
!         $context = $question->context;
!         $result = new stdClass;
! 
!         $oldanswers = $DB->get_records('question_answers',
!                 array('question' => $question->id), 'id ASC');
! 
!         // following hack to check at least two answers exist
!         $answercount = 0;
!         foreach ($question->answer as $key => $answer) {
!             if ($answer != '') {
!                 $answercount++;
!             }
!         }
!         if ($answercount < 2) { // check there are at lest 2 answers for multiple choice
!             $result->notice = get_string('notenoughanswers', 'qtype_multichoice', '2');
!             return $result;
!         }
! 
!         // Insert all the new answers
!         $totalfraction = 0;
!         $maxfraction = -1;
!         $answers = array();
!         foreach ($question->answer as $key => $answerdata) {
!             if ($answerdata == '') {
!                 continue;
!             }
! 
!             // Update an existing answer if possible.
!             $answer = array_shift($oldanswers);
!             if (!$answer) {
!                 $answer = new stdClass();
!                 $answer->question = $question->id;
!                 $answer->answer = '';
!                 $answer->feedback = '';
!                 $answer->id = $DB->insert_record('question_answers', $answer);
!             }
! 
!             if (is_array($answerdata)) {
!                 // Doing an import
!                 $answer->answer = $this->import_or_save_files($answerdata,
!                         $context, 'question', 'answer', $answer->id);
!                 $answer->answerformat = $answerdata['format'];
!             } else {
!                 // Saving the form
!                 $answer->answer = $answerdata;
!                 $answer->answerformat = FORMAT_HTML;
!             }
!             $answer->fraction = $question->fraction[$key];
!             $answer->feedback = $this->import_or_save_files($question->feedback[$key],
!                     $context, 'question', 'answerfeedback', $answer->id);
!             $answer->feedbackformat = $question->feedback[$key]['format'];
! 
!             $DB->update_record('question_answers', $answer);
!             $answers[] = $answer->id;
! 
!             if ($question->fraction[$key] > 0) {
!                 $totalfraction += $question->fraction[$key];
!             }
!             if ($question->fraction[$key] > $maxfraction) {
!                 $maxfraction = $question->fraction[$key];
!             }
!         }
! 
!         // Delete any left over old answer records.
!         $fs = get_file_storage();
!         foreach($oldanswers as $oldanswer) {
!             $fs->delete_area_files($context->id, 'question', 'answerfeedback', $oldanswer->id);
!             $DB->delete_records('question_answers', array('id' => $oldanswer->id));
!         }
! 
!         $options = $DB->get_record('question_multichoice', array('question' => $question->id));
!         if (!$options) {
!             $options = new stdClass;
!             $options->question = $question->id;
!             $options->correctfeedback = '';
!             $options->partiallycorrectfeedback = '';
!             $options->incorrectfeedback = '';
!             $options->id = $DB->insert_record('question_multichoice', $options);
!         }
! 
!         $options->answers = implode(',', $answers);
!         $options->single = $question->single;
!         if (isset($question->layout)) {
!             $options->layout = $question->layout;
!         }
!         $options->answernumbering = $question->answernumbering;
!         $options->shuffleanswers = $question->shuffleanswers;
!         $options->correctfeedback = $this->import_or_save_files($question->correctfeedback,
!                 $context, 'qtype_multichoice', 'correctfeedback', $question->id);
!         $options->correctfeedbackformat = $question->correctfeedback['format'];
!         $options->partiallycorrectfeedback = $this->import_or_save_files($question->partiallycorrectfeedback,
!                 $context, 'qtype_multichoice', 'partiallycorrectfeedback', $question->id);
!         $options->partiallycorrectfeedbackformat = $question->partiallycorrectfeedback['format'];
!         $options->incorrectfeedback = $this->import_or_save_files($question->incorrectfeedback,
!                 $context, 'qtype_multichoice', 'incorrectfeedback', $question->id);
!         $options->incorrectfeedbackformat = $question->incorrectfeedback['format'];
! 
!         $DB->update_record('question_multichoice', $options);
! 
!         /// Perform sanity checks on fractional grades
!         if ($options->single) {
!             if ($maxfraction != 1) {
!                 $result->noticeyesno = get_string('fractionsnomax', 'qtype_multichoice', $maxfraction * 100);
!                 return $result;
!             }
!         } else {
!             $totalfraction = round($totalfraction, 2);
!             if ($totalfraction != 1) {
!                 $result->noticeyesno = get_string('fractionsaddwrong', 'qtype_multichoice', $totalfraction * 100);
!                 return $result;
!             }
!         }
! 
!         return true;
!     }
! 
!     function delete_question($questionid, $contextid) {
!         global $DB;
!         $DB->delete_records('question_multichoice', array('question' => $questionid));
! 
!         parent::delete_question($questionid, $contextid);
!     }
! 
!     function create_session_and_responses(&$question, &$state, $cmoptions, $attempt) {
!         // create an array of answerids ??? why so complicated ???
!         $answerids = array_values(array_map(create_function('$val',
              'return $val->id;'), $question->options->answers));
!         // Shuffle the answers if required
!         if (!empty($cmoptions->shuffleanswers) and !empty($question->options->shuffleanswers)) {
!             $answerids = swapshuffle($answerids);
!         }
!         $state->options->order = $answerids;
!         // Create empty responses
!         if ($question->options->single) {
!             $state->responses = array('' => '');
!         } else {
!             $state->responses = array();
!         }
!         return true;
!     }
! 
! 
!     function restore_session_and_responses(&$question, &$state) {
!         // The serialized format for multiple choice quetsions
!         // is an optional comma separated list of answer ids (the order of the
!         // answers) followed by a colon, followed by another comma separated
!         // list of answer ids, which are the radio/checkboxes that were
!         // ticked.
!         // E.g. 1,3,2,4:2,4 means that the answers were shown in the order
!         // 1, 3, 2 and then 4 and the answers 2 and 4 were checked.
! 
!         $pos = strpos($state->responses[''], ':');
!         if (false === $pos) { // No order of answers is given, so use the default
!             $state->options->order = array_keys($question->options->answers);
!         } else { // Restore the order of the answers
!             $state->options->order = explode(',', substr($state->responses[''], 0, $pos));
!             $state->responses[''] = substr($state->responses[''], $pos + 1);
!         }
!         // Restore the responses
!         // This is done in different ways if only a single answer is allowed or
!         // if multiple answers are allowed. For single answers the answer id is
!         // saved in $state->responses[''], whereas for the multiple answers case
!         // the $state->responses array is indexed by the answer ids and the
!         // values are also the answer ids (i.e. key = value).
!         if (empty($state->responses[''])) { // No previous responses
!             $state->responses = array('' => '');
!         } else {
!             if ($question->options->single) {
!                 $state->responses = array('' => $state->responses['']);
!             } else {
!                 // Get array of answer ids
!                 $state->responses = explode(',', $state->responses['']);
!                 // Create an array indexed by these answer ids
!                 $state->responses = array_flip($state->responses);
!                 // Set the value of each element to be equal to the index
!                 array_walk($state->responses, create_function('&$a, $b',
                      '$a = $b;'));
!             }
!         }
!         return true;
!     }
! 
!     function save_session_and_responses(&$question, &$state) {
!         global $DB;
!         // Bundle the answer order and the responses into the legacy answer
!         // field.
!         // The serialized format for multiple choice quetsions
!         // is (optionally) a comma separated list of answer ids
!         // followed by a colon, followed by another comma separated
!         // list of answer ids, which are the radio/checkboxes that were
!         // ticked.
!         // E.g. 1,3,2,4:2,4 means that the answers were shown in the order
!         // 1, 3, 2 and then 4 and the answers 2 and 4 were checked.
!         $responses  = implode(',', $state->options->order) . ':';
!         $responses .= implode(',', $state->responses);
! 
!         // Set the legacy answer field
!         $DB->set_field('question_states', 'answer', $responses, array('id' => $state->id));
!         return true;
!     }
! 
!     function get_correct_responses(&$question, &$state) {
!         if ($question->options->single) {
!             foreach ($question->options->answers as $answer) {
!                 if (((int) $answer->fraction) === 1) {
!                     return array('' => $answer->id);
!                 }
!             }
!             return null;
!         } else {
!             $responses = array();
!             foreach ($question->options->answers as $answer) {
!                 if (((float) $answer->fraction) > 0.0) {
!                     $responses[$answer->id] = (string) $answer->id;
!                 }
!             }
!             return empty($responses) ? null : $responses;
!         }
!     }
! 
!     function print_question_formulation_and_controls(&$question, &$state, $cmoptions, $options) {
!         global $CFG;
! 
!         // required by file api
!         $context = $this->get_context_by_category_id($question->category);
!         $component = 'qtype_' . $question->qtype;
! 
!         $answers = &$question->options->answers;
!         $correctanswers = $this->get_correct_responses($question, $state);
!         $readonly = empty($options->readonly) ? '' : 'disabled="disabled"';
! 
!         $formatoptions = new stdClass;
!         $formatoptions->noclean = true;
!         $formatoptions->para = false;
! 
!         // Print formulation
!         $questiontext = format_text($question->questiontext, $question->questiontextformat,
!             $formatoptions, $cmoptions->course);
!         $answerprompt = ($question->options->single) ? get_string('singleanswer', 'quiz') :
!             get_string('multipleanswers', 'quiz');
! 
!         // Print each answer in a separate row
!         foreach ($state->options->order as $key => $aid) {
!             $answer = &$answers[$aid];
!             $checked = '';
!             $chosen = false;
! 
!             if ($question->options->single) {
!                 $type = 'type="radio"';
!                 $name   = "name=\"{$question->name_prefix}\"";
!                 if (isset($state->responses['']) and $aid == $state->responses['']) {
!                     $checked = 'checked="checked"';
!                     $chosen = true;
!                 }
!             } else {
!                 $type = ' type="checkbox" ';
!                 $name   = "name=\"{$question->name_prefix}{$aid}\"";
!                 if (isset($state->responses[$aid])) {
!                     $checked = 'checked="checked"';
!                     $chosen = true;
!                 }
!             }
! 
!             $a = new stdClass;
!             $a->id   = $question->name_prefix . $aid;
!             $a->class = '';
!             $a->feedbackimg = '';
! 
!             // Print the control
!             $a->control = "<input $readonly id=\"$a->id\" $name $checked $type value=\"$aid\" />";
! 
!             if ($options->correct_responses && $answer->fraction > 0) {
!                 $a->class = question_get_feedback_class(1);
!             }
!             if (($options->feedback && $chosen) || $options->correct_responses) {
!                 if ($type == ' type="checkbox" ') {
!                     $a->feedbackimg = question_get_feedback_image($answer->fraction > 0 ? 1 : 0, $chosen && $options->feedback);
!                 } else {
!                     $a->feedbackimg = question_get_feedback_image($answer->fraction, $chosen && $options->feedback);
!                 }
!             }
! 
!             // Print the answer text
!             $a->text = $this->number_in_style($key, $question->options->answernumbering) .
!                 format_text($answer->answer, $answer->answerformat, $formatoptions, $cmoptions->course);
! 
!             // Print feedback if feedback is on
!             if (($options->feedback || $options->correct_responses) && $checked) {
!                 // feedback for each answer
!                 $a->feedback = quiz_rewrite_question_urls($answer->feedback, 'pluginfile.php', $context->id, 'question', 'answerfeedback', array($state->attempt, $state->question), $answer->id);
!                 $a->feedback = format_text($a->feedback, $answer->feedbackformat, $formatoptions, $cmoptions->course);
!             } else {
!                 $a->feedback = '';
!             }
! 
!             $anss[] = clone($a);
!         }
! 
!         $feedback = '';
!         if ($options->feedback) {
!             if ($state->raw_grade >= $question->maxgrade/1.01) {
!                 $feedback = $question->options->correctfeedback;
!                 $feedbacktype = 'correctfeedback';
!             } else if ($state->raw_grade > 0) {
!                 $feedback = $question->options->partiallycorrectfeedback;
!                 $feedbacktype = 'partiallycorrectfeedback';
!             } else {
!                 $feedback = $question->options->incorrectfeedback;
!                 $feedbacktype = 'incorrectfeedback';
!             }
! 
!             $feedback = quiz_rewrite_question_urls($feedback, 'pluginfile.php', $context->id, $component, $feedbacktype, array($state->attempt, $state->question), $question->id);
!             $feedbackformat = $feedbacktype . 'format';
!             $feedback = format_text($feedback, $question->options->$feedbackformat, $formatoptions, $cmoptions->course);
!         }
! 
!         include("$CFG->dirroot/question/type/multichoice/display.html");
!     }
! 
!     function compare_responses($question, $state, $teststate) {
!         if ($question->options->single) {
!             if (!empty($state->responses[''])) {
!                 return $state->responses[''] == $teststate->responses[''];
!             } else {
!                 return empty($teststate->response['']);
!             }
!         } else {
!             foreach ($question->options->answers as $ansid => $notused) {
!                 if (empty($state->responses[$ansid]) != empty($teststate->responses[$ansid])) {
!                     return false;
!                 }
!             }
!             return true;
!         }
!     }
! 
!     function grade_responses(&$question, &$state, $cmoptions) {
!         $state->raw_grade = 0;
!         if($question->options->single) {
!             $response = reset($state->responses);
!             if ($response) {
!                 $state->raw_grade = $question->options->answers[$response]->fraction;
!             }
!         } else {
!             foreach ($state->responses as $response) {
!                 if ($response) {
!                     $state->raw_grade += $question->options->answers[$response]->fraction;
!                 }
!             }
!         }
! 
!         // Make sure we don't assign negative or too high marks
!         $state->raw_grade = min(max((float) $state->raw_grade,
!             0.0), 1.0) * $question->maxgrade;
! 
!         // Apply the penalty for this attempt
!         $state->penalty = $question->penalty * $question->maxgrade;
! 
!         // mark the state as graded
!         $state->event = ($state->event ==  QUESTION_EVENTCLOSE) ? QUESTION_EVENTCLOSEANDGRADE : QUESTION_EVENTGRADE;
! 
!         return true;
!     }
! 
!     // ULPGC ecastro
!     function get_actual_response($question, $state) {
!         $answers = $question->options->answers;
!         $responses = array();
!         if (!empty($state->responses)) {
!             foreach ($state->responses as $aid =>$rid){
!                 if (!empty($answers[$rid])) {
!                     $responses[] = $answers[$rid]->answer;
!                 }
!             }
!         } else {
!             $responses[] = '';
!         }
!         return $responses;
!     }
! 
!     /**
!      * @param object $question
!      * @return mixed either a integer score out of 1 that the average random
!      * guess by a student might give or an empty string which means will not
!      * calculate.
!      */
!     function get_random_guess_score($question) {
!         $totalfraction = 0;
!         foreach ($question->options->answers as $answer){
!             $totalfraction += $answer->fraction;
!         }
!         return $totalfraction / count($question->options->answers);
!     }
! 
!     /**
!      * @return array of the numbering styles supported. For each one, there
!      *      should be a lang string answernumberingxxx in teh qtype_multichoice
!      *      language file, and a case in the switch statement in number_in_style,
!      *      and it should be listed in the definition of this column in install.xml.
!      */
!     function get_numbering_styles() {
!         return array('abc', 'ABCD', '123', 'none');
!     }
! 
!     function number_html($qnum) {
!         return '<span class="anun">' . $qnum . '<span class="anumsep">.</span></span> ';
!     }
! 
!     /**
!      * @param int $num The number, starting at 0.
!      * @param string $style The style to render the number in. One of the ones returned by $numberingoptions.
!      * @return string the number $num in the requested style.
!      */
!     function number_in_style($num, $style) {
!         switch($style) {
!         case 'abc':
!             return $this->number_html(chr(ord('a') + $num));
!         case 'ABCD':
!             return $this->number_html(chr(ord('A') + $num));
!         case '123':
!             return $this->number_html(($num + 1));
!         case 'none':
!             return '';
!         default:
!             return 'ERR';
!         }
!     }
! 
!     /**
!      * Runs all the code required to set up and save an essay question for testing purposes.
!      * Alternate DB table prefix may be used to facilitate data deletion.
!      */
!     function generate_test($name, $courseid = null) {
!         global $DB;
!         list($form, $question) = parent::generate_test($name, $courseid);
!         $question->category = $form->category;
!         $form->questiontext = "How old is the sun?";
!         $form->generalfeedback = "General feedback";
!         $form->penalty = 0.1;
!         $form->single = 1;
!         $form->shuffleanswers = 1;
!         $form->answernumbering = 'abc';
!         $form->noanswers = 3;
!         $form->answer = array('Ancient', '5 billion years old', '4.5 billion years old');
!         $form->fraction = array(0.3, 0.9, 1);
!         $form->feedback = array('True, but lacking in accuracy', 'Close, but no cigar!', 'Yep, that is it!');
!         $form->correctfeedback = 'Excellent!';
!         $form->incorrectfeedback = 'Nope!';
!         $form->partiallycorrectfeedback = 'Not bad';
! 
!         if ($courseid) {
!             $course = $DB->get_record('course', array('id' => $courseid));
!         }
! 
!         return $this->save_question($question, $form);
!     }
! 
!     function move_files($questionid, $oldcontextid, $newcontextid) {
!         $fs = get_file_storage();
! 
!         parent::move_files($questionid, $oldcontextid, $newcontextid);
!         $this->move_files_in_answers($questionid, $oldcontextid, $newcontextid, true);
! 
!         $fs->move_area_files_to_new_context($oldcontextid,
!                 $newcontextid, 'qtype_multichoice', 'correctfeedback', $questionid);
!         $fs->move_area_files_to_new_context($oldcontextid,
!                 $newcontextid, 'qtype_multichoice', 'partiallycorrectfeedback', $questionid);
!         $fs->move_area_files_to_new_context($oldcontextid,
!                 $newcontextid, 'qtype_multichoice', 'incorrectfeedback', $questionid);
!     }
! 
!     protected function delete_files($questionid, $contextid) {
!         $fs = get_file_storage();
! 
!         parent::delete_files($questionid, $contextid);
!         $this->delete_files_in_answers($questionid, $contextid, true);
!         $fs->delete_area_files($contextid, 'qtype_multichoice', 'correctfeedback', $questionid);
!         $fs->delete_area_files($contextid, 'qtype_multichoice', 'partiallycorrectfeedback', $questionid);
!         $fs->delete_area_files($contextid, 'qtype_multichoice', 'incorrectfeedback', $questionid);
!     }
! 
!     function check_file_access($question, $state, $options, $contextid, $component,
!             $filearea, $args) {
!         $itemid = reset($args);
! 
!         if (empty($question->maxgrade)) {
!             $question->maxgrade = $question->defaultgrade;
!         }
! 
!         if (in_array($filearea, array('correctfeedback', 'partiallycorrectfeedback', 'incorrectfeedback'))) {
!             $result = $options->feedback && ($itemid == $question->id);
!             if (!$result) {
!                 return false;
!             }
!             if ($state->raw_grade >= $question->maxgrade/1.01) {
!                 $feedbacktype = 'correctfeedback';
!             } else if ($state->raw_grade > 0) {
!                 $feedbacktype = 'partiallycorrectfeedback';
!             } else {
!                 $feedbacktype = 'incorrectfeedback';
!             }
!             if ($feedbacktype != $filearea) {
!                 return false;
!             }
!             return true;
!         } else if ($component == 'question' && $filearea == 'answerfeedback') {
!             return $options->feedback && (array_key_exists($itemid, $question->options->answers));
!         } else {
!             return parent::check_file_access($question, $state, $options, $contextid, $component,
!                     $filearea, $args);
!         }
!     }
  }
  
  // Register this question type with the question bank.
--- 11,597 ----
   */
  class question_multichoice_qtype extends default_questiontype {
  
! 	function name() {
! 		return 'multichoice';
! 	}
! 
! 	function get_question_options(&$question) {
! 		global $DB, $OUTPUT;
! 		// Get additional information from database
! 		// and attach it to the question object
! 		if (!$question->options = $DB->get_record('question_multichoice', array('question' => $question->id))) {
! 			echo $OUTPUT->notification('Error: Missing question options for multichoice question'.$question->id.'!');
! 			return false;
! 		}
! 
! 		list ($usql, $params) = $DB->get_in_or_equal(explode(',', $question->options->answers));
! 		if (!$question->options->answers = $DB->get_records_select('question_answers', "id $usql", $params, 'id')) {
! 			echo $OUTPUT->notification('Error: Missing question answers for multichoice question'.$question->id.'!');
! 			return false;
! 		}
! 
! 		return true;
! 	}
! 
! 	function save_question_options($question) {
! 		global $DB;
! 		$context = $question->context;
! 		$result = new stdClass;
! 
! 		$oldanswers = $DB->get_records('question_answers',
! 		array('question' => $question->id), 'id ASC');
! 
! 		// following hack to check at least two answers exist
! 		$answercount = 0;
! 		foreach ($question->answer as $key => $answer) {
! 			if ($answer != '') {
! 				$answercount++;
! 			}
! 		}
! 		if ($answercount < 2) { // check there are at lest 2 answers for multiple choice
! 			$result->notice = get_string('notenoughanswers', 'qtype_multichoice', '2');
! 			return $result;
! 		}
! 
! 		// Insert all the new answers
! 		$totalfraction = 0;
! 		$maxfraction = -1;
! 		$answers = array();
! 		foreach ($question->answer as $key => $answerdata) {
! 			if ($answerdata == '') {
! 				continue;
! 			}
! 
! 			// Update an existing answer if possible.
! 			$answer = array_shift($oldanswers);
! 			if (!$answer) {
! 				$answer = new stdClass();
! 				$answer->question = $question->id;
! 				$answer->answer = '';
! 				$answer->feedback = '';
! 				$answer->id = $DB->insert_record('question_answers', $answer);
! 			}
! 
! 			if (is_array($answerdata)) {
! 				// Doing an import
! 				$answer->answer = $this->import_or_save_files($answerdata,
! 				$context, 'question', 'answer', $answer->id);
! 				$answer->answerformat = $answerdata['format'];
! 			} else {
! 				// Saving the form
! 				$answer->answer = $answerdata;
! 				$answer->answerformat = FORMAT_HTML;
! 			}
! 			$answer->fraction = $question->fraction[$key];
! 			$answer->feedback = $this->import_or_save_files($question->feedback[$key],
! 			$context, 'question', 'answerfeedback', $answer->id);
! 			$answer->feedbackformat = $question->feedback[$key]['format'];
! 
! 			$DB->update_record('question_answers', $answer);
! 			$answers[] = $answer->id;
! 
! 			if ($question->fraction[$key] > 0) {
! 				$totalfraction += $question->fraction[$key];
! 			}
! 			if ($question->fraction[$key] > $maxfraction) {
! 				$maxfraction = $question->fraction[$key];
! 			}
! 		}
! 
! 		// Delete any left over old answer records.
! 		$fs = get_file_storage();
! 		foreach($oldanswers as $oldanswer) {
! 			$fs->delete_area_files($context->id, 'question', 'answerfeedback', $oldanswer->id);
! 			$DB->delete_records('question_answers', array('id' => $oldanswer->id));
! 		}
! 
! 		$options = $DB->get_record('question_multichoice', array('question' => $question->id));
! 		if (!$options) {
! 			$options = new stdClass;
! 			$options->question = $question->id;
! 			$options->correctfeedback = '';
! 			$options->partiallycorrectfeedback = '';
! 			$options->incorrectfeedback = '';
! 			$options->id = $DB->insert_record('question_multichoice', $options);
! 		}
! 
! 		$options->answers = implode(',', $answers);
! 		$options->single = $question->single;
! 		if (isset($question->layout)) {
! 			$options->layout = $question->layout;
! 		}
! 		$options->answernumbering = $question->answernumbering;
! 		$options->shuffleanswers = $question->shuffleanswers;
! 		$options->correctfeedback = $this->import_or_save_files($question->correctfeedback,
! 		$context, 'qtype_multichoice', 'correctfeedback', $question->id);
! 		$options->correctfeedbackformat = $question->correctfeedback['format'];
! 		$options->partiallycorrectfeedback = $this->import_or_save_files($question->partiallycorrectfeedback,
! 		$context, 'qtype_multichoice', 'partiallycorrectfeedback', $question->id);
! 		$options->partiallycorrectfeedbackformat = $question->partiallycorrectfeedback['format'];
! 		$options->incorrectfeedback = $this->import_or_save_files($question->incorrectfeedback,
! 		$context, 'qtype_multichoice', 'incorrectfeedback', $question->id);
! 		$options->incorrectfeedbackformat = $question->incorrectfeedback['format'];
! 
! 		$DB->update_record('question_multichoice', $options);
! 
! 		/// Perform sanity checks on fractional grades
! 		if ($options->single) {
! 			if ($maxfraction != 1) {
! 				$result->noticeyesno = get_string('fractionsnomax', 'qtype_multichoice', $maxfraction * 100);
! 				return $result;
! 			}
! 		} else {
! 			$totalfraction = round($totalfraction, 2);
! 			if ($totalfraction != 1) {
! 				$result->noticeyesno = get_string('fractionsaddwrong', 'qtype_multichoice', $totalfraction * 100);
! 				return $result;
! 			}
! 		}
! 
! 		return true;
! 	}
! 
! 	function delete_question($questionid, $contextid) {
! 		global $DB;
! 		$DB->delete_records('question_multichoice', array('question' => $questionid));
! 
! 		parent::delete_question($questionid, $contextid);
! 	}
! 
! 	function create_session_and_responses(&$question, &$state, $cmoptions, $attempt) {
! 		// create an array of answerids ??? why so complicated ???
! 		$answerids = array_values(array_map(create_function('$val',
              'return $val->id;'), $question->options->answers));
! 		// Shuffle the answers if required
! 		if (!empty($cmoptions->shuffleanswers) and !empty($question->options->shuffleanswers)) {
! 			$answerids = swapshuffle($answerids);
! 		}
! 		$state->options->order = $answerids;
! 		// Create empty responses
! 		if ($question->options->single) {
! 			$state->responses = array('' => '');
! 		} else {
! 			$state->responses = array();
! 		}
! 		return true;
! 	}
! 
! 
! 	function restore_session_and_responses(&$question, &$state) {
! 		// The serialized format for multiple choice quetsions
! 		// is an optional comma separated list of answer ids (the order of the
! 		// answers) followed by a colon, followed by another comma separated
! 		// list of answer ids, which are the radio/checkboxes that were
! 		// ticked.
! 		// E.g. 1,3,2,4:2,4 means that the answers were shown in the order
! 		// 1, 3, 2 and then 4 and the answers 2 and 4 were checked.
! 
! 		$pos = strpos($state->responses[''], ':');
! 		if (false === $pos) { // No order of answers is given, so use the default
! 			$state->options->order = array_keys($question->options->answers);
! 		} else { // Restore the order of the answers
! 			$state->options->order = explode(',', substr($state->responses[''], 0, $pos));
! 			$state->responses[''] = substr($state->responses[''], $pos + 1);
! 		}
! 		// Restore the responses
! 		// This is done in different ways if only a single answer is allowed or
! 		// if multiple answers are allowed. For single answers the answer id is
! 		// saved in $state->responses[''], whereas for the multiple answers case
! 		// the $state->responses array is indexed by the answer ids and the
! 		// values are also the answer ids (i.e. key = value).
! 		if (empty($state->responses[''])) { // No previous responses
! 			$state->responses = array('' => '');
! 		} else {
! 			if ($question->options->single) {
! 				$state->responses = array('' => $state->responses['']);
! 			} else {
! 				// Get array of answer ids
! 				$state->responses = explode(',', $state->responses['']);
! 				// Create an array indexed by these answer ids
! 				$state->responses = array_flip($state->responses);
! 				// Set the value of each element to be equal to the index
! 				array_walk($state->responses, create_function('&$a, $b',
                      '$a = $b;'));
! 			}
! 		}
! 		return true;
! 	}
! 
! 	function save_session_and_responses(&$question, &$state) {
! 		global $DB;
! 		// Bundle the answer order and the responses into the legacy answer
! 		// field.
! 		// The serialized format for multiple choice quetsions
! 		// is (optionally) a comma separated list of answer ids
! 		// followed by a colon, followed by another comma separated
! 		// list of answer ids, which are the radio/checkboxes that were
! 		// ticked.
! 		// E.g. 1,3,2,4:2,4 means that the answers were shown in the order
! 		// 1, 3, 2 and then 4 and the answers 2 and 4 were checked.
! 		$responses  = implode(',', $state->options->order) . ':';
! 		$responses .= implode(',', $state->responses);
! 
! 		// Set the legacy answer field
! 		$DB->set_field('question_states', 'answer', $responses, array('id' => $state->id));
! 		return true;
! 	}
! 
! 	function get_correct_responses(&$question, &$state) {
! 		if ($question->options->single) {
! 			foreach ($question->options->answers as $answer) {
! 				if (((int) $answer->fraction) === 1) {
! 					return array('' => $answer->id);
! 				}
! 			}
! 			return null;
! 		} else {
! 			$responses = array();
! 			foreach ($question->options->answers as $answer) {
! 				if (((float) $answer->fraction) > 0.0) {
! 					$responses[$answer->id] = (string) $answer->id;
! 				}
! 			}
! 			return empty($responses) ? null : $responses;
! 		}
! 	}
! 
! 	function print_question_formulation_and_controls(&$question, &$state, $cmoptions, $options) {
! 		global $CFG;
! 
! 		// required by file api
! 		$context = $this->get_context_by_category_id($question->category);
! 		$component = 'qtype_' . $question->qtype;
! 
! 		$answers = &$question->options->answers;
! 		$correctanswers = $this->get_correct_responses($question, $state);
! 		$readonly = empty($options->readonly) ? '' : 'disabled="disabled"';
! 
! 		$formatoptions = new stdClass;
! 		$formatoptions->noclean = true;
! 		$formatoptions->para = false;
! 
! 		// Print formulation
! 		$questiontext = format_text($question->questiontext, $question->questiontextformat,
! 		$formatoptions, $cmoptions->course);
! 		$answerprompt = ($question->options->single) ? get_string('singleanswer', 'quiz') :
! 		get_string('multipleanswers', 'quiz');
! 		//if($_POST['export']==true){
! 		$_SESSION['content'].="&nbsp;&nbsp;&nbsp;&nbsp;".$question->questiontext."</b></td></tr><tr><td>";
! 		//}
! 
! 		// Print each answer in a separate row
! 		foreach ($state->options->order as $key => $aid) {
! 			$answer = &$answers[$aid];
! 			$checked = '';
! 			$chosen = false;
! 
! 			if ($question->options->single) {
! 				$type = 'type="radio"';
! 				$name   = "name=\"{$question->name_prefix}\"";
! 				if (isset($state->responses['']) and $aid == $state->responses['']) {
! 
! 					$choose =$answer->answer;
! 
! 					$checked = 'checked="checked"';
! 					$chosen = true;
! 				}
! 
! 				if($checked == 'checked="checked"')
! 				$_SESSION['content'].='<img src="filled rb.jpg" height="12" width="12" />';
! 				else
! 				$_SESSION['content'].='<img src="hollow rb.jpg" height="12" width="12" />';
! 
! 			} else {
! 				$type = ' type="checkbox" ';
! 				$name   = "name=\"{$question->name_prefix}{$aid}\"";
! 				if (isset($state->responses[$aid])) {
! 					$checked = 'checked="checked"';
! 					$chosen = true;
! 				}
! 
! 				if($checked == 'checked="checked"')
! 				$_SESSION['content'].='<img src="filled rb.jpg" height="12" width="12" />';
! 				else
! 				$_SESSION['content'].='<img src="hollow rb.jpg" height="12" width="12" />';
! 
! 			}
! 			//if($_POST['export']==true){
! 			if( $answer->fraction==1){
! 				//$_SESSION['content'].="Yes";
! 				//echo "correct".$answer->answer."chosen".$choose ;
! 				$correct=$answer->answer;
! 			}
! 			else{
! 				//$_SESSION['content'].="No";
! 
! 			}
! 			//}
! 			//echo $name;
! 			$a = new stdClass;
! 			$a->id   = $question->name_prefix . $aid;
! 			$a->class = '';
! 			$a->feedbackimg = '';
! 
! 			// Print the control
! 			$a->control = "<input $readonly id=\"$a->id\" $name $checked $type value=\"$aid\" />";
! 
! 
! 			if ($options->correct_responses && $answer->fraction > 0) {
! 				$a->class = question_get_feedback_class(1);
! 			}
! 			if (($options->feedback && $chosen) || $options->correct_responses) {
! 				if ($type == ' type="checkbox" ') {
! 						
! 					$a->feedbackimg = question_get_feedback_image($answer->fraction > 0 ? 1 : 0, $chosen && $options->feedback);
! 					//if($_POST['export']==true){$_SESSION['content'].=" mm".$a->feedbackimg;}
! 				} else {
! 						
! 					$a->feedbackimg = question_get_feedback_image($answer->fraction, $chosen && $options->feedback);
! 					//if($_POST['export']==true){$_SESSION['content'].=" mm".$a->feedbackimg;}
! 				}
! 			}
! 
! 			// Print the answer text
! 			$a->text = $this->number_in_style($key, $question->options->answernumbering) .
! 			format_text($answer->answer, $answer->answerformat, $formatoptions, $cmoptions->course);
! 			//if($_POST['export']==true){
! 			$_SESSION['content'].=$answer->answer."<br/>";
! 			//}
! 
! 			//echo "ans  ". $answer->answer;
! 			// Print feedback if feedback is on
! 			if (($options->feedback || $options->correct_responses) && $checked) {
! 				// feedback for each answer
! 				$a->feedback = quiz_rewrite_question_urls($answer->feedback, 'pluginfile.php', $context->id, 'question', 'answerfeedback', array($state->attempt, $state->question), $answer->id);
! 				$a->feedback = format_text($a->feedback, $answer->feedbackformat, $formatoptions, $cmoptions->course);
! 			} else {
! 				$a->feedback = '';
! 			}
! 
! 			$anss[] = clone($a);
! 		}
! 
! 		$feedback = '';
! 
! 		if ($options->feedback) {
! 			if ($state->raw_grade >= $question->maxgrade/1.01) {
! 				$feedback = $question->options->correctfeedback;
! 				$feedbacktype = 'correctfeedback';
! 			} else if ($state->raw_grade > 0) {
! 				$feedback = $question->options->partiallycorrectfeedback;
! 				$feedbacktype = 'partiallycorrectfeedback';
! 			} else {
! 				$feedback = $question->options->incorrectfeedback;
! 				$feedbacktype = 'incorrectfeedback';
! 			}
! 
! 			$feedback = quiz_rewrite_question_urls($feedback, 'pluginfile.php', $context->id, $component, $feedbacktype, array($state->attempt, $state->question), $question->id);
! 			$feedbackformat = $feedbacktype . 'format';
! 			$feedback = format_text($feedback, $question->options->$feedbackformat, $formatoptions, $cmoptions->course);
! 		}
! 			
! 
! 		$_SESSION['content'].="</td></tr>";
! 
! 		if($_POST['export']==false){
! 			include("$CFG->dirroot/question/type/multichoice/display.html");
! 		}
! 			
! 	}
! 
! 	function compare_responses($question, $state, $teststate) {
! 		if ($question->options->single) {
! 			if (!empty($state->responses[''])) {
! 				return $state->responses[''] == $teststate->responses[''];
! 			} else {
! 				return empty($teststate->response['']);
! 			}
! 		} else {
! 			foreach ($question->options->answers as $ansid => $notused) {
! 				if (empty($state->responses[$ansid]) != empty($teststate->responses[$ansid])) {
! 					return false;
! 				}
! 			}
! 			return true;
! 		}
! 	}
! 
! 	function grade_responses(&$question, &$state, $cmoptions) {
! 		$state->raw_grade = 0;
! 		if($question->options->single) {
! 			$response = reset($state->responses);
! 			if ($response) {
! 				$state->raw_grade = $question->options->answers[$response]->fraction;
! 			}
! 		} else {
! 			foreach ($state->responses as $response) {
! 				if ($response) {
! 					$state->raw_grade += $question->options->answers[$response]->fraction;
! 				}
! 			}
! 		}
! 
! 		// Make sure we don't assign negative or too high marks
! 		$state->raw_grade = min(max((float) $state->raw_grade,
! 		0.0), 1.0) * $question->maxgrade;
! 
! 		// Apply the penalty for this attempt
! 		$state->penalty = $question->penalty * $question->maxgrade;
! 
! 		// mark the state as graded
! 		$state->event = ($state->event ==  QUESTION_EVENTCLOSE) ? QUESTION_EVENTCLOSEANDGRADE : QUESTION_EVENTGRADE;
! 
! 		return true;
! 	}
! 
! 	// ULPGC ecastro
! 	function get_actual_response($question, $state) {
! 		$answers = $question->options->answers;
! 		$responses = array();
! 		if (!empty($state->responses)) {
! 			foreach ($state->responses as $aid =>$rid){
! 				if (!empty($answers[$rid])) {
! 					$responses[] = $answers[$rid]->answer;
! 				}
! 			}
! 		} else {
! 			$responses[] = '';
! 		}
! 		return $responses;
! 	}
! 
! 	/**
! 	 * @param object $question
! 	 * @return mixed either a integer score out of 1 that the average random
! 	 * guess by a student might give or an empty string which means will not
! 	 * calculate.
! 	 */
! 	function get_random_guess_score($question) {
! 		$totalfraction = 0;
! 		foreach ($question->options->answers as $answer){
! 			$totalfraction += $answer->fraction;
! 		}
! 		return $totalfraction / count($question->options->answers);
! 	}
! 
! 	/**
! 	 * @return array of the numbering styles supported. For each one, there
! 	 *      should be a lang string answernumberingxxx in teh qtype_multichoice
! 	 *      language file, and a case in the switch statement in number_in_style,
! 	 *      and it should be listed in the definition of this column in install.xml.
! 	 */
! 	function get_numbering_styles() {
! 		return array('abc', 'ABCD', '123', 'none');
! 	}
! 
! 	function number_html($qnum) {
! 		return '<span class="anun">' . $qnum . '<span class="anumsep">.</span></span> ';
! 	}
! 
! 	/**
! 	 * @param int $num The number, starting at 0.
! 	 * @param string $style The style to render the number in. One of the ones returned by $numberingoptions.
! 	 * @return string the number $num in the requested style.
! 	 */
! 	function number_in_style($num, $style) {
! 		switch($style) {
! 			case 'abc':
! 				return $this->number_html(chr(ord('a') + $num));
! 			case 'ABCD':
! 				return $this->number_html(chr(ord('A') + $num));
! 			case '123':
! 				return $this->number_html(($num + 1));
! 			case 'none':
! 				return '';
! 			default:
! 				return 'ERR';
! 		}
! 	}
! 
! 	/**
! 	 * Runs all the code required to set up and save an essay question for testing purposes.
! 	 * Alternate DB table prefix may be used to facilitate data deletion.
! 	 */
! 	function generate_test($name, $courseid = null) {
! 		global $DB;
! 		list($form, $question) = parent::generate_test($name, $courseid);
! 		$question->category = $form->category;
! 		$form->questiontext = "How old is the sun?";
! 		$form->generalfeedback = "General feedback";
! 		$form->penalty = 0.1;
! 		$form->single = 1;
! 		$form->shuffleanswers = 1;
! 		$form->answernumbering = 'abc';
! 		$form->noanswers = 3;
! 		$form->answer = array('Ancient', '5 billion years old', '4.5 billion years old');
! 		$form->fraction = array(0.3, 0.9, 1);
! 		$form->feedback = array('True, but lacking in accuracy', 'Close, but no cigar!', 'Yep, that is it!');
! 		$form->correctfeedback = 'Excellent!';
! 		$form->incorrectfeedback = 'Nope!';
! 		$form->partiallycorrectfeedback = 'Not bad';
! 
! 		if ($courseid) {
! 			$course = $DB->get_record('course', array('id' => $courseid));
! 		}
! 
! 		return $this->save_question($question, $form);
! 	}
! 
! 	function move_files($questionid, $oldcontextid, $newcontextid) {
! 		$fs = get_file_storage();
! 
! 		parent::move_files($questionid, $oldcontextid, $newcontextid);
! 		$this->move_files_in_answers($questionid, $oldcontextid, $newcontextid, true);
! 
! 		$fs->move_area_files_to_new_context($oldcontextid,
! 		$newcontextid, 'qtype_multichoice', 'correctfeedback', $questionid);
! 		$fs->move_area_files_to_new_context($oldcontextid,
! 		$newcontextid, 'qtype_multichoice', 'partiallycorrectfeedback', $questionid);
! 		$fs->move_area_files_to_new_context($oldcontextid,
! 		$newcontextid, 'qtype_multichoice', 'incorrectfeedback', $questionid);
! 	}
! 
! 	protected function delete_files($questionid, $contextid) {
! 		$fs = get_file_storage();
! 
! 		parent::delete_files($questionid, $contextid);
! 		$this->delete_files_in_answers($questionid, $contextid, true);
! 		$fs->delete_area_files($contextid, 'qtype_multichoice', 'correctfeedback', $questionid);
! 		$fs->delete_area_files($contextid, 'qtype_multichoice', 'partiallycorrectfeedback', $questionid);
! 		$fs->delete_area_files($contextid, 'qtype_multichoice', 'incorrectfeedback', $questionid);
! 	}
! 
! 	function check_file_access($question, $state, $options, $contextid, $component,
! 	$filearea, $args) {
! 		$itemid = reset($args);
! 
! 		if (empty($question->maxgrade)) {
! 			$question->maxgrade = $question->defaultgrade;
! 		}
! 
! 		if (in_array($filearea, array('correctfeedback', 'partiallycorrectfeedback', 'incorrectfeedback'))) {
! 			$result = $options->feedback && ($itemid == $question->id);
! 			if (!$result) {
! 				return false;
! 			}
! 			if ($state->raw_grade >= $question->maxgrade/1.01) {
! 				$feedbacktype = 'correctfeedback';
! 			} else if ($state->raw_grade > 0) {
! 				$feedbacktype = 'partiallycorrectfeedback';
! 			} else {
! 				$feedbacktype = 'incorrectfeedback';
! 			}
! 			if ($feedbacktype != $filearea) {
! 				return false;
! 			}
! 			return true;
! 		} else if ($component == 'question' && $filearea == 'answerfeedback') {
! 			return $options->feedback && (array_key_exists($itemid, $question->options->answers));
! 		} else {
! 			return parent::check_file_access($question, $state, $options, $contextid, $component,
! 			$filearea, $args);
! 		}
! 	}
  }
  
  // Register this question type with the question bank.
diff -crB questionorg/type/numerical/backup/moodle2/backup_qtype_numerical_plugin.class.php questionupd/type/numerical/backup/moodle2/backup_qtype_numerical_plugin.class.php
*** questionorg/type/numerical/backup/moodle2/backup_qtype_numerical_plugin.class.php	2012-04-13 12:31:12.519178274 +0500
--- questionupd/type/numerical/backup/moodle2/backup_qtype_numerical_plugin.class.php	2012-04-13 09:42:58.000000000 +0500
***************
*** 28,87 ****
   */
  class backup_qtype_numerical_plugin extends backup_qtype_plugin {
  
!     /**
!      * Returns the qtype information to attach to question element
!      */
!     protected function define_question_plugin_structure() {
  
!         // Define the virtual plugin element with the condition to fulfill
!         $plugin = $this->get_plugin_element(null, '../../qtype', 'numerical');
  
!         // Create one standard named plugin element (the visible container)
!         $pluginwrapper = new backup_nested_element($this->get_recommended_name());
  
!         // connect the visible container ASAP
!         $plugin->add_child($pluginwrapper);
  
!         // This qtype uses standard question_answers, add them here
!         // to the tree before any other information that will use them
!         $this->add_question_question_answers($pluginwrapper);
  
!         // This qtype uses standard numerical units, add them here
!         $this->add_question_numerical_units($pluginwrapper);
  
!         // This qtype uses standard numerical options, add them here
!         $this->add_question_numerical_options($pluginwrapper);
  
!         // Now create the qtype own structures
!         $numericalrecords = new backup_nested_element('numerical_records');
!         $numericalrecord = new backup_nested_element('numerical_record', array('id'), array(
              'answer', 'tolerance'));
  
!         // Now the own qtype tree
!         $pluginwrapper->add_child($numericalrecords);
!         $numericalrecords->add_child($numericalrecord);
! 
!         // set source to populate the data
!         $numericalrecord->set_source_table('question_numerical', array('question' => backup::VAR_PARENTID));
! 
!         // don't need to annotate ids nor files
! 
!         return $plugin;
!     }
! 
!     /**
!      * Returns one array with filearea => mappingname elements for the qtype
!      *
!      * Used by {@link get_components_and_fileareas} to know about all the qtype
!      * files to be processed both in backup and restore.
!      */
!     public static function get_qtype_fileareas() {
!         // TODO: Discuss. Commented below are the "in theory" correct
!         // mappings for those fileareas. Instead we are using question for
!         // them, that will cause problems in the future if we want to change
!         // any of them to be 1..n (i.e. we should be always pointing to own id)
!         return array(
!             //'instruction' => 'question_numerical_option');
              'instruction' => 'question_created');
!     }
  }
--- 28,87 ----
   */
  class backup_qtype_numerical_plugin extends backup_qtype_plugin {
  
! 	/**
! 	 * Returns the qtype information to attach to question element
! 	 */
! 	protected function define_question_plugin_structure() {
  
! 		// Define the virtual plugin element with the condition to fulfill
! 		$plugin = $this->get_plugin_element(null, '../../qtype', 'numerical');
  
! 		// Create one standard named plugin element (the visible container)
! 		$pluginwrapper = new backup_nested_element($this->get_recommended_name());
  
! 		// connect the visible container ASAP
! 		$plugin->add_child($pluginwrapper);
  
! 		// This qtype uses standard question_answers, add them here
! 		// to the tree before any other information that will use them
! 		$this->add_question_question_answers($pluginwrapper);
  
! 		// This qtype uses standard numerical units, add them here
! 		$this->add_question_numerical_units($pluginwrapper);
  
! 		// This qtype uses standard numerical options, add them here
! 		$this->add_question_numerical_options($pluginwrapper);
  
! 		// Now create the qtype own structures
! 		$numericalrecords = new backup_nested_element('numerical_records');
! 		$numericalrecord = new backup_nested_element('numerical_record', array('id'), array(
              'answer', 'tolerance'));
  
! 		// Now the own qtype tree
! 		$pluginwrapper->add_child($numericalrecords);
! 		$numericalrecords->add_child($numericalrecord);
! 
! 		// set source to populate the data
! 		$numericalrecord->set_source_table('question_numerical', array('question' => backup::VAR_PARENTID));
! 
! 		// don't need to annotate ids nor files
! 
! 		return $plugin;
! 	}
! 
! 	/**
! 	 * Returns one array with filearea => mappingname elements for the qtype
! 	 *
! 	 * Used by {@link get_components_and_fileareas} to know about all the qtype
! 	 * files to be processed both in backup and restore.
! 	 */
! 	public static function get_qtype_fileareas() {
! 		// TODO: Discuss. Commented below are the "in theory" correct
! 		// mappings for those fileareas. Instead we are using question for
! 		// them, that will cause problems in the future if we want to change
! 		// any of them to be 1..n (i.e. we should be always pointing to own id)
! 		return array(
! 		//'instruction' => 'question_numerical_option');
              'instruction' => 'question_created');
! 	}
  }
diff -crB questionorg/type/numerical/backup/moodle2/restore_qtype_numerical_plugin.class.php questionupd/type/numerical/backup/moodle2/restore_qtype_numerical_plugin.class.php
*** questionorg/type/numerical/backup/moodle2/restore_qtype_numerical_plugin.class.php	2012-04-13 12:31:12.518178273 +0500
--- questionupd/type/numerical/backup/moodle2/restore_qtype_numerical_plugin.class.php	2012-04-13 09:42:58.000000000 +0500
***************
*** 30,83 ****
   */
  class restore_qtype_numerical_plugin extends restore_qtype_plugin {
  
!     /**
!      * Returns the paths to be handled by the plugin at question level
!      */
!     protected function define_question_plugin_structure() {
! 
!         $paths = array();
! 
!         // This qtype uses question_answers, add them
!         $this->add_question_question_answers($paths);
! 
!         // This qtype uses question_numerical_options and question_numerical_units, add them
!         $this->add_question_numerical_options($paths);
!         $this->add_question_numerical_units($paths);
! 
!         // Add own qtype stuff
!         $elename = 'numerical';
!         $elepath = $this->get_pathfor('/numerical_records/numerical_record'); // we used get_recommended_name() so this works
!         $paths[] = new restore_path_element($elename, $elepath);
! 
! 
!         return $paths; // And we return the interesting paths
!     }
! 
!     /**
!      * Process the qtype/numerical element
!      */
!     public function process_numerical($data) {
!         global $DB;
! 
!         $data = (object)$data;
!         $oldid = $data->id;
! 
!         // Detect if the question is created or mapped
!         $oldquestionid   = $this->get_old_parentid('question');
!         $newquestionid   = $this->get_new_parentid('question');
!         $questioncreated = $this->get_mappingid('question_created', $oldquestionid) ? true : false;
! 
!         // If the question has been created by restore, we need to create its question_numerical too
!         if ($questioncreated) {
!             // Adjust some columns
!             $data->question = $newquestionid;
!             $data->answer = $this->get_mappingid('question_answer', $data->answer);
!             // Insert record
!             $newitemid = $DB->insert_record('question_numerical', $data);
!             // Create mapping (not needed, no files nor childs nor states here)
!             //$this->set_mapping('question_numerical', $oldid, $newitemid);
!         } else {
!             // Nothing to remap if the question already existed
!         }
!     }
  }
--- 30,83 ----
   */
  class restore_qtype_numerical_plugin extends restore_qtype_plugin {
  
! 	/**
! 	 * Returns the paths to be handled by the plugin at question level
! 	 */
! 	protected function define_question_plugin_structure() {
! 
! 		$paths = array();
! 
! 		// This qtype uses question_answers, add them
! 		$this->add_question_question_answers($paths);
! 
! 		// This qtype uses question_numerical_options and question_numerical_units, add them
! 		$this->add_question_numerical_options($paths);
! 		$this->add_question_numerical_units($paths);
! 
! 		// Add own qtype stuff
! 		$elename = 'numerical';
! 		$elepath = $this->get_pathfor('/numerical_records/numerical_record'); // we used get_recommended_name() so this works
! 		$paths[] = new restore_path_element($elename, $elepath);
! 
! 
! 		return $paths; // And we return the interesting paths
! 	}
! 
! 	/**
! 	 * Process the qtype/numerical element
! 	 */
! 	public function process_numerical($data) {
! 		global $DB;
! 
! 		$data = (object)$data;
! 		$oldid = $data->id;
! 
! 		// Detect if the question is created or mapped
! 		$oldquestionid   = $this->get_old_parentid('question');
! 		$newquestionid   = $this->get_new_parentid('question');
! 		$questioncreated = $this->get_mappingid('question_created', $oldquestionid) ? true : false;
! 
! 		// If the question has been created by restore, we need to create its question_numerical too
! 		if ($questioncreated) {
! 			// Adjust some columns
! 			$data->question = $newquestionid;
! 			$data->answer = $this->get_mappingid('question_answer', $data->answer);
! 			// Insert record
! 			$newitemid = $DB->insert_record('question_numerical', $data);
! 			// Create mapping (not needed, no files nor childs nor states here)
! 			//$this->set_mapping('question_numerical', $oldid, $newitemid);
! 		} else {
! 			// Nothing to remap if the question already existed
! 		}
! 	}
  }
diff -crB questionorg/type/numerical/db/install.xml questionupd/type/numerical/db/install.xml
*** questionorg/type/numerical/db/install.xml	2012-04-13 12:31:12.707178277 +0500
--- questionupd/type/numerical/db/install.xml	2012-04-13 09:42:58.000000000 +0500
***************
*** 1,54 ****
  <?xml version="1.0" encoding="UTF-8" ?>
! <XMLDB PATH="question/type/numerical/db" VERSION="20100720" COMMENT="XMLDB file for Moodle question/type/numerical"
!     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
!     xsi:noNamespaceSchemaLocation="../../../../lib/xmldb/xmldb.xsd"
! >
!   <TABLES>
!     <TABLE NAME="question_numerical" COMMENT="Options for numerical questions." NEXT="question_numerical_options">
!       <FIELDS>
!         <FIELD NAME="id" TYPE="int" LENGTH="10" NOTNULL="true" UNSIGNED="true" SEQUENCE="true" NEXT="question"/>
!         <FIELD NAME="question" TYPE="int" LENGTH="10" NOTNULL="true" UNSIGNED="true" DEFAULT="0" SEQUENCE="false" COMMENT="Redundant, because of the answer field. Foreign key references question.id." PREVIOUS="id" NEXT="answer"/>
!         <FIELD NAME="answer" TYPE="int" LENGTH="10" NOTNULL="true" UNSIGNED="true" DEFAULT="0" SEQUENCE="false" COMMENT="Foreign key references question_answers.id." PREVIOUS="question" NEXT="tolerance"/>
!         <FIELD NAME="tolerance" TYPE="char" LENGTH="255" NOTNULL="true" DEFAULT="0.0" SEQUENCE="false" COMMENT="Allowed error when matching a response to this answer. I don't know why this is stored as a string." PREVIOUS="answer"/>
!       </FIELDS>
!       <KEYS>
!         <KEY NAME="primary" TYPE="primary" FIELDS="id" NEXT="question"/>
!         <KEY NAME="question" TYPE="foreign" FIELDS="question" REFTABLE="question" REFFIELDS="id" PREVIOUS="primary"/>
!       </KEYS>
!       <INDEXES>
!         <INDEX NAME="answer" UNIQUE="false" FIELDS="answer"/>
!       </INDEXES>
!     </TABLE>
!     <TABLE NAME="question_numerical_options" COMMENT="Options for questions of type numerical This table is also used by the calculated question type" PREVIOUS="question_numerical" NEXT="question_numerical_units">
!       <FIELDS>
!         <FIELD NAME="id" TYPE="int" LENGTH="10" NOTNULL="true" UNSIGNED="true" SEQUENCE="true" NEXT="question"/>
!         <FIELD NAME="question" TYPE="int" LENGTH="10" NOTNULL="true" UNSIGNED="true" DEFAULT="0" SEQUENCE="false" PREVIOUS="id" NEXT="instructions"/>
!         <FIELD NAME="instructions" TYPE="text" LENGTH="small" NOTNULL="false" SEQUENCE="false" COMMENT="Feedback shown for any incorrect response." PREVIOUS="question" NEXT="instructionsformat"/>
!         <FIELD NAME="instructionsformat" TYPE="int" LENGTH="2" NOTNULL="true" UNSIGNED="false" DEFAULT="0" SEQUENCE="false" PREVIOUS="instructions" NEXT="showunits"/>
!         <FIELD NAME="showunits" TYPE="int" LENGTH="4" NOTNULL="true" UNSIGNED="true" DEFAULT="0" SEQUENCE="false" COMMENT="display units as multichoice" PREVIOUS="instructionsformat" NEXT="unitsleft"/>
!         <FIELD NAME="unitsleft" TYPE="int" LENGTH="4" NOTNULL="true" UNSIGNED="false" DEFAULT="0" SEQUENCE="false" COMMENT="display the unit at left as in $1.00" PREVIOUS="showunits" NEXT="unitgradingtype"/>
!         <FIELD NAME="unitgradingtype" TYPE="int" LENGTH="4" NOTNULL="true" UNSIGNED="true" DEFAULT="0" SEQUENCE="false" COMMENT="0 no penalty, 1 total grade, 2 response grade" PREVIOUS="unitsleft" NEXT="unitpenalty"/>
!         <FIELD NAME="unitpenalty" TYPE="number" LENGTH="12" NOTNULL="true" UNSIGNED="true" DEFAULT="0.1" SEQUENCE="false" DECIMALS="7" PREVIOUS="unitgradingtype"/>
!       </FIELDS>
!       <KEYS>
!         <KEY NAME="primary" TYPE="primary" FIELDS="id" NEXT="question"/>
!         <KEY NAME="question" TYPE="foreign" FIELDS="question" REFTABLE="question" REFFIELDS="id" PREVIOUS="primary"/>
!       </KEYS>
!     </TABLE>
!     <TABLE NAME="question_numerical_units" COMMENT="Optional unit options for numerical questions. This table is also used by the calculated question type." PREVIOUS="question_numerical_options">
!       <FIELDS>
!         <FIELD NAME="id" TYPE="int" LENGTH="10" NOTNULL="true" UNSIGNED="true" SEQUENCE="true" NEXT="question"/>
!         <FIELD NAME="question" TYPE="int" LENGTH="10" NOTNULL="true" UNSIGNED="true" DEFAULT="0" SEQUENCE="false" COMMENT="Foreign key references question.id" PREVIOUS="id" NEXT="multiplier"/>
!         <FIELD NAME="multiplier" TYPE="number" LENGTH="40" NOTNULL="true" UNSIGNED="false" DEFAULT="1.00000000000000000000" SEQUENCE="false" DECIMALS="20" COMMENT="The multiplier for this unit. For example, if the first unit is (1.0, 'cm'), another unit might be (0.1, 'mm') or (100.0, 'm')." PREVIOUS="question" NEXT="unit"/>
!         <FIELD NAME="unit" TYPE="char" LENGTH="50" NOTNULL="true" SEQUENCE="false" COMMENT="The unit. For example 'm' or 'kg'." PREVIOUS="multiplier"/>
!       </FIELDS>
!       <KEYS>
!         <KEY NAME="primary" TYPE="primary" FIELDS="id" NEXT="question"/>
!         <KEY NAME="question" TYPE="foreign" FIELDS="question" REFTABLE="question" REFFIELDS="id" PREVIOUS="primary"/>
!       </KEYS>
!       <INDEXES>
!         <INDEX NAME="question-unit" UNIQUE="true" FIELDS="question, unit" COMMENT="Unique index to ensure that only one unit with a particular name is created for each question."/>
!       </INDEXES>
!     </TABLE>
!   </TABLES>
  </XMLDB>
\ No newline at end of file
--- 1,98 ----
  <?xml version="1.0" encoding="UTF-8" ?>
! <XMLDB PATH="question/type/numerical/db" VERSION="20100720"
! 	COMMENT="XMLDB file for Moodle question/type/numerical" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
! 	xsi:noNamespaceSchemaLocation="../../../../lib/xmldb/xmldb.xsd">
! 	<TABLES>
! 		<TABLE NAME="question_numerical" COMMENT="Options for numerical questions."
! 			NEXT="question_numerical_options">
! 			<FIELDS>
! 				<FIELD NAME="id" TYPE="int" LENGTH="10" NOTNULL="true"
! 					UNSIGNED="true" SEQUENCE="true" NEXT="question" />
! 				<FIELD NAME="question" TYPE="int" LENGTH="10" NOTNULL="true"
! 					UNSIGNED="true" DEFAULT="0" SEQUENCE="false"
! 					COMMENT="Redundant, because of the answer field. Foreign key references question.id."
! 					PREVIOUS="id" NEXT="answer" />
! 				<FIELD NAME="answer" TYPE="int" LENGTH="10" NOTNULL="true"
! 					UNSIGNED="true" DEFAULT="0" SEQUENCE="false"
! 					COMMENT="Foreign key references question_answers.id." PREVIOUS="question"
! 					NEXT="tolerance" />
! 				<FIELD NAME="tolerance" TYPE="char" LENGTH="255" NOTNULL="true"
! 					DEFAULT="0.0" SEQUENCE="false"
! 					COMMENT="Allowed error when matching a response to this answer. I don't know why this is stored as a string."
! 					PREVIOUS="answer" />
! 			</FIELDS>
! 			<KEYS>
! 				<KEY NAME="primary" TYPE="primary" FIELDS="id" NEXT="question" />
! 				<KEY NAME="question" TYPE="foreign" FIELDS="question" REFTABLE="question"
! 					REFFIELDS="id" PREVIOUS="primary" />
! 			</KEYS>
! 			<INDEXES>
! 				<INDEX NAME="answer" UNIQUE="false" FIELDS="answer" />
! 			</INDEXES>
! 		</TABLE>
! 		<TABLE NAME="question_numerical_options"
! 			COMMENT="Options for questions of type numerical This table is also used by the calculated question type"
! 			PREVIOUS="question_numerical" NEXT="question_numerical_units">
! 			<FIELDS>
! 				<FIELD NAME="id" TYPE="int" LENGTH="10" NOTNULL="true"
! 					UNSIGNED="true" SEQUENCE="true" NEXT="question" />
! 				<FIELD NAME="question" TYPE="int" LENGTH="10" NOTNULL="true"
! 					UNSIGNED="true" DEFAULT="0" SEQUENCE="false" PREVIOUS="id"
! 					NEXT="instructions" />
! 				<FIELD NAME="instructions" TYPE="text" LENGTH="small" NOTNULL="false"
! 					SEQUENCE="false" COMMENT="Feedback shown for any incorrect response."
! 					PREVIOUS="question" NEXT="instructionsformat" />
! 				<FIELD NAME="instructionsformat" TYPE="int" LENGTH="2"
! 					NOTNULL="true" UNSIGNED="false" DEFAULT="0" SEQUENCE="false"
! 					PREVIOUS="instructions" NEXT="showunits" />
! 				<FIELD NAME="showunits" TYPE="int" LENGTH="4" NOTNULL="true"
! 					UNSIGNED="true" DEFAULT="0" SEQUENCE="false" COMMENT="display units as multichoice"
! 					PREVIOUS="instructionsformat" NEXT="unitsleft" />
! 				<FIELD NAME="unitsleft" TYPE="int" LENGTH="4" NOTNULL="true"
! 					UNSIGNED="false" DEFAULT="0" SEQUENCE="false"
! 					COMMENT="display the unit at left as in $1.00" PREVIOUS="showunits"
! 					NEXT="unitgradingtype" />
! 				<FIELD NAME="unitgradingtype" TYPE="int" LENGTH="4" NOTNULL="true"
! 					UNSIGNED="true" DEFAULT="0" SEQUENCE="false"
! 					COMMENT="0 no penalty, 1 total grade, 2 response grade" PREVIOUS="unitsleft"
! 					NEXT="unitpenalty" />
! 				<FIELD NAME="unitpenalty" TYPE="number" LENGTH="12" NOTNULL="true"
! 					UNSIGNED="true" DEFAULT="0.1" SEQUENCE="false" DECIMALS="7"
! 					PREVIOUS="unitgradingtype" />
! 			</FIELDS>
! 			<KEYS>
! 				<KEY NAME="primary" TYPE="primary" FIELDS="id" NEXT="question" />
! 				<KEY NAME="question" TYPE="foreign" FIELDS="question" REFTABLE="question"
! 					REFFIELDS="id" PREVIOUS="primary" />
! 			</KEYS>
! 		</TABLE>
! 		<TABLE NAME="question_numerical_units"
! 			COMMENT="Optional unit options for numerical questions. This table is also used by the calculated question type."
! 			PREVIOUS="question_numerical_options">
! 			<FIELDS>
! 				<FIELD NAME="id" TYPE="int" LENGTH="10" NOTNULL="true"
! 					UNSIGNED="true" SEQUENCE="true" NEXT="question" />
! 				<FIELD NAME="question" TYPE="int" LENGTH="10" NOTNULL="true"
! 					UNSIGNED="true" DEFAULT="0" SEQUENCE="false"
! 					COMMENT="Foreign key references question.id" PREVIOUS="id" NEXT="multiplier" />
! 				<FIELD NAME="multiplier" TYPE="number" LENGTH="40" NOTNULL="true"
! 					UNSIGNED="false" DEFAULT="1.00000000000000000000" SEQUENCE="false"
! 					DECIMALS="20"
! 					COMMENT="The multiplier for this unit. For example, if the first unit is (1.0, 'cm'), another unit might be (0.1, 'mm') or (100.0, 'm')."
! 					PREVIOUS="question" NEXT="unit" />
! 				<FIELD NAME="unit" TYPE="char" LENGTH="50" NOTNULL="true"
! 					SEQUENCE="false" COMMENT="The unit. For example 'm' or 'kg'."
! 					PREVIOUS="multiplier" />
! 			</FIELDS>
! 			<KEYS>
! 				<KEY NAME="primary" TYPE="primary" FIELDS="id" NEXT="question" />
! 				<KEY NAME="question" TYPE="foreign" FIELDS="question" REFTABLE="question"
! 					REFFIELDS="id" PREVIOUS="primary" />
! 			</KEYS>
! 			<INDEXES>
! 				<INDEX NAME="question-unit" UNIQUE="true" FIELDS="question, unit"
! 					COMMENT="Unique index to ensure that only one unit with a particular name is created for each question." />
! 			</INDEXES>
! 		</TABLE>
! 	</TABLES>
  </XMLDB>
\ No newline at end of file
diff -crB questionorg/type/numerical/db/upgrade.php questionupd/type/numerical/db/upgrade.php
*** questionorg/type/numerical/db/upgrade.php	2012-04-13 12:31:12.710178273 +0500
--- questionupd/type/numerical/db/upgrade.php	2012-04-13 09:42:58.000000000 +0500
***************
*** 21,90 ****
  // before any action that may take longer time to finish.
  
  function xmldb_qtype_numerical_upgrade($oldversion) {
!     global $CFG, $DB;
  
!     $dbman = $DB->get_manager();
  
! //===== 1.9.0 upgrade line ======//
!     if ($oldversion < 2009100100 ) { //New version in version.php
  
!     /// Define table question_numerical_options to be created
!         $table = new xmldb_table('question_numerical_options');
! 
!     /// Adding fields to table question_numerical_options
!         $table->add_field('id', XMLDB_TYPE_INTEGER, '10', XMLDB_UNSIGNED, XMLDB_NOTNULL, XMLDB_SEQUENCE, null);
!         $table->add_field('question', XMLDB_TYPE_INTEGER, '10', XMLDB_UNSIGNED, XMLDB_NOTNULL, null, '0');
!         $table->add_field('instructions', XMLDB_TYPE_TEXT, 'small', null, null, null, null);
!         $table->add_field('showunits', XMLDB_TYPE_INTEGER, '4', XMLDB_UNSIGNED, XMLDB_NOTNULL, null, '0');
!         $table->add_field('unitsleft', XMLDB_TYPE_INTEGER, '4', null, XMLDB_NOTNULL, null, '0');
!         $table->add_field('unitgradingtype', XMLDB_TYPE_INTEGER, '4', XMLDB_UNSIGNED, XMLDB_NOTNULL, null, '0');
!         $table->add_field('unitpenalty', XMLDB_TYPE_NUMBER, '12, 7', XMLDB_UNSIGNED, XMLDB_NOTNULL, null, '0.1');
! 
!     /// Adding keys to table question_numerical_options
!         $table->add_key('primary', XMLDB_KEY_PRIMARY, array('id'));
!         $table->add_key('question', XMLDB_KEY_FOREIGN, array('question'), 'question', array('id'));
!     /// Conditionally launch create table for question_calculated_options
!         if (!$dbman->table_exists($table)) {
!             // $dbman->create_table doesnt return a result, we just have to trust it
!             $dbman->create_table($table);
!         }//else
!         upgrade_plugin_savepoint(true, 2009100100, 'qtype', 'numerical');
!     }
! 
!     if ($oldversion < 2009100101) {
! 
!         // Define field instructionsformat to be added to question_numerical_options
!         $table = new xmldb_table('question_numerical_options');
!         $field = new xmldb_field('instructionsformat', XMLDB_TYPE_INTEGER, '2', null, XMLDB_NOTNULL, null, '0', 'instructions');
! 
!         // Conditionally launch add field instructionsformat
!         if (!$dbman->field_exists($table, $field)) {
!             $dbman->add_field($table, $field);
!         }
! 
!         // In the past, question_match_sub.questiontext assumed to contain
!         // content of the same form as question.questiontextformat. If we are
!         // using the HTML editor, then convert FORMAT_MOODLE content to FORMAT_HTML.
!         $rs = $DB->get_recordset_sql('
                  SELECT qno.*, q.oldquestiontextformat
                  FROM {question_numerical_options} qno
                  JOIN {question} q ON qno.question = q.id');
!         foreach ($rs as $record) {
!             if ($CFG->texteditors !== 'textarea' && $record->oldquestiontextformat == FORMAT_MOODLE) {
!                 $record->instructions = text_to_html($record->questiontext, false, false, true);
!                 $record->instructionsformat = FORMAT_HTML;
!             } else {
!                 $record->instructionsformat = $record->oldquestiontextformat;
!             }
!             $DB->update_record('question_numerical_options', $record);
!         }
!         $rs->close();
! 
!         // numerical savepoint reached
!         upgrade_plugin_savepoint(true, 2009100101, 'qtype', 'numerical');
!     }
  
!     return true;
  }
  
  
--- 21,90 ----
  // before any action that may take longer time to finish.
  
  function xmldb_qtype_numerical_upgrade($oldversion) {
! 	global $CFG, $DB;
  
! 	$dbman = $DB->get_manager();
  
! 	//===== 1.9.0 upgrade line ======//
! 	if ($oldversion < 2009100100 ) { //New version in version.php
  
! 		/// Define table question_numerical_options to be created
! 		$table = new xmldb_table('question_numerical_options');
! 
! 		/// Adding fields to table question_numerical_options
! 		$table->add_field('id', XMLDB_TYPE_INTEGER, '10', XMLDB_UNSIGNED, XMLDB_NOTNULL, XMLDB_SEQUENCE, null);
! 		$table->add_field('question', XMLDB_TYPE_INTEGER, '10', XMLDB_UNSIGNED, XMLDB_NOTNULL, null, '0');
! 		$table->add_field('instructions', XMLDB_TYPE_TEXT, 'small', null, null, null, null);
! 		$table->add_field('showunits', XMLDB_TYPE_INTEGER, '4', XMLDB_UNSIGNED, XMLDB_NOTNULL, null, '0');
! 		$table->add_field('unitsleft', XMLDB_TYPE_INTEGER, '4', null, XMLDB_NOTNULL, null, '0');
! 		$table->add_field('unitgradingtype', XMLDB_TYPE_INTEGER, '4', XMLDB_UNSIGNED, XMLDB_NOTNULL, null, '0');
! 		$table->add_field('unitpenalty', XMLDB_TYPE_NUMBER, '12, 7', XMLDB_UNSIGNED, XMLDB_NOTNULL, null, '0.1');
! 
! 		/// Adding keys to table question_numerical_options
! 		$table->add_key('primary', XMLDB_KEY_PRIMARY, array('id'));
! 		$table->add_key('question', XMLDB_KEY_FOREIGN, array('question'), 'question', array('id'));
! 		/// Conditionally launch create table for question_calculated_options
! 		if (!$dbman->table_exists($table)) {
! 			// $dbman->create_table doesnt return a result, we just have to trust it
! 			$dbman->create_table($table);
! 		}//else
! 		upgrade_plugin_savepoint(true, 2009100100, 'qtype', 'numerical');
! 	}
! 
! 	if ($oldversion < 2009100101) {
! 
! 		// Define field instructionsformat to be added to question_numerical_options
! 		$table = new xmldb_table('question_numerical_options');
! 		$field = new xmldb_field('instructionsformat', XMLDB_TYPE_INTEGER, '2', null, XMLDB_NOTNULL, null, '0', 'instructions');
! 
! 		// Conditionally launch add field instructionsformat
! 		if (!$dbman->field_exists($table, $field)) {
! 			$dbman->add_field($table, $field);
! 		}
! 
! 		// In the past, question_match_sub.questiontext assumed to contain
! 		// content of the same form as question.questiontextformat. If we are
! 		// using the HTML editor, then convert FORMAT_MOODLE content to FORMAT_HTML.
! 		$rs = $DB->get_recordset_sql('
                  SELECT qno.*, q.oldquestiontextformat
                  FROM {question_numerical_options} qno
                  JOIN {question} q ON qno.question = q.id');
! 		foreach ($rs as $record) {
! 			if ($CFG->texteditors !== 'textarea' && $record->oldquestiontextformat == FORMAT_MOODLE) {
! 				$record->instructions = text_to_html($record->questiontext, false, false, true);
! 				$record->instructionsformat = FORMAT_HTML;
! 			} else {
! 				$record->instructionsformat = $record->oldquestiontextformat;
! 			}
! 			$DB->update_record('question_numerical_options', $record);
! 		}
! 		$rs->close();
! 
! 		// numerical savepoint reached
! 		upgrade_plugin_savepoint(true, 2009100101, 'qtype', 'numerical');
! 	}
  
! 	return true;
  }
  
  
diff -crB questionorg/type/numerical/display.html questionupd/type/numerical/display.html
*** questionorg/type/numerical/display.html	2012-04-13 12:31:12.531178275 +0500
--- questionupd/type/numerical/display.html	2012-04-13 09:42:58.000000000 +0500
***************
*** 1,55 ****
  <div class="qtext">
!   <?php echo $questiontext; ?>
  </div>
  
  <div class="ablock clearfix">
!   <div class="prompt">
!     <?php echo get_string("answer", "quiz").': '; ?>
!   </div>
! <div  class="que numerical clearfix">
! <?php
          $textlength = 20 ;
  ?>
  
! <?php
   if ( $question->options->unitsleft == 0 ){ ?>
  
!   <div class="answer">
!     <fieldset class="answer"  id="generalheader">
!          <legend class="ftoggler">
!             <?php 
                  echo $OUTPUT->help_icon('validnumberformats', 'qtype_numerical', '');
                  echo get_string('datasetnumber', 'quiz') ; 
              ?>
!          </legend>
!     <input type="text" class="<?php echo $class; ?>" <?php echo "$readonly  $nameanswer $valueanswer"; //
!     ?> size="<?php echo $textlength;?>" />
!     <?php echo $feedbackimg; 
      if(! $answerasterisk  && $question->options->unitgradingtype != 0 &&  $unit_in_numerical_answer){
          print_string('nonvalidcharactersinnumber', 'qtype_numerical'); 
      }
          
  
      ?>
! </fieldset>
!   </div>
  
  
! <?php }// display unit
          
          if ($question->options->showunits == NUMERICALQUESTIONUNITNODISPLAY || (isset($question->options->units) && count($question->options->units) == 0 )) {// no unit display or tested
  
  ?>
!   <div class="answer">
!     <input type="hidden" <?php echo $nameunit; ?> value ="" />
!   </div>
! <?php
    } else if ($question->options->showunits == NUMERICALQUESTIONUNITTEXTINPUTDISPLAY  ) {// display unit text input
  ?>
! <div class="answer numerical ">
!     <fieldset class="clearfix"  id="generalheader">
!          <legend class="ftoggler">
!             <?php
                  if ( $question->options->unitgradingtype == 0 ){
                      echo $OUTPUT->help_icon('unitoptional', 'qtype_numerical', '');
                  }else { // unitgradingtype ==  1 
--- 1,61 ----
  <div class="qtext">
! 	<?php 
! 	$_SESSION['content'].="&nbsp;&nbsp;&nbsp;&nbsp;".$questiontext."</b></td></tr>";
! 	echo $questiontext; ?>
  </div>
  
  <div class="ablock clearfix">
! 	<div class="prompt">
! 		<?php $_SESSION['content'].="<tr><td>".get_string("answer", "quiz")." : "; 
! 		  echo get_string("answer", "quiz").': '; ?>
! 	</div>
! 	<div class="que numerical clearfix">
! 		<?php
          $textlength = 20 ;
  ?>
  
! 		<?php
   if ( $question->options->unitsleft == 0 ){ ?>
  
! 		<div class="answer">
! 			<fieldset class="answer" id="generalheader">
! 				<legend class="ftoggler">
! 					<?php 
                  echo $OUTPUT->help_icon('validnumberformats', 'qtype_numerical', '');
                  echo get_string('datasetnumber', 'quiz') ; 
              ?>
! 				</legend>
! 				<input type="text" class="<?php echo $class; ?>"<?php echo
! 				"$readonly $nameanswer $valueanswer"; ?> size="
! 				<?php  $_SESSION['content'].=$valueanswer." </td></tr> ";
! 	 echo $textlength;?>
! 				" />
! 				<?php echo  $feedbackimg; 
      if(! $answerasterisk  && $question->options->unitgradingtype != 0 &&  $unit_in_numerical_answer){
          print_string('nonvalidcharactersinnumber', 'qtype_numerical'); 
      }
          
  
      ?>
! 			</fieldset>
! 		</div>
  
  
! 		<?php }// display unit
          
          if ($question->options->showunits == NUMERICALQUESTIONUNITNODISPLAY || (isset($question->options->units) && count($question->options->units) == 0 )) {// no unit display or tested
  
  ?>
! 		<div class="answer">
! 			<input type="hidden"<?php echo $nameunit; ?> value ="" />
! 		</div>
! 		<?php
    } else if ($question->options->showunits == NUMERICALQUESTIONUNITTEXTINPUTDISPLAY  ) {// display unit text input
  ?>
! 		<div class="answer numerical ">
! 			<fieldset class="clearfix" id="generalheader">
! 				<legend class="ftoggler">
! 					<?php
                  if ( $question->options->unitgradingtype == 0 ){
                      echo $OUTPUT->help_icon('unitoptional', 'qtype_numerical', '');
                  }else { // unitgradingtype ==  1 
***************
*** 58,67 ****
                  echo get_string('unit', 'quiz'); 
                  if ($state->responses['unit'] == '')$classunit = '';
                  ?>
!          </legend>
!     <input type="text" class="<?php echo $classunit; ?>" <?php echo "$readonly  $nameunit $valueunit"; //
!     ?> size="<?php echo $textlength;?>"/>
!     <?php if ($state->responses['unit'] != '') echo $feedbackimgunit; 
      if ($options->feedback &&  $question->options->unitgradingtype == 1 && ! $valid_numerical_unit && ! $answerasterisk ){
          if (!empty($empty_unit)) {
              print_string('unitmandatory', 'qtype_numerical'); 
--- 64,75 ----
                  echo get_string('unit', 'quiz'); 
                  if ($state->responses['unit'] == '')$classunit = '';
                  ?>
! 				</legend>
! 				<input type="text" class="<?php echo $classunit; ?>"<?php
! 				echo "$readonly $nameunit $valueunit"; // ?> size="
! 				<?php echo $textlength;?>
! 				"/>
! 				<?php if ($state->responses['unit'] != '') echo $feedbackimgunit; 
      if ($options->feedback &&  $question->options->unitgradingtype == 1 && ! $valid_numerical_unit && ! $answerasterisk ){
          if (!empty($empty_unit)) {
              print_string('unitmandatory', 'qtype_numerical'); 
***************
*** 83,123 ****
          }
      }
      ?>
! </fieldset>
!   </div>
! <?php
  
    } else if ($question->options->showunits == NUMERICALQUESTIONUNITTEXTDISPLAY ) {// display text
  
  ?>
!   <div class="answer">
!     <fieldset class="clearfix"  id="generalheader">
!          <legend class="ftoggler">
!             <?php echo get_string('unit', 'quiz');
               ?>
!          </legend>
!     <input type="hidden" <?php echo $nameunit; echo $valueunit; ?> />
!     <?php echo $question->options->units[0]->unit; echo '&nbsp; '; ?>
!     </fieldset>
!   </div>
  
!   <?php
  
      //display the units as choice
      } else if ($question->options->showunits == NUMERICALQUESTIONUNITMULTICHOICEDISPLAY){?>
! <?php
      //display the units as choice 
      if ( isset($question->options->units)){?>
!     <div class="answer">
!     <fieldset class="clearfix"  id="generalheader">
!          <legend class="ftoggler">
!             <?php 
                 echo get_string('selectunit', 'qtype_numerical');
               ?>
!          </legend>
!          <table >
  
! <?php
              // the order is not shuffled
              //however the unitvalue is related to the number value
              // if the response/unit->multiplier is true then
--- 91,132 ----
          }
      }
      ?>
! 			</fieldset>
! 		</div>
! 		<?php
  
    } else if ($question->options->showunits == NUMERICALQUESTIONUNITTEXTDISPLAY ) {// display text
  
  ?>
! 		<div class="answer">
! 			<fieldset class="clearfix" id="generalheader">
! 				<legend class="ftoggler">
! 					<?php echo get_string('unit', 'quiz');
               ?>
! 				</legend>
! 				<input type="hidden"<?php echo $nameunit; echo $valueunit;
! 				?> />
! 				<?php echo $question->options->units[0]->unit; echo '&nbsp; '; ?>
! 			</fieldset>
! 		</div>
  
! 		<?php
  
      //display the units as choice
      } else if ($question->options->showunits == NUMERICALQUESTIONUNITMULTICHOICEDISPLAY){?>
! 		<?php
      //display the units as choice 
      if ( isset($question->options->units)){?>
! 		<div class="answer">
! 			<fieldset class="clearfix" id="generalheader">
! 				<legend class="ftoggler">
! 					<?php 
                 echo get_string('selectunit', 'qtype_numerical');
               ?>
! 				</legend>
! 				<table>
  
! 					<?php
              // the order is not shuffled
              //however the unitvalue is related to the number value
              // if the response/unit->multiplier is true then
***************
*** 203,279 ****
                  $a->text = s($unit->unit);
                  $row = 0 ;
  ?>
!                         <tr class="<?php echo 'r'.$row = $row ? 0 : 1; ?>">
!                             <td class="c0 control " style=" ">
!                       <?php echo $a->control.'&nbsp;&nbsp;&nbsp;'; ?>
!                             </td>
!                             <td style=" " class="c1 text <?php echo $a->class ?>">
!                                 <label for="<?php echo $a->id ?>">
!                         <?php echo $a->text.'<br />'; ?>
!                         <?php echo $a->feedbackimg; 
                          if ($options->feedback &&  $classunit == 0  && $chosen && !$answerasterisk){
                              print_string('unitnotvalid', 'qtype_numerical');
                          }else {
                              echo '&nbsp;&nbsp;&nbsp;';
                          }
! ?>
!                                 </label>
!                             </td>
!                         </tr>
!                 <?php } ?>
!                     </table>
!              <?php    if ($options->feedback && isset($state->responses['answer'])&& $state->responses['answer'] != '' &&  (!isset($state->responses['unit']) || $state->responses['unit'] == '') && ! $answerasterisk ){
          
              print_string('unitnotselected', 'qtype_numerical'); 
          }
          ?>
!         
!          </fieldset>    
!     </div>
!             <?php } // end unit choices
              // display intructions
              // general message first
          }
  
   if ($question->options->unitsleft == 1 ){?>
  
!  <div class="answer">
!     <fieldset class="clearfix"  id="generalheader">
!          <legend class="ftoggler">
!             <?php 
                  echo $OUTPUT->help_icon('validnumberformats', 'qtype_numerical', ''); 
                  echo get_string('datasetnumber', 'quiz'); 
              ?>
!          </legend>
!     <input type="text" class="<?php echo $class; ?>" <?php echo "$readonly  $nameanswer $valueanswer"; //
!     ?> size="<?php echo $textlength;?>"/>
!     <?php echo $feedbackimg; ?>
!    </fieldset>
!   </div>
! <?php }
  
          //</div> put a div to enclose the answer and unit elements
  ?>
! </div>
  
  
!      <?php if (!empty($question->options->instructions)){?>
!        <div class="feedback">
!         <fieldset class="clearfix"  id="generalheader">
!          <legend class="ftoggler">
!             <?php echo get_string('instructions', 'auth'); ?>
!          </legend>
!         <div>
!      <?php echo format_text($question->options->instructions, $question->options->instructionsformat, $formatoptions, $cmoptions->course);?>
!         </div>
!      </fieldset>
!      </div>
!      <?php }?>
! 
!   <?php if ($feedback) { ?>
!     <div class="feedback">
!       <?php echo $feedback ?>
!     </div>
!   <?php } ?>
!   <?php $this->print_question_submit_buttons($question, $state, $cmoptions, $options); ?>
  </div>
--- 212,286 ----
                  $a->text = s($unit->unit);
                  $row = 0 ;
  ?>
! 					<tr class="<?php echo 'r'.$row = $row ? 0 : 1; ?>">
! 						<td class="c0 control " style="">
! 							<?php echo $a->control.'&nbsp;&nbsp;&nbsp;'; ?></td>
! 						<td style="" class="c1 text <?php echo $a->class ?>"><label
! 							for="<?php echo $a->id ?>"> <?php echo $a->text.'<br />'; ?>
! 								<?php echo $a->feedbackimg; 
                          if ($options->feedback &&  $classunit == 0  && $chosen && !$answerasterisk){
                              print_string('unitnotvalid', 'qtype_numerical');
                          }else {
                              echo '&nbsp;&nbsp;&nbsp;';
                          }
! ?> </label></td>
! 					</tr>
! 					<?php } ?>
! 				</table>
! 				<?php    if ($options->feedback && isset($state->responses['answer'])&& $state->responses['answer'] != '' &&  (!isset($state->responses['unit']) || $state->responses['unit'] == '') && ! $answerasterisk ){
          
              print_string('unitnotselected', 'qtype_numerical'); 
          }
          ?>
! 
! 			</fieldset>
! 		</div>
! 		<?php } // end unit choices
              // display intructions
              // general message first
          }
  
   if ($question->options->unitsleft == 1 ){?>
  
! 		<div class="answer">
! 			<fieldset class="clearfix" id="generalheader">
! 				<legend class="ftoggler">
! 					<?php 
                  echo $OUTPUT->help_icon('validnumberformats', 'qtype_numerical', ''); 
                  echo get_string('datasetnumber', 'quiz'); 
              ?>
! 				</legend>
! 				<input type="text" class="<?php echo $class; ?>"<?php echo
! 				"$readonly $nameanswer $valueanswer"; ?> size="
! 				<?php echo $textlength;?>
! 				"/>
! 				<?php echo $feedbackimg; ?>
! 			</fieldset>
! 		</div>
! 		<?php }
  
          //</div> put a div to enclose the answer and unit elements
  ?>
! 	</div>
  
  
! 	<?php if (!empty($question->options->instructions)){?>
! 	<div class="feedback">
! 		<fieldset class="clearfix" id="generalheader">
! 			<legend class="ftoggler">
! 				<?php echo get_string('instructions', 'auth'); ?>
! 			</legend>
! 			<div>
! 				<?php echo format_text($question->options->instructions, $question->options->instructionsformat, $formatoptions, $cmoptions->course);?>
! 			</div>
! 		</fieldset>
! 	</div>
! 	<?php }?>
! 
! 	<?php if ($feedback) { ?>
! 	<div class="feedback">
! 		<?php echo $feedback ?>
! 	</div>
! 	<?php } ?>
! 	<?php $this->print_question_submit_buttons($question, $state, $cmoptions, $options); ?>
  </div>
diff -crB questionorg/type/numerical/edit_numerical_form.php questionupd/type/numerical/edit_numerical_form.php
*** questionorg/type/numerical/edit_numerical_form.php	2012-04-13 12:31:12.472178273 +0500
--- questionupd/type/numerical/edit_numerical_form.php	2012-04-13 09:42:58.000000000 +0500
***************
*** 30,131 ****
   */
  class question_edit_numerical_form extends question_edit_form {
  
!     function get_per_answer_fields(&$mform, $label, $gradeoptions, &$repeatedoptions, &$answersoption) {
!         $repeated = parent::get_per_answer_fields($mform, $label, $gradeoptions, $repeatedoptions, $answersoption);
  
!         $tolerance =& $mform->createElement('text', 'tolerance', get_string('acceptederror', 'quiz'));
!         $repeatedoptions['tolerance']['type'] = PARAM_NUMBER;
!         array_splice($repeated, 3, 0, array($tolerance));
!         $repeated[1]->setSize(10);
! 
!         return $repeated;
!     }
! 
!     /**
!      * Add question-type specific form fields.
!      *
!      * @param MoodleQuickForm $mform the form being built.
!      */
!     function definition_inner(&$mform) {
!         global $QTYPES ;
! 
! //------------------------------------------------------------------------------------------
!         $creategrades = get_grade_options();
!         $this->add_per_answer_fields($mform, get_string('answerno', 'qtype_numerical', '{no}'),
!                 $creategrades->gradeoptions);
! //------------------------------------------------------------------------------------------
!         $QTYPES['numerical']->add_units_options($mform,$this);
!         $QTYPES['numerical']->add_units_elements($mform,$this);
!     }
! 
!     function data_preprocessing($question) {
!         global $QTYPES ;
!         if (isset($question->options)){
!             $answers = $question->options->answers;
!             if (count($answers)) {
!                 $key = 0;
!                 foreach ($answers as $answer){
!                     $draftid = file_get_submitted_draft_itemid('feedback['.$key.']');
!                     $default_values['answer['.$key.']'] = $answer->answer;
!                     $default_values['fraction['.$key.']'] = $answer->fraction;
!                     $default_values['tolerance['.$key.']'] = $answer->tolerance;
!                     $default_values['feedback['.$key.']'] = array();
!                     $default_values['feedback['.$key.']']['format'] = $answer->feedbackformat;
!                     $default_values['feedback['.$key.']']['text'] = file_prepare_draft_area(
!                         $draftid,       // draftid
!                         $this->context->id,    // context
                          'question',   // component
                          'answerfeedback',             // filarea
!                         !empty($answer->id)?(int)$answer->id:null, // itemid
!                         $this->fileoptions,    // options
!                         $answer->feedback      // text
!                     );
!                     $default_values['feedback['.$key.']']['itemid'] = $draftid;
!                     $key++;
!                 }
!             }
!             $QTYPES['numerical']->set_numerical_unit_data($this, $question, $default_values);
! 
!             $question = (object)((array)$question + $default_values);
!         }
!         return $question;
!     }
! 
!     function validation($data, $files) {
!         global $QTYPES;
!         $errors = parent::validation($data, $files);
! 
!         // Check the answers.
!         $answercount = 0;
!         $maxgrade = false;
!         $answers = $data['answer'];
!         foreach ($answers as $key => $answer) {
!             $trimmedanswer = trim($answer);
!             if ($trimmedanswer != '') {
!                 $answercount++;
!                 if (!(is_numeric($trimmedanswer) || $trimmedanswer == '*')) {
!                     $errors["answer[$key]"] = get_string('answermustbenumberorstar', 'qtype_numerical');
!                 }
!                 if ($data['fraction'][$key] == 1) {
!                     $maxgrade = true;
!                 }
!             } else if ($data['fraction'][$key] != 0 || !html_is_blank($data['feedback'][$key]['text'])) {
!                 $errors["answer[$key]"] = get_string('answermustbenumberorstar', 'qtype_numerical');
!                 $answercount++;
!             }
!         }
!         if ($answercount == 0) {
!             $errors['answer[0]'] = get_string('notenoughanswers', 'qtype_numerical');
!         }
!         if ($maxgrade == false) {
!             $errors['fraction[0]'] = get_string('fractionsnomax', 'question');
!         }
!         $QTYPES['numerical']->validate_numerical_options($data, $errors) ;
! 
!         return $errors;
!     }
! 
!     function qtype() {
!         return 'numerical';
!     }
  }
--- 30,131 ----
   */
  class question_edit_numerical_form extends question_edit_form {
  
! 	function get_per_answer_fields(&$mform, $label, $gradeoptions, &$repeatedoptions, &$answersoption) {
! 		$repeated = parent::get_per_answer_fields($mform, $label, $gradeoptions, $repeatedoptions, $answersoption);
  
! 		$tolerance =& $mform->createElement('text', 'tolerance', get_string('acceptederror', 'quiz'));
! 		$repeatedoptions['tolerance']['type'] = PARAM_NUMBER;
! 		array_splice($repeated, 3, 0, array($tolerance));
! 		$repeated[1]->setSize(10);
! 
! 		return $repeated;
! 	}
! 
! 	/**
! 	 * Add question-type specific form fields.
! 	 *
! 	 * @param MoodleQuickForm $mform the form being built.
! 	 */
! 	function definition_inner(&$mform) {
! 		global $QTYPES ;
! 
! 		//------------------------------------------------------------------------------------------
! 		$creategrades = get_grade_options();
! 		$this->add_per_answer_fields($mform, get_string('answerno', 'qtype_numerical', '{no}'),
! 		$creategrades->gradeoptions);
! 		//------------------------------------------------------------------------------------------
! 		$QTYPES['numerical']->add_units_options($mform,$this);
! 		$QTYPES['numerical']->add_units_elements($mform,$this);
! 	}
! 
! 	function data_preprocessing($question) {
! 		global $QTYPES ;
! 		if (isset($question->options)){
! 			$answers = $question->options->answers;
! 			if (count($answers)) {
! 				$key = 0;
! 				foreach ($answers as $answer){
! 					$draftid = file_get_submitted_draft_itemid('feedback['.$key.']');
! 					$default_values['answer['.$key.']'] = $answer->answer;
! 					$default_values['fraction['.$key.']'] = $answer->fraction;
! 					$default_values['tolerance['.$key.']'] = $answer->tolerance;
! 					$default_values['feedback['.$key.']'] = array();
! 					$default_values['feedback['.$key.']']['format'] = $answer->feedbackformat;
! 					$default_values['feedback['.$key.']']['text'] = file_prepare_draft_area(
! 					$draftid,       // draftid
! 					$this->context->id,    // context
                          'question',   // component
                          'answerfeedback',             // filarea
! 					!empty($answer->id)?(int)$answer->id:null, // itemid
! 					$this->fileoptions,    // options
! 					$answer->feedback      // text
! 					);
! 					$default_values['feedback['.$key.']']['itemid'] = $draftid;
! 					$key++;
! 				}
! 			}
! 			$QTYPES['numerical']->set_numerical_unit_data($this, $question, $default_values);
! 
! 			$question = (object)((array)$question + $default_values);
! 		}
! 		return $question;
! 	}
! 
! 	function validation($data, $files) {
! 		global $QTYPES;
! 		$errors = parent::validation($data, $files);
! 
! 		// Check the answers.
! 		$answercount = 0;
! 		$maxgrade = false;
! 		$answers = $data['answer'];
! 		foreach ($answers as $key => $answer) {
! 			$trimmedanswer = trim($answer);
! 			if ($trimmedanswer != '') {
! 				$answercount++;
! 				if (!(is_numeric($trimmedanswer) || $trimmedanswer == '*')) {
! 					$errors["answer[$key]"] = get_string('answermustbenumberorstar', 'qtype_numerical');
! 				}
! 				if ($data['fraction'][$key] == 1) {
! 					$maxgrade = true;
! 				}
! 			} else if ($data['fraction'][$key] != 0 || !html_is_blank($data['feedback'][$key]['text'])) {
! 				$errors["answer[$key]"] = get_string('answermustbenumberorstar', 'qtype_numerical');
! 				$answercount++;
! 			}
! 		}
! 		if ($answercount == 0) {
! 			$errors['answer[0]'] = get_string('notenoughanswers', 'qtype_numerical');
! 		}
! 		if ($maxgrade == false) {
! 			$errors['fraction[0]'] = get_string('fractionsnomax', 'question');
! 		}
! 		$QTYPES['numerical']->validate_numerical_options($data, $errors) ;
! 
! 		return $errors;
! 	}
! 
! 	function qtype() {
! 		return 'numerical';
! 	}
  }
diff -crB questionorg/type/numerical/lib.php questionupd/type/numerical/lib.php
*** questionorg/type/numerical/lib.php	2012-04-13 12:31:12.751178279 +0500
--- questionupd/type/numerical/lib.php	2012-04-13 09:42:58.000000000 +0500
***************
*** 25,31 ****
   * @license   http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
   */
  function qtype_numerical_pluginfile($course, $cm, $context, $filearea, $args, $forcedownload) {
!     global $CFG;
!     require_once($CFG->libdir . '/questionlib.php');
!     question_pluginfile($course, $context, 'qtype_numerical', $filearea, $args, $forcedownload);
  }
--- 25,31 ----
   * @license   http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
   */
  function qtype_numerical_pluginfile($course, $cm, $context, $filearea, $args, $forcedownload) {
! 	global $CFG;
! 	require_once($CFG->libdir . '/questionlib.php');
! 	question_pluginfile($course, $context, 'qtype_numerical', $filearea, $args, $forcedownload);
  }
diff -crB questionorg/type/numerical/questiontype.php questionupd/type/numerical/questiontype.php
*** questionorg/type/numerical/questiontype.php	2012-04-13 12:31:12.665178275 +0500
--- questionupd/type/numerical/questiontype.php	2012-04-13 09:42:58.000000000 +0500
***************
*** 38,1397 ****
  
  class question_numerical_qtype extends question_shortanswer_qtype {
  
!     public $virtualqtype = false;
!     function name() {
!         return 'numerical';
!     }
! 
!     function has_wildcards_in_responses() {
!         return true;
!     }
! 
!     function requires_qtypes() {
!         return array('shortanswer');
!     }
! 
!     function get_question_options(&$question) {
!         // Get the question answers and their respective tolerances
!         // Note: question_numerical is an extension of the answer table rather than
!         //       the question table as is usually the case for qtype
!         //       specific tables.
!         global $CFG, $DB, $OUTPUT;
!         if (!$question->options->answers = $DB->get_records_sql(
                                  "SELECT a.*, n.tolerance " .
                                  "FROM {question_answers} a, " .
                                  "     {question_numerical} n " .
                                  "WHERE a.question = ? " .
                                  "    AND   a.id = n.answer " .
                                  "ORDER BY a.id ASC", array($question->id))) {
!             echo $OUTPUT->notification('Error: Missing question answer for numerical question ' . $question->id . '!');
!             return false;
!         }
!         $this->get_numerical_units($question);
!         //get_numerical_options() need to know if there are units
!         // to set correctly default values
!         $this->get_numerical_options($question);
! 
!         // If units are defined we strip off the default unit from the answer, if
!         // it is present. (Required for compatibility with the old code and DB).
!         if ($defaultunit = $this->get_default_numerical_unit($question)) {
!             foreach($question->options->answers as $key => $val) {
!                 $answer = trim($val->answer);
!                 $length = strlen($defaultunit->unit);
!                 if ($length && substr($answer, -$length) == $defaultunit->unit) {
!                     $question->options->answers[$key]->answer =
!                             substr($answer, 0, strlen($answer)-$length);
!                 }
!             }
!         }
! 
!         return true;
!     }
!     function get_numerical_units(&$question) {
!         global $DB;
!         if ($units = $DB->get_records('question_numerical_units', array('question' => $question->id), 'id ASC')) {
!             $units  = array_values($units);
!         } else {
!             $units = array();
!         }
!         foreach ($units as $key => $unit) {
!             $units[$key]->multiplier = clean_param($unit->multiplier, PARAM_NUMBER);
!         }
!         $question->options->units = $units;
!         return true;
!     }
! 
!     function get_default_numerical_unit(&$question) {
!         if (isset($question->options->units[0])) {
!             foreach ($question->options->units as $unit) {
!                 if (abs($unit->multiplier - 1.0) < '1.0e-' . ini_get('precision')) {
!                     return $unit;
!                 }
!             }
!         }
!         return false;
!     }
! 
!     function get_numerical_options(&$question) {
!         global $DB;
!         if (!$options = $DB->get_record('question_numerical_options', array('question' => $question->id))) {
!             $question->options->unitgradingtype = 0; // total grade
!             $question->options->unitpenalty = 0.1; // default for old questions
!             // the default
!             if ($defaultunit = $this->get_default_numerical_unit($question)) {
!                 // so units can be graded
!                 $question->options->showunits = NUMERICALQUESTIONUNITTEXTINPUTDISPLAY ;
!             }else {
!                 // only numerical will be graded
!                 $question->options->showunits = NUMERICALQUESTIONUNITNODISPLAY ;
!             }
!             $question->options->unitsleft = 0 ;
!             $question->options->instructions = '';
!             $question->options->instructionsformat = editors_get_preferred_format();
!         } else {
!             $question->options->unitgradingtype = $options->unitgradingtype;
!             $question->options->unitpenalty = $options->unitpenalty;
!             $question->options->showunits = $options->showunits;
!             $question->options->unitsleft = $options->unitsleft;
!             $question->options->instructions = $options->instructions;
!             $question->options->instructionsformat = $options->instructionsformat; 
!         }
! 
!         return true;
!     }
! 
! 
!     /**
!      * Save the units and the answers associated with this question.
!      */
!     function save_question_options($question) {
!         global $DB;
!         $context = $question->context;
! 
!         // Get old versions of the objects
!         $oldanswers = $DB->get_records('question_answers',
!                 array('question' => $question->id), 'id ASC');
!         $oldoptions = $DB->get_records('question_numerical',
!                 array('question' => $question->id), 'answer ASC');
! 
!         // Save the units.
!         $result = $this->save_numerical_units($question);
!         if (isset($result->error)) {
!             return $result;
!         } else {
!             $units = $result->units;
!         }
! 
!         // Insert all the new answers
!         foreach ($question->answer as $key => $answerdata) {
!             // Check for, and ingore, completely blank answer from the form.
!             if (trim($answerdata) == '' && $question->fraction[$key] == 0 &&
!                     html_is_blank($question->feedback[$key]['text'])) {
!                 continue;
!             }
! 
!             // Update an existing answer if possible.
!             $answer = array_shift($oldanswers);
!             if (!$answer) {
!                 $answer = new stdClass();
!                 $answer->question = $question->id;
!                 $answer->answer = '';
!                 $answer->feedback = '';
!                 $answer->id = $DB->insert_record('question_answers', $answer);
!             }
! 
!             if (trim($answerdata) === '*') {
!                 $answer->answer = '*';
!             } else {
!                 $answer->answer = $this->apply_unit($answerdata, $units);
!                 if ($answer->answer === false) {
!                     $result->notice = get_string('invalidnumericanswer', 'quiz');
!                 }
!             }
!             $answer->fraction = $question->fraction[$key];
!             $answer->feedback = $this->import_or_save_files($question->feedback[$key],
!                     $context, 'question', 'answerfeedback', $answer->id);
!             $answer->feedbackformat = $question->feedback[$key]['format'];
!             $DB->update_record('question_answers', $answer);
! 
!             // Set up the options object
!             if (!$options = array_shift($oldoptions)) {
!                 $options = new stdClass();
!             }
!             $options->question = $question->id;
!             $options->answer   = $answer->id;
!             if (trim($question->tolerance[$key]) == '') {
!                 $options->tolerance = '';
!             } else {
!                 $options->tolerance = $this->apply_unit($question->tolerance[$key], $units);
!                 if ($options->tolerance === false) {
!                     $result->notice = get_string('invalidnumerictolerance', 'quiz');
!                 }
!             }
!             if (isset($options->id)) {
!                 $DB->update_record('question_numerical', $options);
!             } else {
!                 $DB->insert_record('question_numerical', $options);
!             }
!         }
! 
!         // Delete any left over old answer records.
!         $fs = get_file_storage();
!         foreach($oldanswers as $oldanswer) {
!             $fs->delete_area_files($context->id, 'question', 'answerfeedback', $oldanswer->id);
!             $DB->delete_records('question_answers', array('id' => $oldanswer->id));
!         }
!         foreach($oldoptions as $oldoption) {
!             $DB->delete_records('question_numerical', array('id' => $oldoption->id));
!         }
! 
!         $result = $this->save_numerical_options($question);
!         if (!empty($result->error) || !empty($result->notice)) {
!             return $result;
!         }
! 
!         return true;
!     }
! 
!     /**
!      * The numerical options control the display and the grading of the unit
!      * part of the numerical question and related types (calculateds)
!      * Questions previous to 2,0 do not have this table as multianswer questions
!      * in all versions including 2,0. The default values are set to give the same grade
!      * as old question.
!      *
!      */
!     function save_numerical_options($question) {
!         global $DB;
! 
!         $result = new stdClass;
! 
!         $update = true ;
!         $options = $DB->get_record('question_numerical_options', array('question' => $question->id));
!         if (!$options) {
!             $options = new stdClass;
!             $options->question = $question->id;
!             $options->instructions = '';
!             $options->id = $DB->insert_record('question_numerical_options', $options);
!         }
! 
!         if (isset($question->options->unitgradingtype)) {
!             $options->unitgradingtype = $question->options->unitgradingtype;
!         } else {
!             $options->unitgradingtype = 0 ;
!         }
!         if (isset($question->unitpenalty)){
!             $options->unitpenalty = $question->unitpenalty;
!         } else { //so this is either an old question or a close question type
!             $options->unitpenalty = 1 ;
!         }
!         // if we came from the form then 'unitrole' exists
!         if (isset($question->unitrole)){
!             switch ($question->unitrole){
!                 case '0' : $options->showunits = NUMERICALQUESTIONUNITNODISPLAY ;
!                 break ;
!                 case '1' : $options->showunits = NUMERICALQUESTIONUNITTEXTDISPLAY ;
!                 break ;
!                 case '2' : $options->showunits = NUMERICALQUESTIONUNITTEXTINPUTDISPLAY ;
!                            $options->unitgradingtype = 0 ;
!                 break ;
!                 case '3' : $options->showunits = $question->multichoicedisplay ;
!                            $options->unitgradingtype = $question->unitgradingtypes ;
!                 break ;
!             }
!         } else {
!             if (isset($question->showunits)){
!                 $options->showunits = $question->showunits;
!             } else {
!                 if ($defaultunit = $this->get_default_numerical_unit($question)) {
!                     // so units can be used
!                     $options->showunits = NUMERICALQUESTIONUNITTEXTINPUTDISPLAY ;
!                 } else {
!                     // only numerical will be graded
!                     $options->showunits = NUMERICALQUESTIONUNITNODISPLAY ;
!                 }
!             }
!         }
! 
!         if (isset($question->unitsleft)) {
!             $options->unitsleft = $question->unitsleft;
!         } else {
!             $options->unitsleft = 0 ;
!         }
! 
!         if (isset($question->instructions) && is_array($question->instructions)){
!             $options->instructions = $this->import_or_save_files($question->instructions,
!                     $question->context, 'qtype_'.$question->qtype , 'instruction', $question->id);
!             $options->instructionsformat = $question->instructions['format'];
!         } else {
!             $options->instructions = '' ;
!             $options->instructionsformat = editors_get_preferred_format();
!         }
! 
!         $DB->update_record('question_numerical_options', $options);
! 
!         return $result;
!     }
! 
!     function save_numerical_units($question) {
!         global $DB;
!         $result = new stdClass;
! 
!         // Delete the units previously saved for this question.
!         $DB->delete_records('question_numerical_units', array('question' => $question->id));
! 
!         // Nothing to do.
!         if (!isset($question->multiplier)) {
!             $result->units = array();
!             return $result;
!         }
! 
!         // Save the new units.
!         $units = array();
!         $unitalreadyinsert = array();
!         foreach ($question->multiplier as $i => $multiplier) {
!             // Discard any unit which doesn't specify the unit or the multiplier
!             if (!empty($question->multiplier[$i]) && !empty($question->unit[$i])&& !array_key_exists($question->unit[$i],$unitalreadyinsert)) {
!                 $unitalreadyinsert[$question->unit[$i]] = 1 ;
!                 $units[$i] = new stdClass;
!                 $units[$i]->question = $question->id;
!                 $units[$i]->multiplier = $this->apply_unit($question->multiplier[$i], array());
!                 $units[$i]->unit = $question->unit[$i];
!                 $DB->insert_record('question_numerical_units', $units[$i]);
!             }
!         }
!         unset($question->multiplier, $question->unit);
! 
!         $result->units = &$units;
!         return $result;
!     }
! 
!     function create_session_and_responses(&$question, &$state, $cmoptions, $attempt) {
!         $state->responses = array();
!         $state->responses['answer'] =  '';
!         $state->responses['unit'] = '';
! 
!         return true;
!     }
!     function restore_session_and_responses(&$question, &$state) {
!        if(false === strpos($state->responses[''], '|||||')){
!              $state->responses['answer']= $state->responses[''];
!              $state->responses['unit'] = '';
!              $this->split_old_answer($state->responses[''], $question->options->units, $state->responses['answer'] ,$state->responses['unit'] );
!        }else {
!             $responses = explode('|||||', $state->responses['']);
!             $state->responses['answer']= $responses[0];
!             $state->responses['unit'] = $responses[1];
!        }
! 
!        return true;
!     }
! 
!     function find_unit_index(&$question,$value){
!             $length = 0;
!             $goodkey = 0 ;
!             foreach ($question->options->units as $key => $unit){
!                     if($unit->unit ==$value ) {
!                     return $key ;
!                 }
!             }
!         return 0 ;
!     }
! 
!     function split_old_answer($rawresponse, $units, &$answer ,&$unit ) {
!         $answer = $rawresponse ;
!         // remove spaces and normalise decimal places.
!         $search  = array(' ', ',');
!         $replace = array('', '.');
!         $rawresponse = str_replace($search, $replace, trim($rawresponse));
!         if (preg_match('~^([+-]?([0-9]+(\\.[0-9]*)?|\\.[0-9]+)([eE][-+]?[0-9]+)?)([^0-9].*)?$~',
!                 $rawresponse, $responseparts)) {
!             if(isset($responseparts[5]) ){
!                 $unit = $responseparts[5] ;
!             }
!             if(isset($responseparts[1]) ){
!                 $answer = $responseparts[1] ;
!             }
!         }
!         return ;
!     }
! 
! 
!     function save_session_and_responses(&$question, &$state) {
!         global $DB;
! 
!         $responses = '';
!         if(isset($state->responses['unit']) && isset($question->options->units[$state->responses['unit']])){
!             $responses = $state->responses['answer'].'|||||'.$question->options->units[$state->responses['unit']]->unit;
!         }else if(isset($state->responses['unit'])){
!             $responses = $state->responses['answer'].'|||||'.$state->responses['unit'] ;
!         }else {
!             $responses = $state->responses['answer'].'|||||';
!         }
!         // Set the legacy answer field
!         $DB->set_field('question_states', 'answer', $responses, array('id' => $state->id));
!         return true;
!     }
! 
!     function delete_question($questionid, $contextid) {
!         global $DB;
!         $DB->delete_records('question_numerical', array('question' => $questionid));
!         $DB->delete_records('question_numerical_options', array('question' => $questionid));
!         $DB->delete_records('question_numerical_units', array('question' => $questionid));
! 
!         parent::delete_question($questionid, $contextid);
!     }
! 
!     /**
!     * This function has been reinserted in numerical/questiontype.php to simplify
!     * the separate rendering of number and unit
!     */
!     function print_question_formulation_and_controls(&$question, &$state, $cmoptions, $options) {
!         global $CFG, $OUTPUT;
! 
!         $context = $this->get_context_by_category_id($question->category);
!         $readonly = empty($options->readonly) ? '' : 'readonly="readonly"';
!         $formatoptions = new stdClass;
!         $formatoptions->noclean = true;
!         $formatoptions->para = false;
!         $nameprefix = $question->name_prefix;
!         $component = 'qtype_' . $question->qtype;        
!         // rewrite instructions text 
!         $question->options->instructions = quiz_rewrite_question_urls($question->options->instructions, 'pluginfile.php', $context->id, $component, 'instruction', array($state->attempt, $state->question), $question->id);
!         /// Print question text and media
! 
!         $questiontext = format_text($question->questiontext,
!                 $question->questiontextformat,
!                 $formatoptions, $cmoptions->course);
! 
!         /// Print input controls
!         // as the entry is controlled the question type here is numerical
!         // In all cases there is a text input for the number
!         // If $question->options->showunits == NUMERICALQUESTIONUNITTEXTDISPLAY
!         // there is an additional text input for the unit
!         // If $question->options->showunits == NUMERICALQUESTIONUNITMULTICHOICEDISPLAY"
!         // radio elements display the defined unit
!         // The code allows the input number elememt to be displayed
!         // before i.e. at left or after at rigth of the unit variants.
!         $nameanswer = "name=\"".$question->name_prefix."answer\"";
!         $nameunit   = "name=\"".$question->name_prefix."unit\"";
!         // put old answer data in $state->responses['answer'] and $state->responses['unit']
!         if (isset($state->responses['']) && $state->responses[''] != '' && !isset($state->responses['answer'])){
!               $this->split_old_answer($state->responses[''], $question->options->units, $state->responses['answer'] ,$state->responses['unit'] );
!         }
!         // prepare the values of the input elements to be dispalyed answer i.e. number  and unit
!         if (isset($state->responses['answer']) && $state->responses['answer']!='') {
!             $valueanswer = ' value="'.s($state->responses['answer']).'" ';
!         } else {
!             $valueanswer = ' value="" ';
!         }
!         if (isset($state->responses['unit']) && $state->responses['unit']!='') {
!             $valueunit = ' value="'.s($state->responses['unit']).'" ';
!         } else {
!             $valueunit = ' value="" ';
!             if ($question->options->showunits == NUMERICALQUESTIONUNITTEXTDISPLAY ){
!               $valueunit = ' value="'.s($question->options->units[0]->unit).'" ';
!             }
!         }
! 
!         $feedback = '';
!         $class = '';
!         $classunit = '' ;
!         $classunitvalue = '' ;
!         $feedbackimg = '';
!         $feedbackimgunit = '' ;
!         $answerasterisk = false ;
!         $response = '' ;
!         $valid_numerical_unit = false ;
!         $valid_numerical_unit_index = -1 ;
!         $unit_in_numerical_answer = false ;
!         $rawgrade = 0 ;
!         if ($options->feedback) {
!             $class = question_get_feedback_class(0);
!             $classunit = question_get_feedback_class(0);
!             $feedbackimg = question_get_feedback_image(0);
!             $feedbackimgunit = question_get_feedback_image(0);
!             $classunitvalue = 0 ;
!             $valid_numerical_unit_index = -1 ;
!             // if there is unit in answer and unitgradingtype = 0
!             // the grade is 0
!             //this is OK for the first answer with a good response
!             // having to test for * so response as long as not empty
!            // $response = $this->extract_numerical_response($state->responses['answer']);
!             // test for a greater than 0 grade
!             foreach($question->options->answers as $answer) {
!                 if ($this->test_response($question, $state, $answer)) {
!                     // Answer was correct or partially correct.
!                     if ( $answer->answer === '*'){
!                         $answerasterisk = true ;
!                     }
!                     // in all cases
!                     $class = question_get_feedback_class($answer->fraction);
!                     $feedbackimg = question_get_feedback_image($answer->fraction);
!                     if ($question->options->unitgradingtype == 0 || ($question->options->unitgradingtype == 0 && $answer->answer === '*')){
!                         // if * then unit has the $answer->fraction value
!                         // if $question->options->unitgradingtype == 0 everything has been checked
!                         // if $question->options->showunits == NUMERICALQUESTIONUNITTEXTINPUTDISPLAY
!                         // then number - unit combination has been used to test response
!                         // so the unit should have same color
!                         $classunit = question_get_feedback_class($answer->fraction);
!                         $feedbackimgunit = question_get_feedback_image($answer->fraction);
!                         $rawgrade = $answer->fraction ;
! 
! 
!                     }else {
!                         /* so we need to apply unit grading i.e. to check if the number-unit combination
!                         * was the rigth one
!                         * on NUMERICALQUESTIONUNITTEXTINPUTDISPLAY we need only to ckeck if applyunit will test OK
!                         * with the $state->responses['unit'] value which cannot be empty
!                         * if $state->responses['unit']
!                         * if apply-unit is true with a specific unit as long as the unit as been written either in the
!                         * we need the numerical response and test it with the available units
!                         * if the unit used is good then it should be set OK
!                         * however the unit could have been put in the number element in this case
!                         * the unit penalty should be apllied.
!                         * testing apply_unit with no units will get us a false response if there is any text in it
!                         * testing apply_unit with a given unit will get a good value if the number is good with this unit
!                         * apply unit will return the numerical if
!                         * we need to know which conditions let to a good numerical value that were done in the
!                         */
!                         $valid_numerical_unit = false ;
!                         $rawgrade = $answer->fraction ;
!                         $valid_numerical_unit_index = -1 ;
!                         $invalid_unit_in_numerical_answer = false ;
!                         if ( $answerasterisk ) {
!                             $classunit = question_get_feedback_class($answer->fraction);
!                             $feedbackimgunit = question_get_feedback_image($answer->fraction);
!                             $valid_numerical_unit = true ;//everything is true with *
!                         } else {
!                           //  if( isset($state->responses['unit']) && $state->responses['unit'] != '' ){// unit should be written in the unit input or checked in multichoice
!                             // we need to see if something was written in the answer field that was not in the number
!                             // although we cannot actually detect units put before the number which will cause bad numerical.
!                             // use extract response
!                             $response = $this->extract_numerical_response($state->responses['answer']);
!                             if(isset($response->unit ) && $response->unit != ''){
!                                 $unit_in_numerical_answer = true ;
!                             }else {
!                                 $unit_in_numerical_answer = false ;
!                             }
! 
!                             // the we let the testing to the two cases either
!                             // NUMERICALQUESTIONUNITTEXTINPUTDISPLAY or
!                             // NUMERICALQUESTIONUNITMULTICHOICEDISPLAY
!                             if( !isset($state->responses['unit']) || $state->responses['unit'] == '' ){
!                                 // unit should be written in the unit input or checked in multichoice
!                                 $valid_numerical_unit = false ;
!                                 $classunit = question_get_feedback_class(0);
!                                 $feedbackimgunit = question_get_feedback_image(0);
!                                 $empty_unit = true ;
!                             } else {
!                                // echo"<p> some unit answer <pre>";print_r($answer) ;echo"</pre></p>";
!                                // echo"<p> some unit answer <pre>";print_r($answer) ;echo"</pre></p>";
!                                 $empty_unit = false ;
!                                 $valid_numerical_unit = false ;
! 
!                                 foreach ($question->options->units as $key => $unit) {
!                                     if ($unit->unit == $state->responses['unit']){
!                                     //    $response = $this->apply_unit($state->responses['answer'].$unit->unit, array($question->options->units[$key])) ;
!                                 //       echo "<p> avant false valid_numerical_unit_index $valid_numerical_unit_index  ".$state->responses['answer']."</p>";
!                                         $invalid_unit_found = 0 ;
!                                         if ($response->number !== false) {
!                                 //echo "<p> avanr get valid_numerical_unit_index $valid_numerical_unit_index  </p>";
!                                        //     $this->get_tolerance_interval($answer);
!                                        $testresponse = $response->number /$unit->multiplier ;
!                                             if($answer->min <= $testresponse && $testresponse <= $answer->max){
!                                 //echo "<p> apres min max  valid_numerical_unit_index $valid_numerical_unit_index  </p>";
!                                                 $classunit = question_get_feedback_class($answer->fraction) ; //question_get_feedback_class(1);
!                                                 $feedbackimgunit = question_get_feedback_image($rawgrade);
!                                                 $valid_numerical_unit = true ;
!                                                 $valid_numerical_unit_index = $key ;
!                                                 break ;
!                                             }
!                                         }
!                                     }
                                  }
!                             }
!                         }
!                     }
!                     if ($answer->feedback) {
!                         $answer->feedback = quiz_rewrite_question_urls($answer->feedback, 'pluginfile.php', $context->id, 'question', 'answerfeedback', array($state->attempt, $state->question), $answer->id);
!                         $feedback = format_text($answer->feedback, $answer->feedbackformat, $formatoptions, $cmoptions->course);
!                     }
! 
!                     break;
!                 }
!             }
!     }
!         $state->options->raw_unitpenalty = 0 ;
!         $raw_unitpenalty = 0 ;
!         if( $question->options->showunits == NUMERICALQUESTIONUNITNODISPLAY ||
!                 $question->options->showunits == NUMERICALQUESTIONUNITTEXTDISPLAY ) {
!                     $classunitvalue = 1 ;
!         }
! 
!         if(! $answerasterisk  && $question->options->unitgradingtype != 0 && (! $valid_numerical_unit || $unit_in_numerical_answer)){
!             if($question->options->unitgradingtype == 1){
!                 $raw_unitpenalty = $question->options->unitpenalty * $rawgrade ;
!             }else {
!                 $raw_unitpenalty = $question->options->unitpenalty ;
!             }
!             $state->options->raw_unitpenalty = $raw_unitpenalty ;
!         }
! 
!         /// Removed correct answer, to be displayed later MDL-7496
!         include("$CFG->dirroot/question/type/numerical/display.html");
!     }
! 
! 
!     function compare_responses(&$question, $state, $teststate) {
! 
!                if ($question->options->showunits == NUMERICALQUESTIONUNITMULTICHOICEDISPLAY && isset($question->options->units) && isset($state->responses['unit']) && isset($question->options->units[$state->responses['unit']] )){
!             $state->responses['unit']=$question->options->units[$state->responses['unit']]->unit;
!         };
! 
! 
!         $responses = '';
!         $testresponses = '';
!         if (isset($state->responses['answer'])){
!             $responses = $state->responses['answer'];
!         }
!         if (isset($state->responses['unit'])){
!             $responses .= $state->responses['unit'];
!         }
!         if (isset($teststate->responses['answer'])){
!             $testresponses = $teststate->responses['answer'];
!         }
!         if (isset($teststate->responses['unit'])){
!             $testresponses .= $teststate->responses['unit'];
!         }
! 
!         if ( isset($responses)  && isset($testresponses )) {
! 
!             return $responses == $testresponses ;
!         }
!         return false;
!     }
! 
!     /**
!      * Checks whether a response matches a given answer, taking the tolerance
!      * and but NOT the unit into account. Returns a true for if a response matches the
!      * answer or in one of the unit , false if it doesn't.
!      * the total grading will see if the unit match.
!      * if unit != -1 then the test is done only on this unit
!      */
!     function test_response(&$question, &$state, $answer ) {
!         // Deal with the match anything answer.
!         if ($answer->answer === '*') {
!             return true;
!         }
!         // using old grading process if $question->unitgradingtype == 0
!         // and adding unit1 for the new option NUMERICALQUESTIONUNITTEXTDISPLAY
!         if ($question->options->unitgradingtype == 0 ){
!             // values coming form old question stored in attempts
!             if (!isset($state->responses['answer']) && isset($state->responses[''])){
!                $state->responses['answer'] =  $state->responses[''];
!             }
!             $answertotest = $state->responses['answer'];
!             // values coming from  NUMERICALQUESTIONUNITTEXTINPUTDISPLAY
!             // or NUMERICALQUESTIONUNITTEXTDISPLAY as unit hidden HTML element
! 
!             if($question->options->showunits == NUMERICALQUESTIONUNITTEXTINPUTDISPLAY ){
! 
!                 $testresponse = $this->extract_numerical_response($state->responses['answer']);
!                 if($testresponse->unit != '' || $testresponse->number === false){
!                    return false;
!                 }
!                 $answertotest = $testresponse->number ;
!             }
!             if(isset($state->responses['unit'])) {
!                 $answertotest .= $state->responses['unit'] ;
!             }
!           //  if ($question->options->showunits == NUMERICALQUESTIONUNITTEXTDISPLAY && isset($question->options->units[0])){
!            //     $answertotest .= $question->options->units[0]->unit ;
!            // }
!            // test OK if only numerical or numerical with known unit names with the unit mltiplier applied
!             $response = $this->apply_unit($answertotest, $question->options->units);
! 
!             if ($response === false) {
!                 return false; // The student did not type a number.
!             }
! 
!             // The student did type a number, so check it with tolerances.
!             $this->get_tolerance_interval($answer);
!             return ($answer->min <= $response && $response <= $answer->max);
!         } else { // $question->options->unitgradingtype > 0
!             /* testing with unitgradingtype $question->options->unitgradingtype > 0
!             * if the response is at least patially true
!             * if the numerical value agree in the interval
!             * if so the only non valid case will be a bad unit and a unity penalty.
! 
!              To be able to test (old) questions that do not have an unit
!             * input element the test is done using the $state->responses['']
!             * which contains the response which is analyzed by extract_numerical_response()
!             * If the data comes from the numerical or calculated display
!             * the $state->responses['unit'] comes from either
!             * a multichoice radio element NUMERICALQUESTIONUNITMULTICHOICEDISPLAY
!             * where the $state->responses['unit'] value is the key => unit object
!             * in the  the $question->options->units array
!             * or an input text element NUMERICALQUESTIONUNITTEXTINPUTDISPLAY
!             * which contains the student response
!             * for NUMERICALQUESTIONUNITTEXTDISPLAY and NUMERICALQUESTIONUNITNODISPLAY
!             *
!             */
! 
!             $response = $this->extract_numerical_response($state->responses['answer']);
! 
! 
!             if ($response->number === false ) {
!                 return false; // The student did not type a number.
!             }
! 
!             // The student did type a number, so check it with tolerances.
!             $this->get_tolerance_interval($answer);
!             if ($answer->min <= $response->number && $response->number <= $answer->max){
!                return true;
!             }
!             // testing for other units
!             if ( isset($question->options->units) && count($question->options->units) > 0) {
!                 foreach($question->options->units as $key =>$unit){
!                     $testresponse = $response->number /$unit->multiplier ;
!                     if($answer->min <= $testresponse && $testresponse<= $answer->max) {
!                         return true;
!                     }
!                 }
!             }
!             return false;
!         }
!         return false;
!     }
! 
!     /**
!     * Performs response processing and grading
!     * The function was redefined for handling correctly the two parts
!     * number and unit of numerical or calculated questions
!     * The code handles also the case when there no unit defined by the user or
!     * when used in a multianswer (Cloze) question.
!     * This function performs response processing and grading and updates
!     * the state accordingly.
!     * @return boolean         Indicates success or failure.
!     * @param object $question The question to be graded. Question type
!     *                         specific information is included.
!     * @param object $state    The state of the question to grade. The current
!     *                         responses are in ->responses. The last graded state
!     *                         is in ->last_graded (hence the most recently graded
!     *                         responses are in ->last_graded->responses). The
!     *                         question type specific information is also
!     *                         included. The ->raw_grade and ->penalty fields
!     *                         must be updated. The method is able to
!     *                         close the question session (preventing any further
!     *                         attempts at this question) by setting
!     *                         $state->event to QUESTION_EVENTCLOSEANDGRADE
!     * @param object $cmoptions
!     */
!     function grade_responses(&$question, &$state, $cmoptions) {
!         if ( isset($state->responses['']) && $state->responses[''] != '' && !isset($state->responses['answer'])){
!               $this->split_old_answer($state->responses[''], $question->options->units, $state->responses['answer'] ,$state->responses['unit'] );
!         }
! 
!         $state->raw_grade = 0;
!         $valid_numerical_unit = false ;
!         $break = 0 ;
!         $unittested = '';
!         $hasunits = 0 ;
!         $answerasterisk = false ;
! 
!         $break = 0 ;
!         foreach($question->options->answers as $answer) {
!             if ($this->test_response($question, $state, $answer)) {
!                 // Answer was correct or partially correct.
!                 $state->raw_grade = $answer->fraction ;
!                 if ($question->options->unitgradingtype == 0 || $answer->answer === '*'){
!                     // if * then unit has the $answer->fraction value
!                     // if $question->options->unitgradingtype == 0 everything has been checked
!                     // if $question->options->showunits == NUMERICALQUESTIONUNITTEXTINPUTDISPLAY
!                     // then number - unit combination has been used to test response
!                     // so the unit should have same color
! 
!                 }else {
!                     // so we need to apply unit grading i.e. to check if the number-unit combination
!                     // was the rigth one
!                     $valid_numerical_unit = false ;
!                     $class = question_get_feedback_class($answer->fraction);
!                     $feedbackimg = question_get_feedback_image($answer->fraction);
!                     if(isset($state->responses['unit']) && $state->responses['unit'] != '' ){
!                         foreach ($question->options->units as $key => $unit) {
!                             if ($unit->unit == $state->responses['unit']){
! 
!                                 $response = $this->apply_unit($state->responses['answer'].$state->responses['unit'], array($question->options->units[$key])) ;
!                                 if ($response !== false) {
!                                     $this->get_tolerance_interval($answer);
!                                     if($answer->min <= $response && $response <= $answer->max){
!                                         $valid_numerical_unit = true ;
!                                     }
                                  }
!                                 break ;
!                             }
!                         }
!                     }
!                 }
!                 break ;
!             }
!         }
!         // apply unit penalty
!         $raw_unitpenalty = 0 ;
!         if($question->options->unitgradingtype != 0 && !empty($question->options->unitpenalty)&& $valid_numerical_unit != true ){
!             if($question->options->unitgradingtype == 1){
!                 $raw_unitpenalty = $question->options->unitpenalty * $state->raw_grade ;
!             }else {
!                 $raw_unitpenalty = $question->options->unitpenalty ;
!             }
!             $state->raw_grade -= $raw_unitpenalty ;
!         }
! 
!         // Make sure we don't assign negative or too high marks.
!         $state->raw_grade = min(max((float) $state->raw_grade,
!                             0.0), 1.0) * $question->maxgrade;
! 
!         // Update the penalty.
!         $state->penalty = $question->penalty * $question->maxgrade;
! 
!         // mark the state as graded
!         $state->event = ($state->event ==  QUESTION_EVENTCLOSE) ? QUESTION_EVENTCLOSEANDGRADE : QUESTION_EVENTGRADE;
! 
!         return true;
!     }
! 
! 
!     function get_correct_responses(&$question, &$state) {
!         $correct = parent::get_correct_responses($question, $state);
!         $unit = $this->get_default_numerical_unit($question);
!         if (isset($correct['']) && $correct[''] != '*' && $unit) {
!             $correct[''] .= ' '.$unit->unit;
!         }
!         return $correct;
!     }
! 
!     // ULPGC ecastro
!     function get_all_responses(&$question, &$state) {
!         $result = new stdClass;
!         $answers = array();
!         $unit = $this->get_default_numerical_unit($question);
!         if (is_array($question->options->answers)) {
!             foreach ($question->options->answers as $aid=>$answer) {
!                 $r = new stdClass;
!                 $r->answer = $answer->answer;
!                 $r->credit = $answer->fraction;
!                 $this->get_tolerance_interval($answer);
!                 if ($r->answer != '*' && $unit) {
!                     $r->answer .= ' ' . $unit->unit;
!                 }
!                 if ($answer->max != $answer->min) {
!                     $max = "$answer->max"; //format_float($answer->max, 2);
!                     $min = "$answer->min"; //format_float($answer->max, 2);
!                     $r->answer .= ' ('.$min.'..'.$max.')';
!                 }
!                 $answers[$aid] = $r;
!             }
!         }
!         $result->id = $question->id;
!         $result->responses = $answers;
!         return $result;
!     }
!     function get_actual_response($question, $state) {
!        if (!empty($state->responses) && !empty($state->responses[''])) {
!            if(false === strpos($state->responses[''], '|||||')){
!                 $responses[] = $state->responses[''];
!             }else {
!                 $resp = explode('|||||', $state->responses['']);
!                 $responses[] = $resp[0].$resp[1];
!             }
!        } else {
!            $responses[] = '';
!         }
! 
!        return $responses;
!     }
! 
! 
!     function get_tolerance_interval(&$answer) {
!         // No tolerance
!         if (empty($answer->tolerance)) {
!             $answer->tolerance = 0;
!         }
! 
!         // Calculate the interval of correct responses (min/max)
!         if (!isset($answer->tolerancetype)) {
!             $answer->tolerancetype = 2; // nominal
!         }
! 
!         // We need to add a tiny fraction depending on the set precision to make the
!         // comparison work correctly. Otherwise seemingly equal values can yield
!         // false. (fixes bug #3225)
!         $tolerance = (float)$answer->tolerance + ("1.0e-".ini_get('precision'));
!         switch ($answer->tolerancetype) {
!             case '1': case 'relative':
!                 /// Recalculate the tolerance and fall through
!                 /// to the nominal case:
!                 $tolerance = $answer->answer * $tolerance;
!                 // Do not fall through to the nominal case because the tiny fraction is a factor of the answer
!                  $tolerance = abs($tolerance); // important - otherwise min and max are swapped
!                 $max = $answer->answer + $tolerance;
!                 $min = $answer->answer - $tolerance;
!                 break;
!             case '2': case 'nominal':
!                 $tolerance = abs($tolerance); // important - otherwise min and max are swapped
!                 // $answer->tolerance 0 or something else
!                 if ((float)$answer->tolerance == 0.0  &&  abs((float)$answer->answer) <= $tolerance ){
!                     $tolerance = (float) ("1.0e-".ini_get('precision')) * abs((float)$answer->answer) ; //tiny fraction
!                 } else if ((float)$answer->tolerance != 0.0 && abs((float)$answer->tolerance) < abs((float)$answer->answer) &&  abs((float)$answer->answer) <= $tolerance){
!                     $tolerance = (1+("1.0e-".ini_get('precision')) )* abs((float) $answer->tolerance) ;//tiny fraction
!                }
! 
!                 $max = $answer->answer + $tolerance;
!                 $min = $answer->answer - $tolerance;
!                 break;
!             case '3': case 'geometric':
!                 $quotient = 1 + abs($tolerance);
!                 $max = $answer->answer * $quotient;
!                 $min = $answer->answer / $quotient;
!                 break;
!             default:
!                 print_error('unknowntolerance', 'question', '', $answer->tolerancetype);
!         }
! 
!         $answer->min = $min;
!         $answer->max = $max;
!         return true;
!     }
! 
!     /**
!      * Checks if the $rawresponse has a unit and applys it if appropriate.
!      *
!      * @param string $rawresponse  The response string to be converted to a float.
!      * @param array $units         An array with the defined units, where the
!      *                             unit is the key and the multiplier the value.
!      * @return float               The rawresponse with the unit taken into
!      *                             account as a float.
!      */
!     function extract_numerical_response($rawresponse) {
!         $extractedresponse = new stdClass() ;
!         $rawresponse = trim($rawresponse) ;
!         $search  = array(' ', ',');
!         // test if a . is present or there are multiple , (i.e. 2,456,789 ) so that we don't need spaces and ,
!         if ( strpos($rawresponse,'.' ) !== false || substr_count($rawresponse,',') > 1 ) {
!             $replace = array('', '');
!         }else { // remove spaces and normalise , to a . .
!             $replace = array('', '.');
!         }
!         $rawresponse = str_replace($search, $replace, $rawresponse);
! 
!          if (preg_match('~^([+-]?([0-9]+(\\.[0-9]*)?|\\.[0-9]+)([eE][-+]?[0-9]+)?)([^0-9].*)?$~',
!                 $rawresponse, $responseparts)) {
!         //return (float)$responseparts[1] ;
!             $extractedresponse->number = (float)$responseparts[1] ;
!         }else {
!             $extractedresponse->number = false ;
!         }
!         if (!empty($responseparts[5])) {
!             $extractedresponse->unit = $responseparts[5] ;
!         }else {
!             $extractedresponse->unit = '';
!         }
! 
!         // Invalid number. Must be wrong.
!         return clone($extractedresponse) ;
!     }
!     /**
!      * Checks if the $rawresponse has a unit and applys it if appropriate.
!      *
!      * @param string $rawresponse  The response string to be converted to a float.
!      * @param array $units         An array with the defined units, where the
!      *                             unit is the key and the multiplier the value.
!      * @return float               The rawresponse with the unit taken into
!      *                             account as a float.
!      */
!     function apply_unit($rawresponse, $units) {
! 
!         // Make units more useful
!         $tmpunits = array();
!         foreach ($units as $unit) {
!             $tmpunits[$unit->unit] = $unit->multiplier;
!         }
!         // remove spaces and normalise decimal places.
!         $rawresponse = trim($rawresponse) ;
!         $search  = array(' ', ',');
!         // test if a . is present or there are multiple , (i.e. 2,456,789 ) so that we don't need spaces and ,
!         if ( strpos($rawresponse,'.' ) !== false || substr_count($rawresponse,',') > 1 ) {
!             $replace = array('', '');
!         }else { // remove spaces and normalise , to a . .
!             $replace = array('', '.');
!         }
!         $rawresponse = str_replace($search, $replace, $rawresponse);
! 
! 
!         // Apply any unit that is present.
!         if (ereg('^([+-]?([0-9]+(\\.[0-9]*)?|\\.[0-9]+)([eE][-+]?[0-9]+)?)([^0-9].*)?$',
!                 $rawresponse, $responseparts)) {
!            //     echo"<p> responseparts <pre>";print_r($responseparts) ;echo"</pre></p>";
! 
!             if (!empty($responseparts[5])) {
! 
!                 if (isset($tmpunits[$responseparts[5]])) {
!                     // Valid number with unit.
!                     return (float)$responseparts[1] / $tmpunits[$responseparts[5]];
!                 } else {
!                     // Valid number with invalid unit. Must be wrong.
!                     return false;
!                 }
! 
!             } else {
!                 // Valid number without unit.
!                 return (float)$responseparts[1];
!             }
!         }
!         // Invalid number. Must be wrong.
!         return false;
!     }
! 
!     /**
!      * function used in function definition_inner()
!      * of edit_..._form.php for
!      * numerical, calculated, calculatedsimple
!      */
!     function add_units_options(&$mform, &$that){
!         // Units are graded
!         $mform->addElement('header', 'unithandling', get_string('unitshandling', 'qtype_numerical'));
!         $mform->addElement('radio', 'unitrole', get_string('unitnotused', 'qtype_numerical'), get_string('onlynumerical', 'qtype_numerical'),0);
!         $mform->addElement('radio', 'unitrole', get_string('unitdisplay', 'qtype_numerical'), get_string('oneunitshown', 'qtype_numerical'),1);
!         $mform->addElement('radio', 'unitrole', get_string('unitsused', 'qtype_numerical'), get_string('manynumerical', 'qtype_numerical'),2);
!         $mform->addElement('static', 'separator2', '', '<HR/>');
!         $mform->addElement('radio', 'unitrole', get_string('unitgraded1', 'qtype_numerical'), get_string('unitgraded', 'qtype_numerical'),3);
!         $penaltygrp = array();
!         $penaltygrp[] =& $mform->createElement('text', 'unitpenalty', get_string('unitpenalty', 'qtype_numerical') ,
!                 array('size' => 6));
!         $unitgradingtypes = array('1' => get_string('decfractionofresponsegrade', 'qtype_numerical'), '2' => get_string('decfractionofquestiongrade', 'qtype_numerical'));
!         $penaltygrp[] =& $mform->createElement('select', 'unitgradingtypes', '' , $unitgradingtypes );
!         $mform->addGroup($penaltygrp, 'penaltygrp', get_string('unitpenalty', 'qtype_numerical'),' ' , false);
!         $multichoicedisplaygrp = array();
!         $multichoicedisplaygrp[] =& $mform->createElement('radio', 'multichoicedisplay', get_string('unitedit', 'qtype_numerical'), get_string('editableunittext', 'qtype_numerical'),0);
!         $multichoicedisplaygrp[] =& $mform->createElement('radio', 'multichoicedisplay', get_string('selectunits', 'qtype_numerical') , get_string('unitchoice', 'qtype_numerical'),1);
!         $mform->addGroup($multichoicedisplaygrp, 'multichoicedisplaygrp', get_string('studentunitanswer', 'qtype_numerical'),' OR ' , false);
!         $unitslefts = array('0' => get_string('rightexample', 'qtype_numerical'),'1' => get_string('leftexample', 'qtype_numerical'));
!         $mform->addElement('select', 'unitsleft', get_string('unitposition', 'qtype_numerical') , $unitslefts );
! 
!         $mform->addElement('static', 'separator2', '<HR/>', '<HR/>');
! 
!         $mform->addElement('editor', 'instructions', get_string('instructions', 'qtype_numerical'), null, $that->editoroptions);
!         $showunits1grp = array();
!         $mform->addElement('static', 'separator2', '<HR/>', '<HR/>');
! 
!         $mform->setType('unitpenalty', PARAM_NUMBER);
!         $mform->setDefault('unitpenalty', 0.1);
!         $mform->setDefault('unitgradingtypes', 1);
!         $mform->addHelpButton('penaltygrp', 'unitpenalty', 'qtype_numerical'); // TODO help did not exist before MDL-21695
!         $mform->setDefault('unitsleft', 0);
!         $mform->setType('instructions', PARAM_RAW);
!         $mform->addHelpButton('instructions', 'numericalinstructions', 'qtype_numerical');
!         $mform->disabledIf('penaltygrp', 'unitrole','eq','0');
!         $mform->disabledIf('penaltygrp', 'unitrole','eq','1');
!         $mform->disabledIf('penaltygrp', 'unitrole','eq','2');
!         $mform->disabledIf('unitsleft', 'unitrole','eq','0');
!         $mform->disabledIf('multichoicedisplay','unitrole','eq','0');
!         $mform->disabledIf('multichoicedisplay','unitrole','eq','1');
!         $mform->disabledIf('multichoicedisplay','unitrole','eq','2');
!     }
! 
!     /**
!      * function used in in function definition_inner()
!      * of edit_..._form.php for
!      * numerical, calculated, calculatedsimple
!      */
!     function add_units_elements(& $mform,& $that) {
!         $repeated = array();
!         $repeated[] =& $mform->createElement('header', 'unithdr', get_string('unithdr', 'qtype_numerical', '{no}'));
! 
!         $repeated[] =& $mform->createElement('text', 'unit', get_string('unit', 'quiz'));
!         $mform->setType('unit', PARAM_NOTAGS);
! 
!         $repeated[] =& $mform->createElement('text', 'multiplier', get_string('multiplier', 'quiz'));
!         $mform->setType('multiplier', PARAM_NUMBER);
! 
!         if (isset($that->question->options->units)){
!             $countunits = count($that->question->options->units);
!         } else {
!             $countunits = 0;
!         }
!         if ($that->question->formoptions->repeatelements){
!             $repeatsatstart = $countunits + 1;
!         } else {
!             $repeatsatstart = $countunits;
!         }
!         $that->repeat_elements($repeated, $repeatsatstart, array(), 'nounits', 'addunits', 2, get_string('addmoreunitblanks', 'qtype_calculated', '{no}'));
! 
!         if ($mform->elementExists('multiplier[0]')){
!             $firstunit =& $mform->getElement('multiplier[0]');
!             $firstunit->freeze();
!             $firstunit->setValue('1.0');
!             $firstunit->setPersistantFreeze(true);
!             $mform->addHelpButton('multiplier[0]', 'numericalmultiplier', 'qtype_numerical');
!         }
!     }
! 
!     /**
!       * function used in in function data_preprocessing() of edit_numerical_form.php for
!       * numerical, calculated, calculatedsimple
!       */
!     function set_numerical_unit_data($mform, &$question, &$default_values){
! 
!         list($categoryid) = explode(',', $question->category);
!         $context = $this->get_context_by_category_id($categoryid);
! 
!         if (isset($question->options)){
!             if (isset($question->options->unitpenalty)){
!                 $default_values['unitpenalty'] = $question->options->unitpenalty ;
!             }
!             $default_values['unitgradingtypes'] = 1 ;
!             if (isset($question->options->unitgradingtype )&& isset($question->options->showunits ) ){
!                 if ( $question->options->unitgradingtype == 2 ) {
!                     $default_values['unitgradingtypes'] = 1 ;
!                 }
!                 if ( $question->options->unitgradingtype == 0 ) {
!                     $default_values['unitgradingtypes'] = 0 ;
!                 }
!                 switch ($question->options->showunits){
!                     case 0 :// NUMERICALQUESTIONUNITTEXTINPUTDISPLAY
!                         if($question->options->unitgradingtype == 0 ){
!                             $default_values['unitrole'] = 2 ;
!                             $default_values['multichoicedisplay'] = 0 ;
!                         }else { // 1 or 2
!                             $default_values['unitrole'] = 3 ;
!                             $default_values['multichoicedisplay'] = 0 ;
!                             $default_values['unitgradingtypes'] = $question->options->unitgradingtype ;
!                         }
!                         break;
!                     case 1 : // NUMERICALQUESTIONUNITMULTICHOICEDISPLAY
!                         $default_values['unitrole'] = 3 ;
!                         $default_values['multichoicedisplay'] = $question->options->unitgradingtype ;
!                         $default_values['unitgradingtypes'] = $question->options->unitgradingtype ;
!                         break;
!                     case 2 : // NUMERICALQUESTIONUNITTEXTDISPLAY
!                         $default_values['unitrole'] = 1 ;
!                         break;
!                     case 3 : // NUMERICALQUESTIONUNITNODISPLAY
!                         $default_values['unitrole'] = 0 ;
!                         //  $default_values['showunits1'] = $question->options->showunits ;
!                         break;
!                 }
!             }
!             if (isset($question->options->unitsleft)){
!                 $default_values['unitsleft'] = $question->options->unitsleft ;
!             }
! 
!             // processing files
!             $component = 'qtype_' . $question->qtype;
!             $draftid = file_get_submitted_draft_itemid('instruction');
!             $default_values['instructions'] = array();
!             if (isset($question->options->instructionsformat) && isset($question->options->instructions)){
!                 $default_values['instructions']['format'] = $question->options->instructionsformat;
!                 $default_values['instructions']['text'] = file_prepare_draft_area(
!                     $draftid,       // draftid
!                     $context->id,   // context
!                     $component,     // component
                      'instruction',  // filarea
!                     !empty($question->id)?(int)$question->id:null, // itemid
!                     $mform->fileoptions,    // options
!                     $question->options->instructions // text
!                 );
!             }
!             $default_values['instructions']['itemid'] = $draftid ;
! 
!             if (isset($question->options->units)) {
!                 $units  = array_values($question->options->units);
!                 if (!empty($units)) {
!                     foreach ($units as $key => $unit){
!                         $default_values['unit['.$key.']'] = $unit->unit;
!                         $default_values['multiplier['.$key.']'] = $unit->multiplier;
!                     }
!                 }
!             }
!         }
!     }
! 
!     /**
!       * function use in in function validation()
!       * of edit_..._form.php for
!       * numerical, calculated, calculatedsimple
!       */
! 
!     function validate_numerical_options(& $data, & $errors){
!         $units  = $data['unit'];
!             switch ($data['unitrole']){
!                 case '0' : $showunits = NUMERICALQUESTIONUNITNODISPLAY ;
!                 break ;
!                 case '1' : $showunits = NUMERICALQUESTIONUNITTEXTDISPLAY ;
!                 break ;
!                 case '2' : $showunits = NUMERICALQUESTIONUNITTEXTINPUTDISPLAY ;
!                 break ;
!                 case '3' : $showunits = $data['multichoicedisplay'] ;
!                 break ;
!             }
! 
!         if (($showunits == NUMERICALQUESTIONUNITTEXTINPUTDISPLAY) ||
!                 ($showunits == NUMERICALQUESTIONUNITMULTICHOICEDISPLAY ) ||
!                 ($showunits == NUMERICALQUESTIONUNITTEXTDISPLAY )){
!            if (trim($units[0]) == ''){
!              $errors['unit[0]'] = 'You must set a valid unit name' ;
!             }
!         }
!         if ($showunits == NUMERICALQUESTIONUNITNODISPLAY ){
!             if (count($units)) {
!                 foreach ($units as $key => $unit){
!                     if ($units[$key] != ''){
!                     $errors["unit[$key]"] = 'You must erase this unit name' ;
!                     }
!                 }
!             }
!         }
! 
! 
!         // Check double units.
!         $alreadyseenunits = array();
!         if (isset($data['unit'])) {
!             foreach ($data['unit'] as $key => $unit) {
!                 $trimmedunit = trim($unit);
!                 if ($trimmedunit!='' && in_array($trimmedunit, $alreadyseenunits)) {
!                     $errors["unit[$key]"] = get_string('errorrepeatedunit', 'qtype_numerical');
!                     if (trim($data['multiplier'][$key]) == '') {
!                         $errors["multiplier[$key]"] = get_string('errornomultiplier', 'qtype_numerical');
!                     }
!                 } elseif($trimmedunit!='') {
!                     $alreadyseenunits[] = $trimmedunit;
!                 }
!             }
!         }
!              $units  = $data['unit'];
!             if (count($units)) {
!                 foreach ($units as $key => $unit){
!                     if (is_numeric($unit)){
!                         $errors['unit['.$key.']'] = get_string('mustnotbenumeric', 'qtype_calculated');
!                     }
!                     $trimmedunit = trim($unit);
!                     $trimmedmultiplier = trim($data['multiplier'][$key]);
!                     if (!empty($trimmedunit)){
!                         if (empty($trimmedmultiplier)){
!                             $errors['multiplier['.$key.']'] = get_string('youmustenteramultiplierhere', 'qtype_calculated');
!                         }
!                         if (!is_numeric($trimmedmultiplier)){
!                             $errors['multiplier['.$key.']'] = get_string('mustbenumeric', 'qtype_calculated');
!                         }
! 
!                     }
!                 }
!             }
! 
!     }
! 
! 
!     function valid_unit($rawresponse, $units) {
!         // Make units more useful
!         $tmpunits = array();
!         foreach ($units as $unit) {
!             $tmpunits[$unit->unit] = $unit->multiplier;
!         }
!         // remove spaces and normalise decimal places.
!         $search  = array(' ', ',');
!         $replace = array('', '.');
!         $rawresponse = str_replace($search, $replace, trim($rawresponse));
! 
!         // Apply any unit that is present.
!         if (preg_match('~^([+-]?([0-9]+(\\.[0-9]*)?|\\.[0-9]+)([eE][-+]?[0-9]+)?)([^0-9].*)?$~',
!                 $rawresponse, $responseparts)) {
! 
!             if (!empty($responseparts[5])) {
! 
!                 if (isset($tmpunits[$responseparts[5]])) {
!                     // Valid number with unit.
!                     return true ; //(float)$responseparts[1] / $tmpunits[$responseparts[5]];
!                 } else {
!                     // Valid number with invalid unit. Must be wrong.
!                     return false;
!                 }
! 
!             } else {
!                 // Valid number without unit.
!                 return false ; //(float)$responseparts[1];
!             }
!         }
!         // Invalid number. Must be wrong.
!         return false;
!     }
! 
!     /**
!      * Runs all the code required to set up and save an essay question for testing purposes.
!      * Alternate DB table prefix may be used to facilitate data deletion.
!      */
!     function generate_test($name, $courseid = null) {
!         global $DB;
!         list($form, $question) = default_questiontype::generate_test($name, $courseid);
!         $question->category = $form->category;
! 
!         $form->questiontext = "What is 674 * 36?";
!         $form->generalfeedback = "Thank you";
!         $form->penalty = 0.1;
!         $form->defaultgrade = 1;
!         $form->noanswers = 3;
!         $form->answer = array('24264', '24264', '1');
!         $form->tolerance = array(10, 100, 0);
!         $form->fraction = array(1, 0.5, 0);
!         $form->nounits = 2;
!         $form->unit = array(0 => null, 1 => null);
!         $form->multiplier = array(1, 0);
!         $form->feedback = array('Very good', 'Close, but not quite there', 'Well at least you tried....');
! 
!         if ($courseid) {
!             $course = $DB->get_record('course', array('id' => $courseid));
!         }
! 
!         return $this->save_question($question, $form);
!     }
! 
!     function move_files($questionid, $oldcontextid, $newcontextid) {
!         $fs = get_file_storage();
! 
!         parent::move_files($questionid, $oldcontextid, $newcontextid);
!         $this->move_files_in_answers($questionid, $oldcontextid, $newcontextid);
! 
!         $fs->move_area_files_to_new_context($oldcontextid,
!                 $newcontextid, 'qtype_numerical', 'instruction', $questionid);
!     }
! 
!     protected function delete_files($questionid, $contextid) {
!         $fs = get_file_storage();
! 
!         parent::delete_files($questionid, $contextid);
!         $this->delete_files_in_answers($questionid, $contextid);
!         $fs->delete_area_files($contextid, 'qtype_numerical', 'instruction', $questionid);
!     }
! 
!     function check_file_access($question, $state, $options, $contextid, $component,
!             $filearea, $args) {
!         $itemid = reset($args);
!         
!         if ($component == 'question' && $filearea == 'answerfeedback') {
!             $result = $options->feedback && array_key_exists($itemid, $question->options->answers);
!             if (!$result) {
!                 return false;
!             }
!             foreach($question->options->answers as $answer) {
!                 if ($this->test_response($question, $state, $answer)) {
!                     return true;
!                 }
!             }
!             return false;
!         } else if ($filearea == 'instruction') {
!             if ($itemid != $question->id) {
!                 return false;
!             } else {
!                 return true;
!             }
!         } else {
!             return parent::check_file_access($question, $state, $options, $contextid, $component,
!                     $filearea, $args);
!         }
!     }
  }
  
  // INITIATION - Without this line the question type is not in use.
  question_register_questiontype(new question_numerical_qtype());
  if ( ! defined ("NUMERICALQUESTIONUNITTEXTINPUTDISPLAY")) {
!     define("NUMERICALQUESTIONUNITTEXTINPUTDISPLAY",   0);
  }
  if ( ! defined ("NUMERICALQUESTIONUNITMULTICHOICEDISPLAY")) {
!     define("NUMERICALQUESTIONUNITMULTICHOICEDISPLAY",   1);
  }
  if ( ! defined ("NUMERICALQUESTIONUNITTEXTDISPLAY")) {
!     define("NUMERICALQUESTIONUNITTEXTDISPLAY",   2);
  }
  if ( ! defined ("NUMERICALQUESTIONUNITNODISPLAY")) {
!     define("NUMERICALQUESTIONUNITNODISPLAY",    3);
  }
--- 38,1397 ----
  
  class question_numerical_qtype extends question_shortanswer_qtype {
  
! 	public $virtualqtype = false;
! 	function name() {
! 		return 'numerical';
! 	}
! 
! 	function has_wildcards_in_responses() {
! 		return true;
! 	}
! 
! 	function requires_qtypes() {
! 		return array('shortanswer');
! 	}
! 
! 	function get_question_options(&$question) {
! 		// Get the question answers and their respective tolerances
! 		// Note: question_numerical is an extension of the answer table rather than
! 		//       the question table as is usually the case for qtype
! 		//       specific tables.
! 		global $CFG, $DB, $OUTPUT;
! 		if (!$question->options->answers = $DB->get_records_sql(
                                  "SELECT a.*, n.tolerance " .
                                  "FROM {question_answers} a, " .
                                  "     {question_numerical} n " .
                                  "WHERE a.question = ? " .
                                  "    AND   a.id = n.answer " .
                                  "ORDER BY a.id ASC", array($question->id))) {
! 		echo $OUTPUT->notification('Error: Missing question answer for numerical question ' . $question->id . '!');
! 		return false;
                                  }
!                                 $this->get_numerical_units($question);
!                                 //get_numerical_options() need to know if there are units
!                                 // to set correctly default values
!                                 $this->get_numerical_options($question);
! 
!                                 // If units are defined we strip off the default unit from the answer, if
!                                 // it is present. (Required for compatibility with the old code and DB).
!                                 if ($defaultunit = $this->get_default_numerical_unit($question)) {
!                                 	foreach($question->options->answers as $key => $val) {
!                                 		$answer = trim($val->answer);
!                                 		$length = strlen($defaultunit->unit);
!                                 		if ($length && substr($answer, -$length) == $defaultunit->unit) {
!                                 			$question->options->answers[$key]->answer =
!                                 			substr($answer, 0, strlen($answer)-$length);
!                                 		}
!                                 	}
                                  }
! 
!                                 return true;
! 	}
! 	function get_numerical_units(&$question) {
! 		global $DB;
! 		if ($units = $DB->get_records('question_numerical_units', array('question' => $question->id), 'id ASC')) {
! 			$units  = array_values($units);
! 		} else {
! 			$units = array();
! 		}
! 		foreach ($units as $key => $unit) {
! 			$units[$key]->multiplier = clean_param($unit->multiplier, PARAM_NUMBER);
! 		}
! 		$question->options->units = $units;
! 		return true;
! 	}
! 
! 	function get_default_numerical_unit(&$question) {
! 		if (isset($question->options->units[0])) {
! 			foreach ($question->options->units as $unit) {
! 				if (abs($unit->multiplier - 1.0) < '1.0e-' . ini_get('precision')) {
! 					return $unit;
! 				}
! 			}
! 		}
! 		return false;
! 	}
! 
! 	function get_numerical_options(&$question) {
! 		global $DB;
! 		if (!$options = $DB->get_record('question_numerical_options', array('question' => $question->id))) {
! 			$question->options->unitgradingtype = 0; // total grade
! 			$question->options->unitpenalty = 0.1; // default for old questions
! 			// the default
! 			if ($defaultunit = $this->get_default_numerical_unit($question)) {
! 				// so units can be graded
! 				$question->options->showunits = NUMERICALQUESTIONUNITTEXTINPUTDISPLAY ;
! 			}else {
! 				// only numerical will be graded
! 				$question->options->showunits = NUMERICALQUESTIONUNITNODISPLAY ;
! 			}
! 			$question->options->unitsleft = 0 ;
! 			$question->options->instructions = '';
! 			$question->options->instructionsformat = editors_get_preferred_format();
! 		} else {
! 			$question->options->unitgradingtype = $options->unitgradingtype;
! 			$question->options->unitpenalty = $options->unitpenalty;
! 			$question->options->showunits = $options->showunits;
! 			$question->options->unitsleft = $options->unitsleft;
! 			$question->options->instructions = $options->instructions;
! 			$question->options->instructionsformat = $options->instructionsformat;
! 		}
! 
! 		return true;
! 	}
! 
! 
! 	/**
! 	 * Save the units and the answers associated with this question.
! 	 */
! 	function save_question_options($question) {
! 		global $DB;
! 		$context = $question->context;
! 
! 		// Get old versions of the objects
! 		$oldanswers = $DB->get_records('question_answers',
! 		array('question' => $question->id), 'id ASC');
! 		$oldoptions = $DB->get_records('question_numerical',
! 		array('question' => $question->id), 'answer ASC');
! 
! 		// Save the units.
! 		$result = $this->save_numerical_units($question);
! 		if (isset($result->error)) {
! 			return $result;
! 		} else {
! 			$units = $result->units;
! 		}
! 
! 		// Insert all the new answers
! 		foreach ($question->answer as $key => $answerdata) {
! 			// Check for, and ingore, completely blank answer from the form.
! 			if (trim($answerdata) == '' && $question->fraction[$key] == 0 &&
! 			html_is_blank($question->feedback[$key]['text'])) {
! 				continue;
! 			}
! 
! 			// Update an existing answer if possible.
! 			$answer = array_shift($oldanswers);
! 			if (!$answer) {
! 				$answer = new stdClass();
! 				$answer->question = $question->id;
! 				$answer->answer = '';
! 				$answer->feedback = '';
! 				$answer->id = $DB->insert_record('question_answers', $answer);
! 			}
! 
! 			if (trim($answerdata) === '*') {
! 				$answer->answer = '*';
! 			} else {
! 				$answer->answer = $this->apply_unit($answerdata, $units);
! 				if ($answer->answer === false) {
! 					$result->notice = get_string('invalidnumericanswer', 'quiz');
! 				}
! 			}
! 			$answer->fraction = $question->fraction[$key];
! 			$answer->feedback = $this->import_or_save_files($question->feedback[$key],
! 			$context, 'question', 'answerfeedback', $answer->id);
! 			$answer->feedbackformat = $question->feedback[$key]['format'];
! 			$DB->update_record('question_answers', $answer);
! 
! 			// Set up the options object
! 			if (!$options = array_shift($oldoptions)) {
! 				$options = new stdClass();
! 			}
! 			$options->question = $question->id;
! 			$options->answer   = $answer->id;
! 			if (trim($question->tolerance[$key]) == '') {
! 				$options->tolerance = '';
! 			} else {
! 				$options->tolerance = $this->apply_unit($question->tolerance[$key], $units);
! 				if ($options->tolerance === false) {
! 					$result->notice = get_string('invalidnumerictolerance', 'quiz');
! 				}
! 			}
! 			if (isset($options->id)) {
! 				$DB->update_record('question_numerical', $options);
! 			} else {
! 				$DB->insert_record('question_numerical', $options);
! 			}
! 		}
! 
! 		// Delete any left over old answer records.
! 		$fs = get_file_storage();
! 		foreach($oldanswers as $oldanswer) {
! 			$fs->delete_area_files($context->id, 'question', 'answerfeedback', $oldanswer->id);
! 			$DB->delete_records('question_answers', array('id' => $oldanswer->id));
! 		}
! 		foreach($oldoptions as $oldoption) {
! 			$DB->delete_records('question_numerical', array('id' => $oldoption->id));
! 		}
! 
! 		$result = $this->save_numerical_options($question);
! 		if (!empty($result->error) || !empty($result->notice)) {
! 			return $result;
! 		}
! 
! 		return true;
! 	}
! 
! 	/**
! 	 * The numerical options control the display and the grading of the unit
! 	 * part of the numerical question and related types (calculateds)
! 	 * Questions previous to 2,0 do not have this table as multianswer questions
! 	 * in all versions including 2,0. The default values are set to give the same grade
! 	 * as old question.
! 	 *
! 	 */
! 	function save_numerical_options($question) {
! 		global $DB;
! 
! 		$result = new stdClass;
! 
! 		$update = true ;
! 		$options = $DB->get_record('question_numerical_options', array('question' => $question->id));
! 		if (!$options) {
! 			$options = new stdClass;
! 			$options->question = $question->id;
! 			$options->instructions = '';
! 			$options->id = $DB->insert_record('question_numerical_options', $options);
! 		}
! 
! 		if (isset($question->options->unitgradingtype)) {
! 			$options->unitgradingtype = $question->options->unitgradingtype;
! 		} else {
! 			$options->unitgradingtype = 0 ;
! 		}
! 		if (isset($question->unitpenalty)){
! 			$options->unitpenalty = $question->unitpenalty;
! 		} else { //so this is either an old question or a close question type
! 			$options->unitpenalty = 1 ;
! 		}
! 		// if we came from the form then 'unitrole' exists
! 		if (isset($question->unitrole)){
! 			switch ($question->unitrole){
! 				case '0' : $options->showunits = NUMERICALQUESTIONUNITNODISPLAY ;
! 				break ;
! 				case '1' : $options->showunits = NUMERICALQUESTIONUNITTEXTDISPLAY ;
! 				break ;
! 				case '2' : $options->showunits = NUMERICALQUESTIONUNITTEXTINPUTDISPLAY ;
! 				$options->unitgradingtype = 0 ;
! 				break ;
! 				case '3' : $options->showunits = $question->multichoicedisplay ;
! 				$options->unitgradingtype = $question->unitgradingtypes ;
! 				break ;
! 			}
! 		} else {
! 			if (isset($question->showunits)){
! 				$options->showunits = $question->showunits;
! 			} else {
! 				if ($defaultunit = $this->get_default_numerical_unit($question)) {
! 					// so units can be used
! 					$options->showunits = NUMERICALQUESTIONUNITTEXTINPUTDISPLAY ;
! 				} else {
! 					// only numerical will be graded
! 					$options->showunits = NUMERICALQUESTIONUNITNODISPLAY ;
! 				}
! 			}
! 		}
! 
! 		if (isset($question->unitsleft)) {
! 			$options->unitsleft = $question->unitsleft;
! 		} else {
! 			$options->unitsleft = 0 ;
! 		}
! 
! 		if (isset($question->instructions) && is_array($question->instructions)){
! 			$options->instructions = $this->import_or_save_files($question->instructions,
! 			$question->context, 'qtype_'.$question->qtype , 'instruction', $question->id);
! 			$options->instructionsformat = $question->instructions['format'];
! 		} else {
! 			$options->instructions = '' ;
! 			$options->instructionsformat = editors_get_preferred_format();
! 		}
! 
! 		$DB->update_record('question_numerical_options', $options);
! 
! 		return $result;
! 	}
! 
! 	function save_numerical_units($question) {
! 		global $DB;
! 		$result = new stdClass;
! 
! 		// Delete the units previously saved for this question.
! 		$DB->delete_records('question_numerical_units', array('question' => $question->id));
! 
! 		// Nothing to do.
! 		if (!isset($question->multiplier)) {
! 			$result->units = array();
! 			return $result;
! 		}
! 
! 		// Save the new units.
! 		$units = array();
! 		$unitalreadyinsert = array();
! 		foreach ($question->multiplier as $i => $multiplier) {
! 			// Discard any unit which doesn't specify the unit or the multiplier
! 			if (!empty($question->multiplier[$i]) && !empty($question->unit[$i])&& !array_key_exists($question->unit[$i],$unitalreadyinsert)) {
! 				$unitalreadyinsert[$question->unit[$i]] = 1 ;
! 				$units[$i] = new stdClass;
! 				$units[$i]->question = $question->id;
! 				$units[$i]->multiplier = $this->apply_unit($question->multiplier[$i], array());
! 				$units[$i]->unit = $question->unit[$i];
! 				$DB->insert_record('question_numerical_units', $units[$i]);
! 			}
! 		}
! 		unset($question->multiplier, $question->unit);
! 
! 		$result->units = &$units;
! 		return $result;
! 	}
! 
! 	function create_session_and_responses(&$question, &$state, $cmoptions, $attempt) {
! 		$state->responses = array();
! 		$state->responses['answer'] =  '';
! 		$state->responses['unit'] = '';
! 
! 		return true;
! 	}
! 	function restore_session_and_responses(&$question, &$state) {
! 		if(false === strpos($state->responses[''], '|||||')){
! 			$state->responses['answer']= $state->responses[''];
! 			$state->responses['unit'] = '';
! 			$this->split_old_answer($state->responses[''], $question->options->units, $state->responses['answer'] ,$state->responses['unit'] );
! 		}else {
! 			$responses = explode('|||||', $state->responses['']);
! 			$state->responses['answer']= $responses[0];
! 			$state->responses['unit'] = $responses[1];
! 		}
! 
! 		return true;
! 	}
! 
! 	function find_unit_index(&$question,$value){
! 		$length = 0;
! 		$goodkey = 0 ;
! 		foreach ($question->options->units as $key => $unit){
! 			if($unit->unit ==$value ) {
! 				return $key ;
! 			}
! 		}
! 		return 0 ;
! 	}
! 
! 	function split_old_answer($rawresponse, $units, &$answer ,&$unit ) {
! 		$answer = $rawresponse ;
! 		// remove spaces and normalise decimal places.
! 		$search  = array(' ', ',');
! 		$replace = array('', '.');
! 		$rawresponse = str_replace($search, $replace, trim($rawresponse));
! 		if (preg_match('~^([+-]?([0-9]+(\\.[0-9]*)?|\\.[0-9]+)([eE][-+]?[0-9]+)?)([^0-9].*)?$~',
! 		$rawresponse, $responseparts)) {
! 			if(isset($responseparts[5]) ){
! 				$unit = $responseparts[5] ;
! 			}
! 			if(isset($responseparts[1]) ){
! 				$answer = $responseparts[1] ;
! 			}
! 		}
! 		return ;
! 	}
! 
! 
! 	function save_session_and_responses(&$question, &$state) {
! 		global $DB;
! 
! 		$responses = '';
! 		if(isset($state->responses['unit']) && isset($question->options->units[$state->responses['unit']])){
! 			$responses = $state->responses['answer'].'|||||'.$question->options->units[$state->responses['unit']]->unit;
! 		}else if(isset($state->responses['unit'])){
! 			$responses = $state->responses['answer'].'|||||'.$state->responses['unit'] ;
! 		}else {
! 			$responses = $state->responses['answer'].'|||||';
! 		}
! 		// Set the legacy answer field
! 		$DB->set_field('question_states', 'answer', $responses, array('id' => $state->id));
! 		return true;
! 	}
! 
! 	function delete_question($questionid, $contextid) {
! 		global $DB;
! 		$DB->delete_records('question_numerical', array('question' => $questionid));
! 		$DB->delete_records('question_numerical_options', array('question' => $questionid));
! 		$DB->delete_records('question_numerical_units', array('question' => $questionid));
! 
! 		parent::delete_question($questionid, $contextid);
! 	}
! 
! 	/**
! 	 * This function has been reinserted in numerical/questiontype.php to simplify
! 	 * the separate rendering of number and unit
! 	 */
! 	function print_question_formulation_and_controls(&$question, &$state, $cmoptions, $options) {
! 		global $CFG, $OUTPUT;
! 
! 		$context = $this->get_context_by_category_id($question->category);
! 		$readonly = empty($options->readonly) ? '' : 'readonly="readonly"';
! 		$formatoptions = new stdClass;
! 		$formatoptions->noclean = true;
! 		$formatoptions->para = false;
! 		$nameprefix = $question->name_prefix;
! 		$component = 'qtype_' . $question->qtype;
! 		// rewrite instructions text
! 		$question->options->instructions = quiz_rewrite_question_urls($question->options->instructions, 'pluginfile.php', $context->id, $component, 'instruction', array($state->attempt, $state->question), $question->id);
! 		/// Print question text and media
! 
! 		$questiontext = format_text($question->questiontext,
! 		$question->questiontextformat,
! 		$formatoptions, $cmoptions->course);
! 
! 		/// Print input controls
! 		// as the entry is controlled the question type here is numerical
! 		// In all cases there is a text input for the number
! 		// If $question->options->showunits == NUMERICALQUESTIONUNITTEXTDISPLAY
! 		// there is an additional text input for the unit
! 		// If $question->options->showunits == NUMERICALQUESTIONUNITMULTICHOICEDISPLAY"
! 		// radio elements display the defined unit
! 		// The code allows the input number elememt to be displayed
! 		// before i.e. at left or after at rigth of the unit variants.
! 		$nameanswer = "name=\"".$question->name_prefix."answer\"";
! 		$nameunit   = "name=\"".$question->name_prefix."unit\"";
! 		// put old answer data in $state->responses['answer'] and $state->responses['unit']
! 		if (isset($state->responses['']) && $state->responses[''] != '' && !isset($state->responses['answer'])){
! 			$this->split_old_answer($state->responses[''], $question->options->units, $state->responses['answer'] ,$state->responses['unit'] );
! 		}
! 		// prepare the values of the input elements to be dispalyed answer i.e. number  and unit
! 		if (isset($state->responses['answer']) && $state->responses['answer']!='') {
! 			$valueanswer = ' value="'.s($state->responses['answer']).'" ';
! 		} else {
! 			$valueanswer = ' value="" ';
! 		}
! 		if (isset($state->responses['unit']) && $state->responses['unit']!='') {
! 			$valueunit = ' value="'.s($state->responses['unit']).'" ';
! 		} else {
! 			$valueunit = ' value="" ';
! 			if ($question->options->showunits == NUMERICALQUESTIONUNITTEXTDISPLAY ){
! 				$valueunit = ' value="'.s($question->options->units[0]->unit).'" ';
! 			}
! 		}
! 
! 		$feedback = '';
! 		$class = '';
! 		$classunit = '' ;
! 		$classunitvalue = '' ;
! 		$feedbackimg = '';
! 		$feedbackimgunit = '' ;
! 		$answerasterisk = false ;
! 		$response = '' ;
! 		$valid_numerical_unit = false ;
! 		$valid_numerical_unit_index = -1 ;
! 		$unit_in_numerical_answer = false ;
! 		$rawgrade = 0 ;
! 		if ($options->feedback) {
! 			$class = question_get_feedback_class(0);
! 			$classunit = question_get_feedback_class(0);
! 			$feedbackimg = question_get_feedback_image(0);
! 			$feedbackimgunit = question_get_feedback_image(0);
! 			$classunitvalue = 0 ;
! 			$valid_numerical_unit_index = -1 ;
! 			// if there is unit in answer and unitgradingtype = 0
! 			// the grade is 0
! 			//this is OK for the first answer with a good response
! 			// having to test for * so response as long as not empty
! 			// $response = $this->extract_numerical_response($state->responses['answer']);
! 			// test for a greater than 0 grade
! 			foreach($question->options->answers as $answer) {
! 				if ($this->test_response($question, $state, $answer)) {
! 					// Answer was correct or partially correct.
! 					if ( $answer->answer === '*'){
! 						$answerasterisk = true ;
! 					}
! 					// in all cases
! 					$class = question_get_feedback_class($answer->fraction);
! 					$feedbackimg = question_get_feedback_image($answer->fraction);
! 					if ($question->options->unitgradingtype == 0 || ($question->options->unitgradingtype == 0 && $answer->answer === '*')){
! 						// if * then unit has the $answer->fraction value
! 						// if $question->options->unitgradingtype == 0 everything has been checked
! 						// if $question->options->showunits == NUMERICALQUESTIONUNITTEXTINPUTDISPLAY
! 						// then number - unit combination has been used to test response
! 						// so the unit should have same color
! 						$classunit = question_get_feedback_class($answer->fraction);
! 						$feedbackimgunit = question_get_feedback_image($answer->fraction);
! 						$rawgrade = $answer->fraction ;
! 
! 
! 					}else {
! 						/* so we need to apply unit grading i.e. to check if the number-unit combination
! 						 * was the rigth one
! 						 * on NUMERICALQUESTIONUNITTEXTINPUTDISPLAY we need only to ckeck if applyunit will test OK
! 						 * with the $state->responses['unit'] value which cannot be empty
! 						 * if $state->responses['unit']
! 						 * if apply-unit is true with a specific unit as long as the unit as been written either in the
! 						 * we need the numerical response and test it with the available units
! 						 * if the unit used is good then it should be set OK
! 						 * however the unit could have been put in the number element in this case
! 						 * the unit penalty should be apllied.
! 						 * testing apply_unit with no units will get us a false response if there is any text in it
! 						 * testing apply_unit with a given unit will get a good value if the number is good with this unit
! 						 * apply unit will return the numerical if
! 						 * we need to know which conditions let to a good numerical value that were done in the
! 						 */
! 						$valid_numerical_unit = false ;
! 						$rawgrade = $answer->fraction ;
! 						$valid_numerical_unit_index = -1 ;
! 						$invalid_unit_in_numerical_answer = false ;
! 						if ( $answerasterisk ) {
! 							$classunit = question_get_feedback_class($answer->fraction);
! 							$feedbackimgunit = question_get_feedback_image($answer->fraction);
! 							$valid_numerical_unit = true ;//everything is true with *
! 						} else {
! 							//  if( isset($state->responses['unit']) && $state->responses['unit'] != '' ){// unit should be written in the unit input or checked in multichoice
! 							// we need to see if something was written in the answer field that was not in the number
! 							// although we cannot actually detect units put before the number which will cause bad numerical.
! 							// use extract response
! 							$response = $this->extract_numerical_response($state->responses['answer']);
! 							if(isset($response->unit ) && $response->unit != ''){
! 								$unit_in_numerical_answer = true ;
! 							}else {
! 								$unit_in_numerical_answer = false ;
! 							}
! 
! 							// the we let the testing to the two cases either
! 							// NUMERICALQUESTIONUNITTEXTINPUTDISPLAY or
! 							// NUMERICALQUESTIONUNITMULTICHOICEDISPLAY
! 							if( !isset($state->responses['unit']) || $state->responses['unit'] == '' ){
! 								// unit should be written in the unit input or checked in multichoice
! 								$valid_numerical_unit = false ;
! 								$classunit = question_get_feedback_class(0);
! 								$feedbackimgunit = question_get_feedback_image(0);
! 								$empty_unit = true ;
! 							} else {
! 								// echo"<p> some unit answer <pre>";print_r($answer) ;echo"</pre></p>";
! 								// echo"<p> some unit answer <pre>";print_r($answer) ;echo"</pre></p>";
! 								$empty_unit = false ;
! 								$valid_numerical_unit = false ;
! 
! 								foreach ($question->options->units as $key => $unit) {
! 									if ($unit->unit == $state->responses['unit']){
! 										//    $response = $this->apply_unit($state->responses['answer'].$unit->unit, array($question->options->units[$key])) ;
! 										//       echo "<p> avant false valid_numerical_unit_index $valid_numerical_unit_index  ".$state->responses['answer']."</p>";
! 										$invalid_unit_found = 0 ;
! 										if ($response->number !== false) {
! 											//echo "<p> avanr get valid_numerical_unit_index $valid_numerical_unit_index  </p>";
! 											//     $this->get_tolerance_interval($answer);
! 											$testresponse = $response->number /$unit->multiplier ;
! 											if($answer->min <= $testresponse && $testresponse <= $answer->max){
! 												//echo "<p> apres min max  valid_numerical_unit_index $valid_numerical_unit_index  </p>";
! 												$classunit = question_get_feedback_class($answer->fraction) ; //question_get_feedback_class(1);
! 												$feedbackimgunit = question_get_feedback_image($rawgrade);
! 												$valid_numerical_unit = true ;
! 												$valid_numerical_unit_index = $key ;
! 												break ;
! 											}
! 										}
! 									}
! 								}
! 							}
! 						}
! 					}
! 					if ($answer->feedback) {
! 						$answer->feedback = quiz_rewrite_question_urls($answer->feedback, 'pluginfile.php', $context->id, 'question', 'answerfeedback', array($state->attempt, $state->question), $answer->id);
! 						$feedback = format_text($answer->feedback, $answer->feedbackformat, $formatoptions, $cmoptions->course);
! 					}
! 
! 					break;
! 				}
! 			}
! 		}
! 		$state->options->raw_unitpenalty = 0 ;
! 		$raw_unitpenalty = 0 ;
! 		if( $question->options->showunits == NUMERICALQUESTIONUNITNODISPLAY ||
! 		$question->options->showunits == NUMERICALQUESTIONUNITTEXTDISPLAY ) {
! 			$classunitvalue = 1 ;
! 		}
! 
! 		if(! $answerasterisk  && $question->options->unitgradingtype != 0 && (! $valid_numerical_unit || $unit_in_numerical_answer)){
! 			if($question->options->unitgradingtype == 1){
! 				$raw_unitpenalty = $question->options->unitpenalty * $rawgrade ;
! 			}else {
! 				$raw_unitpenalty = $question->options->unitpenalty ;
! 			}
! 			$state->options->raw_unitpenalty = $raw_unitpenalty ;
! 		}
! 
! 		// Removed correct answer, to be displayed later MDL-7496
! 		include("$CFG->dirroot/question/type/numerical/display.html");
! 	}
! 
! 
! 	function compare_responses(&$question, $state, $teststate) {
! 
! 		if ($question->options->showunits == NUMERICALQUESTIONUNITMULTICHOICEDISPLAY && isset($question->options->units) && isset($state->responses['unit']) && isset($question->options->units[$state->responses['unit']] )){
! 			$state->responses['unit']=$question->options->units[$state->responses['unit']]->unit;
! 		};
! 
! 
! 		$responses = '';
! 		$testresponses = '';
! 		if (isset($state->responses['answer'])){
! 			$responses = $state->responses['answer'];
! 		}
! 		if (isset($state->responses['unit'])){
! 			$responses .= $state->responses['unit'];
! 		}
! 		if (isset($teststate->responses['answer'])){
! 			$testresponses = $teststate->responses['answer'];
! 		}
! 		if (isset($teststate->responses['unit'])){
! 			$testresponses .= $teststate->responses['unit'];
! 		}
! 
! 		if ( isset($responses)  && isset($testresponses )) {
! 
! 			return $responses == $testresponses ;
! 		}
! 		return false;
! 	}
! 
! 	/**
! 	 * Checks whether a response matches a given answer, taking the tolerance
! 	 * and but NOT the unit into account. Returns a true for if a response matches the
! 	 * answer or in one of the unit , false if it doesn't.
! 	 * the total grading will see if the unit match.
! 	 * if unit != -1 then the test is done only on this unit
! 	 */
! 	function test_response(&$question, &$state, $answer ) {
! 		// Deal with the match anything answer.
! 		if ($answer->answer === '*') {
! 			return true;
! 		}
! 		// using old grading process if $question->unitgradingtype == 0
! 		// and adding unit1 for the new option NUMERICALQUESTIONUNITTEXTDISPLAY
! 		if ($question->options->unitgradingtype == 0 ){
! 			// values coming form old question stored in attempts
! 			if (!isset($state->responses['answer']) && isset($state->responses[''])){
! 				$state->responses['answer'] =  $state->responses[''];
! 			}
! 			$answertotest = $state->responses['answer'];
! 			// values coming from  NUMERICALQUESTIONUNITTEXTINPUTDISPLAY
! 			// or NUMERICALQUESTIONUNITTEXTDISPLAY as unit hidden HTML element
! 
! 			if($question->options->showunits == NUMERICALQUESTIONUNITTEXTINPUTDISPLAY ){
! 
! 				$testresponse = $this->extract_numerical_response($state->responses['answer']);
! 				if($testresponse->unit != '' || $testresponse->number === false){
! 					return false;
! 				}
! 				$answertotest = $testresponse->number ;
! 			}
! 			if(isset($state->responses['unit'])) {
! 				$answertotest .= $state->responses['unit'] ;
! 			}
! 			//  if ($question->options->showunits == NUMERICALQUESTIONUNITTEXTDISPLAY && isset($question->options->units[0])){
! 			//     $answertotest .= $question->options->units[0]->unit ;
! 			// }
! 			// test OK if only numerical or numerical with known unit names with the unit mltiplier applied
! 			$response = $this->apply_unit($answertotest, $question->options->units);
! 
! 			if ($response === false) {
! 				return false; // The student did not type a number.
! 			}
! 
! 			// The student did type a number, so check it with tolerances.
! 			$this->get_tolerance_interval($answer);
! 			return ($answer->min <= $response && $response <= $answer->max);
! 		} else { // $question->options->unitgradingtype > 0
! 			/* testing with unitgradingtype $question->options->unitgradingtype > 0
! 			* if the response is at least patially true
! 			* if the numerical value agree in the interval
! 			* if so the only non valid case will be a bad unit and a unity penalty.
! 
! 			To be able to test (old) questions that do not have an unit
! 			* input element the test is done using the $state->responses['']
! 			* which contains the response which is analyzed by extract_numerical_response()
! 			* If the data comes from the numerical or calculated display
! 			* the $state->responses['unit'] comes from either
! 			* a multichoice radio element NUMERICALQUESTIONUNITMULTICHOICEDISPLAY
! 			* where the $state->responses['unit'] value is the key => unit object
! 			* in the  the $question->options->units array
! 			* or an input text element NUMERICALQUESTIONUNITTEXTINPUTDISPLAY
! 			* which contains the student response
! 			* for NUMERICALQUESTIONUNITTEXTDISPLAY and NUMERICALQUESTIONUNITNODISPLAY
! 			*
! 			*/
! 
! 			$response = $this->extract_numerical_response($state->responses['answer']);
! 
! 
! 			if ($response->number === false ) {
! 				return false; // The student did not type a number.
! 			}
! 
! 			// The student did type a number, so check it with tolerances.
! 			$this->get_tolerance_interval($answer);
! 			if ($answer->min <= $response->number && $response->number <= $answer->max){
! 				return true;
! 			}
! 			// testing for other units
! 			if ( isset($question->options->units) && count($question->options->units) > 0) {
! 				foreach($question->options->units as $key =>$unit){
! 					$testresponse = $response->number /$unit->multiplier ;
! 					if($answer->min <= $testresponse && $testresponse<= $answer->max) {
! 						return true;
! 					}
! 				}
! 			}
! 			return false;
! 		}
! 		return false;
! 	}
! 
! 	/**
! 	 * Performs response processing and grading
! 	 * The function was redefined for handling correctly the two parts
! 	 * number and unit of numerical or calculated questions
! 	 * The code handles also the case when there no unit defined by the user or
! 	 * when used in a multianswer (Cloze) question.
! 	 * This function performs response processing and grading and updates
! 	 * the state accordingly.
! 	 * @return boolean         Indicates success or failure.
! 	 * @param object $question The question to be graded. Question type
! 	 *                         specific information is included.
! 	 * @param object $state    The state of the question to grade. The current
! 	 *                         responses are in ->responses. The last graded state
! 	 *                         is in ->last_graded (hence the most recently graded
! 	 *                         responses are in ->last_graded->responses). The
! 	 *                         question type specific information is also
! 	 *                         included. The ->raw_grade and ->penalty fields
! 	 *                         must be updated. The method is able to
! 	 *                         close the question session (preventing any further
! 	 *                         attempts at this question) by setting
! 	 *                         $state->event to QUESTION_EVENTCLOSEANDGRADE
! 	 * @param object $cmoptions
! 	 */
! 	function grade_responses(&$question, &$state, $cmoptions) {
! 		if ( isset($state->responses['']) && $state->responses[''] != '' && !isset($state->responses['answer'])){
! 			$this->split_old_answer($state->responses[''], $question->options->units, $state->responses['answer'] ,$state->responses['unit'] );
! 		}
! 
! 		$state->raw_grade = 0;
! 		$valid_numerical_unit = false ;
! 		$break = 0 ;
! 		$unittested = '';
! 		$hasunits = 0 ;
! 		$answerasterisk = false ;
! 
! 		$break = 0 ;
! 		foreach($question->options->answers as $answer) {
! 			if ($this->test_response($question, $state, $answer)) {
! 				// Answer was correct or partially correct.
! 				$state->raw_grade = $answer->fraction ;
! 				if ($question->options->unitgradingtype == 0 || $answer->answer === '*'){
! 					// if * then unit has the $answer->fraction value
! 					// if $question->options->unitgradingtype == 0 everything has been checked
! 					// if $question->options->showunits == NUMERICALQUESTIONUNITTEXTINPUTDISPLAY
! 					// then number - unit combination has been used to test response
! 					// so the unit should have same color
! 
! 				}else {
! 					// so we need to apply unit grading i.e. to check if the number-unit combination
! 					// was the rigth one
! 					$valid_numerical_unit = false ;
! 					$class = question_get_feedback_class($answer->fraction);
! 					$feedbackimg = question_get_feedback_image($answer->fraction);
! 					if(isset($state->responses['unit']) && $state->responses['unit'] != '' ){
! 						foreach ($question->options->units as $key => $unit) {
! 							if ($unit->unit == $state->responses['unit']){
! 
! 								$response = $this->apply_unit($state->responses['answer'].$state->responses['unit'], array($question->options->units[$key])) ;
! 								if ($response !== false) {
! 									$this->get_tolerance_interval($answer);
! 									if($answer->min <= $response && $response <= $answer->max){
! 										$valid_numerical_unit = true ;
! 									}
! 								}
! 								break ;
! 							}
! 						}
! 					}
! 				}
! 				break ;
! 			}
! 		}
! 		// apply unit penalty
! 		$raw_unitpenalty = 0 ;
! 		if($question->options->unitgradingtype != 0 && !empty($question->options->unitpenalty)&& $valid_numerical_unit != true ){
! 			if($question->options->unitgradingtype == 1){
! 				$raw_unitpenalty = $question->options->unitpenalty * $state->raw_grade ;
! 			}else {
! 				$raw_unitpenalty = $question->options->unitpenalty ;
! 			}
! 			$state->raw_grade -= $raw_unitpenalty ;
! 		}
! 
! 		// Make sure we don't assign negative or too high marks.
! 		$state->raw_grade = min(max((float) $state->raw_grade,
! 		0.0), 1.0) * $question->maxgrade;
! 
! 		// Update the penalty.
! 		$state->penalty = $question->penalty * $question->maxgrade;
! 
! 		// mark the state as graded
! 		$state->event = ($state->event ==  QUESTION_EVENTCLOSE) ? QUESTION_EVENTCLOSEANDGRADE : QUESTION_EVENTGRADE;
! 
! 		return true;
! 	}
! 
! 
! 	function get_correct_responses(&$question, &$state) {
! 		$correct = parent::get_correct_responses($question, $state);
! 		$unit = $this->get_default_numerical_unit($question);
! 		if (isset($correct['']) && $correct[''] != '*' && $unit) {
! 			$correct[''] .= ' '.$unit->unit;
! 		}
! 		return $correct;
! 	}
! 
! 	// ULPGC ecastro
! 	function get_all_responses(&$question, &$state) {
! 		$result = new stdClass;
! 		$answers = array();
! 		$unit = $this->get_default_numerical_unit($question);
! 		if (is_array($question->options->answers)) {
! 			foreach ($question->options->answers as $aid=>$answer) {
! 				$r = new stdClass;
! 				$r->answer = $answer->answer;
! 				$r->credit = $answer->fraction;
! 				$this->get_tolerance_interval($answer);
! 				if ($r->answer != '*' && $unit) {
! 					$r->answer .= ' ' . $unit->unit;
! 				}
! 				if ($answer->max != $answer->min) {
! 					$max = "$answer->max"; //format_float($answer->max, 2);
! 					$min = "$answer->min"; //format_float($answer->max, 2);
! 					$r->answer .= ' ('.$min.'..'.$max.')';
! 				}
! 				$answers[$aid] = $r;
! 			}
! 		}
! 		$result->id = $question->id;
! 		$result->responses = $answers;
! 		return $result;
! 	}
! 	function get_actual_response($question, $state) {
! 		if (!empty($state->responses) && !empty($state->responses[''])) {
! 			if(false === strpos($state->responses[''], '|||||')){
! 				$responses[] = $state->responses[''];
! 			}else {
! 				$resp = explode('|||||', $state->responses['']);
! 				$responses[] = $resp[0].$resp[1];
! 			}
! 		} else {
! 			$responses[] = '';
! 		}
! 
! 		return $responses;
! 	}
! 
! 
! 	function get_tolerance_interval(&$answer) {
! 		// No tolerance
! 		if (empty($answer->tolerance)) {
! 			$answer->tolerance = 0;
! 		}
! 
! 		// Calculate the interval of correct responses (min/max)
! 		if (!isset($answer->tolerancetype)) {
! 			$answer->tolerancetype = 2; // nominal
! 		}
! 
! 		// We need to add a tiny fraction depending on the set precision to make the
! 		// comparison work correctly. Otherwise seemingly equal values can yield
! 		// false. (fixes bug #3225)
! 		$tolerance = (float)$answer->tolerance + ("1.0e-".ini_get('precision'));
! 		switch ($answer->tolerancetype) {
! 			case '1': case 'relative':
! 				/// Recalculate the tolerance and fall through
! 				/// to the nominal case:
! 				$tolerance = $answer->answer * $tolerance;
! 				// Do not fall through to the nominal case because the tiny fraction is a factor of the answer
! 				$tolerance = abs($tolerance); // important - otherwise min and max are swapped
! 				$max = $answer->answer + $tolerance;
! 				$min = $answer->answer - $tolerance;
! 				break;
! 				case '2': case 'nominal':
! 					$tolerance = abs($tolerance); // important - otherwise min and max are swapped
! 					// $answer->tolerance 0 or something else
! 					if ((float)$answer->tolerance == 0.0  &&  abs((float)$answer->answer) <= $tolerance ){
! 						$tolerance = (float) ("1.0e-".ini_get('precision')) * abs((float)$answer->answer) ; //tiny fraction
! 					} else if ((float)$answer->tolerance != 0.0 && abs((float)$answer->tolerance) < abs((float)$answer->answer) &&  abs((float)$answer->answer) <= $tolerance){
! 						$tolerance = (1+("1.0e-".ini_get('precision')) )* abs((float) $answer->tolerance) ;//tiny fraction
! 					}
! 
! 					$max = $answer->answer + $tolerance;
! 					$min = $answer->answer - $tolerance;
! 					break;
! 				case '3': case 'geometric':
! 					$quotient = 1 + abs($tolerance);
! 					$max = $answer->answer * $quotient;
! 					$min = $answer->answer / $quotient;
! 					break;
! 				default:
! 					print_error('unknowntolerance', 'question', '', $answer->tolerancetype);
! 		}
! 
! 		$answer->min = $min;
! 		$answer->max = $max;
! 		return true;
! 	}
! 
! 	/**
! 	 * Checks if the $rawresponse has a unit and applys it if appropriate.
! 	 *
! 	 * @param string $rawresponse  The response string to be converted to a float.
! 	 * @param array $units         An array with the defined units, where the
! 	 *                             unit is the key and the multiplier the value.
! 	 * @return float               The rawresponse with the unit taken into
! 	 *                             account as a float.
! 	 */
! 	function extract_numerical_response($rawresponse) {
! 		$extractedresponse = new stdClass() ;
! 		$rawresponse = trim($rawresponse) ;
! 		$search  = array(' ', ',');
! 		// test if a . is present or there are multiple , (i.e. 2,456,789 ) so that we don't need spaces and ,
! 		if ( strpos($rawresponse,'.' ) !== false || substr_count($rawresponse,',') > 1 ) {
! 			$replace = array('', '');
! 		}else { // remove spaces and normalise , to a . .
! 			$replace = array('', '.');
! 		}
! 		$rawresponse = str_replace($search, $replace, $rawresponse);
! 
! 		if (preg_match('~^([+-]?([0-9]+(\\.[0-9]*)?|\\.[0-9]+)([eE][-+]?[0-9]+)?)([^0-9].*)?$~',
! 		$rawresponse, $responseparts)) {
! 			//return (float)$responseparts[1] ;
! 			$extractedresponse->number = (float)$responseparts[1] ;
! 		}else {
! 			$extractedresponse->number = false ;
! 		}
! 		if (!empty($responseparts[5])) {
! 			$extractedresponse->unit = $responseparts[5] ;
! 		}else {
! 			$extractedresponse->unit = '';
! 		}
! 
! 		// Invalid number. Must be wrong.
! 		return clone($extractedresponse) ;
! 	}
! 	/**
! 	 * Checks if the $rawresponse has a unit and applys it if appropriate.
! 	 *
! 	 * @param string $rawresponse  The response string to be converted to a float.
! 	 * @param array $units         An array with the defined units, where the
! 	 *                             unit is the key and the multiplier the value.
! 	 * @return float               The rawresponse with the unit taken into
! 	 *                             account as a float.
! 	 */
! 	function apply_unit($rawresponse, $units) {
! 
! 		// Make units more useful
! 		$tmpunits = array();
! 		foreach ($units as $unit) {
! 			$tmpunits[$unit->unit] = $unit->multiplier;
! 		}
! 		// remove spaces and normalise decimal places.
! 		$rawresponse = trim($rawresponse) ;
! 		$search  = array(' ', ',');
! 		// test if a . is present or there are multiple , (i.e. 2,456,789 ) so that we don't need spaces and ,
! 		if ( strpos($rawresponse,'.' ) !== false || substr_count($rawresponse,',') > 1 ) {
! 			$replace = array('', '');
! 		}else { // remove spaces and normalise , to a . .
! 			$replace = array('', '.');
! 		}
! 		$rawresponse = str_replace($search, $replace, $rawresponse);
! 
! 
! 		// Apply any unit that is present.
! 		if (ereg('^([+-]?([0-9]+(\\.[0-9]*)?|\\.[0-9]+)([eE][-+]?[0-9]+)?)([^0-9].*)?$',
! 		$rawresponse, $responseparts)) {
! 			//     echo"<p> responseparts <pre>";print_r($responseparts) ;echo"</pre></p>";
! 
! 			if (!empty($responseparts[5])) {
! 
! 				if (isset($tmpunits[$responseparts[5]])) {
! 					// Valid number with unit.
! 					return (float)$responseparts[1] / $tmpunits[$responseparts[5]];
! 				} else {
! 					// Valid number with invalid unit. Must be wrong.
! 					return false;
! 				}
! 
! 			} else {
! 				// Valid number without unit.
! 				return (float)$responseparts[1];
! 			}
! 		}
! 		// Invalid number. Must be wrong.
! 		return false;
! 	}
! 
! 	/**
! 	 * function used in function definition_inner()
! 	 * of edit_..._form.php for
! 	 * numerical, calculated, calculatedsimple
! 	 */
! 	function add_units_options(&$mform, &$that){
! 		// Units are graded
! 		$mform->addElement('header', 'unithandling', get_string('unitshandling', 'qtype_numerical'));
! 		$mform->addElement('radio', 'unitrole', get_string('unitnotused', 'qtype_numerical'), get_string('onlynumerical', 'qtype_numerical'),0);
! 		$mform->addElement('radio', 'unitrole', get_string('unitdisplay', 'qtype_numerical'), get_string('oneunitshown', 'qtype_numerical'),1);
! 		$mform->addElement('radio', 'unitrole', get_string('unitsused', 'qtype_numerical'), get_string('manynumerical', 'qtype_numerical'),2);
! 		$mform->addElement('static', 'separator2', '', '<HR/>');
! 		$mform->addElement('radio', 'unitrole', get_string('unitgraded1', 'qtype_numerical'), get_string('unitgraded', 'qtype_numerical'),3);
! 		$penaltygrp = array();
! 		$penaltygrp[] =& $mform->createElement('text', 'unitpenalty', get_string('unitpenalty', 'qtype_numerical') ,
! 		array('size' => 6));
! 		$unitgradingtypes = array('1' => get_string('decfractionofresponsegrade', 'qtype_numerical'), '2' => get_string('decfractionofquestiongrade', 'qtype_numerical'));
! 		$penaltygrp[] =& $mform->createElement('select', 'unitgradingtypes', '' , $unitgradingtypes );
! 		$mform->addGroup($penaltygrp, 'penaltygrp', get_string('unitpenalty', 'qtype_numerical'),' ' , false);
! 		$multichoicedisplaygrp = array();
! 		$multichoicedisplaygrp[] =& $mform->createElement('radio', 'multichoicedisplay', get_string('unitedit', 'qtype_numerical'), get_string('editableunittext', 'qtype_numerical'),0);
! 		$multichoicedisplaygrp[] =& $mform->createElement('radio', 'multichoicedisplay', get_string('selectunits', 'qtype_numerical') , get_string('unitchoice', 'qtype_numerical'),1);
! 		$mform->addGroup($multichoicedisplaygrp, 'multichoicedisplaygrp', get_string('studentunitanswer', 'qtype_numerical'),' OR ' , false);
! 		$unitslefts = array('0' => get_string('rightexample', 'qtype_numerical'),'1' => get_string('leftexample', 'qtype_numerical'));
! 		$mform->addElement('select', 'unitsleft', get_string('unitposition', 'qtype_numerical') , $unitslefts );
! 
! 		$mform->addElement('static', 'separator2', '<HR/>', '<HR/>');
! 
! 		$mform->addElement('editor', 'instructions', get_string('instructions', 'qtype_numerical'), null, $that->editoroptions);
! 		$showunits1grp = array();
! 		$mform->addElement('static', 'separator2', '<HR/>', '<HR/>');
! 
! 		$mform->setType('unitpenalty', PARAM_NUMBER);
! 		$mform->setDefault('unitpenalty', 0.1);
! 		$mform->setDefault('unitgradingtypes', 1);
! 		$mform->addHelpButton('penaltygrp', 'unitpenalty', 'qtype_numerical'); // TODO help did not exist before MDL-21695
! 		$mform->setDefault('unitsleft', 0);
! 		$mform->setType('instructions', PARAM_RAW);
! 		$mform->addHelpButton('instructions', 'numericalinstructions', 'qtype_numerical');
! 		$mform->disabledIf('penaltygrp', 'unitrole','eq','0');
! 		$mform->disabledIf('penaltygrp', 'unitrole','eq','1');
! 		$mform->disabledIf('penaltygrp', 'unitrole','eq','2');
! 		$mform->disabledIf('unitsleft', 'unitrole','eq','0');
! 		$mform->disabledIf('multichoicedisplay','unitrole','eq','0');
! 		$mform->disabledIf('multichoicedisplay','unitrole','eq','1');
! 		$mform->disabledIf('multichoicedisplay','unitrole','eq','2');
! 	}
! 
! 	/**
! 	 * function used in in function definition_inner()
! 	 * of edit_..._form.php for
! 	 * numerical, calculated, calculatedsimple
! 	 */
! 	function add_units_elements(& $mform,& $that) {
! 		$repeated = array();
! 		$repeated[] =& $mform->createElement('header', 'unithdr', get_string('unithdr', 'qtype_numerical', '{no}'));
! 
! 		$repeated[] =& $mform->createElement('text', 'unit', get_string('unit', 'quiz'));
! 		$mform->setType('unit', PARAM_NOTAGS);
! 
! 		$repeated[] =& $mform->createElement('text', 'multiplier', get_string('multiplier', 'quiz'));
! 		$mform->setType('multiplier', PARAM_NUMBER);
! 
! 		if (isset($that->question->options->units)){
! 			$countunits = count($that->question->options->units);
! 		} else {
! 			$countunits = 0;
! 		}
! 		if ($that->question->formoptions->repeatelements){
! 			$repeatsatstart = $countunits + 1;
! 		} else {
! 			$repeatsatstart = $countunits;
! 		}
! 		$that->repeat_elements($repeated, $repeatsatstart, array(), 'nounits', 'addunits', 2, get_string('addmoreunitblanks', 'qtype_calculated', '{no}'));
! 
! 		if ($mform->elementExists('multiplier[0]')){
! 			$firstunit =& $mform->getElement('multiplier[0]');
! 			$firstunit->freeze();
! 			$firstunit->setValue('1.0');
! 			$firstunit->setPersistantFreeze(true);
! 			$mform->addHelpButton('multiplier[0]', 'numericalmultiplier', 'qtype_numerical');
! 		}
! 	}
! 
! 	/**
! 	 * function used in in function data_preprocessing() of edit_numerical_form.php for
! 	 * numerical, calculated, calculatedsimple
! 	 */
! 	function set_numerical_unit_data($mform, &$question, &$default_values){
! 
! 		list($categoryid) = explode(',', $question->category);
! 		$context = $this->get_context_by_category_id($categoryid);
! 
! 		if (isset($question->options)){
! 			if (isset($question->options->unitpenalty)){
! 				$default_values['unitpenalty'] = $question->options->unitpenalty ;
! 			}
! 			$default_values['unitgradingtypes'] = 1 ;
! 			if (isset($question->options->unitgradingtype )&& isset($question->options->showunits ) ){
! 				if ( $question->options->unitgradingtype == 2 ) {
! 					$default_values['unitgradingtypes'] = 1 ;
! 				}
! 				if ( $question->options->unitgradingtype == 0 ) {
! 					$default_values['unitgradingtypes'] = 0 ;
! 				}
! 				switch ($question->options->showunits){
! 					case 0 :// NUMERICALQUESTIONUNITTEXTINPUTDISPLAY
! 						if($question->options->unitgradingtype == 0 ){
! 							$default_values['unitrole'] = 2 ;
! 							$default_values['multichoicedisplay'] = 0 ;
! 						}else { // 1 or 2
! 							$default_values['unitrole'] = 3 ;
! 							$default_values['multichoicedisplay'] = 0 ;
! 							$default_values['unitgradingtypes'] = $question->options->unitgradingtype ;
! 						}
! 						break;
! 					case 1 : // NUMERICALQUESTIONUNITMULTICHOICEDISPLAY
! 						$default_values['unitrole'] = 3 ;
! 						$default_values['multichoicedisplay'] = $question->options->unitgradingtype ;
! 						$default_values['unitgradingtypes'] = $question->options->unitgradingtype ;
! 						break;
! 					case 2 : // NUMERICALQUESTIONUNITTEXTDISPLAY
! 						$default_values['unitrole'] = 1 ;
! 						break;
! 					case 3 : // NUMERICALQUESTIONUNITNODISPLAY
! 						$default_values['unitrole'] = 0 ;
! 						//  $default_values['showunits1'] = $question->options->showunits ;
! 						break;
! 				}
! 			}
! 			if (isset($question->options->unitsleft)){
! 				$default_values['unitsleft'] = $question->options->unitsleft ;
! 			}
! 
! 			// processing files
! 			$component = 'qtype_' . $question->qtype;
! 			$draftid = file_get_submitted_draft_itemid('instruction');
! 			$default_values['instructions'] = array();
! 			if (isset($question->options->instructionsformat) && isset($question->options->instructions)){
! 				$default_values['instructions']['format'] = $question->options->instructionsformat;
! 				$default_values['instructions']['text'] = file_prepare_draft_area(
! 				$draftid,       // draftid
! 				$context->id,   // context
! 				$component,     // component
                      'instruction',  // filarea
! 				!empty($question->id)?(int)$question->id:null, // itemid
! 				$mform->fileoptions,    // options
! 				$question->options->instructions // text
! 				);
! 			}
! 			$default_values['instructions']['itemid'] = $draftid ;
! 
! 			if (isset($question->options->units)) {
! 				$units  = array_values($question->options->units);
! 				if (!empty($units)) {
! 					foreach ($units as $key => $unit){
! 						$default_values['unit['.$key.']'] = $unit->unit;
! 						$default_values['multiplier['.$key.']'] = $unit->multiplier;
! 					}
! 				}
! 			}
! 		}
! 	}
! 
! 	/**
! 	 * function use in in function validation()
! 	 * of edit_..._form.php for
! 	 * numerical, calculated, calculatedsimple
! 	 */
! 
! 	function validate_numerical_options(& $data, & $errors){
! 		$units  = $data['unit'];
! 		switch ($data['unitrole']){
! 			case '0' : $showunits = NUMERICALQUESTIONUNITNODISPLAY ;
! 			break ;
! 			case '1' : $showunits = NUMERICALQUESTIONUNITTEXTDISPLAY ;
! 			break ;
! 			case '2' : $showunits = NUMERICALQUESTIONUNITTEXTINPUTDISPLAY ;
! 			break ;
! 			case '3' : $showunits = $data['multichoicedisplay'] ;
! 			break ;
! 		}
! 
! 		if (($showunits == NUMERICALQUESTIONUNITTEXTINPUTDISPLAY) ||
! 		($showunits == NUMERICALQUESTIONUNITMULTICHOICEDISPLAY ) ||
! 		($showunits == NUMERICALQUESTIONUNITTEXTDISPLAY )){
! 			if (trim($units[0]) == ''){
! 				$errors['unit[0]'] = 'You must set a valid unit name' ;
! 			}
! 		}
! 		if ($showunits == NUMERICALQUESTIONUNITNODISPLAY ){
! 			if (count($units)) {
! 				foreach ($units as $key => $unit){
! 					if ($units[$key] != ''){
! 						$errors["unit[$key]"] = 'You must erase this unit name' ;
! 					}
! 				}
! 			}
! 		}
! 
! 
! 		// Check double units.
! 		$alreadyseenunits = array();
! 		if (isset($data['unit'])) {
! 			foreach ($data['unit'] as $key => $unit) {
! 				$trimmedunit = trim($unit);
! 				if ($trimmedunit!='' && in_array($trimmedunit, $alreadyseenunits)) {
! 					$errors["unit[$key]"] = get_string('errorrepeatedunit', 'qtype_numerical');
! 					if (trim($data['multiplier'][$key]) == '') {
! 						$errors["multiplier[$key]"] = get_string('errornomultiplier', 'qtype_numerical');
! 					}
! 				} elseif($trimmedunit!='') {
! 					$alreadyseenunits[] = $trimmedunit;
! 				}
! 			}
! 		}
! 		$units  = $data['unit'];
! 		if (count($units)) {
! 			foreach ($units as $key => $unit){
! 				if (is_numeric($unit)){
! 					$errors['unit['.$key.']'] = get_string('mustnotbenumeric', 'qtype_calculated');
! 				}
! 				$trimmedunit = trim($unit);
! 				$trimmedmultiplier = trim($data['multiplier'][$key]);
! 				if (!empty($trimmedunit)){
! 					if (empty($trimmedmultiplier)){
! 						$errors['multiplier['.$key.']'] = get_string('youmustenteramultiplierhere', 'qtype_calculated');
! 					}
! 					if (!is_numeric($trimmedmultiplier)){
! 						$errors['multiplier['.$key.']'] = get_string('mustbenumeric', 'qtype_calculated');
! 					}
! 
! 				}
! 			}
! 		}
! 
! 	}
! 
! 
! 	function valid_unit($rawresponse, $units) {
! 		// Make units more useful
! 		$tmpunits = array();
! 		foreach ($units as $unit) {
! 			$tmpunits[$unit->unit] = $unit->multiplier;
! 		}
! 		// remove spaces and normalise decimal places.
! 		$search  = array(' ', ',');
! 		$replace = array('', '.');
! 		$rawresponse = str_replace($search, $replace, trim($rawresponse));
! 
! 		// Apply any unit that is present.
! 		if (preg_match('~^([+-]?([0-9]+(\\.[0-9]*)?|\\.[0-9]+)([eE][-+]?[0-9]+)?)([^0-9].*)?$~',
! 		$rawresponse, $responseparts)) {
! 
! 			if (!empty($responseparts[5])) {
! 
! 				if (isset($tmpunits[$responseparts[5]])) {
! 					// Valid number with unit.
! 					return true ; //(float)$responseparts[1] / $tmpunits[$responseparts[5]];
! 				} else {
! 					// Valid number with invalid unit. Must be wrong.
! 					return false;
! 				}
! 
! 			} else {
! 				// Valid number without unit.
! 				return false ; //(float)$responseparts[1];
! 			}
! 		}
! 		// Invalid number. Must be wrong.
! 		return false;
! 	}
! 
! 	/**
! 	 * Runs all the code required to set up and save an essay question for testing purposes.
! 	 * Alternate DB table prefix may be used to facilitate data deletion.
! 	 */
! 	function generate_test($name, $courseid = null) {
! 		global $DB;
! 		list($form, $question) = default_questiontype::generate_test($name, $courseid);
! 		$question->category = $form->category;
! 
! 		$form->questiontext = "What is 674 * 36?";
! 		$form->generalfeedback = "Thank you";
! 		$form->penalty = 0.1;
! 		$form->defaultgrade = 1;
! 		$form->noanswers = 3;
! 		$form->answer = array('24264', '24264', '1');
! 		$form->tolerance = array(10, 100, 0);
! 		$form->fraction = array(1, 0.5, 0);
! 		$form->nounits = 2;
! 		$form->unit = array(0 => null, 1 => null);
! 		$form->multiplier = array(1, 0);
! 		$form->feedback = array('Very good', 'Close, but not quite there', 'Well at least you tried....');
! 
! 		if ($courseid) {
! 			$course = $DB->get_record('course', array('id' => $courseid));
! 		}
! 
! 		return $this->save_question($question, $form);
! 	}
! 
! 	function move_files($questionid, $oldcontextid, $newcontextid) {
! 		$fs = get_file_storage();
! 
! 		parent::move_files($questionid, $oldcontextid, $newcontextid);
! 		$this->move_files_in_answers($questionid, $oldcontextid, $newcontextid);
! 
! 		$fs->move_area_files_to_new_context($oldcontextid,
! 		$newcontextid, 'qtype_numerical', 'instruction', $questionid);
! 	}
! 
! 	protected function delete_files($questionid, $contextid) {
! 		$fs = get_file_storage();
! 
! 		parent::delete_files($questionid, $contextid);
! 		$this->delete_files_in_answers($questionid, $contextid);
! 		$fs->delete_area_files($contextid, 'qtype_numerical', 'instruction', $questionid);
! 	}
! 
! 	function check_file_access($question, $state, $options, $contextid, $component,
! 	$filearea, $args) {
! 		$itemid = reset($args);
! 
! 		if ($component == 'question' && $filearea == 'answerfeedback') {
! 			$result = $options->feedback && array_key_exists($itemid, $question->options->answers);
! 			if (!$result) {
! 				return false;
! 			}
! 			foreach($question->options->answers as $answer) {
! 				if ($this->test_response($question, $state, $answer)) {
! 					return true;
! 				}
! 			}
! 			return false;
! 		} else if ($filearea == 'instruction') {
! 			if ($itemid != $question->id) {
! 				return false;
! 			} else {
! 				return true;
! 			}
! 		} else {
! 			return parent::check_file_access($question, $state, $options, $contextid, $component,
! 			$filearea, $args);
! 		}
! 	}
  }
  
  // INITIATION - Without this line the question type is not in use.
  question_register_questiontype(new question_numerical_qtype());
  if ( ! defined ("NUMERICALQUESTIONUNITTEXTINPUTDISPLAY")) {
! 	define("NUMERICALQUESTIONUNITTEXTINPUTDISPLAY",   0);
  }
  if ( ! defined ("NUMERICALQUESTIONUNITMULTICHOICEDISPLAY")) {
! 	define("NUMERICALQUESTIONUNITMULTICHOICEDISPLAY",   1);
  }
  if ( ! defined ("NUMERICALQUESTIONUNITTEXTDISPLAY")) {
! 	define("NUMERICALQUESTIONUNITTEXTDISPLAY",   2);
  }
  if ( ! defined ("NUMERICALQUESTIONUNITNODISPLAY")) {
! 	define("NUMERICALQUESTIONUNITNODISPLAY",    3);
  }
diff -crB questionorg/type/numerical/simpletest/testquestiontype.php questionupd/type/numerical/simpletest/testquestiontype.php
*** questionorg/type/numerical/simpletest/testquestiontype.php	2012-04-13 12:31:12.613178276 +0500
--- questionupd/type/numerical/simpletest/testquestiontype.php	2012-04-13 09:42:58.000000000 +0500
***************
*** 9,116 ****
   */
  
  if (!defined('MOODLE_INTERNAL')) {
!     die('Direct access to this script is forbidden.');    ///  It must be included from a Moodle page
  }
  
  require_once($CFG->dirroot . '/question/type/numerical/questiontype.php');
  
  class question_numerical_qtype_test extends UnitTestCase {
!     public static $includecoverage = array('question/type/questiontype.php', 'question/type/numerical/questiontype.php');
!     var $tolerance = 0.00000001;
!     var $qtype;
! 
!     function setUp() {
!         $this->qtype = new question_numerical_qtype();
!     }
! 
!     function tearDown() {
!         $this->qtype = null;
!     }
! 
!     function test_name() {
!         $this->assertEqual($this->qtype->name(), 'numerical');
!     }
! 
!     function test_get_tolerance_interval() {
!         $answer = new stdClass;
!         $answer->tolerance = 0.01;
!         $answer->tolerancetype = 'relative';
!         $answer->answer = 1.0;
!         $this->qtype->get_tolerance_interval($answer);
!         $this->assertWithinMargin($answer->min, 0.99, $this->tolerance);
!         $this->assertWithinMargin($answer->max, 1.01, $this->tolerance);
! 
!         $answer = new stdClass;
!         $answer->tolerance = 0.01;
!         $answer->tolerancetype = 'relative';
!         $answer->answer = 10.0;
!         $this->qtype->get_tolerance_interval($answer);
!         $this->assertWithinMargin($answer->min, 9.9, $this->tolerance);
!         $this->assertWithinMargin($answer->max, 10.1, $this->tolerance);
! 
!         $answer = new stdClass;
!         $answer->tolerance = 0.01;
!         $answer->tolerancetype = 'nominal';
!         $answer->answer = 1.0;
!         $this->qtype->get_tolerance_interval($answer);
!         $this->assertWithinMargin($answer->min, 0.99, $this->tolerance);
!         $this->assertWithinMargin($answer->max, 1.01, $this->tolerance);
! 
!         $answer = new stdClass;
!         $answer->tolerance = 2.0;
!         $answer->tolerancetype = 'nominal';
!         $answer->answer = 10.0;
!         $this->qtype->get_tolerance_interval($answer);
!         $this->assertWithinMargin($answer->min, 8, $this->tolerance);
!         $this->assertWithinMargin($answer->max, 12, $this->tolerance);
! 
!         $answer = new stdClass; // Test default tolerance 0.
!         $answer->tolerancetype = 'nominal';
!         $answer->answer = 0.0;
!         $this->qtype->get_tolerance_interval($answer);
!         $this->assertWithinMargin($answer->min, 0, $this->tolerance);
!         $this->assertWithinMargin($answer->max, 0, $this->tolerance);
! 
!         $answer = new stdClass; // Test default type nominal.
!         $answer->tolerance = 1.0;
!         $answer->answer = 1.0;
!         $this->qtype->get_tolerance_interval($answer);
!         $this->assertWithinMargin($answer->min, 0, $this->tolerance);
!         $this->assertWithinMargin($answer->max, 2, $this->tolerance);
! 
!         $answer = new stdClass;
!         $answer->tolerance = 1.0;
!         $answer->tolerancetype = 'geometric';
!         $answer->answer = 1.0;
!         $this->qtype->get_tolerance_interval($answer);
!         $this->assertWithinMargin($answer->min, 0.5, $this->tolerance);
!         $this->assertWithinMargin($answer->max, 2.0, $this->tolerance);
!     }
! 
!     function test_apply_unit() {
!         $units = array(
!             (object) array('unit' => 'm', 'multiplier' => 1),
!             (object) array('unit' => 'cm', 'multiplier' => 100),
!             (object) array('unit' => 'mm', 'multiplier' => 1000),
!             (object) array('unit' => 'inch', 'multiplier' => 1.0/0.0254)
!         );
! 
!         $this->assertWithinMargin($this->qtype->apply_unit('1', $units), 1, $this->tolerance);
!         $this->assertWithinMargin($this->qtype->apply_unit('1.0', $units), 1, $this->tolerance);
!         $this->assertWithinMargin($this->qtype->apply_unit('-1e0', $units), -1, $this->tolerance);
!         $this->assertWithinMargin($this->qtype->apply_unit('100m', $units), 100, $this->tolerance);
!         $this->assertWithinMargin($this->qtype->apply_unit('1cm', $units), 0.01, $this->tolerance);
!         $this->assertWithinMargin($this->qtype->apply_unit('12inch', $units), .3048, $this->tolerance);
!     //    $this->assertIdentical($this->qtype->apply_unit('1km', $units), false);
!         $this->assertWithinMargin($this->qtype->apply_unit('-100', array()), -100, $this->tolerance);
!     //    $this->assertIdentical($this->qtype->apply_unit('1000 miles', array()), false);
!     }
! 
! //    function test_backup() {
! //    }
! //
! //    function test_restore() {
! //    }
! }
  
  
--- 9,116 ----
   */
  
  if (!defined('MOODLE_INTERNAL')) {
! 	die('Direct access to this script is forbidden.');    ///  It must be included from a Moodle page
  }
  
  require_once($CFG->dirroot . '/question/type/numerical/questiontype.php');
  
  class question_numerical_qtype_test extends UnitTestCase {
! 	public static $includecoverage = array('question/type/questiontype.php', 'question/type/numerical/questiontype.php');
! 	var $tolerance = 0.00000001;
! 	var $qtype;
! 
! 	function setUp() {
! 		$this->qtype = new question_numerical_qtype();
! 	}
! 
! 	function tearDown() {
! 		$this->qtype = null;
! 	}
! 
! 	function test_name() {
! 		$this->assertEqual($this->qtype->name(), 'numerical');
! 	}
! 
! 	function test_get_tolerance_interval() {
! 		$answer = new stdClass;
! 		$answer->tolerance = 0.01;
! 		$answer->tolerancetype = 'relative';
! 		$answer->answer = 1.0;
! 		$this->qtype->get_tolerance_interval($answer);
! 		$this->assertWithinMargin($answer->min, 0.99, $this->tolerance);
! 		$this->assertWithinMargin($answer->max, 1.01, $this->tolerance);
! 
! 		$answer = new stdClass;
! 		$answer->tolerance = 0.01;
! 		$answer->tolerancetype = 'relative';
! 		$answer->answer = 10.0;
! 		$this->qtype->get_tolerance_interval($answer);
! 		$this->assertWithinMargin($answer->min, 9.9, $this->tolerance);
! 		$this->assertWithinMargin($answer->max, 10.1, $this->tolerance);
! 
! 		$answer = new stdClass;
! 		$answer->tolerance = 0.01;
! 		$answer->tolerancetype = 'nominal';
! 		$answer->answer = 1.0;
! 		$this->qtype->get_tolerance_interval($answer);
! 		$this->assertWithinMargin($answer->min, 0.99, $this->tolerance);
! 		$this->assertWithinMargin($answer->max, 1.01, $this->tolerance);
! 
! 		$answer = new stdClass;
! 		$answer->tolerance = 2.0;
! 		$answer->tolerancetype = 'nominal';
! 		$answer->answer = 10.0;
! 		$this->qtype->get_tolerance_interval($answer);
! 		$this->assertWithinMargin($answer->min, 8, $this->tolerance);
! 		$this->assertWithinMargin($answer->max, 12, $this->tolerance);
! 
! 		$answer = new stdClass; // Test default tolerance 0.
! 		$answer->tolerancetype = 'nominal';
! 		$answer->answer = 0.0;
! 		$this->qtype->get_tolerance_interval($answer);
! 		$this->assertWithinMargin($answer->min, 0, $this->tolerance);
! 		$this->assertWithinMargin($answer->max, 0, $this->tolerance);
! 
! 		$answer = new stdClass; // Test default type nominal.
! 		$answer->tolerance = 1.0;
! 		$answer->answer = 1.0;
! 		$this->qtype->get_tolerance_interval($answer);
! 		$this->assertWithinMargin($answer->min, 0, $this->tolerance);
! 		$this->assertWithinMargin($answer->max, 2, $this->tolerance);
! 
! 		$answer = new stdClass;
! 		$answer->tolerance = 1.0;
! 		$answer->tolerancetype = 'geometric';
! 		$answer->answer = 1.0;
! 		$this->qtype->get_tolerance_interval($answer);
! 		$this->assertWithinMargin($answer->min, 0.5, $this->tolerance);
! 		$this->assertWithinMargin($answer->max, 2.0, $this->tolerance);
! 	}
! 
! 	function test_apply_unit() {
! 		$units = array(
! 		(object) array('unit' => 'm', 'multiplier' => 1),
! 		(object) array('unit' => 'cm', 'multiplier' => 100),
! 		(object) array('unit' => 'mm', 'multiplier' => 1000),
! 		(object) array('unit' => 'inch', 'multiplier' => 1.0/0.0254)
! 		);
! 
! 		$this->assertWithinMargin($this->qtype->apply_unit('1', $units), 1, $this->tolerance);
! 		$this->assertWithinMargin($this->qtype->apply_unit('1.0', $units), 1, $this->tolerance);
! 		$this->assertWithinMargin($this->qtype->apply_unit('-1e0', $units), -1, $this->tolerance);
! 		$this->assertWithinMargin($this->qtype->apply_unit('100m', $units), 100, $this->tolerance);
! 		$this->assertWithinMargin($this->qtype->apply_unit('1cm', $units), 0.01, $this->tolerance);
! 		$this->assertWithinMargin($this->qtype->apply_unit('12inch', $units), .3048, $this->tolerance);
! 		//    $this->assertIdentical($this->qtype->apply_unit('1km', $units), false);
! 		$this->assertWithinMargin($this->qtype->apply_unit('-100', array()), -100, $this->tolerance);
! 		//    $this->assertIdentical($this->qtype->apply_unit('1000 miles', array()), false);
! 	}
! 
! 	//    function test_backup() {
! 	//    }
! 	//
! 	//    function test_restore() {
! 	//    }
! 	}
  
  
diff -crB questionorg/type/question.html questionupd/type/question.html
*** questionorg/type/question.html	2012-04-13 12:31:12.794178277 +0500
--- questionupd/type/question.html	2012-04-13 09:42:58.000000000 +0500
***************
*** 3,47 ****
   * print_question() method.
   */
  ?>
! <div id="q<?php echo $actualquestionid; ?>" class="que <?php echo $question->qtype; ?> clearfix">
!   <div class="info">
!     <h2 class="no"><span class="accesshide">Question </span><?php echo $number;
      if ($editlink) { ?>
!       <span class="edit"><?php echo $editlink; ?></span>
!     <?php } ?></h2><?php
      if ($grade) { ?>
!       <div class="grade">
!         <?php echo get_string('marks', 'quiz').': '.$grade; ?>
!       </div>
!     <?php }
      $this->print_question_flag($question, $state, $options->flags); ?>
!   </div>
!   <div class="content">
!     <?php $this->print_question_formulation_and_controls($question, $state, $cmoptions, $options);
      if ($generalfeedback) { ?>
!       <div class="generalfeedback">
!         <?php echo $generalfeedback ?>
!       </div>
!     <?php }
      if ($comment) { ?>
!       <div class="comment">
!         <?php
            echo get_string('comment', 'quiz').': ';
            echo $comment;
          ?>
!       </div>
!     <?php }
      echo $commentlink;  ?>
!     <div class="grading">
!       <?php $this->print_question_grading_details($question, $state, $cmoptions, $options); ?>
!     </div><?php
      if ($history) { ?>
!       <div class="history">
!         <?php
            print_string('history', 'quiz');
            echo $history;
          ?>
!       </div>
!     <?php } ?>
!   </div>
  </div>
--- 3,56 ----
   * print_question() method.
   */
  ?>
! <div id="q<?php echo $actualquestionid; ?>"
! 	class="que <?php echo $question->qtype; ?> clearfix">
! 	<div class="info">
! 		<h2 class="no">
! 			<span class="accesshide">Question </span>
! 			<?php $_SESSION['content'].="<tr><td><b>Q ".$number; echo $number;
      if ($editlink) { ?>
! 			<span class="edit">
! 				<?php echo $editlink; ?>
! 			</span>
! 			<?php } ?>
! 		</h2>
! 		<?php
      if ($grade) { ?>
! 		<div class="grade">
! 			<?php //$_SESSION['content'].="  -  (".get_string('marks', 'quiz').': '.$grade.")";
! 			  echo get_string('marks', 'quiz').': '.$grade; ?>
! 		</div>
! 		<?php }
      $this->print_question_flag($question, $state, $options->flags); ?>
! 	</div>
! 	<div class="content">
! 		<?php $this->print_question_formulation_and_controls($question, $state, $cmoptions, $options);
      if ($generalfeedback) { ?>
! 		<div class="generalfeedback">
! 			<?php echo $generalfeedback ?>
! 		</div>
! 		<?php }
      if ($comment) { ?>
! 		<div class="comment">
! 			<?php
            echo get_string('comment', 'quiz').': ';
            echo $comment;
          ?>
! 		</div>
! 		<?php }
      echo $commentlink;  ?>
! 		<div class="grading">
! 			<?php $this->print_question_grading_details($question, $state, $cmoptions, $options); ?>
! 		</div>
! 		<?php
      if ($history) { ?>
! 		<div class="history">
! 			<?php
            print_string('history', 'quiz');
            echo $history;
          ?>
! 		</div>
! 		<?php } ?>
! 	</div>
  </div>
diff -crB questionorg/type/questiontype.php questionupd/type/questiontype.php
*** questionorg/type/questiontype.php	2012-04-13 12:31:13.926178297 +0500
--- questionupd/type/questiontype.php	2012-04-13 09:42:58.000000000 +0500
***************
*** 46,1782 ****
   * @subpackage questiontypes
   */
  class default_questiontype {
!     protected $fileoptions = array(
          'subdirs' => false,
          'maxfiles' => -1,
          'maxbytes' => 0,
!     );
  
!     /**
!      * Name of the question type
!      *
!      * The name returned should coincide with the name of the directory
!      * in which this questiontype is located
!      *
!      * @return string the name of this question type.
!      */
!     function name() {
!         return 'default';
!     }
! 
!     /**
!      * Returns a list of other question types that this one requires in order to
!      * work. For example, the calculated question type is a subclass of the
!      * numerical question type, which is a subclass of the shortanswer question
!      * type; and the randomsamatch question type requires the shortanswer type
!      * to be installed.
!      *
!      * @return array any other question types that this one relies on. An empty
!      * array if none.
!      */
!     function requires_qtypes() {
!         return array();
!     }
! 
!     /**
!      * @return string the name of this pluginfor passing to get_string, set/get_config, etc.
!      */
!     function plugin_name() {
!         return 'qtype_' . $this->name();
!     }
! 
!     /**
!      * @return string the name of this question type in the user's language.
!      * You should not need to override this method, the default behaviour should be fine.
!      */
!     function local_name() {
!         return get_string($this->name(), $this->plugin_name());
!     }
! 
!     /**
!      * The name this question should appear as in the create new question
!      * dropdown. Override this method to return false if you don't want your
!      * question type to be createable, for example if it is an abstract base type,
!      * otherwise, you should not need to override this method.
!      *
!      * @return mixed the desired string, or false to hide this question type in the menu.
!      */
!     function menu_name() {
!         return $this->local_name();
!     }
! 
!     /**
!      * @return boolean override this to return false if this is not really a
!      *      question type, for example the description question type is not
!      *      really a question type.
!      */
!     function is_real_question_type() {
!         return true;
!     }
! 
!     /**
!      * @return boolean true if this question type may require manual grading.
!      */
!     function is_manual_graded() {
!         return false;
!     }
! 
!     /**
!      * @param object $question a question of this type.
!      * @param string $otherquestionsinuse comma-separate list of other question ids in this attempt.
!      * @return boolean true if a particular instance of this question requires manual grading.
!      */
!     function is_question_manual_graded($question, $otherquestionsinuse) {
!         return $this->is_manual_graded();
!     }
! 
!     /**
!      * @return boolean true if a table analyzing responses should be shown in
!      * the quiz statistics report. Usually if a question is manually graded
!      * then this analysis table won't be a good idea.
!      */
!     function show_analysis_of_responses() {
!         return !$this->is_manual_graded();
!     }
! 
!     /**
!      * @return boolean true if this question type can be used by the random question type.
!      */
!     function is_usable_by_random() {
!         return true;
!     }
! 
!     /**
!      * @param question record.
!      * @param integer subqid this is the id of the subquestion. Usually the id
!      * of the question record of the question record but this is dependent on
!      * the question type. Not relevant to some question types.
!      * @return whether the teacher supplied responses can include wildcards. Can
!      * more than one answer be equivalent to one teacher supplied response.
!      */
!     function has_wildcards_in_responses($question, $subqid) {
!         return false;
!     }
! 
!     /**
!      * If your question type has a table that extends the question table, and
!      * you want the base class to automatically save, backup and restore the extra fields,
!      * override this method to return an array wherer the first element is the table name,
!      * and the subsequent entries are the column names (apart from id and questionid).
!      *
!      * @return mixed array as above, or null to tell the base class to do nothing.
!      */
!     function extra_question_fields() {
!         return null;
!     }
! 
!     /**
!         * If you use extra_question_fields, overload this function to return question id field name
!         *  in case you table use another name for this column
!         */
!     function questionid_column_name() {
!         return 'questionid';
!     }
! 
!     /**
!      * If your question type has a table that extends the question_answers table,
!      * make this method return an array wherer the first element is the table name,
!      * and the subsequent entries are the column names (apart from id and answerid).
!      *
!      * @return mixed array as above, or null to tell the base class to do nothing.
!      */
!     function extra_answer_fields() {
!         return null;
!     }
! 
!     /**
!      * Return an instance of the question editing form definition. This looks for a
!      * class called edit_{$this->name()}_question_form in the file
!      * {$CFG->dirroot}/question/type/{$this->name()}/edit_{$this->name()}_question_form.php
!      * and if it exists returns an instance of it.
!      *
!      * @param string $submiturl passed on to the constructor call.
!      * @return object an instance of the form definition, or null if one could not be found.
!      */
!     function create_editing_form($submiturl, $question, $category, $contexts, $formeditable) {
!         global $CFG;
!         require_once("{$CFG->dirroot}/question/type/edit_question_form.php");
!         $definition_file = $CFG->dirroot.'/question/type/'.$this->name().'/edit_'.$this->name().'_form.php';
!         if (!(is_readable($definition_file) && is_file($definition_file))) {
!             return null;
!         }
!         require_once($definition_file);
!         $classname = 'question_edit_'.$this->name().'_form';
!         if (!class_exists($classname)) {
!             return null;
!         }
!         return new $classname($submiturl, $question, $category, $contexts, $formeditable);
!     }
! 
!     /**
!      * @return string the full path of the folder this plugin's files live in.
!      */
!     function plugin_dir() {
!         global $CFG;
!         return $CFG->dirroot . '/question/type/' . $this->name();
!     }
! 
!     /**
!      * @return string the URL of the folder this plugin's files live in.
!      */
!     function plugin_baseurl() {
!         global $CFG;
!         return $CFG->wwwroot . '/question/type/' . $this->name();
!     }
! 
!     /**
!      * This method should be overriden if you want to include a special heading or some other
!      * html on a question editing page besides the question editing form.
!      *
!      * @param question_edit_form $mform a child of question_edit_form
!      * @param object $question
!      * @param string $wizardnow is '' for first page.
!      */
!     function display_question_editing_page(&$mform, $question, $wizardnow){
!         global $OUTPUT;
!         $heading = $this->get_heading(empty($question->id));
! 
!         echo $OUTPUT->heading_with_help($heading, $this->name(), $this->plugin_name());
! 
!         $permissionstrs = array();
!         if (!empty($question->id)){
!             if ($question->formoptions->canedit){
!                 $permissionstrs[] = get_string('permissionedit', 'question');
!             }
!             if ($question->formoptions->canmove){
!                 $permissionstrs[] = get_string('permissionmove', 'question');
!             }
!             if ($question->formoptions->cansaveasnew){
!                 $permissionstrs[] = get_string('permissionsaveasnew', 'question');
!             }
!         }
!         if (!$question->formoptions->movecontext  && count($permissionstrs)){
!             echo $OUTPUT->heading(get_string('permissionto', 'question'), 3);
!             $html = '<ul>';
!             foreach ($permissionstrs as $permissionstr){
!                 $html .= '<li>'.$permissionstr.'</li>';
!             }
!             $html .= '</ul>';
!             echo $OUTPUT->box($html, 'boxwidthnarrow boxaligncenter generalbox');
!         }
!         $mform->display();
!     }
! 
!     /**
!      * Method called by display_question_editing_page and by question.php to get heading for breadcrumbs.
!      *
!      * @return array a string heading and the langmodule in which it was found.
!      */
!     function get_heading($adding = false){
!         if ($adding) {
!             $prefix = 'adding';
!         } else {
!             $prefix = 'editing';
!         }
!         return get_string($prefix . $this->name(), $this->plugin_name());
!     }
! 
!     /**
!     * Saves (creates or updates) a question.
!     *
!     * Given some question info and some data about the answers
!     * this function parses, organises and saves the question
!     * It is used by {@link question.php} when saving new data from
!     * a form, and also by {@link import.php} when importing questions
!     * This function in turn calls {@link save_question_options}
!     * to save question-type specific data.
!     *
!     * Whether we are saving a new question or updating an existing one can be
!     * determined by testing !empty($question->id). If it is not empty, we are updating.
!     *
!     * The question will be saved in category $form->category.
!     *
!     * @param object $question the question object which should be updated. For a new question will be mostly empty.
!     * @param object $form the object containing the information to save, as if from the question editing form.
!     * @param object $course not really used any more.
!     * @return object On success, return the new question object. On failure,
!     *       return an object as follows. If the error object has an errors field,
!     *       display that as an error message. Otherwise, the editing form will be
!     *       redisplayed with validation errors, from validation_errors field, which
!     *       is itself an object, shown next to the form fields. (I don't think this is accurate any more.)
!     */
!     function save_question($question, $form) {
!         global $USER, $DB, $OUTPUT;
! 
!         list($question->category) = explode(',', $form->category);
!         $context = $this->get_context_by_category_id($question->category);
! 
!         // This default implementation is suitable for most
!         // question types.
! 
!         // First, save the basic question itself
!         $question->name = trim($form->name);
!         $question->parent = isset($form->parent) ? $form->parent : 0;
!         $question->length = $this->actual_number_of_questions($question);
!         $question->penalty = isset($form->penalty) ? $form->penalty : 0;
! 
!         if (empty($form->questiontext['text'])) {
!             $question->questiontext = '';
!         } else {
!             $question->questiontext = trim($form->questiontext['text']);;
!         }
!         $question->questiontextformat = !empty($form->questiontext['format'])?$form->questiontext['format']:0;
! 
!         if (empty($form->generalfeedback['text'])) {
!             $question->generalfeedback = '';
!         } else {
!             $question->generalfeedback = trim($form->generalfeedback['text']);
!         }
!         $question->generalfeedbackformat = !empty($form->generalfeedback['format'])?$form->generalfeedback['format']:0;
! 
!         if (empty($question->name)) {
!             $question->name = shorten_text(strip_tags($form->questiontext['text']), 15);
!             if (empty($question->name)) {
!                 $question->name = '-';
!             }
!         }
! 
!         if ($question->penalty > 1 or $question->penalty < 0) {
!             $question->errors['penalty'] = get_string('invalidpenalty', 'quiz');
!         }
! 
!         if (isset($form->defaultgrade)) {
!             $question->defaultgrade = $form->defaultgrade;
!         }
! 
!         // If the question is new, create it.
!         if (empty($question->id)) {
!             // Set the unique code
!             $question->stamp = make_unique_id_code();
!             $question->createdby = $USER->id;
!             $question->timecreated = time();
!             $question->id = $DB->insert_record('question', $question);
!         }
! 
!         // Now, whether we are updating a existing question, or creating a new
!         // one, we have to do the files processing and update the record.
!         /// Question already exists, update.
!         $question->modifiedby = $USER->id;
!         $question->timemodified = time();
! 
!         if (!empty($question->questiontext) && !empty($form->questiontext['itemid'])) {
!             $question->questiontext = file_save_draft_area_files($form->questiontext['itemid'], $context->id, 'question', 'questiontext', (int)$question->id, $this->fileoptions, $question->questiontext);
!         }
!         if (!empty($question->generalfeedback) && !empty($form->generalfeedback['itemid'])) {
!             $question->generalfeedback = file_save_draft_area_files($form->generalfeedback['itemid'], $context->id, 'question', 'generalfeedback', (int)$question->id, $this->fileoptions, $question->generalfeedback);
!         }
!         $DB->update_record('question', $question);
! 
!         // Now to save all the answers and type-specific options
!         $form->id = $question->id;
!         $form->qtype = $question->qtype;
!         $form->category = $question->category;
!         $form->questiontext = $question->questiontext;
!         $form->questiontextformat = $question->questiontextformat;
!         // current context
!         $form->context = $context;
! 
!         $result = $this->save_question_options($form);
! 
!         if (!empty($result->error)) {
!             print_error($result->error);
!         }
! 
!         if (!empty($result->notice)) {
!             notice($result->notice, "question.php?id=$question->id");
!         }
! 
!         if (!empty($result->noticeyesno)) {
!             throw new coding_exception('$result->noticeyesno no longer supported in save_question.');
!         }
! 
!         // Give the question a unique version stamp determined by question_hash()
!         $DB->set_field('question', 'version', question_hash($question), array('id' => $question->id));
! 
!         return $question;
!     }
! 
!     /**
!     * Saves question-type specific options
!     *
!     * This is called by {@link save_question()} to save the question-type specific data
!     * @return object $result->error or $result->noticeyesno or $result->notice
!     * @param object $question  This holds the information from the editing form,
!     *                          it is not a standard question object.
!     */
!     function save_question_options($question) {
!         global $DB;
!         $extra_question_fields = $this->extra_question_fields();
! 
!         if (is_array($extra_question_fields)) {
!             $question_extension_table = array_shift($extra_question_fields);
! 
!             $function = 'update_record';
!             $questionidcolname = $this->questionid_column_name();
!             $options = $DB->get_record($question_extension_table, array($questionidcolname => $question->id));
!             if (!$options) {
!                 $function = 'insert_record';
!                 $options = new stdClass;
!                 $options->$questionidcolname = $question->id;
!             }
!             foreach ($extra_question_fields as $field) {
!                 if (!isset($question->$field)) {
!                     $result = new stdClass;
!                     $result->error = "No data for field $field when saving " .
!                             $this->name() . ' question id ' . $question->id;
!                     return $result;
!                 }
!                 $options->$field = $question->$field;
!             }
! 
!             if (!$DB->{$function}($question_extension_table, $options)) {
!                 $result = new stdClass;
!                 $result->error = 'Could not save question options for ' .
!                         $this->name() . ' question id ' . $question->id;
!                 return $result;
!             }
!         }
! 
!         $extra_answer_fields = $this->extra_answer_fields();
!         // TODO save the answers, with any extra data.
! 
!         return null;
!     }
! 
!     /**
!     * Loads the question type specific options for the question.
!     *
!     * This function loads any question type specific options for the
!     * question from the database into the question object. This information
!     * is placed in the $question->options field. A question type is
!     * free, however, to decide on a internal structure of the options field.
!     * @return bool            Indicates success or failure.
!     * @param object $question The question object for the question. This object
!     *                         should be updated to include the question type
!     *                         specific information (it is passed by reference).
!     */
!     function get_question_options(&$question) {
!         global $CFG, $DB, $OUTPUT;
! 
!         if (!isset($question->options)) {
!             $question->options = new stdClass();
!         }
! 
!         $extra_question_fields = $this->extra_question_fields();
!         if (is_array($extra_question_fields)) {
!             $question_extension_table = array_shift($extra_question_fields);
!             $extra_data = $DB->get_record($question_extension_table, array($this->questionid_column_name() => $question->id), implode(', ', $extra_question_fields));
!             if ($extra_data) {
!                 foreach ($extra_question_fields as $field) {
!                     $question->options->$field = $extra_data->$field;
!                 }
!             } else {
!                 echo $OUTPUT->notification("Failed to load question options from the table $question_extension_table for questionid " .
!                         $question->id);
!                 return false;
!             }
!         }
! 
!         $extra_answer_fields = $this->extra_answer_fields();
!         if (is_array($extra_answer_fields)) {
!             $answer_extension_table = array_shift($extra_answer_fields);
!             $question->options->answers = $DB->get_records_sql("
                      SELECT qa.*, qax." . implode(', qax.', $extra_answer_fields) . "
                      FROM {question_answers} qa, {$answer_extension_table} qax
                      WHERE qa.questionid = ? AND qax.answerid = qa.id", array($question->id));
!             if (!$question->options->answers) {
!                 echo $OUTPUT->notification("Failed to load question answers from the table $answer_extension_table for questionid " .
!                         $question->id);
!                 return false;
!             }
!         } else {
!             // Don't check for success or failure because some question types do not use the answers table.
!             $question->options->answers = $DB->get_records('question_answers', array('question' => $question->id), 'id ASC');
!         }
! 
!         return true;
!     }
! 
!     /**
!     * Deletes states from the question-type specific tables
!     *
!     * @param string $stateslist  Comma separated list of state ids to be deleted
!     */
!     function delete_states($stateslist) {
!         /// The default question type does not have any tables of its own
!         // therefore there is nothing to delete
! 
!         return true;
!     }
! 
!     /**
!      * Deletes the question-type specific data when a question is deleted.
!      * @param integer $question the question being deleted.
!      * @param integer $contextid the context this quesiotn belongs to.
!      */
!     function delete_question($questionid, $contextid) {
!         global $DB;
! 
!         $this->delete_files($questionid, $contextid);
! 
!         $extra_question_fields = $this->extra_question_fields();
!         if (is_array($extra_question_fields)) {
!             $question_extension_table = array_shift($extra_question_fields);
!             $DB->delete_records($question_extension_table,
!                     array($this->questionid_column_name() => $questionid));
!         }
! 
!         $extra_answer_fields = $this->extra_answer_fields();
!         if (is_array($extra_answer_fields)) {
!             $answer_extension_table = array_shift($extra_answer_fields);
!             $DB->delete_records_select($answer_extension_table,
                  "answerid IN (SELECT qa.id FROM {question_answers} qa WHERE qa.question = ?)", array($questionid));
!         }
  
!         $DB->delete_records('question_answers', array('question' => $questionid));
!     }
  
!     /**
!     * Returns the number of question numbers which are used by the question
!     *
!     * This function returns the number of question numbers to be assigned
!     * to the question. Most question types will have length one; they will be
!     * assigned one number. The 'description' type, however does not use up a
!     * number and so has a length of zero. Other question types may wish to
!     * handle a bundle of questions and hence return a number greater than one.
!     * @return integer         The number of question numbers which should be
!     *                         assigned to the question.
!     * @param object $question The question whose length is to be determined.
!     *                         Question type specific information is included.
!     */
!     function actual_number_of_questions($question) {
!         // By default, each question is given one number
!         return 1;
!     }
! 
!     /**
!     * Creates empty session and response information for the question
!     *
!     * This function is called to start a question session. Empty question type
!     * specific session data (if any) and empty response data will be added to the
!     * state object. Session data is any data which must persist throughout the
!     * attempt possibly with updates as the user interacts with the
!     * question. This function does NOT create new entries in the database for
!     * the session; a call to the {@link save_session_and_responses} member will
!     * occur to do this.
!     * @return bool            Indicates success or failure.
!     * @param object $question The question for which the session is to be
!     *                         created. Question type specific information is
!     *                         included.
!     * @param object $state    The state to create the session for. Note that
!     *                         this will not have been saved in the database so
!     *                         there will be no id. This object will be updated
!     *                         to include the question type specific information
!     *                         (it is passed by reference). In particular, empty
!     *                         responses will be created in the ->responses
!     *                         field.
!     * @param object $cmoptions
!     * @param object $attempt  The attempt for which the session is to be
!     *                         started. Questions may wish to initialize the
!     *                         session in different ways depending on the user id
!     *                         or time available for the attempt.
!     */
!     function create_session_and_responses(&$question, &$state, $cmoptions, $attempt) {
!         // The default implementation should work for the legacy question types.
!         // Most question types with only a single form field for the student's response
!         // will use the empty string '' as the index for that one response. This will
!         // automatically be stored in and restored from the answer field in the
!         // question_states table.
!         $state->responses = array(
                  '' => '',
!         );
!         return true;
!     }
! 
!     /**
!     * Restores the session data and most recent responses for the given state
!     *
!     * This function loads any session data associated with the question
!     * session in the given state from the database into the state object.
!     * In particular it loads the responses that have been saved for the given
!     * state into the ->responses member of the state object.
!     *
!     * Question types with only a single form field for the student's response
!     * will not need not restore the responses; the value of the answer
!     * field in the question_states table is restored to ->responses['']
!     * before this function is called. Question types with more response fields
!     * should override this method and set the ->responses field to an
!     * associative array of responses.
!     * @return bool            Indicates success or failure.
!     * @param object $question The question object for the question including any
!     *                         question type specific information.
!     * @param object $state    The saved state to load the session for. This
!     *                         object should be updated to include the question
!     *                         type specific session information and responses
!     *                         (it is passed by reference).
!     */
!     function restore_session_and_responses(&$question, &$state) {
!         // The default implementation does nothing (successfully)
!         return true;
!     }
! 
!     /**
!     * Saves the session data and responses for the given question and state
!     *
!     * This function saves the question type specific session data from the
!     * state object to the database. In particular for most question types it saves the
!     * responses from the ->responses member of the state object. The question type
!     * non-specific data for the state has already been saved in the question_states
!     * table and the state object contains the corresponding id and
!     * sequence number which may be used to index a question type specific table.
!     *
!     * Question types with only a single form field for the student's response
!     * which is contained in ->responses[''] will not have to save this response,
!     * it will already have been saved to the answer field of the question_states table.
!     * Question types with more response fields should override this method to convert
!     * the data the ->responses array into a single string field, and save it in the
!     * database. The implementation in the multichoice question type is a good model to follow.
!     * http://cvs.moodle.org/contrib/plugins/question/type/opaque/questiontype.php?view=markup
!     * has a solution that is probably quite generally applicable.
!     * @return bool            Indicates success or failure.
!     * @param object $question The question object for the question including
!     *                         the question type specific information.
!     * @param object $state    The state for which the question type specific
!     *                         data and responses should be saved.
!     */
!     function save_session_and_responses(&$question, &$state) {
!         // The default implementation does nothing (successfully)
!         return true;
!     }
! 
!     /**
!     * Returns an array of values which will give full marks if graded as
!     * the $state->responses field
!     *
!     * The correct answer to the question in the given state, or an example of
!     * a correct answer if there are many, is returned. This is used by some question
!     * types in the {@link grade_responses()} function but it is also used by the
!     * question preview screen to fill in correct responses.
!     * @return mixed           A response array giving the responses corresponding
!     *                         to the (or a) correct answer to the question. If there is
!     *                         no correct answer that scores 100% then null is returned.
!     * @param object $question The question for which the correct answer is to
!     *                         be retrieved. Question type specific information is
!     *                         available.
!     * @param object $state    The state of the question, for which a correct answer is
!     *                         needed. Question type specific information is included.
!     */
!     function get_correct_responses(&$question, &$state) {
!         /* The default implementation returns the response for the first answer
!         that gives full marks. */
!         if ($question->options->answers) {
!             foreach ($question->options->answers as $answer) {
!                 if (((int) $answer->fraction) === 1) {
!                     return array('' => $answer->answer);
!                 }
!             }
!         }
!         return null;
!     }
! 
!     /**
!     * Return an array of values with the texts for all possible responses stored
!     * for the question
!     *
!     * All answers are found and their text values isolated
!     * @return object          A mixed object
!     *             ->id        question id. Needed to manage random questions:
!     *                         it's the id of the actual question presented to user in a given attempt
!     *             ->responses An array of values giving the responses corresponding
!     *                         to all answers to the question. Answer ids are used as keys.
!     *                         The text and partial credit are the object components
!     * @param object $question The question for which the answers are to
!     *                         be retrieved. Question type specific information is
!     *                         available.
!     */
!     // ULPGC ecastro
!     function get_all_responses(&$question, &$state) {
!         if (isset($question->options->answers) && is_array($question->options->answers)) {
!             $answers = array();
!             foreach ($question->options->answers as $aid=>$answer) {
!                 $r = new stdClass;
!                 $r->answer = $answer->answer;
!                 $r->credit = $answer->fraction;
!                 $answers[$aid] = $r;
!             }
!             $result = new stdClass;
!             $result->id = $question->id;
!             $result->responses = $answers;
!             return $result;
!         } else {
!             return null;
!         }
!     }
!     /**
!      * The difference between this method an get_all_responses is that this
!      * method is not passed a state object. It is the possible answers to a
!      * question no matter what the state.
!      * This method is not called for random questions.
!      * @return array of possible answers.
!      */
!     function get_possible_responses(&$question) {
!         static $responses = array();
!         if (!isset($responses[$question->id])){
!             $responses[$question->id] = $this->get_all_responses($question, new object());
!         }
!         return array($question->id => $responses[$question->id]->responses);
!     }
! 
!     /**
!      * @param object $question
!      * @return mixed either a integer score out of 1 that the average random
!      * guess by a student might give or an empty string which means will not
!      * calculate.
!      */
!     function get_random_guess_score($question) {
!         return 0;
!     }
!    /**
!     * Return the actual response to the question in a given state
!     * for the question. Text is not yet formatted for output.
!     *
!     * @return mixed           An array containing the response or reponses (multiple answer, match)
!     *                         given by the user in a particular attempt.
!     * @param object $question The question for which the correct answer is to
!     *                         be retrieved. Question type specific information is
!     *                         available.
!     * @param object $state    The state object that corresponds to the question,
!     *                         for which a correct answer is needed. Question
!     *                         type specific information is included.
!     */
!     // ULPGC ecastro
!     function get_actual_response($question, $state) {
!        if (!empty($state->responses)) {
!            $responses[] = $state->responses[''];
!        } else {
!            $responses[] = '';
!        }
!        return $responses;
!     }
! 
!     function get_actual_response_details($question, $state) {
!         $response = array_shift($this->get_actual_response($question, $state));
!         $teacherresponses = $this->get_possible_responses($question, $state);
!         //only one response
!         list($tsubqid, $tresponses) = each($teacherresponses);
!         $responsedetail = new stdClass();
!         $responsedetail->subqid = $tsubqid;
!         $responsedetail->response = $response;
!         if ($aid = $this->check_response($question, $state)){
!             $responsedetail->aid = $aid;
!         } else {
!             foreach ($tresponses as $aid => $tresponse){
!                 if ($tresponse->answer == $response){
!                     $responsedetail->aid = $aid;
!                     break;
!                 }
!             }
!         }
!         if (isset($responsedetail->aid)){
!             $responsedetail->credit = $tresponses[$aid]->credit;
!         } else {
!             $responsedetail->aid = 0;
!             $responsedetail->credit = 0;
!         }
!         return array($responsedetail);
!     }
! 
!     // ULPGC ecastro
!     function get_fractional_grade(&$question, &$state) {
!         $grade = $state->grade;
!         if ($question->maxgrade > 0) {
!             return (float)($grade / $question->maxgrade);
!         } else {
!             return (float)$grade;
!         }
!     }
! 
! 
!     /**
!     * Checks if the response given is correct and returns the id
!     *
!     * @return int             The ide number for the stored answer that matches the response
!     *                         given by the user in a particular attempt.
!     * @param object $question The question for which the correct answer is to
!     *                         be retrieved. Question type specific information is
!     *                         available.
!     * @param object $state    The state object that corresponds to the question,
!     *                         for which a correct answer is needed. Question
!     *                         type specific information is included.
!     */
!     // ULPGC ecastro
!     function check_response(&$question, &$state){
!         return false;
!     }
! 
!     // Used by the following function, so that it only returns results once per quiz page.
!     private $htmlheadalreadydone = false;
!     /**
!      * Hook to allow question types to include required JavaScrip or CSS on pages
!      * where they are going to be printed.
!      *
!      * If this question type requires JavaScript to function,
!      * then this method, which will be called before print_header on any page
!      * where this question is going to be printed, is a chance to call
!      * $PAGE->requires->js, and so on.
!      *
!      * The two parameters match the first two parameters of print_question.
!      *
!      * @param object $question The question object.
!      * @param object $state    The state object.
!      */
!     function get_html_head_contributions(&$question, &$state) {
!         // We only do this once for this question type, no matter how often this
!         // method is called on one page.
!         if ($this->htmlheadalreadydone) {
!             return;
!         }
!         $this->htmlheadalreadydone = true;
! 
!         // By default, we link to any of the files script.js or script.php that
!         // exist in the plugin folder.
!         $this->find_standard_scripts();
!     }
! 
!     /**
!      * Like @see{get_html_head_contributions}, but this method is for CSS and
!      * JavaScript required on the question editing page question/question.php.
!      */
!     function get_editing_head_contributions() {
!         // By default, we link to any of the files styles.css, styles.php,
!         // script.js or script.php that exist in the plugin folder.
!         // Core question types should not use this mechanism. Their styles
!         // should be included in the standard theme.
!         $this->find_standard_scripts();
!     }
! 
!     /**
!      * Utility method used by @see{get_html_head_contributions} and
!      * @see{get_editing_head_contributions}. This looks for any of the files
!      * script.js or script.php that exist in the plugin folder and ensures they
!      * get included.
!      */
!     protected function find_standard_scripts() {
!         global $PAGE;
! 
!         $plugindir = $this->plugin_dir();
!         $plugindirrel = 'question/type/' . $this->name();
! 
!         if (file_exists($plugindir . '/script.js')) {
!             $PAGE->requires->js('/' . $plugindirrel . '/script.js');
!         }
!         if (file_exists($plugindir . '/script.php')) {
!             $PAGE->requires->js('/' . $plugindirrel . '/script.php');
!         }
!     }
! 
!     /**
!      * Prints the question including the number, grading details, content,
!      * feedback and interactions
!      *
!      * This function prints the question including the question number,
!      * grading details, content for the question, any feedback for the previously
!      * submitted responses and the interactions. The default implementation calls
!      * various other methods to print each of these parts and most question types
!      * will just override those methods.
!      * @param object $question The question to be rendered. Question type
!      *                         specific information is included. The
!      *                         maximum possible grade is in ->maxgrade. The name
!      *                         prefix for any named elements is in ->name_prefix.
!      * @param object $state    The state to render the question in. The grading
!      *                         information is in ->grade, ->raw_grade and
!      *                         ->penalty. The current responses are in
!      *                         ->responses. This is an associative array (or the
!      *                         empty string or null in the case of no responses
!      *                         submitted). The last graded state is in
!      *                         ->last_graded (hence the most recently graded
!      *                         responses are in ->last_graded->responses). The
!      *                         question type specific information is also
!      *                         included.
!      * @param integer $number  The number for this question.
!      * @param object $cmoptions
!      * @param object $options  An object describing the rendering options.
!      */
!     function print_question(&$question, &$state, $number, $cmoptions, $options, $context=null) {
!         /* The default implementation should work for most question types
!         provided the member functions it calls are overridden where required.
!         The layout is determined by the template question.html */
! 
!         global $CFG, $OUTPUT;
! 
!         $context = $this->get_context_by_category_id($question->category);
!         $question->questiontext = quiz_rewrite_question_urls($question->questiontext, 'pluginfile.php', $context->id, 'question', 'questiontext', array($state->attempt, $state->question), $question->id);
! 
!         $question->generalfeedback = quiz_rewrite_question_urls($question->generalfeedback, 'pluginfile.php', $context->id, 'question', 'generalfeedback', array($state->attempt, $state->question), $question->id);
! 
!         $isgraded = question_state_is_graded($state->last_graded);
! 
!         if (isset($question->randomquestionid)) {
!             $actualquestionid = $question->randomquestionid;
!         } else {
!             $actualquestionid = $question->id;
!         }
! 
!         // For editing teachers print a link to an editing popup window
!         $editlink = $this->get_question_edit_link($question, $cmoptions, $options);
! 
!         $generalfeedback = '';
!         if ($isgraded && $options->generalfeedback) {
!             $generalfeedback = $this->format_text($question->generalfeedback,
!                     $question->generalfeedbackformat, $cmoptions);
!         }
! 
!         $grade = '';
!         if ($question->maxgrade > 0 && $options->scores) {
!             if ($cmoptions->optionflags & QUESTION_ADAPTIVE) {
!                 if ($isgraded) {
!                     $grade = question_format_grade($cmoptions, $state->last_graded->grade).'/';
!                 } else {
!                     $grade = '--/';
!                 }
!             }
!             $grade .= question_format_grade($cmoptions, $question->maxgrade);
!         }
! 
!         $formatoptions = new stdClass;
!         $formatoptions->para = false;
!         $comment = format_text($state->manualcomment, $state->manualcommentformat,
!                 $formatoptions, $cmoptions->course);
!         $commentlink = '';
! 
!         if (!empty($options->questioncommentlink)) {
!             $strcomment = get_string('commentorgrade', 'quiz');
! 
!             $link = new moodle_url($options->questioncommentlink, array('question' => $actualquestionid));
!             $action = new popup_action('click', $link, 'commentquestion', array('height' => 480, 'width' => 750));
!             $commentlink = $OUTPUT->container($OUTPUT->action_link($link, $strcomment, $action), 'commentlink');
!         }
! 
!         $history = $this->history($question, $state, $number, $cmoptions, $options);
! 
!         include "$CFG->dirroot/question/type/question.html";
!     }
! 
!     /**
!      * Render the question flag, assuming $flagsoption allows it. You will probably
!      * never need to override this method.
!      *
!      * @param object $question the question
!      * @param object $state its current state
!      * @param integer $flagsoption the option that says whether flags should be displayed.
!      */
!     protected function print_question_flag($question, $state, $flagsoption) {
!         global $CFG, $PAGE;
!         switch ($flagsoption) {
!             case QUESTION_FLAGSSHOWN:
!                 $flagcontent = $this->get_question_flag_tag($state->flagged);
!                 break;
!             case QUESTION_FLAGSEDITABLE:
!                 $id = $question->name_prefix . '_flagged';
!                 if ($state->flagged) {
!                     $checked = 'checked="checked" ';
!                 } else {
!                     $checked = '';
!                 }
!                 $qsid = $state->questionsessionid;
!                 $aid = $state->attempt;
!                 $qid = $state->question;
!                 $checksum = question_get_toggleflag_checksum($aid, $qid, $qsid);
!                 $postdata = "qsid=$qsid&aid=$aid&qid=$qid&checksum=$checksum&sesskey=" .
!                         sesskey() . '&newstate=';
!                 $flagcontent = '<input type="checkbox" id="' . $id . '" name="' . $id .
                          '" class="questionflagcheckbox" value="1" ' . $checked . ' />' .
                          '<input type="hidden" value="' . s($postdata) . '" class="questionflagpostdata" />' .
                          '<label id="' . $id . 'label" for="' . $id .
                          '" class="questionflaglabel">' . $this->get_question_flag_tag(
!                         $state->flagged, $id . 'img') . '</label>' . "\n";
!                 question_init_qengine_js();
!                 break;
!             default:
!                 $flagcontent = '';
!         }
!         if ($flagcontent) {
!             echo '<div class="questionflag">' . $flagcontent . "</div>\n";
!         }
!     }
! 
!     /**
!      * Work out the actual img tag needed for the flag
!      *
!      * @param boolean $flagged whether the question is currently flagged.
!      * @param string $id an id to be added as an attribute to the img (optional).
!      * @return string the img tag.
!      */
!     protected function get_question_flag_tag($flagged, $id = '') {
!         global $OUTPUT;
!         if ($id) {
!             $id = 'id="' . $id . '" ';
!         }
!         if ($flagged) {
!             $img = 'i/flagged';
!         } else {
!             $img = 'i/unflagged';
!         }
!         return '<img ' . $id . 'src="' . $OUTPUT->pix_url($img) .
                  '" alt="' . get_string('flagthisquestion', 'question') . '" />';
!     }
  
!     /**
!      * Get a link to an edit icon for this question, if the current user is allowed
!      * to edit it.
!      *
!      * @param object $question the question object.
!      * @param object $cmoptions the options from the module. If $cmoptions->thispageurl is set
!      *      then the link will be to edit the question in this browser window, then return to
!      *      $cmoptions->thispageurl. Otherwise the link will be to edit in a popup.
!      * @return string the HTML of the link, or nothing it the currenty user is not allowed to edit.
!      */
!     function get_question_edit_link($question, $cmoptions, $options) {
!         global $CFG, $OUTPUT;
! 
!     /// Is this user allowed to edit this question?
!         if (!empty($options->noeditlink) || !question_has_capability_on($question, 'edit')) {
!             return '';
!         }
! 
!     /// Work out the right URL.
!         $url = new moodle_url('/question/question.php', array('id' => $question->id));
!         if (!empty($cmoptions->cmid)) {
!             $url->param('cmid', $cmoptions->cmid);
!         } else if (!empty($cmoptions->course)) {
!             $url->param('courseid', $cmoptions->course);
!         } else {
!             print_error('missingcourseorcmidtolink', 'question');
!         }
! 
!         $icon = new pix_icon('t/edit', get_string('edit'));
! 
!         $action = null;
!         if (!empty($cmoptions->thispageurl)) {
!             // The module allow editing in the same window, print an ordinary
!             // link with a returnurl.
!             $url->param('returnurl', $cmoptions->thispageurl);
!         } else {
!             // We have to edit in a pop-up.
!             $url->param('inpopup', 1);
!             $action = new popup_action('click', $link, 'editquestion');
!         }
! 
!         return $OUTPUT->action_icon($url, $icon, $action);
!     }
! 
!     /**
!      * Print history of responses
!      *
!      * Used by print_question()
!      */
!     function history($question, $state, $number, $cmoptions, $options) {
!         global $DB, $OUTPUT;
! 
!         if (empty($options->history)) {
!             return '';
!         }
! 
!         if (isset($question->randomquestionid)) {
!             $actualquestionid = $question->randomquestionid;
!             $randomprefix = 'random' . $question->id . '-';
!         } else {
!             $actualquestionid = $question->id;
!             $randomprefix = '';
!         }
!         if ($options->history == 'all') {
!             $eventtest = 'event > 0';
!         } else {
!             $eventtest = 'event IN (' . QUESTION_EVENTS_GRADED . ')';
!         }
!         $states = $DB->get_records_select('question_states',
                  'attempt = :aid AND question = :qid AND ' . $eventtest,
!                 array('aid' => $state->attempt, 'qid' => $actualquestionid), 'seq_number,id');
!         if (count($states) <= 1) {
!             return '';
!         }
! 
!         $strreviewquestion = get_string('reviewresponse', 'quiz');
!         $table = new html_table();
!         $table->width = '100%';
!         $table->head  = array (
!             get_string('numberabbr', 'quiz'),
!             get_string('action', 'quiz'),
!             get_string('response', 'quiz'),
!             get_string('time'),
!         );
!         if ($options->scores) {
!             $table->head[] = get_string('score', 'quiz');
!             $table->head[] = get_string('grade', 'quiz');
!         }
! 
!         foreach ($states as $st) {
!             if ($randomprefix && strpos($st->answer, $randomprefix) === 0) {
!                 $st->answer = substr($st->answer, strlen($randomprefix));
!             }
!             $st->responses[''] = $st->answer;
!             $this->restore_session_and_responses($question, $st);
! 
!             if ($state->id == $st->id) {
!                 $link = '<b>' . $st->seq_number . '</b>';
!             } else if (isset($options->questionreviewlink)) {
!                 $reviewlink = new moodle_url($options->questionreviewlink);
!                 $reviewlink->params(array('state' => $st->id,'question' => $actualquestionid));
!                 $link = new moodle_url($reviewlink);
!                 $action = new popup_action('click', $link, 'reviewquestion', array('height' => 450, 'width' => 650));
!                 $link = $OUTPUT->action_link($link, $st->seq_number, $action, array('title'=>$strreviewquestion));
!             } else {
!                 $link = $st->seq_number;
!             }
! 
!             if ($state->id == $st->id) {
!                 $b = '<b>';
!                 $be = '</b>';
!             } else {
!                 $b = '';
!                 $be = '';
!             }
! 
!             $data = array (
!                 $link,
!                 $b.get_string('event'.$st->event, 'quiz').$be,
!                 $b.$this->response_summary($question, $st).$be,
!                 $b.userdate($st->timestamp, get_string('timestr', 'quiz')).$be,
!             );
!             if ($options->scores) {
!                 $data[] = $b.question_format_grade($cmoptions, $st->raw_grade).$be;
!                 $data[] = $b.question_format_grade($cmoptions, $st->raw_grade).$be;
!             }
!             $table->data[] = $data;
!         }
!         return html_writer::table($table);
!     }
! 
!     /**
!     * Prints the score obtained and maximum score available plus any penalty
!     * information
!     *
!     * This function prints a summary of the scoring in the most recently
!     * graded state (the question may not have been submitted for marking at
!     * the current state). The default implementation should be suitable for most
!     * question types.
!     * @param object $question The question for which the grading details are
!     *                         to be rendered. Question type specific information
!     *                         is included. The maximum possible grade is in
!     *                         ->maxgrade.
!     * @param object $state    The state. In particular the grading information
!     *                          is in ->grade, ->raw_grade and ->penalty.
!     * @param object $cmoptions
!     * @param object $options  An object describing the rendering options.
!     */
!     function print_question_grading_details(&$question, &$state, $cmoptions, $options) {
!         /* The default implementation prints the number of marks if no attempt
!         has been made. Otherwise it displays the grade obtained out of the
!         maximum grade available and a warning if a penalty was applied for the
!         attempt and displays the overall grade obtained counting all previous
!         responses (and penalties) */
! 
!         if (QUESTION_EVENTDUPLICATE == $state->event) {
!             echo ' ';
!             print_string('duplicateresponse', 'quiz');
!         }
!         if ($question->maxgrade > 0 && $options->scores) {
!             if (question_state_is_graded($state->last_graded)) {
!                 // Display the grading details from the last graded state
!                 $grade = new stdClass;
!                 $grade->cur = question_format_grade($cmoptions, $state->last_graded->grade);
!                 $grade->max = question_format_grade($cmoptions, $question->maxgrade);
!                 $grade->raw = question_format_grade($cmoptions, $state->last_graded->raw_grade);
! 
!                 // let student know wether the answer was correct
!                 $class = question_get_feedback_class($state->last_graded->raw_grade /
!                         $question->maxgrade);
!                 echo '<div class="correctness ' . $class . '">' . get_string($class, 'quiz') . '</div>';
! 
!                 echo '<div class="gradingdetails">';
!                 // print grade for this submission
!                 print_string('gradingdetails', 'quiz', $grade);
!                 if ($cmoptions->penaltyscheme) {
!                     // print details of grade adjustment due to penalties
!                     if ($state->last_graded->raw_grade > $state->last_graded->grade){
!                         echo ' ';
!                         print_string('gradingdetailsadjustment', 'quiz', $grade);
!                     }
!                     // print info about new penalty
!                     // penalty is relevant only if the answer is not correct and further attempts are possible
!                     if (($state->last_graded->raw_grade < $question->maxgrade / 1.01)
!                                 and (QUESTION_EVENTCLOSEANDGRADE != $state->event)) {
! 
!                         if ('' !== $state->last_graded->penalty && ((float)$state->last_graded->penalty) > 0.0) {
!                             // A penalty was applied so display it
!                             echo ' ';
!                             print_string('gradingdetailspenalty', 'quiz', question_format_grade($cmoptions, $state->last_graded->penalty));
!                         } else {
!                             /* No penalty was applied even though the answer was
!                             not correct (eg. a syntax error) so tell the student
!                             that they were not penalised for the attempt */
!                             echo ' ';
!                             print_string('gradingdetailszeropenalty', 'quiz');
!                         }
!                     }
!                 }
!                 echo '</div>';
!             }
!         }
!     }
! 
!     /**
!     * Prints the main content of the question including any interactions
!     *
!     * This function prints the main content of the question including the
!     * interactions for the question in the state given. The last graded responses
!     * are printed or indicated and the current responses are selected or filled in.
!     * Any names (eg. for any form elements) are prefixed with $question->name_prefix.
!     * This method is called from the print_question method.
!     * @param object $question The question to be rendered. Question type
!     *                         specific information is included. The name
!     *                         prefix for any named elements is in ->name_prefix.
!     * @param object $state    The state to render the question in. The grading
!     *                         information is in ->grade, ->raw_grade and
!     *                         ->penalty. The current responses are in
!     *                         ->responses. This is an associative array (or the
!     *                         empty string or null in the case of no responses
!     *                         submitted). The last graded state is in
!     *                         ->last_graded (hence the most recently graded
!     *                         responses are in ->last_graded->responses). The
!     *                         question type specific information is also
!     *                         included.
!     *                         The state is passed by reference because some adaptive
!     *                         questions may want to update it during rendering
!     * @param object $cmoptions
!     * @param object $options  An object describing the rendering options.
!     */
!     function print_question_formulation_and_controls(&$question, &$state, $cmoptions, $options) {
!         /* This default implementation prints an error and must be overridden
!         by all question type implementations, unless the default implementation
!         of print_question has been overridden. */
!         global $OUTPUT;
!         echo $OUTPUT->notification('Error: Question formulation and input controls has not'
!                .'  been implemented for question type '.$this->name());
!     }
! 
!     function check_file_access($question, $state, $options, $contextid, $component,
!             $filearea, $args) {
! 
!         if ($component == 'question' && $filearea == 'questiontext') {
!             // Question text always visible.
!             return true;
! 
!         } else if ($component == 'question' && $filearea = 'generalfeedback') {
!             return $options->generalfeedback && question_state_is_graded($state->last_graded);
! 
!         } else {
!             // Unrecognised component or filearea.
!             return false;
!         }
!     }
! 
!     /**
!     * Prints the submit button(s) for the question in the given state
!     *
!     * This function prints the submit button(s) for the question in the
!     * given state. The name of any button created will be prefixed with the
!     * unique prefix for the question in $question->name_prefix. The suffix
!     * 'submit' is reserved for the single question submit button and the suffix
!     * 'validate' is reserved for the single question validate button (for
!     * question types which support it). Other suffixes will result in a response
!     * of that name in $state->responses which the printing and grading methods
!     * can then use.
!     * @param object $question The question for which the submit button(s) are to
!     *                         be rendered. Question type specific information is
!     *                         included. The name prefix for any
!     *                         named elements is in ->name_prefix.
!     * @param object $state    The state to render the buttons for. The
!     *                         question type specific information is also
!     *                         included.
!     * @param object $cmoptions
!     * @param object $options  An object describing the rendering options.
!     */
!     function print_question_submit_buttons(&$question, &$state, $cmoptions, $options) {
!         // The default implementation should be suitable for most question types.
!         // It prints a mark button in the case where individual marking is allowed.
!         if (($cmoptions->optionflags & QUESTION_ADAPTIVE) and !$options->readonly) {
!             echo '<input type="submit" name="', $question->name_prefix, 'submit" value="',
!                     get_string('mark', 'quiz'), '" class="submit btn" />';
!         }
!     }
! 
!     /**
!     * Return a summary of the student response
!     *
!     * This function returns a short string of no more than a given length that
!     * summarizes the student's response in the given $state. This is used for
!     * example in the response history table. This string should already be
!     * formatted for output.
!     * @return string         The summary of the student response
!     * @param object $question
!     * @param object $state   The state whose responses are to be summarized
!     * @param int $length     The maximum length of the returned string
!     */
!     function response_summary($question, $state, $length = 80, $formatting = true) {
!         // This should almost certainly be overridden
!         $responses = $this->get_actual_response($question, $state);
!         if ($formatting){
!             $responses = $this->format_responses($responses, $question->questiontextformat);
!         }
!         $responses = implode('; ', $responses);
!         return shorten_text($responses, $length);
!     }
!     /**
!      * @param array responses is an array of responses.
!      * @return formatted responses
!      */
!     function format_responses($responses, $format){
!         $toreturn = array();
!         foreach ($responses as $response){
!             $toreturn[] = $this->format_response($response, $format);
!         }
!         return $toreturn;
!     }
! 
!     /**
!      * @param string response is a response.
!      * @return formatted response
!      */
!     function format_response($response, $format) {
!         return s(html_to_text($this->format_text($response, $format), 0, false));
!     }
! 
!     /**
!     * Renders the question for printing and returns the LaTeX source produced
!     *
!     * This function should render the question suitable for a printed problem
!     * or solution sheet in LaTeX and return the rendered output.
!     * @return string          The LaTeX output.
!     * @param object $question The question to be rendered. Question type
!     *                         specific information is included.
!     * @param object $state    The state to render the question in. The
!     *                         question type specific information is also
!     *                         included.
!     * @param object $cmoptions
!     * @param string $type     Indicates if the question or the solution is to be
!     *                         rendered with the values 'question' and
!     *                         'solution'.
!     */
!     function get_texsource(&$question, &$state, $cmoptions, $type) {
!         // The default implementation simply returns a string stating that
!         // the question is only available online.
! 
!         return get_string('onlineonly', 'texsheet');
!     }
! 
!     /**
!     * Compares two question states for equivalence of the student's responses
!     *
!     * The responses for the two states must be examined to see if they represent
!     * equivalent answers to the question by the student. This method will be
!     * invoked for each of the previous states of the question before grading
!     * occurs. If the student is found to have already attempted the question
!     * with equivalent responses then the attempt at the question is ignored;
!     * grading does not occur and the state does not change. Thus they are not
!     * penalized for this case.
!     * @return boolean
!     * @param object $question  The question for which the states are to be
!     *                          compared. Question type specific information is
!     *                          included.
!     * @param object $state     The state of the question. The responses are in
!     *                          ->responses. This is the only field of $state
!     *                          that it is safe to use.
!     * @param object $teststate The state whose responses are to be
!     *                          compared. The state will be of the same age or
!     *                          older than $state. If possible, the method should
!     *                          only use the field $teststate->responses, however
!     *                          any field that is set up by restore_session_and_responses
!     *                          can be used.
!     */
!     function compare_responses(&$question, $state, $teststate) {
!         // The default implementation performs a comparison of the response
!         // arrays. The ordering of the arrays does not matter.
!         // Question types may wish to override this (eg. to ignore trailing
!         // white space or to make "7.0" and "7" compare equal).
! 
!         // In php neither == nor === compare arrays the way you want. The following
!         // ensures that the arrays have the same keys, with the same values.
!         $result = false;
!         $diff1 = array_diff_assoc($state->responses, $teststate->responses);
!         if (empty($diff1)) {
!             $diff2 = array_diff_assoc($teststate->responses, $state->responses);
!             $result =  empty($diff2);
!         }
! 
!         return $result;
!     }
! 
!     /**
!     * Checks whether a response matches a given answer
!     *
!     * This method only applies to questions that use teacher-defined answers
!     *
!     * @return boolean
!     */
!     function test_response(&$question, &$state, $answer) {
!         $response = isset($state->responses['']) ? $state->responses[''] : '';
!         return ($response == $answer->answer);
!     }
! 
!     /**
!     * Performs response processing and grading
!     *
!     * This function performs response processing and grading and updates
!     * the state accordingly.
!     * @return boolean         Indicates success or failure.
!     * @param object $question The question to be graded. Question type
!     *                         specific information is included.
!     * @param object $state    The state of the question to grade. The current
!     *                         responses are in ->responses. The last graded state
!     *                         is in ->last_graded (hence the most recently graded
!     *                         responses are in ->last_graded->responses). The
!     *                         question type specific information is also
!     *                         included. The ->raw_grade and ->penalty fields
!     *                         must be updated. The method is able to
!     *                         close the question session (preventing any further
!     *                         attempts at this question) by setting
!     *                         $state->event to QUESTION_EVENTCLOSEANDGRADE
!     * @param object $cmoptions
!     */
!     function grade_responses(&$question, &$state, $cmoptions) {
!         // The default implementation uses the test_response method to
!         // compare what the student entered against each of the possible
!         // answers stored in the question, and uses the grade from the
!         // first one that matches. It also sets the marks and penalty.
!         // This should be good enought for most simple question types.
! 
!         $state->raw_grade = 0;
!         foreach($question->options->answers as $answer) {
!             if($this->test_response($question, $state, $answer)) {
!                 $state->raw_grade = $answer->fraction;
!                 break;
!             }
!         }
! 
!         // Make sure we don't assign negative or too high marks.
!         $state->raw_grade = min(max((float) $state->raw_grade,
!                             0.0), 1.0) * $question->maxgrade;
! 
!         // Update the penalty.
!         $state->penalty = $question->penalty * $question->maxgrade;
! 
!         // mark the state as graded
!         $state->event = ($state->event ==  QUESTION_EVENTCLOSE) ? QUESTION_EVENTCLOSEANDGRADE : QUESTION_EVENTGRADE;
! 
!         return true;
!     }
! 
!     /**
!     * Returns true if the editing wizard is finished, false otherwise.
!     *
!     * The default implementation returns true, which is suitable for all question-
!     * types that only use one editing form. This function is used in
!     * question.php to decide whether we can regrade any states of the edited
!     * question and redirect to edit.php.
!     *
!     * The dataset dependent question-type, which is extended by the calculated
!     * question-type, overwrites this method because it uses multiple pages (i.e.
!     * a wizard) to set up the question and associated datasets.
!     *
!     * @param object $form  The data submitted by the previous page.
!     *
!     * @return boolean      Whether the wizard's last page was submitted or not.
!     */
!     function finished_edit_wizard(&$form) {
!         //In the default case there is only one edit page.
!         return true;
!     }
! 
!     /**
!      * Call format_text from weblib.php with the options appropriate to question types.
!      *
!      * @param string $text the text to format.
!      * @param integer $text the type of text. Normally $question->questiontextformat.
!      * @param object $cmoptions the context the string is being displayed in. Only $cmoptions->course is used.
!      * @return string the formatted text.
!      */
!     function format_text($text, $textformat, $cmoptions = NULL) {
!         $formatoptions = new stdClass;
!         $formatoptions->noclean = true;
!         $formatoptions->para = false;
!         return format_text($text, $textformat, $formatoptions, $cmoptions === NULL ? NULL : $cmoptions->course);
!     }
! 
!     /**
!      * @return the best link to pass to print_error.
!      * @param $cmoptions as passed in from outside.
!      */
!     function error_link($cmoptions) {
!         global $CFG;
!         $cm = get_coursemodule_from_instance('quiz', $cmoptions->id);
!         if (!empty($cm->id)) {
!             return $CFG->wwwroot . '/mod/quiz/view.php?id=' . $cm->id;
!         } else if (!empty($cm->course)) {
!             return $CFG->wwwroot . '/course/view.php?id=' . $cm->course;
!         } else {
!             return '';
!         }
!     }
! 
! /// IMPORT/EXPORT FUNCTIONS /////////////////
! 
!     /*
!      * Imports question from the Moodle XML format
!      *
!      * Imports question using information from extra_question_fields function
!      * If some of you fields contains id's you'll need to reimplement this
!      */
!     function import_from_xml($data, $question, $format, $extra=null) {
!         $question_type = $data['@']['type'];
!         if ($question_type != $this->name()) {
!             return false;
!         }
! 
!         $extraquestionfields = $this->extra_question_fields();
!         if (!is_array($extraquestionfields)) {
!             return false;
!         }
! 
!         //omit table name
!         array_shift($extraquestionfields);
!         $qo = $format->import_headers($data);
!         $qo->qtype = $question_type;
! 
!         foreach ($extraquestionfields as $field) {
!             $qo->$field = $format->getpath($data, array('#',$field,0,'#'), $qo->$field);
!         }
! 
!         // run through the answers
!         $answers = $data['#']['answer'];
!         $a_count = 0;
!         $extraasnwersfields = $this->extra_answer_fields();
!         if (is_array($extraasnwersfields)) {
!             //TODO import the answers, with any extra data.
!         } else {
!             foreach ($answers as $answer) {
!                 $ans = $format->import_answer($answer);
!                 $qo->answer[$a_count] = $ans->answer;
!                 $qo->fraction[$a_count] = $ans->fraction;
!                 $qo->feedback[$a_count] = $ans->feedback;
!                 ++$a_count;
!             }
!         }
!         return $qo;
!     }
! 
!     /*
!      * Export question to the Moodle XML format
!      *
!      * Export question using information from extra_question_fields function
!      * If some of you fields contains id's you'll need to reimplement this
!      */
!     function export_to_xml($question, $format, $extra=null) {
!         $extraquestionfields = $this->extra_question_fields();
!         if (!is_array($extraquestionfields)) {
!             return false;
!         }
! 
!         //omit table name
!         array_shift($extraquestionfields);
!         $expout='';
!         foreach ($extraquestionfields as $field) {
!             $exportedvalue = $question->options->$field;
!             if (!empty($exportedvalue) && htmlspecialchars($exportedvalue) != $exportedvalue) {
!                 $exportedvalue = '<![CDATA[' . $exportedvalue . ']]>';
!             }
!             $expout .= "    <$field>{$exportedvalue}</$field>\n";
!         }
! 
!         $extraasnwersfields = $this->extra_answer_fields();
!         if (is_array($extraasnwersfields)) {
!             //TODO export answers with any extra data
!         } else {
!             foreach ($question->options->answers as $answer) {
!                 $percent = 100 * $answer->fraction;
!                 $expout .= "    <answer fraction=\"$percent\">\n";
!                 $expout .= $format->writetext($answer->answer, 3, false);
!                 $expout .= "      <feedback>\n";
!                 $expout .= $format->writetext($answer->feedback, 4, false);
!                 $expout .= "      </feedback>\n";
!                 $expout .= "    </answer>\n";
!             }
!         }
!         return $expout;
!     }
! 
!     /**
!      * Abstract function implemented by each question type. It runs all the code
!      * required to set up and save a question of any type for testing purposes.
!      * Alternate DB table prefix may be used to facilitate data deletion.
!      */
!     function generate_test($name, $courseid=null) {
!         $form = new stdClass();
!         $form->name = $name;
!         $form->questiontextformat = 1;
!         $form->questiontext = 'test question, generated by script';
!         $form->defaultgrade = 1;
!         $form->penalty = 0.1;
!         $form->generalfeedback = "Well done";
! 
!         $context = get_context_instance(CONTEXT_COURSE, $courseid);
!         $newcategory = question_make_default_categories(array($context));
!         $form->category = $newcategory->id . ',1';
! 
!         $question = new stdClass();
!         $question->courseid = $courseid;
!         $question->qtype = $this->qtype;
!         return array($form, $question);
!     }
! 
!     /**
!      * Get question context by category id
!      * @param int $category
!      * @return object $context
!      */
!     function get_context_by_category_id($category) {
!         global $DB;
!         $contextid = $DB->get_field('question_categories', 'contextid', array('id'=>$category));
!         $context = get_context_instance_by_id($contextid);
!         return $context;
!     }
! 
!     /**
!      * Save the file belonging to one text field.
!      *
!      * @param array $field the data from the form (or from import). This will
!      *      normally have come from the formslib editor element, so it will be an
!      *      array with keys 'text', 'format' and 'itemid'. However, when we are
!      *      importing, it will be an array with keys 'text', 'format' and 'files'
!      * @param object $context the context the question is in.
!      * @param string $component indentifies the file area question.
!      * @param string $filearea indentifies the file area questiontext, generalfeedback,answerfeedback.
!      * @param integer $itemid identifies the file area.
!      *
!      * @return string the text for this field, after files have been processed.
!      */
!     protected function import_or_save_files($field, $context, $component, $filearea, $itemid) {
!         if (!empty($field['itemid'])) {
!             // This is the normal case. We are safing the questions editing form.
!             return file_save_draft_area_files($field['itemid'], $context->id, $component,
!                     $filearea, $itemid, $this->fileoptions, trim($field['text']));
! 
!         } else if (!empty($field['files'])) {
!             // This is the case when we are doing an import.
!             foreach ($field['files'] as $file) {
!                 $this->import_file($context, $component,  $filearea, $itemid, $file);
!             }
!         }
!         return trim($field['text']);
!     }
! 
!     /**
!      * Move all the files belonging to this question from one context to another.
!      * @param integer $questionid the question being moved.
!      * @param integer $oldcontextid the context it is moving from.
!      * @param integer $newcontextid the context it is moving to.
!      */
!     public function move_files($questionid, $oldcontextid, $newcontextid) {
!         $fs = get_file_storage();
!         $fs->move_area_files_to_new_context($oldcontextid,
!                 $newcontextid, 'question', 'questiontext', $questionid);
!         $fs->move_area_files_to_new_context($oldcontextid,
!                 $newcontextid, 'question', 'generalfeedback', $questionid);
!     }
! 
!     /**
!      * Move all the files belonging to this question's answers when the question
!      * is moved from one context to another.
!      * @param integer $questionid the question being moved.
!      * @param integer $oldcontextid the context it is moving from.
!      * @param integer $newcontextid the context it is moving to.
!      * @param boolean $answerstoo whether there is an 'answer' question area,
!      *      as well as an 'answerfeedback' one. Default false.
!      */
!     protected function move_files_in_answers($questionid, $oldcontextid, $newcontextid, $answerstoo = false) {
!         global $DB;
!         $fs = get_file_storage();
! 
!         $answerids = $DB->get_records_menu('question_answers',
!                 array('question' => $questionid), 'id', 'id,1');
!         foreach ($answerids as $answerid => $notused) {
!             if ($answerstoo) {
!                 $fs->move_area_files_to_new_context($oldcontextid,
!                         $newcontextid, 'question', 'answer', $answerid);
!             }
!             $fs->move_area_files_to_new_context($oldcontextid,
!                     $newcontextid, 'question', 'answerfeedback', $answerid);
!         }
!     }
! 
!     /**
!      * Delete all the files belonging to this question.
!      * @param integer $questionid the question being deleted.
!      * @param integer $contextid the context the question is in.
!      */
!     protected function delete_files($questionid, $contextid) {
!         $fs = get_file_storage();
!         $fs->delete_area_files($contextid, 'question', 'questiontext', $questionid);
!         $fs->delete_area_files($contextid, 'question', 'generalfeedback', $questionid);
!     }
! 
!     /**
!      * Delete all the files belonging to this question's answers.
!      * @param integer $questionid the question being deleted.
!      * @param integer $contextid the context the question is in.
!      * @param boolean $answerstoo whether there is an 'answer' question area,
!      *      as well as an 'answerfeedback' one. Default false.
!      */
!     protected function delete_files_in_answers($questionid, $contextid, $answerstoo = false) {
!         global $DB;
!         $fs = get_file_storage();
! 
!         $answerids = $DB->get_records_menu('question_answers',
!                 array('question' => $questionid), 'id', 'id,1');
!         foreach ($answerids as $answerid => $notused) {
!             if ($answerstoo) {
!                 $fs->delete_area_files($contextid, 'question', 'answer', $answerid);
!             }
!             $fs->delete_area_files($contextid, 'question', 'answerfeedback', $answerid);
!         }
!     }
! 
!     function import_file($context, $component, $filearea, $itemid, $file) {
!         $fs = get_file_storage();
!         $record = new stdclass;
!         if (is_object($context)) {
!             $record->contextid = $context->id;
!         } else {
!             $record->contextid = $context;
!         }
!         $record->component = $component;
!         $record->filearea  = $filearea;
!         $record->itemid    = $itemid;
!         $record->filename  = $file->name;
!         $record->filepath  = '/';
!         return $fs->create_file_from_string($record, $this->decode_file($file));
!     }
! 
!     function decode_file($file) {
!         switch ($file->encoding) {
!         case 'base64':
!         default:
!             return base64_decode($file->content);
!         }
!     }
  }
--- 46,1796 ----
   * @subpackage questiontypes
   */
  class default_questiontype {
! 	protected $fileoptions = array(
          'subdirs' => false,
          'maxfiles' => -1,
          'maxbytes' => 0,
! 	);
  
! 	/**
! 	 * Name of the question type
! 	 *
! 	 * The name returned should coincide with the name of the directory
! 	 * in which this questiontype is located
! 	 *
! 	 * @return string the name of this question type.
! 	 */
! 	function name() {
! 		return 'default';
! 	}
! 
! 	/**
! 	 * Returns a list of other question types that this one requires in order to
! 	 * work. For example, the calculated question type is a subclass of the
! 	 * numerical question type, which is a subclass of the shortanswer question
! 	 * type; and the randomsamatch question type requires the shortanswer type
! 	 * to be installed.
! 	 *
! 	 * @return array any other question types that this one relies on. An empty
! 	 * array if none.
! 	 */
! 	function requires_qtypes() {
! 		return array();
! 	}
! 
! 	/**
! 	 * @return string the name of this pluginfor passing to get_string, set/get_config, etc.
! 	 */
! 	function plugin_name() {
! 		return 'qtype_' . $this->name();
! 	}
! 
! 	/**
! 	 * @return string the name of this question type in the user's language.
! 	 * You should not need to override this method, the default behaviour should be fine.
! 	 */
! 	function local_name() {
! 		return get_string($this->name(), $this->plugin_name());
! 	}
! 
! 	/**
! 	 * The name this question should appear as in the create new question
! 	 * dropdown. Override this method to return false if you don't want your
! 	 * question type to be createable, for example if it is an abstract base type,
! 	 * otherwise, you should not need to override this method.
! 	 *
! 	 * @return mixed the desired string, or false to hide this question type in the menu.
! 	 */
! 	function menu_name() {
! 		return $this->local_name();
! 	}
! 
! 	/**
! 	 * @return boolean override this to return false if this is not really a
! 	 *      question type, for example the description question type is not
! 	 *      really a question type.
! 	 */
! 	function is_real_question_type() {
! 		return true;
! 	}
! 
! 	/**
! 	 * @return boolean true if this question type may require manual grading.
! 	 */
! 	function is_manual_graded() {
! 		return false;
! 	}
! 
! 	/**
! 	 * @param object $question a question of this type.
! 	 * @param string $otherquestionsinuse comma-separate list of other question ids in this attempt.
! 	 * @return boolean true if a particular instance of this question requires manual grading.
! 	 */
! 	function is_question_manual_graded($question, $otherquestionsinuse) {
! 		return $this->is_manual_graded();
! 	}
! 
! 	/**
! 	 * @return boolean true if a table analyzing responses should be shown in
! 	 * the quiz statistics report. Usually if a question is manually graded
! 	 * then this analysis table won't be a good idea.
! 	 */
! 	function show_analysis_of_responses() {
! 		return !$this->is_manual_graded();
! 	}
! 
! 	/**
! 	 * @return boolean true if this question type can be used by the random question type.
! 	 */
! 	function is_usable_by_random() {
! 		return true;
! 	}
! 
! 	/**
! 	 * @param question record.
! 	 * @param integer subqid this is the id of the subquestion. Usually the id
! 	 * of the question record of the question record but this is dependent on
! 	 * the question type. Not relevant to some question types.
! 	 * @return whether the teacher supplied responses can include wildcards. Can
! 	 * more than one answer be equivalent to one teacher supplied response.
! 	 */
! 	function has_wildcards_in_responses($question, $subqid) {
! 		return false;
! 	}
! 
! 	/**
! 	 * If your question type has a table that extends the question table, and
! 	 * you want the base class to automatically save, backup and restore the extra fields,
! 	 * override this method to return an array wherer the first element is the table name,
! 	 * and the subsequent entries are the column names (apart from id and questionid).
! 	 *
! 	 * @return mixed array as above, or null to tell the base class to do nothing.
! 	 */
! 	function extra_question_fields() {
! 		return null;
! 	}
! 
! 	/**
! 	 * If you use extra_question_fields, overload this function to return question id field name
! 	 *  in case you table use another name for this column
! 	 */
! 	function questionid_column_name() {
! 		return 'questionid';
! 	}
! 
! 	/**
! 	 * If your question type has a table that extends the question_answers table,
! 	 * make this method return an array wherer the first element is the table name,
! 	 * and the subsequent entries are the column names (apart from id and answerid).
! 	 *
! 	 * @return mixed array as above, or null to tell the base class to do nothing.
! 	 */
! 	function extra_answer_fields() {
! 		return null;
! 	}
! 
! 	/**
! 	 * Return an instance of the question editing form definition. This looks for a
! 	 * class called edit_{$this->name()}_question_form in the file
! 	 * {$CFG->dirroot}/question/type/{$this->name()}/edit_{$this->name()}_question_form.php
! 	 * and if it exists returns an instance of it.
! 	 *
! 	 * @param string $submiturl passed on to the constructor call.
! 	 * @return object an instance of the form definition, or null if one could not be found.
! 	 */
! 	function create_editing_form($submiturl, $question, $category, $contexts, $formeditable) {
! 		global $CFG;
! 		require_once("{$CFG->dirroot}/question/type/edit_question_form.php");
! 		$definition_file = $CFG->dirroot.'/question/type/'.$this->name().'/edit_'.$this->name().'_form.php';
! 		if (!(is_readable($definition_file) && is_file($definition_file))) {
! 			return null;
! 		}
! 		require_once($definition_file);
! 		$classname = 'question_edit_'.$this->name().'_form';
! 		if (!class_exists($classname)) {
! 			return null;
! 		}
! 		return new $classname($submiturl, $question, $category, $contexts, $formeditable);
! 	}
! 
! 	/**
! 	 * @return string the full path of the folder this plugin's files live in.
! 	 */
! 	function plugin_dir() {
! 		global $CFG;
! 		return $CFG->dirroot . '/question/type/' . $this->name();
! 	}
! 
! 	/**
! 	 * @return string the URL of the folder this plugin's files live in.
! 	 */
! 	function plugin_baseurl() {
! 		global $CFG;
! 		return $CFG->wwwroot . '/question/type/' . $this->name();
! 	}
! 
! 	/**
! 	 * This method should be overriden if you want to include a special heading or some other
! 	 * html on a question editing page besides the question editing form.
! 	 *
! 	 * @param question_edit_form $mform a child of question_edit_form
! 	 * @param object $question
! 	 * @param string $wizardnow is '' for first page.
! 	 */
! 	function display_question_editing_page(&$mform, $question, $wizardnow){
! 		global $OUTPUT;
! 		$heading = $this->get_heading(empty($question->id));
! 
! 		echo $OUTPUT->heading_with_help($heading, $this->name(), $this->plugin_name());
! 
! 		$permissionstrs = array();
! 		if (!empty($question->id)){
! 			if ($question->formoptions->canedit){
! 				$permissionstrs[] = get_string('permissionedit', 'question');
! 			}
! 			if ($question->formoptions->canmove){
! 				$permissionstrs[] = get_string('permissionmove', 'question');
! 			}
! 			if ($question->formoptions->cansaveasnew){
! 				$permissionstrs[] = get_string('permissionsaveasnew', 'question');
! 			}
! 		}
! 		if (!$question->formoptions->movecontext  && count($permissionstrs)){
! 			echo $OUTPUT->heading(get_string('permissionto', 'question'), 3);
! 			$html = '<ul>';
! 			foreach ($permissionstrs as $permissionstr){
! 				$html .= '<li>'.$permissionstr.'</li>';
! 			}
! 			$html .= '</ul>';
! 			echo $OUTPUT->box($html, 'boxwidthnarrow boxaligncenter generalbox');
! 		}
! 		$mform->display();
! 	}
! 
! 	/**
! 	 * Method called by display_question_editing_page and by question.php to get heading for breadcrumbs.
! 	 *
! 	 * @return array a string heading and the langmodule in which it was found.
! 	 */
! 	function get_heading($adding = false){
! 		if ($adding) {
! 			$prefix = 'adding';
! 		} else {
! 			$prefix = 'editing';
! 		}
! 		return get_string($prefix . $this->name(), $this->plugin_name());
! 	}
! 
! 	/**
! 	 * Saves (creates or updates) a question.
! 	 *
! 	 * Given some question info and some data about the answers
! 	 * this function parses, organises and saves the question
! 	 * It is used by {@link question.php} when saving new data from
! 	 * a form, and also by {@link import.php} when importing questions
! 	 * This function in turn calls {@link save_question_options}
! 	 * to save question-type specific data.
! 	 *
! 	 * Whether we are saving a new question or updating an existing one can be
! 	 * determined by testing !empty($question->id). If it is not empty, we are updating.
! 	 *
! 	 * The question will be saved in category $form->category.
! 	 *
! 	 * @param object $question the question object which should be updated. For a new question will be mostly empty.
! 	 * @param object $form the object containing the information to save, as if from the question editing form.
! 	 * @param object $course not really used any more.
! 	 * @return object On success, return the new question object. On failure,
! 	 *       return an object as follows. If the error object has an errors field,
! 	 *       display that as an error message. Otherwise, the editing form will be
! 	 *       redisplayed with validation errors, from validation_errors field, which
! 	 *       is itself an object, shown next to the form fields. (I don't think this is accurate any more.)
! 	 */
! 	function save_question($question, $form) {
! 		global $USER, $DB, $OUTPUT;
! 
! 		list($question->category) = explode(',', $form->category);
! 		$context = $this->get_context_by_category_id($question->category);
! 
! 		// This default implementation is suitable for most
! 		// question types.
! 
! 		// First, save the basic question itself
! 		$question->name = trim($form->name);
! 		$question->parent = isset($form->parent) ? $form->parent : 0;
! 		$question->length = $this->actual_number_of_questions($question);
! 		$question->penalty = isset($form->penalty) ? $form->penalty : 0;
! 
! 		if (empty($form->questiontext['text'])) {
! 			$question->questiontext = '';
! 		} else {
! 			$question->questiontext = trim($form->questiontext['text']);;
! 		}
! 		$question->questiontextformat = !empty($form->questiontext['format'])?$form->questiontext['format']:0;
! 
! 		if (empty($form->generalfeedback['text'])) {
! 			$question->generalfeedback = '';
! 		} else {
! 			$question->generalfeedback = trim($form->generalfeedback['text']);
! 		}
! 		$question->generalfeedbackformat = !empty($form->generalfeedback['format'])?$form->generalfeedback['format']:0;
! 
! 		if (empty($question->name)) {
! 			$question->name = shorten_text(strip_tags($form->questiontext['text']), 15);
! 			if (empty($question->name)) {
! 				$question->name = '-';
! 			}
! 		}
! 
! 		if ($question->penalty > 1 or $question->penalty < 0) {
! 			$question->errors['penalty'] = get_string('invalidpenalty', 'quiz');
! 		}
! 
! 		if (isset($form->defaultgrade)) {
! 			$question->defaultgrade = $form->defaultgrade;
! 		}
! 
! 		// If the question is new, create it.
! 		if (empty($question->id)) {
! 			// Set the unique code
! 			$question->stamp = make_unique_id_code();
! 			$question->createdby = $USER->id;
! 			$question->timecreated = time();
! 			$question->id = $DB->insert_record('question', $question);
! 		}
! 
! 		// Now, whether we are updating a existing question, or creating a new
! 		// one, we have to do the files processing and update the record.
! 		/// Question already exists, update.
! 		$question->modifiedby = $USER->id;
! 		$question->timemodified = time();
! 
! 		if (!empty($question->questiontext) && !empty($form->questiontext['itemid'])) {
! 			$question->questiontext = file_save_draft_area_files($form->questiontext['itemid'], $context->id, 'question', 'questiontext', (int)$question->id, $this->fileoptions, $question->questiontext);
! 		}
! 		if (!empty($question->generalfeedback) && !empty($form->generalfeedback['itemid'])) {
! 			$question->generalfeedback = file_save_draft_area_files($form->generalfeedback['itemid'], $context->id, 'question', 'generalfeedback', (int)$question->id, $this->fileoptions, $question->generalfeedback);
! 		}
! 		$DB->update_record('question', $question);
! 
! 		// Now to save all the answers and type-specific options
! 		$form->id = $question->id;
! 		$form->qtype = $question->qtype;
! 		$form->category = $question->category;
! 		$form->questiontext = $question->questiontext;
! 		$form->questiontextformat = $question->questiontextformat;
! 		// current context
! 		$form->context = $context;
! 
! 		$result = $this->save_question_options($form);
! 
! 		if (!empty($result->error)) {
! 			print_error($result->error);
! 		}
! 
! 		if (!empty($result->notice)) {
! 			notice($result->notice, "question.php?id=$question->id");
! 		}
! 
! 		if (!empty($result->noticeyesno)) {
! 			throw new coding_exception('$result->noticeyesno no longer supported in save_question.');
! 		}
! 
! 		// Give the question a unique version stamp determined by question_hash()
! 		$DB->set_field('question', 'version', question_hash($question), array('id' => $question->id));
! 
! 		return $question;
! 	}
! 
! 	/**
! 	 * Saves question-type specific options
! 	 *
! 	 * This is called by {@link save_question()} to save the question-type specific data
! 	 * @return object $result->error or $result->noticeyesno or $result->notice
! 	 * @param object $question  This holds the information from the editing form,
! 	 *                          it is not a standard question object.
! 	 */
! 	function save_question_options($question) {
! 		global $DB;
! 		$extra_question_fields = $this->extra_question_fields();
! 
! 		if (is_array($extra_question_fields)) {
! 			$question_extension_table = array_shift($extra_question_fields);
! 
! 			$function = 'update_record';
! 			$questionidcolname = $this->questionid_column_name();
! 			$options = $DB->get_record($question_extension_table, array($questionidcolname => $question->id));
! 			if (!$options) {
! 				$function = 'insert_record';
! 				$options = new stdClass;
! 				$options->$questionidcolname = $question->id;
! 			}
! 			foreach ($extra_question_fields as $field) {
! 				if (!isset($question->$field)) {
! 					$result = new stdClass;
! 					$result->error = "No data for field $field when saving " .
! 					$this->name() . ' question id ' . $question->id;
! 					return $result;
! 				}
! 				$options->$field = $question->$field;
! 			}
! 
! 			if (!$DB->{$function}($question_extension_table, $options)) {
! 				$result = new stdClass;
! 				$result->error = 'Could not save question options for ' .
! 				$this->name() . ' question id ' . $question->id;
! 				return $result;
! 			}
! 		}
! 
! 		$extra_answer_fields = $this->extra_answer_fields();
! 		// TODO save the answers, with any extra data.
! 
! 		return null;
! 	}
! 
! 	/**
! 	 * Loads the question type specific options for the question.
! 	 *
! 	 * This function loads any question type specific options for the
! 	 * question from the database into the question object. This information
! 	 * is placed in the $question->options field. A question type is
! 	 * free, however, to decide on a internal structure of the options field.
! 	 * @return bool            Indicates success or failure.
! 	 * @param object $question The question object for the question. This object
! 	 *                         should be updated to include the question type
! 	 *                         specific information (it is passed by reference).
! 	 */
! 	function get_question_options(&$question) {
! 		global $CFG, $DB, $OUTPUT;
! 
! 		if (!isset($question->options)) {
! 			$question->options = new stdClass();
! 		}
! 
! 		$extra_question_fields = $this->extra_question_fields();
! 		if (is_array($extra_question_fields)) {
! 			$question_extension_table = array_shift($extra_question_fields);
! 			$extra_data = $DB->get_record($question_extension_table, array($this->questionid_column_name() => $question->id), implode(', ', $extra_question_fields));
! 			if ($extra_data) {
! 				foreach ($extra_question_fields as $field) {
! 					$question->options->$field = $extra_data->$field;
! 				}
! 			} else {
! 				echo $OUTPUT->notification("Failed to load question options from the table $question_extension_table for questionid " .
! 				$question->id);
! 				return false;
! 			}
! 		}
! 
! 		$extra_answer_fields = $this->extra_answer_fields();
! 		if (is_array($extra_answer_fields)) {
! 			$answer_extension_table = array_shift($extra_answer_fields);
! 			$question->options->answers = $DB->get_records_sql("
                      SELECT qa.*, qax." . implode(', qax.', $extra_answer_fields) . "
                      FROM {question_answers} qa, {$answer_extension_table} qax
                      WHERE qa.questionid = ? AND qax.answerid = qa.id", array($question->id));
! 			if (!$question->options->answers) {
! 				echo $OUTPUT->notification("Failed to load question answers from the table $answer_extension_table for questionid " .
! 				$question->id);
! 				return false;
! 			}
! 		} else {
! 			// Don't check for success or failure because some question types do not use the answers table.
! 			$question->options->answers = $DB->get_records('question_answers', array('question' => $question->id), 'id ASC');
! 		}
! 
! 		return true;
! 	}
! 
! 	/**
! 	 * Deletes states from the question-type specific tables
! 	 *
! 	 * @param string $stateslist  Comma separated list of state ids to be deleted
! 	 */
! 	function delete_states($stateslist) {
! 		/// The default question type does not have any tables of its own
! 		// therefore there is nothing to delete
! 
! 		return true;
! 	}
! 
! 	/**
! 	 * Deletes the question-type specific data when a question is deleted.
! 	 * @param integer $question the question being deleted.
! 	 * @param integer $contextid the context this quesiotn belongs to.
! 	 */
! 	function delete_question($questionid, $contextid) {
! 		global $DB;
! 
! 		$this->delete_files($questionid, $contextid);
! 
! 		$extra_question_fields = $this->extra_question_fields();
! 		if (is_array($extra_question_fields)) {
! 			$question_extension_table = array_shift($extra_question_fields);
! 			$DB->delete_records($question_extension_table,
! 			array($this->questionid_column_name() => $questionid));
! 		}
! 
! 		$extra_answer_fields = $this->extra_answer_fields();
! 		if (is_array($extra_answer_fields)) {
! 			$answer_extension_table = array_shift($extra_answer_fields);
! 			$DB->delete_records_select($answer_extension_table,
                  "answerid IN (SELECT qa.id FROM {question_answers} qa WHERE qa.question = ?)", array($questionid));
! 		}
  
! 		$DB->delete_records('question_answers', array('question' => $questionid));
! 	}
  
! 	/**
! 	 * Returns the number of question numbers which are used by the question
! 	 *
! 	 * This function returns the number of question numbers to be assigned
! 	 * to the question. Most question types will have length one; they will be
! 	 * assigned one number. The 'description' type, however does not use up a
! 	 * number and so has a length of zero. Other question types may wish to
! 	 * handle a bundle of questions and hence return a number greater than one.
! 	 * @return integer         The number of question numbers which should be
! 	 *                         assigned to the question.
! 	 * @param object $question The question whose length is to be determined.
! 	 *                         Question type specific information is included.
! 	 */
! 	function actual_number_of_questions($question) {
! 		// By default, each question is given one number
! 		return 1;
! 	}
! 
! 	/**
! 	 * Creates empty session and response information for the question
! 	 *
! 	 * This function is called to start a question session. Empty question type
! 	 * specific session data (if any) and empty response data will be added to the
! 	 * state object. Session data is any data which must persist throughout the
! 	 * attempt possibly with updates as the user interacts with the
! 	 * question. This function does NOT create new entries in the database for
! 	 * the session; a call to the {@link save_session_and_responses} member will
! 	 * occur to do this.
! 	 * @return bool            Indicates success or failure.
! 	 * @param object $question The question for which the session is to be
! 	 *                         created. Question type specific information is
! 	 *                         included.
! 	 * @param object $state    The state to create the session for. Note that
! 	 *                         this will not have been saved in the database so
! 	 *                         there will be no id. This object will be updated
! 	 *                         to include the question type specific information
! 	 *                         (it is passed by reference). In particular, empty
! 	 *                         responses will be created in the ->responses
! 	 *                         field.
! 	 * @param object $cmoptions
! 	 * @param object $attempt  The attempt for which the session is to be
! 	 *                         started. Questions may wish to initialize the
! 	 *                         session in different ways depending on the user id
! 	 *                         or time available for the attempt.
! 	 */
! 	function create_session_and_responses(&$question, &$state, $cmoptions, $attempt) {
! 		// The default implementation should work for the legacy question types.
! 		// Most question types with only a single form field for the student's response
! 		// will use the empty string '' as the index for that one response. This will
! 		// automatically be stored in and restored from the answer field in the
! 		// question_states table.
! 		$state->responses = array(
                  '' => '',
! 		);
! 		return true;
! 	}
! 
! 	/**
! 	 * Restores the session data and most recent responses for the given state
! 	 *
! 	 * This function loads any session data associated with the question
! 	 * session in the given state from the database into the state object.
! 	 * In particular it loads the responses that have been saved for the given
! 	 * state into the ->responses member of the state object.
! 	 *
! 	 * Question types with only a single form field for the student's response
! 	 * will not need not restore the responses; the value of the answer
! 	 * field in the question_states table is restored to ->responses['']
! 	 * before this function is called. Question types with more response fields
! 	 * should override this method and set the ->responses field to an
! 	 * associative array of responses.
! 	 * @return bool            Indicates success or failure.
! 	 * @param object $question The question object for the question including any
! 	 *                         question type specific information.
! 	 * @param object $state    The saved state to load the session for. This
! 	 *                         object should be updated to include the question
! 	 *                         type specific session information and responses
! 	 *                         (it is passed by reference).
! 	 */
! 	function restore_session_and_responses(&$question, &$state) {
! 		// The default implementation does nothing (successfully)
! 		return true;
! 	}
! 
! 	/**
! 	 * Saves the session data and responses for the given question and state
! 	 *
! 	 * This function saves the question type specific session data from the
! 	 * state object to the database. In particular for most question types it saves the
! 	 * responses from the ->responses member of the state object. The question type
! 	 * non-specific data for the state has already been saved in the question_states
! 	 * table and the state object contains the corresponding id and
! 	 * sequence number which may be used to index a question type specific table.
! 	 *
! 	 * Question types with only a single form field for the student's response
! 	 * which is contained in ->responses[''] will not have to save this response,
! 	 * it will already have been saved to the answer field of the question_states table.
! 	 * Question types with more response fields should override this method to convert
! 	 * the data the ->responses array into a single string field, and save it in the
! 	 * database. The implementation in the multichoice question type is a good model to follow.
! 	 * http://cvs.moodle.org/contrib/plugins/question/type/opaque/questiontype.php?view=markup
! 	 * has a solution that is probably quite generally applicable.
! 	 * @return bool            Indicates success or failure.
! 	 * @param object $question The question object for the question including
! 	 *                         the question type specific information.
! 	 * @param object $state    The state for which the question type specific
! 	 *                         data and responses should be saved.
! 	 */
! 	function save_session_and_responses(&$question, &$state) {
! 		// The default implementation does nothing (successfully)
! 		return true;
! 	}
! 
! 	/**
! 	 * Returns an array of values which will give full marks if graded as
! 	 * the $state->responses field
! 	 *
! 	 * The correct answer to the question in the given state, or an example of
! 	 * a correct answer if there are many, is returned. This is used by some question
! 	 * types in the {@link grade_responses()} function but it is also used by the
! 	 * question preview screen to fill in correct responses.
! 	 * @return mixed           A response array giving the responses corresponding
! 	 *                         to the (or a) correct answer to the question. If there is
! 	 *                         no correct answer that scores 100% then null is returned.
! 	 * @param object $question The question for which the correct answer is to
! 	 *                         be retrieved. Question type specific information is
! 	 *                         available.
! 	 * @param object $state    The state of the question, for which a correct answer is
! 	 *                         needed. Question type specific information is included.
! 	 */
! 	function get_correct_responses(&$question, &$state) {
! 		/* The default implementation returns the response for the first answer
! 		 that gives full marks. */
! 		if ($question->options->answers) {
! 			foreach ($question->options->answers as $answer) {
! 				if (((int) $answer->fraction) === 1) {
! 					return array('' => $answer->answer);
! 				}
! 			}
! 		}
! 		return null;
! 	}
! 
! 	/**
! 	 * Return an array of values with the texts for all possible responses stored
! 	 * for the question
! 	 *
! 	 * All answers are found and their text values isolated
! 	 * @return object          A mixed object
! 	 *             ->id        question id. Needed to manage random questions:
! 	 *                         it's the id of the actual question presented to user in a given attempt
! 	 *             ->responses An array of values giving the responses corresponding
! 	 *                         to all answers to the question. Answer ids are used as keys.
! 	 *                         The text and partial credit are the object components
! 	 * @param object $question The question for which the answers are to
! 	 *                         be retrieved. Question type specific information is
! 	 *                         available.
! 	 */
! 	// ULPGC ecastro
! 	function get_all_responses(&$question, &$state) {
! 		if (isset($question->options->answers) && is_array($question->options->answers)) {
! 			$answers = array();
! 			foreach ($question->options->answers as $aid=>$answer) {
! 				$r = new stdClass;
! 				$r->answer = $answer->answer;
! 				$r->credit = $answer->fraction;
! 				$answers[$aid] = $r;
! 			}
! 			$result = new stdClass;
! 			$result->id = $question->id;
! 			$result->responses = $answers;
! 			return $result;
! 		} else {
! 			return null;
! 		}
! 	}
! 	/**
! 	 * The difference between this method an get_all_responses is that this
! 	 * method is not passed a state object. It is the possible answers to a
! 	 * question no matter what the state.
! 	 * This method is not called for random questions.
! 	 * @return array of possible answers.
! 	 */
! 	function get_possible_responses(&$question) {
! 		static $responses = array();
! 		if (!isset($responses[$question->id])){
! 			$responses[$question->id] = $this->get_all_responses($question, new object());
! 		}
! 		return array($question->id => $responses[$question->id]->responses);
! 	}
! 
! 	/**
! 	 * @param object $question
! 	 * @return mixed either a integer score out of 1 that the average random
! 	 * guess by a student might give or an empty string which means will not
! 	 * calculate.
! 	 */
! 	function get_random_guess_score($question) {
! 		return 0;
! 	}
! 	/**
! 	 * Return the actual response to the question in a given state
! 	 * for the question. Text is not yet formatted for output.
! 	 *
! 	 * @return mixed           An array containing the response or reponses (multiple answer, match)
! 	 *                         given by the user in a particular attempt.
! 	 * @param object $question The question for which the correct answer is to
! 	 *                         be retrieved. Question type specific information is
! 	 *                         available.
! 	 * @param object $state    The state object that corresponds to the question,
! 	 *                         for which a correct answer is needed. Question
! 	 *                         type specific information is included.
! 	 */
! 	// ULPGC ecastro
! 	function get_actual_response($question, $state) {
! 		if (!empty($state->responses)) {
! 			$responses[] = $state->responses[''];
! 		} else {
! 			$responses[] = '';
! 		}
! 		return $responses;
! 	}
! 
! 	function get_actual_response_details($question, $state) {
! 		$response = array_shift($this->get_actual_response($question, $state));
! 		$teacherresponses = $this->get_possible_responses($question, $state);
! 		//only one response
! 		list($tsubqid, $tresponses) = each($teacherresponses);
! 		$responsedetail = new stdClass();
! 		$responsedetail->subqid = $tsubqid;
! 		$responsedetail->response = $response;
! 		if ($aid = $this->check_response($question, $state)){
! 			$responsedetail->aid = $aid;
! 		} else {
! 			foreach ($tresponses as $aid => $tresponse){
! 				if ($tresponse->answer == $response){
! 					$responsedetail->aid = $aid;
! 					break;
! 				}
! 			}
! 		}
! 		if (isset($responsedetail->aid)){
! 			$responsedetail->credit = $tresponses[$aid]->credit;
! 		} else {
! 			$responsedetail->aid = 0;
! 			$responsedetail->credit = 0;
! 		}
! 		return array($responsedetail);
! 	}
! 
! 	// ULPGC ecastro
! 	function get_fractional_grade(&$question, &$state) {
! 		$grade = $state->grade;
! 		if ($question->maxgrade > 0) {
! 			return (float)($grade / $question->maxgrade);
! 		} else {
! 			return (float)$grade;
! 		}
! 	}
! 
! 
! 	/**
! 	 * Checks if the response given is correct and returns the id
! 	 *
! 	 * @return int             The ide number for the stored answer that matches the response
! 	 *                         given by the user in a particular attempt.
! 	 * @param object $question The question for which the correct answer is to
! 	 *                         be retrieved. Question type specific information is
! 	 *                         available.
! 	 * @param object $state    The state object that corresponds to the question,
! 	 *                         for which a correct answer is needed. Question
! 	 *                         type specific information is included.
! 	 */
! 	// ULPGC ecastro
! 	function check_response(&$question, &$state){
! 		return false;
! 	}
! 
! 	// Used by the following function, so that it only returns results once per quiz page.
! 	private $htmlheadalreadydone = false;
! 	/**
! 	 * Hook to allow question types to include required JavaScrip or CSS on pages
! 	 * where they are going to be printed.
! 	 *
! 	 * If this question type requires JavaScript to function,
! 	 * then this method, which will be called before print_header on any page
! 	 * where this question is going to be printed, is a chance to call
! 	 * $PAGE->requires->js, and so on.
! 	 *
! 	 * The two parameters match the first two parameters of print_question.
! 	 *
! 	 * @param object $question The question object.
! 	 * @param object $state    The state object.
! 	 */
! 	function get_html_head_contributions(&$question, &$state) {
! 		// We only do this once for this question type, no matter how often this
! 		// method is called on one page.
! 		if ($this->htmlheadalreadydone) {
! 			return;
! 		}
! 		$this->htmlheadalreadydone = true;
! 
! 		// By default, we link to any of the files script.js or script.php that
! 		// exist in the plugin folder.
! 		$this->find_standard_scripts();
! 	}
! 
! 	/**
! 	 * Like @see{get_html_head_contributions}, but this method is for CSS and
! 	 * JavaScript required on the question editing page question/question.php.
! 	 */
! 	function get_editing_head_contributions() {
! 		// By default, we link to any of the files styles.css, styles.php,
! 		// script.js or script.php that exist in the plugin folder.
! 		// Core question types should not use this mechanism. Their styles
! 		// should be included in the standard theme.
! 		$this->find_standard_scripts();
! 	}
! 
! 	/**
! 	 * Utility method used by @see{get_html_head_contributions} and
! 	 * @see{get_editing_head_contributions}. This looks for any of the files
! 	 * script.js or script.php that exist in the plugin folder and ensures they
! 	 * get included.
! 	 */
! 	protected function find_standard_scripts() {
! 		global $PAGE;
! 
! 		$plugindir = $this->plugin_dir();
! 		$plugindirrel = 'question/type/' . $this->name();
! 
! 		if (file_exists($plugindir . '/script.js')) {
! 			$PAGE->requires->js('/' . $plugindirrel . '/script.js');
! 		}
! 		if (file_exists($plugindir . '/script.php')) {
! 			$PAGE->requires->js('/' . $plugindirrel . '/script.php');
! 		}
! 	}
! 
! 	/**
! 	 * Prints the question including the number, grading details, content,
! 	 * feedback and interactions
! 	 *
! 	 * This function prints the question including the question number,
! 	 * grading details, content for the question, any feedback for the previously
! 	 * submitted responses and the interactions. The default implementation calls
! 	 * various other methods to print each of these parts and most question types
! 	 * will just override those methods.
! 	 * @param object $question The question to be rendered. Question type
! 	 *                         specific information is included. The
! 	 *                         maximum possible grade is in ->maxgrade. The name
! 	 *                         prefix for any named elements is in ->name_prefix.
! 	 * @param object $state    The state to render the question in. The grading
! 	 *                         information is in ->grade, ->raw_grade and
! 	 *                         ->penalty. The current responses are in
! 	 *                         ->responses. This is an associative array (or the
! 	 *                         empty string or null in the case of no responses
! 	 *                         submitted). The last graded state is in
! 	 *                         ->last_graded (hence the most recently graded
! 	 *                         responses are in ->last_graded->responses). The
! 	 *                         question type specific information is also
! 	 *                         included.
! 	 * @param integer $number  The number for this question.
! 	 * @param object $cmoptions
! 	 * @param object $options  An object describing the rendering options.
! 	 */
! 	function print_question(&$question, &$state, $number, $cmoptions, $options, $context=null) {
! 		/* The default implementation should work for most question types
! 		 provided the member functions it calls are overridden where required.
! 		 The layout is determined by the template question.html */
! 
! 		global $CFG, $OUTPUT;
! 
! 		$context = $this->get_context_by_category_id($question->category);
! 		$question->questiontext = quiz_rewrite_question_urls($question->questiontext, 'pluginfile.php', $context->id, 'question', 'questiontext', array($state->attempt, $state->question), $question->id);
! 
! 		$question->generalfeedback = quiz_rewrite_question_urls($question->generalfeedback, 'pluginfile.php', $context->id, 'question', 'generalfeedback', array($state->attempt, $state->question), $question->id);
! 
! 		$isgraded = question_state_is_graded($state->last_graded);
! 
! 		if (isset($question->randomquestionid)) {
! 			$actualquestionid = $question->randomquestionid;
! 		} else {
! 			$actualquestionid = $question->id;
! 		}
! 
! 		// For editing teachers print a link to an editing popup window
! 		$editlink = $this->get_question_edit_link($question, $cmoptions, $options);
! 
! 		$generalfeedback = '';
! 		if ($isgraded && $options->generalfeedback) {
! 			$generalfeedback = $this->format_text($question->generalfeedback,
! 			$question->generalfeedbackformat, $cmoptions);
! 		}
! 
! 		$grade = '';
! 		if ($question->maxgrade > 0 && $options->scores) {
! 			if ($cmoptions->optionflags & QUESTION_ADAPTIVE) {
! 				if ($isgraded) {
! 					$grade = question_format_grade($cmoptions, $state->last_graded->grade).'/';
! 				} else {
! 					$grade = '--/';
! 				}
! 			}
! 
! 			$grade .= question_format_grade($cmoptions, $question->maxgrade);
! 		}
! 
! 		$formatoptions = new stdClass;
! 		$formatoptions->para = false;
! 		$comment = format_text($state->manualcomment, $state->manualcommentformat,
! 		$formatoptions, $cmoptions->course);
! 		$commentlink = '';
! 
! 		if (!empty($options->questioncommentlink)) {
! 			$strcomment = get_string('commentorgrade', 'quiz');
! 
! 			$link = new moodle_url($options->questioncommentlink, array('question' => $actualquestionid));
! 			$action = new popup_action('click', $link, 'commentquestion', array('height' => 480, 'width' => 750));
! 			$commentlink = $OUTPUT->container($OUTPUT->action_link($link, $strcomment, $action), 'commentlink');
! 		}
! 
! 		$history = $this->history($question, $state, $number, $cmoptions, $options);
! 
! 		include "$CFG->dirroot/question/type/question.html";
! 	}
! 
! 	/**
! 	 * Render the question flag, assuming $flagsoption allows it. You will probably
! 	 * never need to override this method.
! 	 *
! 	 * @param object $question the question
! 	 * @param object $state its current state
! 	 * @param integer $flagsoption the option that says whether flags should be displayed.
! 	 */
! 	protected function print_question_flag($question, $state, $flagsoption) {
! 		global $CFG, $PAGE;
! 		switch ($flagsoption) {
! 			case QUESTION_FLAGSSHOWN:
! 				$flagcontent = $this->get_question_flag_tag($state->flagged);
! 				break;
! 			case QUESTION_FLAGSEDITABLE:
! 				$id = $question->name_prefix . '_flagged';
! 				if ($state->flagged) {
! 					$checked = 'checked="checked" ';
! 				} else {
! 					$checked = '';
! 				}
! 				$qsid = $state->questionsessionid;
! 				$aid = $state->attempt;
! 				$qid = $state->question;
! 				$checksum = question_get_toggleflag_checksum($aid, $qid, $qsid);
! 				$postdata = "qsid=$qsid&aid=$aid&qid=$qid&checksum=$checksum&sesskey=" .
! 				sesskey() . '&newstate=';
! 				$flagcontent = '<input type="checkbox" id="' . $id . '" name="' . $id .
                          '" class="questionflagcheckbox" value="1" ' . $checked . ' />' .
                          '<input type="hidden" value="' . s($postdata) . '" class="questionflagpostdata" />' .
                          '<label id="' . $id . 'label" for="' . $id .
                          '" class="questionflaglabel">' . $this->get_question_flag_tag(
! 				$state->flagged, $id . 'img') . '</label>' . "\n";
! 				question_init_qengine_js();
! 				break;
! 			default:
! 				$flagcontent = '';
! 		}
! 		if ($flagcontent) {
! 			echo '<div class="questionflag">' . $flagcontent . "</div>\n";
! 		}
! 	}
! 
! 	/**
! 	 * Work out the actual img tag needed for the flag
! 	 *
! 	 * @param boolean $flagged whether the question is currently flagged.
! 	 * @param string $id an id to be added as an attribute to the img (optional).
! 	 * @return string the img tag.
! 	 */
! 	protected function get_question_flag_tag($flagged, $id = '') {
! 		global $OUTPUT;
! 		if ($id) {
! 			$id = 'id="' . $id . '" ';
! 		}
! 		if ($flagged) {
! 			$img = 'i/flagged';
! 		} else {
! 			$img = 'i/unflagged';
! 		}
! 		return '<img ' . $id . 'src="' . $OUTPUT->pix_url($img) .
                  '" alt="' . get_string('flagthisquestion', 'question') . '" />';
! 	}
  
! 	/**
! 	 * Get a link to an edit icon for this question, if the current user is allowed
! 	 * to edit it.
! 	 *
! 	 * @param object $question the question object.
! 	 * @param object $cmoptions the options from the module. If $cmoptions->thispageurl is set
! 	 *      then the link will be to edit the question in this browser window, then return to
! 	 *      $cmoptions->thispageurl. Otherwise the link will be to edit in a popup.
! 	 * @return string the HTML of the link, or nothing it the currenty user is not allowed to edit.
! 	 */
! 	function get_question_edit_link($question, $cmoptions, $options) {
! 		global $CFG, $OUTPUT;
! 
! 		/// Is this user allowed to edit this question?
! 		if (!empty($options->noeditlink) || !question_has_capability_on($question, 'edit')) {
! 			return '';
! 		}
! 
! 		/// Work out the right URL.
! 		$url = new moodle_url('/question/question.php', array('id' => $question->id));
! 		if (!empty($cmoptions->cmid)) {
! 			$url->param('cmid', $cmoptions->cmid);
! 		} else if (!empty($cmoptions->course)) {
! 			$url->param('courseid', $cmoptions->course);
! 		} else {
! 			print_error('missingcourseorcmidtolink', 'question');
! 		}
! 
! 		$icon = new pix_icon('t/edit', get_string('edit'));
! 
! 		$action = null;
! 		if (!empty($cmoptions->thispageurl)) {
! 			// The module allow editing in the same window, print an ordinary
! 			// link with a returnurl.
! 			$url->param('returnurl', $cmoptions->thispageurl);
! 		} else {
! 			// We have to edit in a pop-up.
! 			$url->param('inpopup', 1);
! 			$action = new popup_action('click', $link, 'editquestion');
! 		}
! 
! 		return $OUTPUT->action_icon($url, $icon, $action);
! 	}
! 
! 	/**
! 	 * Print history of responses
! 	 *
! 	 * Used by print_question()
! 	 */
! 	function history($question, $state, $number, $cmoptions, $options) {
! 		global $DB, $OUTPUT;
! 
! 		if (empty($options->history)) {
! 			return '';
! 		}
! 
! 		if (isset($question->randomquestionid)) {
! 			$actualquestionid = $question->randomquestionid;
! 			$randomprefix = 'random' . $question->id . '-';
! 		} else {
! 			$actualquestionid = $question->id;
! 			$randomprefix = '';
! 		}
! 		if ($options->history == 'all') {
! 			$eventtest = 'event > 0';
! 		} else {
! 			$eventtest = 'event IN (' . QUESTION_EVENTS_GRADED . ')';
! 		}
! 		$states = $DB->get_records_select('question_states',
                  'attempt = :aid AND question = :qid AND ' . $eventtest,
! 		array('aid' => $state->attempt, 'qid' => $actualquestionid), 'seq_number,id');
! 		if (count($states) <= 1) {
! 			return '';
! 		}
! 
! 		$strreviewquestion = get_string('reviewresponse', 'quiz');
! 		$table = new html_table();
! 		$table->width = '100%';
! 		$table->head  = array (
! 		get_string('numberabbr', 'quiz'),
! 		get_string('action', 'quiz'),
! 		get_string('response', 'quiz'),
! 		get_string('time'),
! 		);
! 		if ($options->scores) {
! 			$table->head[] = get_string('score', 'quiz');
! 			$table->head[] = get_string('grade', 'quiz');
! 		}
! 
! 		foreach ($states as $st) {
! 			if ($randomprefix && strpos($st->answer, $randomprefix) === 0) {
! 				$st->answer = substr($st->answer, strlen($randomprefix));
! 			}
! 			$st->responses[''] = $st->answer;
! 			$this->restore_session_and_responses($question, $st);
! 
! 			if ($state->id == $st->id) {
! 				$link = '<b>' . $st->seq_number . '</b>';
! 			} else if (isset($options->questionreviewlink)) {
! 				$reviewlink = new moodle_url($options->questionreviewlink);
! 				$reviewlink->params(array('state' => $st->id,'question' => $actualquestionid));
! 				$link = new moodle_url($reviewlink);
! 				$action = new popup_action('click', $link, 'reviewquestion', array('height' => 450, 'width' => 650));
! 				$link = $OUTPUT->action_link($link, $st->seq_number, $action, array('title'=>$strreviewquestion));
! 			} else {
! 				$link = $st->seq_number;
! 			}
! 
! 			if ($state->id == $st->id) {
! 				$b = '<b>';
! 				$be = '</b>';
! 			} else {
! 				$b = '';
! 				$be = '';
! 			}
! 
! 			$data = array (
! 			$link,
! 			$b.get_string('event'.$st->event, 'quiz').$be,
! 			$b.$this->response_summary($question, $st).$be,
! 			$b.userdate($st->timestamp, get_string('timestr', 'quiz')).$be,
! 			);
! 			if ($options->scores) {
! 				$data[] = $b.question_format_grade($cmoptions, $st->raw_grade).$be;
! 				$data[] = $b.question_format_grade($cmoptions, $st->raw_grade).$be;
! 			}
! 			$table->data[] = $data;
! 		}
! 		return html_writer::table($table);
! 	}
! 
! 	/**
! 	 * Prints the score obtained and maximum score available plus any penalty
! 	 * information
! 	 *
! 	 * This function prints a summary of the scoring in the most recently
! 	 * graded state (the question may not have been submitted for marking at
! 	 * the current state). The default implementation should be suitable for most
! 	 * question types.
! 	 * @param object $question The question for which the grading details are
! 	 *                         to be rendered. Question type specific information
! 	 *                         is included. The maximum possible grade is in
! 	 *                         ->maxgrade.
! 	 * @param object $state    The state. In particular the grading information
! 	 *                          is in ->grade, ->raw_grade and ->penalty.
! 	 * @param object $cmoptions
! 	 * @param object $options  An object describing the rendering options.
! 	 */
! 	function print_question_grading_details(&$question, &$state, $cmoptions, $options) {
! 		/* The default implementation prints the number of marks if no attempt
! 		 has been made. Otherwise it displays the grade obtained out of the
! 		 maximum grade available and a warning if a penalty was applied for the
! 		 attempt and displays the overall grade obtained counting all previous
! 		 responses (and penalties) */
! 
! 
! 		if (QUESTION_EVENTDUPLICATE == $state->event) {
! 			echo ' ';
! 			print_string('duplicateresponse', 'quiz');
! 		}
! 		if ($question->maxgrade > 0 && $options->scores) {
! 			if (question_state_is_graded($state->last_graded)) {
! 				// Display the grading details from the last graded state
! 				$grade = new stdClass;
! 				$grade->cur = question_format_grade($cmoptions, $state->last_graded->grade);
! 				$grade->max = question_format_grade($cmoptions, $question->maxgrade);
! 				$grade->raw = question_format_grade($cmoptions, $state->last_graded->raw_grade);
! 
! 				// let student know wether the answer was correct
! 				$class = question_get_feedback_class($state->last_graded->raw_grade /
! 				$question->maxgrade);
! 				echo '<div class="correctness ' . $class . '">' . get_string($class, 'quiz') . '</div>';
! 
! 				$_SESSION['content'].= "<tr><td><b>".get_string($class, 'quiz')."</b></td></tr>";
! 				echo '<div class="gradingdetails">';
! 				// print grade for this submission
! 				$_SESSION['content'].= "<tr><td><b>". get_string('gradingdetails', 'quiz', $grade)."</b></td></tr>";
! 				print_string('gradingdetails', 'quiz', $grade);
! 				if ($cmoptions->penaltyscheme) {
! 					// print details of grade adjustment due to penalties
! 					if ($state->last_graded->raw_grade > $state->last_graded->grade){
! 						echo ' ';
! 						print_string('gradingdetailsadjustment', 'quiz', $grade);
! 						$_SESSION['content'].= "<tr><td><b>".get_string('gradingdetailsadjustment', 'quiz', $grade)."</b></td></tr>";
! 
! 					}
! 					// print info about new penalty
! 					// penalty is relevant only if the answer is not correct and further attempts are possible
! 					if (($state->last_graded->raw_grade < $question->maxgrade / 1.01)
! 					and (QUESTION_EVENTCLOSEANDGRADE != $state->event)) {
! 
! 						if ('' !== $state->last_graded->penalty && ((float)$state->last_graded->penalty) > 0.0) {
! 							// A penalty was applied so display it
! 							echo ' ';
! 
! 							$_SESSION['content'].= "<tr><td><b>". get_string('gradingdetailspenalty', 'quiz', question_format_grade($cmoptions, $state->last_graded->penalty))
! 							."</b></td></tr>";
! 
! 							print_string('gradingdetailspenalty', 'quiz', question_format_grade($cmoptions, $state->last_graded->penalty));
! 						} else {
! 							/* No penalty was applied even though the answer was
! 							 not correct (eg. a syntax error) so tell the student
! 							 that they were not penalised for the attempt */
! 							echo ' ';
! 
! 							$_SESSION['content'].= "<tr><td><b>".  get_string('gradingdetailszeropenalty', 'quiz')."</b></td></tr>";
! 							print_string('gradingdetailszeropenalty', 'quiz');
! 						}
! 					}
! 				}
! 				echo '</div>';
! 
! 			}
! 		}
! 		$_SESSION['content'].="</table>";
! 	}
! 
! 	/**
! 	 * Prints the main content of the question including any interactions
! 	 *
! 	 * This function prints the main content of the question including the
! 	 * interactions for the question in the state given. The last graded responses
! 	 * are printed or indicated and the current responses are selected or filled in.
! 	 * Any names (eg. for any form elements) are prefixed with $question->name_prefix.
! 	 * This method is called from the print_question method.
! 	 * @param object $question The question to be rendered. Question type
! 	 *                         specific information is included. The name
! 	 *                         prefix for any named elements is in ->name_prefix.
! 	 * @param object $state    The state to render the question in. The grading
! 	 *                         information is in ->grade, ->raw_grade and
! 	 *                         ->penalty. The current responses are in
! 	 *                         ->responses. This is an associative array (or the
! 	 *                         empty string or null in the case of no responses
! 	 *                         submitted). The last graded state is in
! 	 *                         ->last_graded (hence the most recently graded
! 	 *                         responses are in ->last_graded->responses). The
! 	 *                         question type specific information is also
! 	 *                         included.
! 	 *                         The state is passed by reference because some adaptive
! 	 *                         questions may want to update it during rendering
! 	 * @param object $cmoptions
! 	 * @param object $options  An object describing the rendering options.
! 	 */
! 	function print_question_formulation_and_controls(&$question, &$state, $cmoptions, $options) {
! 		/* This default implementation prints an error and must be overridden
! 		 by all question type implementations, unless the default implementation
! 		 of print_question has been overridden. */
! 		global $OUTPUT;
! 		echo $OUTPUT->notification('Error: Question formulation and input controls has not'
! 		.'  been implemented for question type '.$this->name());
! 	}
! 
! 	function check_file_access($question, $state, $options, $contextid, $component,
! 	$filearea, $args) {
! 
! 		if ($component == 'question' && $filearea == 'questiontext') {
! 			// Question text always visible.
! 			return true;
! 
! 		} else if ($component == 'question' && $filearea = 'generalfeedback') {
! 			return $options->generalfeedback && question_state_is_graded($state->last_graded);
! 
! 		} else {
! 			// Unrecognised component or filearea.
! 			return false;
! 		}
! 	}
! 
! 	/**
! 	 * Prints the submit button(s) for the question in the given state
! 	 *
! 	 * This function prints the submit button(s) for the question in the
! 	 * given state. The name of any button created will be prefixed with the
! 	 * unique prefix for the question in $question->name_prefix. The suffix
! 	 * 'submit' is reserved for the single question submit button and the suffix
! 	 * 'validate' is reserved for the single question validate button (for
! 	 * question types which support it). Other suffixes will result in a response
! 	 * of that name in $state->responses which the printing and grading methods
! 	 * can then use.
! 	 * @param object $question The question for which the submit button(s) are to
! 	 *                         be rendered. Question type specific information is
! 	 *                         included. The name prefix for any
! 	 *                         named elements is in ->name_prefix.
! 	 * @param object $state    The state to render the buttons for. The
! 	 *                         question type specific information is also
! 	 *                         included.
! 	 * @param object $cmoptions
! 	 * @param object $options  An object describing the rendering options.
! 	 */
! 	function print_question_submit_buttons(&$question, &$state, $cmoptions, $options) {
! 		// The default implementation should be suitable for most question types.
! 		// It prints a mark button in the case where individual marking is allowed.
! 		if (($cmoptions->optionflags & QUESTION_ADAPTIVE) and !$options->readonly) {
! 			echo '<input type="submit" name="', $question->name_prefix, 'submit" value="',
! 			get_string('mark', 'quiz'), '" class="submit btn" />';
! 		}
! 	}
! 
! 	/**
! 	 * Return a summary of the student response
! 	 *
! 	 * This function returns a short string of no more than a given length that
! 	 * summarizes the student's response in the given $state. This is used for
! 	 * example in the response history table. This string should already be
! 	 * formatted for output.
! 	 * @return string         The summary of the student response
! 	 * @param object $question
! 	 * @param object $state   The state whose responses are to be summarized
! 	 * @param int $length     The maximum length of the returned string
! 	 */
! 	function response_summary($question, $state, $length = 80, $formatting = true) {
! 		// This should almost certainly be overridden
! 		$responses = $this->get_actual_response($question, $state);
! 		if ($formatting){
! 			$responses = $this->format_responses($responses, $question->questiontextformat);
! 		}
! 		$responses = implode('; ', $responses);
! 		return shorten_text($responses, $length);
! 	}
! 	/**
! 	 * @param array responses is an array of responses.
! 	 * @return formatted responses
! 	 */
! 	function format_responses($responses, $format){
! 		$toreturn = array();
! 		foreach ($responses as $response){
! 			$toreturn[] = $this->format_response($response, $format);
! 		}
! 		return $toreturn;
! 	}
! 
! 	/**
! 	 * @param string response is a response.
! 	 * @return formatted response
! 	 */
! 	function format_response($response, $format) {
! 		return s(html_to_text($this->format_text($response, $format), 0, false));
! 	}
! 
! 	/**
! 	 * Renders the question for printing and returns the LaTeX source produced
! 	 *
! 	 * This function should render the question suitable for a printed problem
! 	 * or solution sheet in LaTeX and return the rendered output.
! 	 * @return string          The LaTeX output.
! 	 * @param object $question The question to be rendered. Question type
! 	 *                         specific information is included.
! 	 * @param object $state    The state to render the question in. The
! 	 *                         question type specific information is also
! 	 *                         included.
! 	 * @param object $cmoptions
! 	 * @param string $type     Indicates if the question or the solution is to be
! 	 *                         rendered with the values 'question' and
! 	 *                         'solution'.
! 	 */
! 	function get_texsource(&$question, &$state, $cmoptions, $type) {
! 		// The default implementation simply returns a string stating that
! 		// the question is only available online.
! 
! 		return get_string('onlineonly', 'texsheet');
! 	}
! 
! 	/**
! 	 * Compares two question states for equivalence of the student's responses
! 	 *
! 	 * The responses for the two states must be examined to see if they represent
! 	 * equivalent answers to the question by the student. This method will be
! 	 * invoked for each of the previous states of the question before grading
! 	 * occurs. If the student is found to have already attempted the question
! 	 * with equivalent responses then the attempt at the question is ignored;
! 	 * grading does not occur and the state does not change. Thus they are not
! 	 * penalized for this case.
! 	 * @return boolean
! 	 * @param object $question  The question for which the states are to be
! 	 *                          compared. Question type specific information is
! 	 *                          included.
! 	 * @param object $state     The state of the question. The responses are in
! 	 *                          ->responses. This is the only field of $state
! 	 *                          that it is safe to use.
! 	 * @param object $teststate The state whose responses are to be
! 	 *                          compared. The state will be of the same age or
! 	 *                          older than $state. If possible, the method should
! 	 *                          only use the field $teststate->responses, however
! 	 *                          any field that is set up by restore_session_and_responses
! 	 *                          can be used.
! 	 */
! 	function compare_responses(&$question, $state, $teststate) {
! 		// The default implementation performs a comparison of the response
! 		// arrays. The ordering of the arrays does not matter.
! 		// Question types may wish to override this (eg. to ignore trailing
! 		// white space or to make "7.0" and "7" compare equal).
! 
! 		// In php neither == nor === compare arrays the way you want. The following
! 		// ensures that the arrays have the same keys, with the same values.
! 		$result = false;
! 		$diff1 = array_diff_assoc($state->responses, $teststate->responses);
! 		if (empty($diff1)) {
! 			$diff2 = array_diff_assoc($teststate->responses, $state->responses);
! 			$result =  empty($diff2);
! 		}
! 
! 		return $result;
! 	}
! 
! 	/**
! 	 * Checks whether a response matches a given answer
! 	 *
! 	 * This method only applies to questions that use teacher-defined answers
! 	 *
! 	 * @return boolean
! 	 */
! 	function test_response(&$question, &$state, $answer) {
! 		$response = isset($state->responses['']) ? $state->responses[''] : '';
! 		return ($response == $answer->answer);
! 	}
! 
! 	/**
! 	 * Performs response processing and grading
! 	 *
! 	 * This function performs response processing and grading and updates
! 	 * the state accordingly.
! 	 * @return boolean         Indicates success or failure.
! 	 * @param object $question The question to be graded. Question type
! 	 *                         specific information is included.
! 	 * @param object $state    The state of the question to grade. The current
! 	 *                         responses are in ->responses. The last graded state
! 	 *                         is in ->last_graded (hence the most recently graded
! 	 *                         responses are in ->last_graded->responses). The
! 	 *                         question type specific information is also
! 	 *                         included. The ->raw_grade and ->penalty fields
! 	 *                         must be updated. The method is able to
! 	 *                         close the question session (preventing any further
! 	 *                         attempts at this question) by setting
! 	 *                         $state->event to QUESTION_EVENTCLOSEANDGRADE
! 	 * @param object $cmoptions
! 	 */
! 	function grade_responses(&$question, &$state, $cmoptions) {
! 		// The default implementation uses the test_response method to
! 		// compare what the student entered against each of the possible
! 		// answers stored in the question, and uses the grade from the
! 		// first one that matches. It also sets the marks and penalty.
! 		// This should be good enought for most simple question types.
! 
! 		$state->raw_grade = 0;
! 		foreach($question->options->answers as $answer) {
! 			if($this->test_response($question, $state, $answer)) {
! 				$state->raw_grade = $answer->fraction;
! 				break;
! 			}
! 		}
! 
! 		// Make sure we don't assign negative or too high marks.
! 		$state->raw_grade = min(max((float) $state->raw_grade,
! 		0.0), 1.0) * $question->maxgrade;
! 
! 		// Update the penalty.
! 		$state->penalty = $question->penalty * $question->maxgrade;
! 
! 		// mark the state as graded
! 		$state->event = ($state->event ==  QUESTION_EVENTCLOSE) ? QUESTION_EVENTCLOSEANDGRADE : QUESTION_EVENTGRADE;
! 
! 		return true;
! 	}
! 
! 	/**
! 	 * Returns true if the editing wizard is finished, false otherwise.
! 	 *
! 	 * The default implementation returns true, which is suitable for all question-
! 	 * types that only use one editing form. This function is used in
! 	 * question.php to decide whether we can regrade any states of the edited
! 	 * question and redirect to edit.php.
! 	 *
! 	 * The dataset dependent question-type, which is extended by the calculated
! 	 * question-type, overwrites this method because it uses multiple pages (i.e.
! 	 * a wizard) to set up the question and associated datasets.
! 	 *
! 	 * @param object $form  The data submitted by the previous page.
! 	 *
! 	 * @return boolean      Whether the wizard's last page was submitted or not.
! 	 */
! 	function finished_edit_wizard(&$form) {
! 		//In the default case there is only one edit page.
! 		return true;
! 	}
! 
! 	/**
! 	 * Call format_text from weblib.php with the options appropriate to question types.
! 	 *
! 	 * @param string $text the text to format.
! 	 * @param integer $text the type of text. Normally $question->questiontextformat.
! 	 * @param object $cmoptions the context the string is being displayed in. Only $cmoptions->course is used.
! 	 * @return string the formatted text.
! 	 */
! 	function format_text($text, $textformat, $cmoptions = NULL) {
! 		$formatoptions = new stdClass;
! 		$formatoptions->noclean = true;
! 		$formatoptions->para = false;
! 		return format_text($text, $textformat, $formatoptions, $cmoptions === NULL ? NULL : $cmoptions->course);
! 	}
! 
! 	/**
! 	 * @return the best link to pass to print_error.
! 	 * @param $cmoptions as passed in from outside.
! 	 */
! 	function error_link($cmoptions) {
! 		global $CFG;
! 		$cm = get_coursemodule_from_instance('quiz', $cmoptions->id);
! 		if (!empty($cm->id)) {
! 			return $CFG->wwwroot . '/mod/quiz/view.php?id=' . $cm->id;
! 		} else if (!empty($cm->course)) {
! 			return $CFG->wwwroot . '/course/view.php?id=' . $cm->course;
! 		} else {
! 			return '';
! 		}
! 	}
! 
! 	/// IMPORT/EXPORT FUNCTIONS /////////////////
! 
! 	/*
! 	 * Imports question from the Moodle XML format
! 	 *
! 	 * Imports question using information from extra_question_fields function
! 	 * If some of you fields contains id's you'll need to reimplement this
! 	 */
! 	function import_from_xml($data, $question, $format, $extra=null) {
! 		$question_type = $data['@']['type'];
! 		if ($question_type != $this->name()) {
! 			return false;
! 		}
! 
! 		$extraquestionfields = $this->extra_question_fields();
! 		if (!is_array($extraquestionfields)) {
! 			return false;
! 		}
! 
! 		//omit table name
! 		array_shift($extraquestionfields);
! 		$qo = $format->import_headers($data);
! 		$qo->qtype = $question_type;
! 
! 		foreach ($extraquestionfields as $field) {
! 			$qo->$field = $format->getpath($data, array('#',$field,0,'#'), $qo->$field);
! 		}
! 
! 		// run through the answers
! 		$answers = $data['#']['answer'];
! 		$a_count = 0;
! 		$extraasnwersfields = $this->extra_answer_fields();
! 		if (is_array($extraasnwersfields)) {
! 			//TODO import the answers, with any extra data.
! 		} else {
! 			foreach ($answers as $answer) {
! 				$ans = $format->import_answer($answer);
! 				$qo->answer[$a_count] = $ans->answer;
! 				$qo->fraction[$a_count] = $ans->fraction;
! 				$qo->feedback[$a_count] = $ans->feedback;
! 				++$a_count;
! 			}
! 		}
! 		return $qo;
! 	}
! 
! 	/*
! 	 * Export question to the Moodle XML format
! 	 *
! 	 * Export question using information from extra_question_fields function
! 	 * If some of you fields contains id's you'll need to reimplement this
! 	 */
! 	function export_to_xml($question, $format, $extra=null) {
! 		$extraquestionfields = $this->extra_question_fields();
! 		if (!is_array($extraquestionfields)) {
! 			return false;
! 		}
! 
! 		//omit table name
! 		array_shift($extraquestionfields);
! 		$expout='';
! 		foreach ($extraquestionfields as $field) {
! 			$exportedvalue = $question->options->$field;
! 			if (!empty($exportedvalue) && htmlspecialchars($exportedvalue) != $exportedvalue) {
! 				$exportedvalue = '<![CDATA[' . $exportedvalue . ']]>';
! 			}
! 			$expout .= "    <$field>{$exportedvalue}</$field>\n";
! 		}
! 
! 		$extraasnwersfields = $this->extra_answer_fields();
! 		if (is_array($extraasnwersfields)) {
! 			//TODO export answers with any extra data
! 		} else {
! 			foreach ($question->options->answers as $answer) {
! 				$percent = 100 * $answer->fraction;
! 				$expout .= "    <answer fraction=\"$percent\">\n";
! 				$expout .= $format->writetext($answer->answer, 3, false);
! 				$expout .= "      <feedback>\n";
! 				$expout .= $format->writetext($answer->feedback, 4, false);
! 				$expout .= "      </feedback>\n";
! 				$expout .= "    </answer>\n";
! 			}
! 		}
! 		return $expout;
! 	}
! 
! 	/**
! 	 * Abstract function implemented by each question type. It runs all the code
! 	 * required to set up and save a question of any type for testing purposes.
! 	 * Alternate DB table prefix may be used to facilitate data deletion.
! 	 */
! 	function generate_test($name, $courseid=null) {
! 		$form = new stdClass();
! 		$form->name = $name;
! 		$form->questiontextformat = 1;
! 		$form->questiontext = 'test question, generated by script';
! 		$form->defaultgrade = 1;
! 		$form->penalty = 0.1;
! 		$form->generalfeedback = "Well done";
! 
! 		$context = get_context_instance(CONTEXT_COURSE, $courseid);
! 		$newcategory = question_make_default_categories(array($context));
! 		$form->category = $newcategory->id . ',1';
! 
! 		$question = new stdClass();
! 		$question->courseid = $courseid;
! 		$question->qtype = $this->qtype;
! 		return array($form, $question);
! 	}
! 
! 	/**
! 	 * Get question context by category id
! 	 * @param int $category
! 	 * @return object $context
! 	 */
! 	function get_context_by_category_id($category) {
! 		global $DB;
! 		$contextid = $DB->get_field('question_categories', 'contextid', array('id'=>$category));
! 		$context = get_context_instance_by_id($contextid);
! 		return $context;
! 	}
! 
! 	/**
! 	 * Save the file belonging to one text field.
! 	 *
! 	 * @param array $field the data from the form (or from import). This will
! 	 *      normally have come from the formslib editor element, so it will be an
! 	 *      array with keys 'text', 'format' and 'itemid'. However, when we are
! 	 *      importing, it will be an array with keys 'text', 'format' and 'files'
! 	 * @param object $context the context the question is in.
! 	 * @param string $component indentifies the file area question.
! 	 * @param string $filearea indentifies the file area questiontext, generalfeedback,answerfeedback.
! 	 * @param integer $itemid identifies the file area.
! 	 *
! 	 * @return string the text for this field, after files have been processed.
! 	 */
! 	protected function import_or_save_files($field, $context, $component, $filearea, $itemid) {
! 		if (!empty($field['itemid'])) {
! 			// This is the normal case. We are safing the questions editing form.
! 			return file_save_draft_area_files($field['itemid'], $context->id, $component,
! 			$filearea, $itemid, $this->fileoptions, trim($field['text']));
! 
! 		} else if (!empty($field['files'])) {
! 			// This is the case when we are doing an import.
! 			foreach ($field['files'] as $file) {
! 				$this->import_file($context, $component,  $filearea, $itemid, $file);
! 			}
! 		}
! 		return trim($field['text']);
! 	}
! 
! 	/**
! 	 * Move all the files belonging to this question from one context to another.
! 	 * @param integer $questionid the question being moved.
! 	 * @param integer $oldcontextid the context it is moving from.
! 	 * @param integer $newcontextid the context it is moving to.
! 	 */
! 	public function move_files($questionid, $oldcontextid, $newcontextid) {
! 		$fs = get_file_storage();
! 		$fs->move_area_files_to_new_context($oldcontextid,
! 		$newcontextid, 'question', 'questiontext', $questionid);
! 		$fs->move_area_files_to_new_context($oldcontextid,
! 		$newcontextid, 'question', 'generalfeedback', $questionid);
! 	}
! 
! 	/**
! 	 * Move all the files belonging to this question's answers when the question
! 	 * is moved from one context to another.
! 	 * @param integer $questionid the question being moved.
! 	 * @param integer $oldcontextid the context it is moving from.
! 	 * @param integer $newcontextid the context it is moving to.
! 	 * @param boolean $answerstoo whether there is an 'answer' question area,
! 	 *      as well as an 'answerfeedback' one. Default false.
! 	 */
! 	protected function move_files_in_answers($questionid, $oldcontextid, $newcontextid, $answerstoo = false) {
! 		global $DB;
! 		$fs = get_file_storage();
! 
! 		$answerids = $DB->get_records_menu('question_answers',
! 		array('question' => $questionid), 'id', 'id,1');
! 		foreach ($answerids as $answerid => $notused) {
! 			if ($answerstoo) {
! 				$fs->move_area_files_to_new_context($oldcontextid,
! 				$newcontextid, 'question', 'answer', $answerid);
! 			}
! 			$fs->move_area_files_to_new_context($oldcontextid,
! 			$newcontextid, 'question', 'answerfeedback', $answerid);
! 		}
! 	}
! 
! 	/**
! 	 * Delete all the files belonging to this question.
! 	 * @param integer $questionid the question being deleted.
! 	 * @param integer $contextid the context the question is in.
! 	 */
! 	protected function delete_files($questionid, $contextid) {
! 		$fs = get_file_storage();
! 		$fs->delete_area_files($contextid, 'question', 'questiontext', $questionid);
! 		$fs->delete_area_files($contextid, 'question', 'generalfeedback', $questionid);
! 	}
! 
! 	/**
! 	 * Delete all the files belonging to this question's answers.
! 	 * @param integer $questionid the question being deleted.
! 	 * @param integer $contextid the context the question is in.
! 	 * @param boolean $answerstoo whether there is an 'answer' question area,
! 	 *      as well as an 'answerfeedback' one. Default false.
! 	 */
! 	protected function delete_files_in_answers($questionid, $contextid, $answerstoo = false) {
! 		global $DB;
! 		$fs = get_file_storage();
! 
! 		$answerids = $DB->get_records_menu('question_answers',
! 		array('question' => $questionid), 'id', 'id,1');
! 		foreach ($answerids as $answerid => $notused) {
! 			if ($answerstoo) {
! 				$fs->delete_area_files($contextid, 'question', 'answer', $answerid);
! 			}
! 			$fs->delete_area_files($contextid, 'question', 'answerfeedback', $answerid);
! 		}
! 	}
! 
! 	function import_file($context, $component, $filearea, $itemid, $file) {
! 		$fs = get_file_storage();
! 		$record = new stdclass;
! 		if (is_object($context)) {
! 			$record->contextid = $context->id;
! 		} else {
! 			$record->contextid = $context;
! 		}
! 		$record->component = $component;
! 		$record->filearea  = $filearea;
! 		$record->itemid    = $itemid;
! 		$record->filename  = $file->name;
! 		$record->filepath  = '/';
! 		return $fs->create_file_from_string($record, $this->decode_file($file));
! 	}
! 
! 	function decode_file($file) {
! 		switch ($file->encoding) {
! 			case 'base64':
! 			default:
! 				return base64_decode($file->content);
! 		}
! 	}
  }
diff -crB questionorg/type/random/backup/moodle2/restore_qtype_random_plugin.class.php questionupd/type/random/backup/moodle2/restore_qtype_random_plugin.class.php
*** questionorg/type/random/backup/moodle2/restore_qtype_random_plugin.class.php	2012-04-13 12:31:12.240178268 +0500
--- questionupd/type/random/backup/moodle2/restore_qtype_random_plugin.class.php	2012-04-13 09:42:58.000000000 +0500
***************
*** 30,69 ****
   */
  class restore_qtype_random_plugin extends restore_qtype_plugin {
  
!     /**
!      * Given one question_states record, return the answer
!      * recoded pointing to all the restored stuff for random questions
!      *
!      * answer format is randomxx-yy, with xx being question->id and
!      * yy the actual response to the question. We'll delegate the recode
!      * to the corresponding qtype
!      *
!      * also, some old states can contain, simply, one question->id,
!      * support them, just in case
!      */
!     public function recode_state_answer($state) {
!         global $DB;
  
!         $answer = $state->answer;
!         $result = '';
!         // randomxx-yy answer format
!         if (preg_match('~^random([0-9]+)-~', $answer, $matches)) {
!             $questionid = $matches[1];
!             $subanswer = substr($answer, strlen('random' . $questionid . '-'));
!             $newquestionid = $this->get_mappingid('question', $questionid);
!             $questionqtype = $DB->get_field('question', 'qtype', array('id' => $newquestionid));
!             // Delegate subanswer recode to proper qtype, faking one question_states record
!             $substate = new stdClass();
!             $substate->question = $newquestionid;
!             $substate->answer = $subanswer;
!             $newanswer = $this->step->restore_recode_answer($substate, $questionqtype);
!             $result = 'random' . $newquestionid . '-' . $newanswer;
  
!         // simple question id format
!         } else {
!             $newquestionid = $this->get_mappingid('question', $answer);
!             $result = $newquestionid;
!         }
!         return $result;
!     }
  }
--- 30,69 ----
   */
  class restore_qtype_random_plugin extends restore_qtype_plugin {
  
! 	/**
! 	 * Given one question_states record, return the answer
! 	 * recoded pointing to all the restored stuff for random questions
! 	 *
! 	 * answer format is randomxx-yy, with xx being question->id and
! 	 * yy the actual response to the question. We'll delegate the recode
! 	 * to the corresponding qtype
! 	 *
! 	 * also, some old states can contain, simply, one question->id,
! 	 * support them, just in case
! 	 */
! 	public function recode_state_answer($state) {
! 		global $DB;
  
! 		$answer = $state->answer;
! 		$result = '';
! 		// randomxx-yy answer format
! 		if (preg_match('~^random([0-9]+)-~', $answer, $matches)) {
! 			$questionid = $matches[1];
! 			$subanswer = substr($answer, strlen('random' . $questionid . '-'));
! 			$newquestionid = $this->get_mappingid('question', $questionid);
! 			$questionqtype = $DB->get_field('question', 'qtype', array('id' => $newquestionid));
! 			// Delegate subanswer recode to proper qtype, faking one question_states record
! 			$substate = new stdClass();
! 			$substate->question = $newquestionid;
! 			$substate->answer = $subanswer;
! 			$newanswer = $this->step->restore_recode_answer($substate, $questionqtype);
! 			$result = 'random' . $newquestionid . '-' . $newanswer;
  
! 			// simple question id format
! 		} else {
! 			$newquestionid = $this->get_mappingid('question', $answer);
! 			$result = $newquestionid;
! 		}
! 		return $result;
! 	}
  }
diff -crB questionorg/type/random/edit_random_form.php questionupd/type/random/edit_random_form.php
*** questionorg/type/random/edit_random_form.php	2012-04-13 12:31:12.242178268 +0500
--- questionupd/type/random/edit_random_form.php	2012-04-13 09:42:58.000000000 +0500
***************
*** 13,97 ****
   * random editing form definition.
   */
  class question_edit_random_form extends question_edit_form {
!     /**
!      * Build the form definition.
!      *
!      * This adds all the form files that the default question type supports.
!      * If your question type does not support all these fields, then you can
!      * override this method and remove the ones you don't want with $mform->removeElement().
!      */
!     function definition() {
!         global $COURSE, $CFG;
! 
!         $qtype = $this->qtype();
!         $langfile = "qtype_$qtype";
! 
!         $mform =& $this->_form;
! 
!         // Standard fields at the start of the form.
!         $mform->addElement('header', 'generalheader', get_string("general", 'form'));
! 
!         $mform->addElement('questioncategory', 'category', get_string('category', 'quiz'),
!                 array('contexts' => $this->contexts->having_cap('moodle/question:useall')));
! 
!         $mform->addElement('advcheckbox', 'questiontext[text]', get_string('recurse', 'quiz'), null, null, array(0, 1));
! 
!         $mform->addElement('hidden', 'name');
!         $mform->setType('name', PARAM_ALPHA);
!         $mform->setDefault('name', '');
! 
!         $mform->addElement('hidden', 'tags[]');
!         $mform->setType('tags[]', PARAM_ALPHA);
!         $mform->setDefault('tags[]', '');
! 
!         // Standard fields at the end of the form.
!         $mform->addElement('hidden', 'questiontextformat', 0);
!         $mform->setType('questiontextformat', PARAM_INT);
! 
!         $mform->addElement('hidden', 'id');
!         $mform->setType('id', PARAM_INT);
! 
!         $mform->addElement('hidden', 'qtype');
!         $mform->setType('qtype', PARAM_ALPHA);
! 
!         $mform->addElement('hidden', 'inpopup');
!         $mform->setType('inpopup', PARAM_INT);
! 
!         $mform->addElement('hidden', 'versioning');
!         $mform->setType('versioning', PARAM_BOOL);
! 
!         $mform->addElement('hidden', 'cmid');
!         $mform->setType('cmid', PARAM_INT);
!         $mform->setDefault('cmid', 0);
! 
!         $mform->addElement('hidden', 'courseid');
!         $mform->setType('courseid', PARAM_INT);
!         $mform->setDefault('courseid', 0);
! 
!         $mform->addElement('hidden', 'returnurl');
!         $mform->setType('returnurl', PARAM_LOCALURL);
!         $mform->setDefault('returnurl', 0);
! 
!         $buttonarray = array();
!         $buttonarray[] = $mform->createElement('submit', 'submitbutton', get_string('savechanges'));
!         $buttonarray[] = $mform->createElement('cancel');
!         $mform->addGroup($buttonarray, 'buttonar', '', array(' '), false);
!         $mform->closeHeaderBefore('buttonar');
!     }
! 
!     function set_data($question) {
!         $question->questiontext = array('text' => $question->questiontext);
!         // We don't want the complex stuff in the base class to run.
!         moodleform::set_data($question);
!     }
! 
!     function validation($fromform, $files) {
!         //validation of category
!         //is not relevant for this question type
!         return array();
!     }
! 
!     function qtype() {
!         return 'random';
!     }
  }
--- 13,97 ----
   * random editing form definition.
   */
  class question_edit_random_form extends question_edit_form {
! 	/**
! 	 * Build the form definition.
! 	 *
! 	 * This adds all the form files that the default question type supports.
! 	 * If your question type does not support all these fields, then you can
! 	 * override this method and remove the ones you don't want with $mform->removeElement().
! 	 */
! 	function definition() {
! 		global $COURSE, $CFG;
! 
! 		$qtype = $this->qtype();
! 		$langfile = "qtype_$qtype";
! 
! 		$mform =& $this->_form;
! 
! 		// Standard fields at the start of the form.
! 		$mform->addElement('header', 'generalheader', get_string("general", 'form'));
! 
! 		$mform->addElement('questioncategory', 'category', get_string('category', 'quiz'),
! 		array('contexts' => $this->contexts->having_cap('moodle/question:useall')));
! 
! 		$mform->addElement('advcheckbox', 'questiontext[text]', get_string('recurse', 'quiz'), null, null, array(0, 1));
! 
! 		$mform->addElement('hidden', 'name');
! 		$mform->setType('name', PARAM_ALPHA);
! 		$mform->setDefault('name', '');
! 
! 		$mform->addElement('hidden', 'tags[]');
! 		$mform->setType('tags[]', PARAM_ALPHA);
! 		$mform->setDefault('tags[]', '');
! 
! 		// Standard fields at the end of the form.
! 		$mform->addElement('hidden', 'questiontextformat', 0);
! 		$mform->setType('questiontextformat', PARAM_INT);
! 
! 		$mform->addElement('hidden', 'id');
! 		$mform->setType('id', PARAM_INT);
! 
! 		$mform->addElement('hidden', 'qtype');
! 		$mform->setType('qtype', PARAM_ALPHA);
! 
! 		$mform->addElement('hidden', 'inpopup');
! 		$mform->setType('inpopup', PARAM_INT);
! 
! 		$mform->addElement('hidden', 'versioning');
! 		$mform->setType('versioning', PARAM_BOOL);
! 
! 		$mform->addElement('hidden', 'cmid');
! 		$mform->setType('cmid', PARAM_INT);
! 		$mform->setDefault('cmid', 0);
! 
! 		$mform->addElement('hidden', 'courseid');
! 		$mform->setType('courseid', PARAM_INT);
! 		$mform->setDefault('courseid', 0);
! 
! 		$mform->addElement('hidden', 'returnurl');
! 		$mform->setType('returnurl', PARAM_LOCALURL);
! 		$mform->setDefault('returnurl', 0);
! 
! 		$buttonarray = array();
! 		$buttonarray[] = $mform->createElement('submit', 'submitbutton', get_string('savechanges'));
! 		$buttonarray[] = $mform->createElement('cancel');
! 		$mform->addGroup($buttonarray, 'buttonar', '', array(' '), false);
! 		$mform->closeHeaderBefore('buttonar');
! 	}
! 
! 	function set_data($question) {
! 		$question->questiontext = array('text' => $question->questiontext);
! 		// We don't want the complex stuff in the base class to run.
! 		moodleform::set_data($question);
! 	}
! 
! 	function validation($fromform, $files) {
! 		//validation of category
! 		//is not relevant for this question type
! 		return array();
! 	}
! 
! 	function qtype() {
! 		return 'random';
! 	}
  }
diff -crB questionorg/type/random/questiontype.php questionupd/type/random/questiontype.php
*** questionorg/type/random/questiontype.php	2012-04-13 12:31:12.248178268 +0500
--- questionupd/type/random/questiontype.php	2012-04-13 09:42:58.000000000 +0500
***************
*** 11,385 ****
   * @subpackage questiontypes
   */
  class random_qtype extends default_questiontype {
!     protected $excludedqtypes = null;
!     protected $manualqtypes = null;
  
!     // Caches questions available as randoms sorted by category
!     // This is a 2-d array. The first key is question category, and the
!     // second is whether to include subcategories.
!     private $catrandoms = array();
! 
!     function name() {
!         return 'random';
!     }
! 
!     function menu_name() {
!         // Don't include this question type in the 'add new question' menu.
!         return false;
!     }
! 
!     function show_analysis_of_responses() {
!         return true;
!     }
! 
!     function is_manual_graded() {
!         return true;
!     }
! 
!     function is_question_manual_graded($question, $otherquestionsinuse) {
!         global $DB;
!         // We take our best shot at working whether a particular question is manually
!         // graded follows: We look to see if any of the questions that this random
!         // question might select if of a manually graded type. If a category contains
!         // a mixture of manual and non-manual questions, and if all the attempts so
!         // far selected non-manual ones, this will give the wrong answer, but we
!         // don't care. Even so, this is an expensive calculation!
!         $this->init_qtype_lists();
!         if (!$this->manualqtypes) {
!             return false;
!         }
!         if ($question->questiontext) {
!             $categorylist = question_categorylist($question->category);
!         } else {
!             $categorylist = $question->category;
!         }
!         return $DB->record_exists_select('question',
                  "category IN ($categorylist)
                       AND parent = 0
                       AND hidden = 0
                       AND id NOT IN ($otherquestionsinuse)
                       AND qtype IN ($this->manualqtypes)");
!     }
  
!     function is_usable_by_random() {
!         return false;
!     }
! 
!     /**
!      * This method needs to be called before the ->excludedqtypes and
!      *      ->manualqtypes fields can be used.
!      */
!     function init_qtype_lists() {
!         global $QTYPES;
!         if (is_null($this->excludedqtypes)) {
!             $excludedqtypes = array();
!             $manualqtypes = array();
!             foreach ($QTYPES as $qtype) {
!                 $quotedname = "'" . $qtype->name() . "'";
!                 if (!$qtype->is_usable_by_random()) {
!                     $excludedqtypes[] = $quotedname;
!                 } else if ($qtype->is_manual_graded()) {
!                     $manualqtypes[] = $quotedname;
!                 }
!             }
!             $this->excludedqtypes = implode(',', $excludedqtypes);
!             $this->manualqtypes = implode(',', $manualqtypes);
!         }
!     }
! 
!     function display_question_editing_page(&$mform, $question, $wizardnow){
!         global $OUTPUT;
!         $heading = $this->get_heading(empty($question->id));
!         echo $OUTPUT->heading_with_help($heading, $this->name(), $this->plugin_name());
!         $mform->display();
!     }
! 
!     function get_question_options(&$question) {
!         // Don't do anything here, because the random question has no options.
!         // Everything is handled by the create- or restore_session_and_responses
!         // functions.
!         return true;
!     }
! 
!     /**
!      * Random questions always get a question name that is Random (cateogryname).
!      * This function is a centralised place to calculate that, given the category.
!      * @param object $category the category this question picks from. (Only $category->name is used.)
!      * @param boolean $includesubcategories whether this question also picks from subcategories.
!      * @return string the name this question should have.
!      */
!     function question_name($category, $includesubcategories) {
!         if ($includesubcategories) {
!             $string = 'randomqplusname';
!         } else {
!             $string = 'randomqname';
!         }
!         return get_string($string, 'qtype_random', $category->name);
!     }
! 
!     function save_question($question, $form) {
!         $form->name = '';
!         // Name is not a required field for random questions, but parent::save_question
!         // Assumes that it is.
!         return parent::save_question($question, $form);
!     }
! 
!     function save_question_options($question) {
!         global $DB;
! 
!         // No options, as such, but we set the parent field to the question's
!         // own id. Setting the parent field has the effect of hiding this
!         // question in various places.
!         $updateobject = new stdClass;
!         $updateobject->id = $question->id;
!         $updateobject->parent = $question->id;
! 
!         // We also force the question name to be 'Random (categoryname)'.
!         if (!$category = $DB->get_record('question_categories', array('id' => $question->category))) {
!             print_error('cannotretrieveqcat', 'question');
!         }
!         $updateobject->name = $this->question_name($category, !empty($question->questiontext));
!         return $DB->update_record('question', $updateobject);
!     }
! 
!     /**
!      * Get all the usable questions from a particular question category.
!      *
!      * @param integer $categoryid the id of a question category.
!      * @param boolean whether to include questions from subcategories.
!      * @param string $questionsinuse comma-separated list of question ids to exclude from consideration.
!      * @return array of question records.
!      */
!     function get_usable_questions_from_category($categoryid, $subcategories, $questionsinuse) {
!         global $DB;
!         $this->init_qtype_lists();
!         if ($subcategories) {
!             $categorylist = question_categorylist($categoryid);
!         } else {
!             $categorylist = $categoryid;
!         }
!         if (!$catrandoms = $DB->get_records_select('question',
                  "category IN ($categorylist)
                       AND parent = 0
                       AND hidden = 0
                       AND id NOT IN ($questionsinuse)
                       AND qtype NOT IN ($this->excludedqtypes)", null, '', 'id')) {
!             $catrandoms = array();
!         }
!         return $catrandoms;
!     }
! 
!     function create_session_and_responses(&$question, &$state, $cmoptions, $attempt) {
!         global $QTYPES, $DB;
!         // Choose a random question from the category:
!         // We need to make sure that no question is used more than once in the
!         // quiz. Therfore the following need to be excluded:
!         // 1. All questions that are explicitly assigned to the quiz
!         // 2. All random questions
!         // 3. All questions that are already chosen by an other random question
!         // 4. Deleted questions
!         if (!isset($cmoptions->questionsinuse)) {
!             $cmoptions->questionsinuse = $attempt->layout;
!         }
! 
!         if (!isset($this->catrandoms[$question->category][$question->questiontext])) {
!             $catrandoms = $this->get_usable_questions_from_category($question->category,
!                     $question->questiontext == "1", $cmoptions->questionsinuse);
!             $this->catrandoms[$question->category][$question->questiontext] = swapshuffle_assoc($catrandoms);
!         }
! 
!         while ($wrappedquestion = array_pop(
!                 $this->catrandoms[$question->category][$question->questiontext])) {
!             if (!preg_match("~(^|,)$wrappedquestion->id(,|$)~", $cmoptions->questionsinuse)) {
!                 /// $randomquestion is not in use and will therefore be used
!                 /// as the randomquestion here...
!                 $wrappedquestion = $DB->get_record('question', array('id' => $wrappedquestion->id));
!                 global $QTYPES;
!                 $QTYPES[$wrappedquestion->qtype]
!                         ->get_question_options($wrappedquestion);
!                 $QTYPES[$wrappedquestion->qtype]
!                         ->create_session_and_responses($wrappedquestion,
!                         $state, $cmoptions, $attempt);
!                 $wrappedquestion->name_prefix = $question->name_prefix;
!                 $wrappedquestion->maxgrade = $question->maxgrade;
!                 $cmoptions->questionsinuse .= ",$wrappedquestion->id";
!                 $state->options->question = &$wrappedquestion;
!                 return true;
!             }
!         }
!         $question->questiontext = '<span class="notifyproblem">'.
!                 get_string('toomanyrandom', 'quiz'). '</span>';
!         $question->qtype = 'description';
!         $state->responses = array('' => '');
!         return true;
!     }
! 
!     function restore_session_and_responses(&$question, &$state) {
!         /// The raw response records for random questions come in two flavours:
!         /// ---- 1 ----
!         /// For responses stored by Moodle version 1.5 and later the answer
!         /// field has the pattern random#-* where the # part is the numeric
!         /// question id of the actual question shown in the quiz attempt
!         /// and * represents the student response to that actual question.
!         /// ---- 2 ----
!         /// For responses stored by older Moodle versions - the answer field is
!         /// simply the question id of the actual question. The student response
!         /// to the actual question is stored in a separate response record.
!         /// -----------------------
!         /// This means that prior to Moodle version 1.5, random questions needed
!         /// two response records for storing the response to a single question.
!         /// From version 1.5 and later the question type random works like all
!         /// the other question types in that it now only needs one response
!         /// record per question.
!         global $QTYPES, $DB, $OUTPUT;
!         if (!preg_match('~^random([0-9]+)-~', $state->responses[''], $matches)) {
!             if (empty($state->responses[''])) {
!                 // This is the case if there weren't enough questions available in the category.
!                 $question->questiontext = '<span class="notifyproblem">'.
!                  get_string('toomanyrandom', 'quiz'). '</span>';
!                 $question->qtype = 'description';
!                 return true;
!             }
!             // this must be an old-style state which stores only the id for the wrapped question
!             if (!$wrappedquestion = $DB->get_record('question', array('id' => $state->responses['']))) {
!                 echo $OUTPUT->notification("Can not find wrapped question {$state->responses['']}");
!             }
!             // In the old model the actual response was stored in a separate entry in
!             // the state table and fortunately there was only a single state per question
!             if (!$state->responses[''] = $DB->get_field('question_states', 'answer', array('attempt' => $state->attempt, 'question' => $wrappedquestion->id))) {
!                 echo $OUTPUT->notification("Wrapped state missing");
!             }
!         } else {
!             $questionid = $matches[1];
!             if (!$wrappedquestion = $DB->get_record('question', array('id' => $questionid))) {
!                 // The teacher must have deleted this question by mistake
!                 // Convert it into a description type question with an explanation to the student
!                 $wrappedquestion = clone($question);
!                 $wrappedquestion->id = $questionid;
!                 $wrappedquestion->questiontext = get_string('questiondeleted', 'quiz');
!                 $wrappedquestion->qtype = 'missingtype';
!             }
!             $state->responses[''] = substr($state->responses[''], strlen('random' . $questionid . '-'));
!             if ($state->responses[''] === false) {
!                 // In PHP, if $response === $prefix, then
!                 // substr($response, strlen($prefix)) returns false, not '',
!                 // which is stupid, and caused MDL-26520. Fix up that case here.
!                 $state->responses[''] = '';
!             }
!         }
! 
!         if (!$QTYPES[$wrappedquestion->qtype]
!          ->get_question_options($wrappedquestion)) {
!             return false;
!         }
! 
!         if (!$QTYPES[$wrappedquestion->qtype]
!          ->restore_session_and_responses($wrappedquestion, $state)) {
!             return false;
!         }
!         $wrappedquestion->name_prefix = $question->name_prefix;
!         $wrappedquestion->maxgrade    = $question->maxgrade;
!         $state->options->question = &$wrappedquestion;
!         return true;
!     }
! 
!     function save_session_and_responses(&$question, &$state) {
!         global $QTYPES, $DB;
!         $wrappedquestion = &$state->options->question;
! 
!         // Trick the wrapped question into pretending to be the random one.
!         $realqid = $wrappedquestion->id;
!         $wrappedquestion->id = $question->id;
!         $QTYPES[$wrappedquestion->qtype]
!          ->save_session_and_responses($wrappedquestion, $state);
! 
!         // Read what the wrapped question has just set the answer field to
!         // (if anything)
!         $response = $DB->get_field('question_states', 'answer', array('id' => $state->id));
!         if(false === $response) {
!             return false;
!         }
! 
!         // Prefix the answer field...
!         $response = "random$realqid-$response";
! 
!         // ... and save it again.
!         $DB->set_field('question_states', 'answer', $response, array('id' => $state->id));
! 
!         // Restore the real id
!         $wrappedquestion->id = $realqid;
!         return true;
!     }
! 
!     function get_correct_responses(&$question, &$state) {
!         global $QTYPES;
!         $wrappedquestion = &$state->options->question;
!         return $QTYPES[$wrappedquestion->qtype]
!          ->get_correct_responses($wrappedquestion, $state);
!     }
! 
!     // ULPGC ecastro
!     function get_all_responses(&$question, &$state){
!         global $QTYPES;
!         $wrappedquestion = &$state->options->question;
!         return $QTYPES[$wrappedquestion->qtype]
!          ->get_all_responses($wrappedquestion, $state);
!     }
! 
!     // ULPGC ecastro
!     function get_actual_response(&$question, &$state){
!         global $QTYPES;
!         $wrappedquestion = &$state->options->question;
!         return $QTYPES[$wrappedquestion->qtype]
!          ->get_actual_response($wrappedquestion, $state);
!     }
! 
!     function get_html_head_contributions(&$question, &$state) {
!         global $QTYPES;
!         $wrappedquestion = &$state->options->question;
!         return $QTYPES[$wrappedquestion->qtype]
!                 ->get_html_head_contributions($wrappedquestion, $state);
!     }
! 
!     function print_question(&$question, &$state, &$number, $cmoptions, $options) {
!         global $QTYPES;
!         $wrappedquestion = &$state->options->question;
!         $wrappedquestion->randomquestionid = $question->id;
!         $QTYPES[$wrappedquestion->qtype]
!          ->print_question($wrappedquestion, $state, $number, $cmoptions, $options);
!     }
! 
!     function grade_responses(&$question, &$state, $cmoptions) {
!         global $QTYPES;
!         $wrappedquestion = &$state->options->question;
!         return $QTYPES[$wrappedquestion->qtype]
!          ->grade_responses($wrappedquestion, $state, $cmoptions);
!     }
! 
!     function get_texsource(&$question, &$state, $cmoptions, $type) {
!         global $QTYPES;
!         $wrappedquestion = &$state->options->question;
!         return $QTYPES[$wrappedquestion->qtype]
!          ->get_texsource($wrappedquestion, $state, $cmoptions, $type);
!     }
! 
!     function compare_responses(&$question, $state, $teststate) {
!         global $QTYPES;
!         $wrappedquestion = &$teststate->options->question;
!         return $QTYPES[$wrappedquestion->qtype]
!          ->compare_responses($wrappedquestion, $state, $teststate);
!     }
! 
!     /**
!      * For random question type return empty string which means won't calculate.
!      * @param object $question
!      * @return mixed either a integer score out of 1 that the average random
!      * guess by a student might give or an empty string which means will not
!      * calculate.
!      */
!     function get_random_guess_score($question) {
!         return '';
!     }
  
  }
  //// END OF CLASS ////
--- 11,385 ----
   * @subpackage questiontypes
   */
  class random_qtype extends default_questiontype {
! 	protected $excludedqtypes = null;
! 	protected $manualqtypes = null;
  
! 	// Caches questions available as randoms sorted by category
! 	// This is a 2-d array. The first key is question category, and the
! 	// second is whether to include subcategories.
! 	private $catrandoms = array();
! 
! 	function name() {
! 		return 'random';
! 	}
! 
! 	function menu_name() {
! 		// Don't include this question type in the 'add new question' menu.
! 		return false;
! 	}
! 
! 	function show_analysis_of_responses() {
! 		return true;
! 	}
! 
! 	function is_manual_graded() {
! 		return true;
! 	}
! 
! 	function is_question_manual_graded($question, $otherquestionsinuse) {
! 		global $DB;
! 		// We take our best shot at working whether a particular question is manually
! 		// graded follows: We look to see if any of the questions that this random
! 		// question might select if of a manually graded type. If a category contains
! 		// a mixture of manual and non-manual questions, and if all the attempts so
! 		// far selected non-manual ones, this will give the wrong answer, but we
! 		// don't care. Even so, this is an expensive calculation!
! 		$this->init_qtype_lists();
! 		if (!$this->manualqtypes) {
! 			return false;
! 		}
! 		if ($question->questiontext) {
! 			$categorylist = question_categorylist($question->category);
! 		} else {
! 			$categorylist = $question->category;
! 		}
! 		return $DB->record_exists_select('question',
                  "category IN ($categorylist)
                       AND parent = 0
                       AND hidden = 0
                       AND id NOT IN ($otherquestionsinuse)
                       AND qtype IN ($this->manualqtypes)");
! 	}
  
! 	function is_usable_by_random() {
! 		return false;
! 	}
! 
! 	/**
! 	 * This method needs to be called before the ->excludedqtypes and
! 	 *      ->manualqtypes fields can be used.
! 	 */
! 	function init_qtype_lists() {
! 		global $QTYPES;
! 		if (is_null($this->excludedqtypes)) {
! 			$excludedqtypes = array();
! 			$manualqtypes = array();
! 			foreach ($QTYPES as $qtype) {
! 				$quotedname = "'" . $qtype->name() . "'";
! 				if (!$qtype->is_usable_by_random()) {
! 					$excludedqtypes[] = $quotedname;
! 				} else if ($qtype->is_manual_graded()) {
! 					$manualqtypes[] = $quotedname;
! 				}
! 			}
! 			$this->excludedqtypes = implode(',', $excludedqtypes);
! 			$this->manualqtypes = implode(',', $manualqtypes);
! 		}
! 	}
! 
! 	function display_question_editing_page(&$mform, $question, $wizardnow){
! 		global $OUTPUT;
! 		$heading = $this->get_heading(empty($question->id));
! 		echo $OUTPUT->heading_with_help($heading, $this->name(), $this->plugin_name());
! 		$mform->display();
! 	}
! 
! 	function get_question_options(&$question) {
! 		// Don't do anything here, because the random question has no options.
! 		// Everything is handled by the create- or restore_session_and_responses
! 		// functions.
! 		return true;
! 	}
! 
! 	/**
! 	 * Random questions always get a question name that is Random (cateogryname).
! 	 * This function is a centralised place to calculate that, given the category.
! 	 * @param object $category the category this question picks from. (Only $category->name is used.)
! 	 * @param boolean $includesubcategories whether this question also picks from subcategories.
! 	 * @return string the name this question should have.
! 	 */
! 	function question_name($category, $includesubcategories) {
! 		if ($includesubcategories) {
! 			$string = 'randomqplusname';
! 		} else {
! 			$string = 'randomqname';
! 		}
! 		return get_string($string, 'qtype_random', $category->name);
! 	}
! 
! 	function save_question($question, $form) {
! 		$form->name = '';
! 		// Name is not a required field for random questions, but parent::save_question
! 		// Assumes that it is.
! 		return parent::save_question($question, $form);
! 	}
! 
! 	function save_question_options($question) {
! 		global $DB;
! 
! 		// No options, as such, but we set the parent field to the question's
! 		// own id. Setting the parent field has the effect of hiding this
! 		// question in various places.
! 		$updateobject = new stdClass;
! 		$updateobject->id = $question->id;
! 		$updateobject->parent = $question->id;
! 
! 		// We also force the question name to be 'Random (categoryname)'.
! 		if (!$category = $DB->get_record('question_categories', array('id' => $question->category))) {
! 			print_error('cannotretrieveqcat', 'question');
! 		}
! 		$updateobject->name = $this->question_name($category, !empty($question->questiontext));
! 		return $DB->update_record('question', $updateobject);
! 	}
! 
! 	/**
! 	 * Get all the usable questions from a particular question category.
! 	 *
! 	 * @param integer $categoryid the id of a question category.
! 	 * @param boolean whether to include questions from subcategories.
! 	 * @param string $questionsinuse comma-separated list of question ids to exclude from consideration.
! 	 * @return array of question records.
! 	 */
! 	function get_usable_questions_from_category($categoryid, $subcategories, $questionsinuse) {
! 		global $DB;
! 		$this->init_qtype_lists();
! 		if ($subcategories) {
! 			$categorylist = question_categorylist($categoryid);
! 		} else {
! 			$categorylist = $categoryid;
! 		}
! 		if (!$catrandoms = $DB->get_records_select('question',
                  "category IN ($categorylist)
                       AND parent = 0
                       AND hidden = 0
                       AND id NOT IN ($questionsinuse)
                       AND qtype NOT IN ($this->excludedqtypes)", null, '', 'id')) {
! 		$catrandoms = array();
!                      }
!                      return $catrandoms;
! 	}
! 
! 	function create_session_and_responses(&$question, &$state, $cmoptions, $attempt) {
! 		global $QTYPES, $DB;
! 		// Choose a random question from the category:
! 		// We need to make sure that no question is used more than once in the
! 		// quiz. Therfore the following need to be excluded:
! 		// 1. All questions that are explicitly assigned to the quiz
! 		// 2. All random questions
! 		// 3. All questions that are already chosen by an other random question
! 		// 4. Deleted questions
! 		if (!isset($cmoptions->questionsinuse)) {
! 			$cmoptions->questionsinuse = $attempt->layout;
! 		}
! 
! 		if (!isset($this->catrandoms[$question->category][$question->questiontext])) {
! 			$catrandoms = $this->get_usable_questions_from_category($question->category,
! 			$question->questiontext == "1", $cmoptions->questionsinuse);
! 			$this->catrandoms[$question->category][$question->questiontext] = swapshuffle_assoc($catrandoms);
! 		}
! 
! 		while ($wrappedquestion = array_pop(
! 		$this->catrandoms[$question->category][$question->questiontext])) {
! 			if (!preg_match("~(^|,)$wrappedquestion->id(,|$)~", $cmoptions->questionsinuse)) {
! 				/// $randomquestion is not in use and will therefore be used
! 				/// as the randomquestion here...
! 				$wrappedquestion = $DB->get_record('question', array('id' => $wrappedquestion->id));
! 				global $QTYPES;
! 				$QTYPES[$wrappedquestion->qtype]
! 				->get_question_options($wrappedquestion);
! 				$QTYPES[$wrappedquestion->qtype]
! 				->create_session_and_responses($wrappedquestion,
! 				$state, $cmoptions, $attempt);
! 				$wrappedquestion->name_prefix = $question->name_prefix;
! 				$wrappedquestion->maxgrade = $question->maxgrade;
! 				$cmoptions->questionsinuse .= ",$wrappedquestion->id";
! 				$state->options->question = &$wrappedquestion;
! 				return true;
! 			}
! 		}
! 		$question->questiontext = '<span class="notifyproblem">'.
! 		get_string('toomanyrandom', 'quiz'). '</span>';
! 		$question->qtype = 'description';
! 		$state->responses = array('' => '');
! 		return true;
! 	}
! 
! 	function restore_session_and_responses(&$question, &$state) {
! 		/// The raw response records for random questions come in two flavours:
! 		/// ---- 1 ----
! 		/// For responses stored by Moodle version 1.5 and later the answer
! 		/// field has the pattern random#-* where the # part is the numeric
! 		/// question id of the actual question shown in the quiz attempt
! 		/// and * represents the student response to that actual question.
! 		/// ---- 2 ----
! 		/// For responses stored by older Moodle versions - the answer field is
! 		/// simply the question id of the actual question. The student response
! 		/// to the actual question is stored in a separate response record.
! 		/// -----------------------
! 		/// This means that prior to Moodle version 1.5, random questions needed
! 		/// two response records for storing the response to a single question.
! 		/// From version 1.5 and later the question type random works like all
! 		/// the other question types in that it now only needs one response
! 		/// record per question.
! 		global $QTYPES, $DB, $OUTPUT;
! 		if (!preg_match('~^random([0-9]+)-~', $state->responses[''], $matches)) {
! 			if (empty($state->responses[''])) {
! 				// This is the case if there weren't enough questions available in the category.
! 				$question->questiontext = '<span class="notifyproblem">'.
! 				get_string('toomanyrandom', 'quiz'). '</span>';
! 				$question->qtype = 'description';
! 				return true;
! 			}
! 			// this must be an old-style state which stores only the id for the wrapped question
! 			if (!$wrappedquestion = $DB->get_record('question', array('id' => $state->responses['']))) {
! 				echo $OUTPUT->notification("Can not find wrapped question {$state->responses['']}");
! 			}
! 			// In the old model the actual response was stored in a separate entry in
! 			// the state table and fortunately there was only a single state per question
! 			if (!$state->responses[''] = $DB->get_field('question_states', 'answer', array('attempt' => $state->attempt, 'question' => $wrappedquestion->id))) {
! 				echo $OUTPUT->notification("Wrapped state missing");
! 			}
! 		} else {
! 			$questionid = $matches[1];
! 			if (!$wrappedquestion = $DB->get_record('question', array('id' => $questionid))) {
! 				// The teacher must have deleted this question by mistake
! 				// Convert it into a description type question with an explanation to the student
! 				$wrappedquestion = clone($question);
! 				$wrappedquestion->id = $questionid;
! 				$wrappedquestion->questiontext = get_string('questiondeleted', 'quiz');
! 				$wrappedquestion->qtype = 'missingtype';
! 			}
! 			$state->responses[''] = substr($state->responses[''], strlen('random' . $questionid . '-'));
! 			if ($state->responses[''] === false) {
! 				// In PHP, if $response === $prefix, then
! 				// substr($response, strlen($prefix)) returns false, not '',
! 				// which is stupid, and caused MDL-26520. Fix up that case here.
! 				$state->responses[''] = '';
! 			}
! 		}
! 
! 		if (!$QTYPES[$wrappedquestion->qtype]
! 		->get_question_options($wrappedquestion)) {
! 			return false;
! 		}
! 
! 		if (!$QTYPES[$wrappedquestion->qtype]
! 		->restore_session_and_responses($wrappedquestion, $state)) {
! 			return false;
! 		}
! 		$wrappedquestion->name_prefix = $question->name_prefix;
! 		$wrappedquestion->maxgrade    = $question->maxgrade;
! 		$state->options->question = &$wrappedquestion;
! 		return true;
! 	}
! 
! 	function save_session_and_responses(&$question, &$state) {
! 		global $QTYPES, $DB;
! 		$wrappedquestion = &$state->options->question;
! 
! 		// Trick the wrapped question into pretending to be the random one.
! 		$realqid = $wrappedquestion->id;
! 		$wrappedquestion->id = $question->id;
! 		$QTYPES[$wrappedquestion->qtype]
! 		->save_session_and_responses($wrappedquestion, $state);
! 
! 		// Read what the wrapped question has just set the answer field to
! 		// (if anything)
! 		$response = $DB->get_field('question_states', 'answer', array('id' => $state->id));
! 		if(false === $response) {
! 			return false;
! 		}
! 
! 		// Prefix the answer field...
! 		$response = "random$realqid-$response";
! 
! 		// ... and save it again.
! 		$DB->set_field('question_states', 'answer', $response, array('id' => $state->id));
! 
! 		// Restore the real id
! 		$wrappedquestion->id = $realqid;
! 		return true;
! 	}
! 
! 	function get_correct_responses(&$question, &$state) {
! 		global $QTYPES;
! 		$wrappedquestion = &$state->options->question;
! 		return $QTYPES[$wrappedquestion->qtype]
! 		->get_correct_responses($wrappedquestion, $state);
! 	}
! 
! 	// ULPGC ecastro
! 	function get_all_responses(&$question, &$state){
! 		global $QTYPES;
! 		$wrappedquestion = &$state->options->question;
! 		return $QTYPES[$wrappedquestion->qtype]
! 		->get_all_responses($wrappedquestion, $state);
! 	}
! 
! 	// ULPGC ecastro
! 	function get_actual_response(&$question, &$state){
! 		global $QTYPES;
! 		$wrappedquestion = &$state->options->question;
! 		return $QTYPES[$wrappedquestion->qtype]
! 		->get_actual_response($wrappedquestion, $state);
! 	}
! 
! 	function get_html_head_contributions(&$question, &$state) {
! 		global $QTYPES;
! 		$wrappedquestion = &$state->options->question;
! 		return $QTYPES[$wrappedquestion->qtype]
! 		->get_html_head_contributions($wrappedquestion, $state);
! 	}
! 
! 	function print_question(&$question, &$state, &$number, $cmoptions, $options) {
! 		global $QTYPES;
! 		$wrappedquestion = &$state->options->question;
! 		$wrappedquestion->randomquestionid = $question->id;
! 		$QTYPES[$wrappedquestion->qtype]
! 		->print_question($wrappedquestion, $state, $number, $cmoptions, $options);
! 	}
! 
! 	function grade_responses(&$question, &$state, $cmoptions) {
! 		global $QTYPES;
! 		$wrappedquestion = &$state->options->question;
! 		return $QTYPES[$wrappedquestion->qtype]
! 		->grade_responses($wrappedquestion, $state, $cmoptions);
! 	}
! 
! 	function get_texsource(&$question, &$state, $cmoptions, $type) {
! 		global $QTYPES;
! 		$wrappedquestion = &$state->options->question;
! 		return $QTYPES[$wrappedquestion->qtype]
! 		->get_texsource($wrappedquestion, $state, $cmoptions, $type);
! 	}
! 
! 	function compare_responses(&$question, $state, $teststate) {
! 		global $QTYPES;
! 		$wrappedquestion = &$teststate->options->question;
! 		return $QTYPES[$wrappedquestion->qtype]
! 		->compare_responses($wrappedquestion, $state, $teststate);
! 	}
! 
! 	/**
! 	 * For random question type return empty string which means won't calculate.
! 	 * @param object $question
! 	 * @return mixed either a integer score out of 1 that the average random
! 	 * guess by a student might give or an empty string which means will not
! 	 * calculate.
! 	 */
! 	function get_random_guess_score($question) {
! 		return '';
! 	}
  
  }
  //// END OF CLASS ////
diff -crB questionorg/type/randomsamatch/backup/moodle2/backup_qtype_randomsamatch_plugin.class.php questionupd/type/randomsamatch/backup/moodle2/backup_qtype_randomsamatch_plugin.class.php
*** questionorg/type/randomsamatch/backup/moodle2/backup_qtype_randomsamatch_plugin.class.php	2012-04-13 12:31:14.335178297 +0500
--- questionupd/type/randomsamatch/backup/moodle2/backup_qtype_randomsamatch_plugin.class.php	2012-04-13 09:42:58.000000000 +0500
***************
*** 28,59 ****
   */
  class backup_qtype_randomsamatch_plugin extends backup_qtype_plugin {
  
!     /**
!      * Returns the qtype information to attach to question element
!      */
!     protected function define_question_plugin_structure() {
! 
!         // Define the virtual plugin element with the condition to fulfill
!         $plugin = $this->get_plugin_element(null, '../../qtype', 'randomsamatch');
  
!         // Create one standard named plugin element (the visible container)
!         $pluginwrapper = new backup_nested_element($this->get_recommended_name());
  
!         // connect the visible container ASAP
!         $plugin->add_child($pluginwrapper);
  
!         // Now create the qtype own structures
!         $randomsamatch = new backup_nested_element('randomsamatch', array('id'), array(
              'choose'));
  
!         // Now the own qtype tree
!         $pluginwrapper->add_child($randomsamatch);
  
!         // set source to populate the data
!         $randomsamatch->set_source_table('question_randomsamatch', array('question' => backup::VAR_PARENTID));
  
!         // don't need to annotate ids nor files
  
!         return $plugin;
!     }
  }
--- 28,59 ----
   */
  class backup_qtype_randomsamatch_plugin extends backup_qtype_plugin {
  
! 	/**
! 	 * Returns the qtype information to attach to question element
! 	 */
! 	protected function define_question_plugin_structure() {
! 
! 		// Define the virtual plugin element with the condition to fulfill
! 		$plugin = $this->get_plugin_element(null, '../../qtype', 'randomsamatch');
  
! 		// Create one standard named plugin element (the visible container)
! 		$pluginwrapper = new backup_nested_element($this->get_recommended_name());
  
! 		// connect the visible container ASAP
! 		$plugin->add_child($pluginwrapper);
  
! 		// Now create the qtype own structures
! 		$randomsamatch = new backup_nested_element('randomsamatch', array('id'), array(
              'choose'));
  
! 		// Now the own qtype tree
! 		$pluginwrapper->add_child($randomsamatch);
  
! 		// set source to populate the data
! 		$randomsamatch->set_source_table('question_randomsamatch', array('question' => backup::VAR_PARENTID));
  
! 		// don't need to annotate ids nor files
  
! 		return $plugin;
! 	}
  }
diff -crB questionorg/type/randomsamatch/backup/moodle2/restore_qtype_randomsamatch_plugin.class.php questionupd/type/randomsamatch/backup/moodle2/restore_qtype_randomsamatch_plugin.class.php
*** questionorg/type/randomsamatch/backup/moodle2/restore_qtype_randomsamatch_plugin.class.php	2012-04-13 12:31:14.294178306 +0500
--- questionupd/type/randomsamatch/backup/moodle2/restore_qtype_randomsamatch_plugin.class.php	2012-04-13 09:42:58.000000000 +0500
***************
*** 30,96 ****
   */
  class restore_qtype_randomsamatch_plugin extends restore_qtype_plugin {
  
!     /**
!      * Returns the paths to be handled by the plugin at question level
!      */
!     protected function define_question_plugin_structure() {
! 
!         $paths = array();
! 
!         // Add own qtype stuff
!         $elename = 'randomsamatch';
!         $elepath = $this->get_pathfor('/randomsamatch'); // we used get_recommended_name() so this works
!         $paths[] = new restore_path_element($elename, $elepath);
! 
! 
!         return $paths; // And we return the interesting paths
!     }
! 
!     /**
!      * Process the qtype/randomsamatch element
!      */
!     public function process_randomsamatch($data) {
!         global $DB;
! 
!         $data = (object)$data;
!         $oldid = $data->id;
! 
!         // Detect if the question is created or mapped
!         $oldquestionid   = $this->get_old_parentid('question');
!         $newquestionid   = $this->get_new_parentid('question');
!         $questioncreated = $this->get_mappingid('question_created', $oldquestionid) ? true : false;
! 
!         // If the question has been created by restore, we need to create its question_randomsamatch too
!         if ($questioncreated) {
!             // Adjust some columns
!             $data->question = $newquestionid;
!             // Insert record
!             $newitemid = $DB->insert_record('question_randomsamatch', $data);
!             // Create mapping
!             $this->set_mapping('question_randomsamatch', $oldid, $newitemid);
!         } else {
!             // Nothing to remap if the question already existed
!         }
!     }
! 
!     /**
!      * Given one question_states record, return the answer
!      * recoded pointing to all the restored stuff for randomsamatch questions
!      *
!      * answer is one comma separated list of hypen separated pairs
!      * containing question->id and question_answers->id
!      */
!     public function recode_state_answer($state) {
!         $answer = $state->answer;
!         $resultarr = array();
!         foreach (explode(',', $answer) as $pair) {
!             $pairarr = explode('-', $pair);
!             $questionid = $pairarr[0];
!             $answerid = $pairarr[1];
!             $newquestionid = $questionid ? $this->get_mappingid('question', $questionid) : 0;
!             $newanswerid = $answerid ? $this->get_mappingid('question_answer', $answerid) : 0;
!             $resultarr[] = implode('-', array($newquestionid, $newanswerid));
!         }
!         return implode(',', $resultarr);
!     }
  }
--- 30,96 ----
   */
  class restore_qtype_randomsamatch_plugin extends restore_qtype_plugin {
  
! 	/**
! 	 * Returns the paths to be handled by the plugin at question level
! 	 */
! 	protected function define_question_plugin_structure() {
! 
! 		$paths = array();
! 
! 		// Add own qtype stuff
! 		$elename = 'randomsamatch';
! 		$elepath = $this->get_pathfor('/randomsamatch'); // we used get_recommended_name() so this works
! 		$paths[] = new restore_path_element($elename, $elepath);
! 
! 
! 		return $paths; // And we return the interesting paths
! 	}
! 
! 	/**
! 	 * Process the qtype/randomsamatch element
! 	 */
! 	public function process_randomsamatch($data) {
! 		global $DB;
! 
! 		$data = (object)$data;
! 		$oldid = $data->id;
! 
! 		// Detect if the question is created or mapped
! 		$oldquestionid   = $this->get_old_parentid('question');
! 		$newquestionid   = $this->get_new_parentid('question');
! 		$questioncreated = $this->get_mappingid('question_created', $oldquestionid) ? true : false;
! 
! 		// If the question has been created by restore, we need to create its question_randomsamatch too
! 		if ($questioncreated) {
! 			// Adjust some columns
! 			$data->question = $newquestionid;
! 			// Insert record
! 			$newitemid = $DB->insert_record('question_randomsamatch', $data);
! 			// Create mapping
! 			$this->set_mapping('question_randomsamatch', $oldid, $newitemid);
! 		} else {
! 			// Nothing to remap if the question already existed
! 		}
! 	}
! 
! 	/**
! 	 * Given one question_states record, return the answer
! 	 * recoded pointing to all the restored stuff for randomsamatch questions
! 	 *
! 	 * answer is one comma separated list of hypen separated pairs
! 	 * containing question->id and question_answers->id
! 	 */
! 	public function recode_state_answer($state) {
! 		$answer = $state->answer;
! 		$resultarr = array();
! 		foreach (explode(',', $answer) as $pair) {
! 			$pairarr = explode('-', $pair);
! 			$questionid = $pairarr[0];
! 			$answerid = $pairarr[1];
! 			$newquestionid = $questionid ? $this->get_mappingid('question', $questionid) : 0;
! 			$newanswerid = $answerid ? $this->get_mappingid('question_answer', $answerid) : 0;
! 			$resultarr[] = implode('-', array($newquestionid, $newanswerid));
! 		}
! 		return implode(',', $resultarr);
! 	}
  }
diff -crB questionorg/type/randomsamatch/db/install.xml questionupd/type/randomsamatch/db/install.xml
*** questionorg/type/randomsamatch/db/install.xml	2012-04-13 12:31:14.401178301 +0500
--- questionupd/type/randomsamatch/db/install.xml	2012-04-13 09:42:58.000000000 +0500
***************
*** 1,19 ****
  <?xml version="1.0" encoding="UTF-8" ?>
! <XMLDB PATH="question/type/randomsamatch/db" VERSION="20060812" COMMENT="XMLDB file for Moodle question/type/randomsamatch"
!     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
!     xsi:noNamespaceSchemaLocation="../../../../lib/xmldb/xmldb.xsd"
! >
!   <TABLES>
!     <TABLE NAME="question_randomsamatch" COMMENT="Info about a random short-answer matching question">
!       <FIELDS>
!         <FIELD NAME="id" TYPE="int" LENGTH="10" NOTNULL="true" UNSIGNED="true" SEQUENCE="true" NEXT="question"/>
!         <FIELD NAME="question" TYPE="int" LENGTH="10" NOTNULL="true" UNSIGNED="true" DEFAULT="0" SEQUENCE="false" COMMENT="Foreign key references question.id." PREVIOUS="id" NEXT="choose"/>
!         <FIELD NAME="choose" TYPE="int" LENGTH="10" NOTNULL="true" UNSIGNED="true" DEFAULT="4" SEQUENCE="false" COMMENT="Number of subquestions to randomly generate." PREVIOUS="question"/>
!       </FIELDS>
!       <KEYS>
!         <KEY NAME="primary" TYPE="primary" FIELDS="id" NEXT="question"/>
!         <KEY NAME="question" TYPE="foreign" FIELDS="question" REFTABLE="question" REFFIELDS="id" PREVIOUS="primary"/>
!       </KEYS>
!     </TABLE>
!   </TABLES>
  </XMLDB>
--- 1,24 ----
  <?xml version="1.0" encoding="UTF-8" ?>
! <XMLDB PATH="question/type/randomsamatch/db" VERSION="20060812"
! 	COMMENT="XMLDB file for Moodle question/type/randomsamatch" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
! 	xsi:noNamespaceSchemaLocation="../../../../lib/xmldb/xmldb.xsd">
! 	<TABLES>
! 		<TABLE NAME="question_randomsamatch" COMMENT="Info about a random short-answer matching question">
! 			<FIELDS>
! 				<FIELD NAME="id" TYPE="int" LENGTH="10" NOTNULL="true"
! 					UNSIGNED="true" SEQUENCE="true" NEXT="question" />
! 				<FIELD NAME="question" TYPE="int" LENGTH="10" NOTNULL="true"
! 					UNSIGNED="true" DEFAULT="0" SEQUENCE="false"
! 					COMMENT="Foreign key references question.id." PREVIOUS="id" NEXT="choose" />
! 				<FIELD NAME="choose" TYPE="int" LENGTH="10" NOTNULL="true"
! 					UNSIGNED="true" DEFAULT="4" SEQUENCE="false"
! 					COMMENT="Number of subquestions to randomly generate." PREVIOUS="question" />
! 			</FIELDS>
! 			<KEYS>
! 				<KEY NAME="primary" TYPE="primary" FIELDS="id" NEXT="question" />
! 				<KEY NAME="question" TYPE="foreign" FIELDS="question" REFTABLE="question"
! 					REFFIELDS="id" PREVIOUS="primary" />
! 			</KEYS>
! 		</TABLE>
! 	</TABLES>
  </XMLDB>
diff -crB questionorg/type/randomsamatch/edit_randomsamatch_form.php questionupd/type/randomsamatch/edit_randomsamatch_form.php
*** questionorg/type/randomsamatch/edit_randomsamatch_form.php	2012-04-13 12:31:14.397178308 +0500
--- questionupd/type/randomsamatch/edit_randomsamatch_form.php	2012-04-13 09:42:58.000000000 +0500
***************
*** 13,72 ****
   * randomsamatch editing form definition.
   */
  class question_edit_randomsamatch_form extends question_edit_form {
!     /**
!      * Add question-type specific form fields.
!      *
!      * @param MoodleQuickForm $mform the form being built.
!      */
!     function definition_inner(&$mform) {
!         $questionstoselect = array();
!         for ($i=2; $i<=QUESTION_NUMANS; $i++){
!             $questionstoselect[$i] = $i;
!         }
! 
!         $mform->addElement('select', 'choose', get_string("randomsamatchnumber", "quiz"), $questionstoselect);
!         $mform->setType('feedback', PARAM_RAW);
! 
!         $mform->addElement('hidden', 'fraction', 0);
!         $mform->setType('fraction', PARAM_RAW);
!     }
! 
!     function data_preprocessing($question) {
!         if (empty($question->name)) {
!             $question->name =  get_string("randomsamatch", "quiz");
!         }
! 
!         if (empty($question->questiontext)) {
!             $question->questiontext = get_string("randomsamatchintro", "quiz");
!         }
!         return $question;
!     }
! 
!     function qtype() {
!         return 'randomsamatch';
!     }
! 
!     function validation($data, $files) {
!         global $QTYPES, $DB;
!         $errors = parent::validation($data, $files);
!         if (isset($data->categorymoveto)) {
!             list($category) = explode(',', $data['categorymoveto']);
!         } else {
!             list($category) = explode(',', $data['category']);
!         }
!         $saquestions = $QTYPES['randomsamatch']->get_sa_candidates($category);
!         $numberavailable = count($saquestions);
!         if ($saquestions === false){
!             $a = new stdClass();
!             $a->catname = $DB->get_field('question_categories', 'name', array('id' => $category));
!             $errors['choose'] = get_string('nosaincategory', 'qtype_randomsamatch', $a);
! 
!         } elseif ($numberavailable < $data['choose']){
!             $a = new stdClass();
!             $a->catname = $DB->get_field('question_categories', 'name', array('id' => $category));
!             $a->nosaquestions = $numberavailable;
!             $errors['choose'] = get_string('notenoughsaincategory', 'qtype_randomsamatch', $a);
!         }
!         return $errors;
!     }
  }
--- 13,72 ----
   * randomsamatch editing form definition.
   */
  class question_edit_randomsamatch_form extends question_edit_form {
! 	/**
! 	 * Add question-type specific form fields.
! 	 *
! 	 * @param MoodleQuickForm $mform the form being built.
! 	 */
! 	function definition_inner(&$mform) {
! 		$questionstoselect = array();
! 		for ($i=2; $i<=QUESTION_NUMANS; $i++){
! 			$questionstoselect[$i] = $i;
! 		}
! 
! 		$mform->addElement('select', 'choose', get_string("randomsamatchnumber", "quiz"), $questionstoselect);
! 		$mform->setType('feedback', PARAM_RAW);
! 
! 		$mform->addElement('hidden', 'fraction', 0);
! 		$mform->setType('fraction', PARAM_RAW);
! 	}
! 
! 	function data_preprocessing($question) {
! 		if (empty($question->name)) {
! 			$question->name =  get_string("randomsamatch", "quiz");
! 		}
! 
! 		if (empty($question->questiontext)) {
! 			$question->questiontext = get_string("randomsamatchintro", "quiz");
! 		}
! 		return $question;
! 	}
! 
! 	function qtype() {
! 		return 'randomsamatch';
! 	}
! 
! 	function validation($data, $files) {
! 		global $QTYPES, $DB;
! 		$errors = parent::validation($data, $files);
! 		if (isset($data->categorymoveto)) {
! 			list($category) = explode(',', $data['categorymoveto']);
! 		} else {
! 			list($category) = explode(',', $data['category']);
! 		}
! 		$saquestions = $QTYPES['randomsamatch']->get_sa_candidates($category);
! 		$numberavailable = count($saquestions);
! 		if ($saquestions === false){
! 			$a = new stdClass();
! 			$a->catname = $DB->get_field('question_categories', 'name', array('id' => $category));
! 			$errors['choose'] = get_string('nosaincategory', 'qtype_randomsamatch', $a);
! 
! 		} elseif ($numberavailable < $data['choose']){
! 			$a = new stdClass();
! 			$a->catname = $DB->get_field('question_categories', 'name', array('id' => $category));
! 			$a->nosaquestions = $numberavailable;
! 			$errors['choose'] = get_string('notenoughsaincategory', 'qtype_randomsamatch', $a);
! 		}
! 		return $errors;
! 	}
  }
diff -crB questionorg/type/randomsamatch/questiontype.php questionupd/type/randomsamatch/questiontype.php
*** questionorg/type/randomsamatch/questiontype.php	2012-04-13 12:31:14.399178305 +0500
--- questionupd/type/randomsamatch/questiontype.php	2012-04-13 09:42:58.000000000 +0500
***************
*** 11,339 ****
  /**
   * @package questionbank
   * @subpackage questiontypes
! */
  class question_randomsamatch_qtype extends question_match_qtype {
! /// Extends 'match' as there are quite a few simularities...
  
!     function name() {
!         return 'randomsamatch';
!     }
! 
!     function requires_qtypes() {
!         return array('shortanswer');
!     }
! 
!     function is_usable_by_random() {
!         return false;
!     }
! 
!     function get_question_options(&$question) {
!         global $DB, $OUTPUT;
!         if (!$question->options = $DB->get_record('question_randomsamatch', array('question' => $question->id))) {
!             echo $OUTPUT->notification('Error: Missing question options for random short answer question '.$question->id.'!');
!             return false;
!         }
! 
!         // This could be included as a flag in the database. It's already
!         // supported by the code.
!         // Recurse subcategories: 0 = no recursion, 1 = recursion
!         $question->options->subcats = 1;
!         return true;
! 
!     }
! 
!     function save_question_options($question) {
!         global $DB;
!         $options->question = $question->id;
!         $options->choose = $question->choose;
! 
!         if (2 > $question->choose) {
!             $result->error = "At least two shortanswer questions need to be chosen!";
!             return $result;
!         }
! 
!         if ($existing = $DB->get_record("question_randomsamatch", array("question" => $options->question))) {
!             $options->id = $existing->id;
!             $DB->update_record("question_randomsamatch", $options);
!         } else {
!             $DB->insert_record("question_randomsamatch", $options);
!         }
!         return true;
!     }
! 
!     function delete_question($questionid, $contextid) {
!         global $DB;
!         $DB->delete_records('question_randomsamatch', array('question' => $questionid));
! 
!         parent::delete_question($questionid, $contextid);
!     }
! 
!     function create_session_and_responses(&$question, &$state, $cmoptions, $attempt) {
!         // Choose a random shortanswer question from the category:
!         // We need to make sure that no question is used more than once in the
!         // quiz. Therfore the following need to be excluded:
!         // 1. All questions that are explicitly assigned to the quiz
!         // 2. All random questions
!         // 3. All questions that are already chosen by an other random question
!         global $QTYPES, $OUTPUT, $USER;
!         if (!isset($cmoptions->questionsinuse)) {
!             $cmoptions->questionsinuse = $cmoptions->questions;
!         }
! 
!         if ($question->options->subcats) {
!             // recurse into subcategories
!             $categorylist = question_categorylist($question->category);
!         } else {
!             $categorylist = $question->category;
!         }
! 
!         $saquestions = $this->get_sa_candidates($categorylist, $cmoptions->questionsinuse);
! 
!         $count  = count($saquestions);
!         $wanted = $question->options->choose;
!         $errorstr = '';
!         if ($count < $wanted && has_coursecontact_role($USER->id)) { //TODO: this teacher test is far from optimal
!             if ($count >= 2) {
!                 $errorstr =  "Error: could not get enough Short-Answer questions!
                   Got $count Short-Answer questions, but wanted $wanted.
                   Reducing number to choose from to $count!";
!                 $wanted = $question->options->choose = $count;
!             } else {
!                 $errorstr = "Error: could not get enough Short-Answer questions!
                   This can happen if all available Short-Answer questions are already
                   taken up by other Random questions or Random Short-Answer question.
                   Another possible cause for this error is that Short-Answer
                   questions were deleted after this Random Short-Answer question was
                   created.";
!             }
!             echo $OUTPUT->notification($errorstr);
!             $errorstr = '<span class="notifyproblem">' . $errorstr . '</span>';
!         }
  
!         if ($count < $wanted) {
!             $question->questiontext = "$errorstr<br /><br />Insufficient selection options are
               available for this question, therefore it is not available in  this
               quiz. Please inform your teacher.";
!             // Treat this as a description from this point on
!             $question->qtype = DESCRIPTION;
!             return true;
!         }
! 
!         $saquestions =
!          draw_rand_array($saquestions, $question->options->choose); // from bug 1889
! 
!         foreach ($saquestions as $key => $wrappedquestion) {
!             if (!$QTYPES[$wrappedquestion->qtype]
!              ->get_question_options($wrappedquestion)) {
!                 return false;
!             }
! 
!             // Now we overwrite the $question->options->answers field to only
!             // *one* (the first) correct answer. This loop can be deleted to
!             // take all answers into account (i.e. put them all into the
!             // drop-down menu.
!             $foundcorrect = false;
!             foreach ($wrappedquestion->options->answers as $answer) {
!                 if ($foundcorrect || $answer->fraction != 1.0) {
!                     unset($wrappedquestion->options->answers[$answer->id]);
!                 } else if (!$foundcorrect) {
!                     $foundcorrect = true;
!                 }
!             }
! 
!             if (!$QTYPES[$wrappedquestion->qtype]
!              ->create_session_and_responses($wrappedquestion, $state, $cmoptions,
!              $attempt)) {
!                 return false;
!             }
!             $wrappedquestion->name_prefix = $question->name_prefix;
!             $wrappedquestion->maxgrade    = $question->maxgrade;
!             $cmoptions->questionsinuse .= ",$wrappedquestion->id";
!             $state->options->subquestions[$key] = clone($wrappedquestion);
!         }
  
!         // Shuffle the answers (Do this always because this is a random question type)
!         $subquestionids = array_values(array_map(create_function('$val',
           'return $val->id;'), $state->options->subquestions));
!         $subquestionids = swapshuffle($subquestionids);
  
!         // Create empty responses
!         foreach ($subquestionids as $val) {
!             $state->responses[$val] = '';
!         }
!         return true;
!     }
! 
!     function restore_session_and_responses(&$question, &$state) {
!         global $DB;
!         global $QTYPES, $OUTPUT;
!         static $wrappedquestions = array();
!         if (empty($state->responses[''])) {
!             $question->questiontext = "Insufficient selection options are
               available for this question, therefore it is not available in  this
               quiz. Please inform your teacher.";
!             // Treat this as a description from this point on
!             $question->qtype = DESCRIPTION;
!         } else {
!             $responses = explode(',', $state->responses['']);
!             $responses = array_map(create_function('$val',
               'return explode("-", $val);'), $responses);
  
!             // Restore the previous responses
!             $state->responses = array();
!             foreach ($responses as $response) {
!                 $wqid = $response[0];
!                 $state->responses[$wqid] = $response[1];
!                 if (!isset($wrappedquestions[$wqid])){
!                     if (!$wrappedquestions[$wqid] = $DB->get_record('question', array('id' => $wqid))) {
!                         echo $OUTPUT->notification("Couldn't get question (id=$wqid)!");
!                         return false;
!                     }
!                     if (!$QTYPES[$wrappedquestions[$wqid]->qtype]
!                      ->get_question_options($wrappedquestions[$wqid])) {
!                         echo $OUTPUT->notification("Couldn't get question options (id=$response[0])!");
!                         return false;
!                     }
! 
!                     // Now we overwrite the $question->options->answers field to only
!                     // *one* (the first) correct answer. This loop can be deleted to
!                     // take all answers into account (i.e. put them all into the
!                     // drop-down menu.
!                     $foundcorrect = false;
!                     foreach ($wrappedquestions[$wqid]->options->answers as $answer) {
!                         if ($foundcorrect || $answer->fraction != 1.0) {
!                             unset($wrappedquestions[$wqid]->options->answers[$answer->id]);
!                         } else if (!$foundcorrect) {
!                             $foundcorrect = true;
!                         }
!                     }
!                 }
!                 $wrappedquestion = clone($wrappedquestions[$wqid]);
! 
!                 if (!$QTYPES[$wrappedquestion->qtype]
!                  ->restore_session_and_responses($wrappedquestion, $state)) {
!                     echo $OUTPUT->notification("Couldn't restore session of question (id=$response[0])!");
!                     return false;
!                 }
!                 $wrappedquestion->name_prefix = $question->name_prefix;
!                 $wrappedquestion->maxgrade    = $question->maxgrade;
! 
!                 $state->options->subquestions[$wrappedquestion->id] =
!                  clone($wrappedquestion);
!             }
!         }
!         return true;
!     }
! 
!     function extract_response($rawresponse, $nameprefix) {
!     /// Simple implementation that does not check with the database
!     /// and thus - does not bother to check whether there has been
!     /// any changes to the question options.
!         $response = array();
!         $rawitems = explode(',', $rawresponse->answer);
!         foreach ($rawitems as $rawitem) {
!             $splits = explode('-', $rawitem, 2);
!             $response[$nameprefix.$splits[0]] = $splits[1];
!         }
!         return $response;
!     }
! 
!     function get_sa_candidates($categorylist, $questionsinuse=0) {
!         global $DB;
!         list ($usql, $params) = $DB->get_in_or_equal(explode(',', $categorylist));
!         list ($ques_usql, $ques_params) = $DB->get_in_or_equal(explode(',', $questionsinuse), SQL_PARAMS_QM, null, false);
!         $params = array_merge($params, $ques_params);
!         return $DB->get_records_select('question',
           "qtype = 'shortanswer' " .
           "AND category $usql " .
           "AND parent = '0' " .
           "AND hidden = '0'" .
           "AND id $ques_usql", $params);
!     }
!     function get_all_responses($question, $state) {
!         $answers = array();
!         if (is_array($question->options->subquestions)) {
!             foreach ($question->options->subquestions as $aid => $answer) {
!                 if ($answer->questiontext) {
!                     foreach($answer->options->answers as $ans ){
!                        $answer->answertext = $ans->answer ;
!                     }
!                     $r = new stdClass;
!                     $r->answer = $answer->questiontext . ": " . $answer->answertext;
!                     $r->credit = 1;
!                     $answers[$aid] = $r;
!                 }
!             }
!         }
!         $result = new stdClass;
!         $result->id = $question->id;
!         $result->responses = $answers;
!         return $result;
!     }
!     /**
!      * The difference between this method an get_all_responses is that this
!      * method is not passed a state object. It is the possible answers to a
!      * question no matter what the state.
!      * This method is not called for random questions.
!      * @return array of possible answers.
!      */
!     function get_possible_responses(&$question) {
!         global $QTYPES;
!         static $answers = array();
!         if (!isset($answers[$question->id])){
!             if ($question->options->subcats) {
!                 // recurse into subcategories
!                 $categorylist = question_categorylist($question->category);
!             } else {
!                 $categorylist = $question->category;
!             }
! 
!             $question->options->subquestions = $this->get_sa_candidates($categorylist);
!             foreach ($question->options->subquestions as $key => $wrappedquestion) {
!                 if (!$QTYPES[$wrappedquestion->qtype]
!                  ->get_question_options($wrappedquestion)) {
!                     return false;
!                 }
! 
!                 // Now we overwrite the $question->options->answers field to only
!                 // *one* (the first) correct answer. This loop can be deleted to
!                 // take all answers into account (i.e. put them all into the
!                 // drop-down menu.
!                 $foundcorrect = false;
!                 foreach ($wrappedquestion->options->answers as $answer) {
!                     if ($foundcorrect || $answer->fraction != 1.0) {
!                         unset($wrappedquestion->options->answers[$answer->id]);
!                     } else if (!$foundcorrect) {
!                         $foundcorrect = true;
!                     }
!                 }
!             }
!             $answers[$question->id] = array();
!             if (is_array($question->options->subquestions)) {
!                 foreach ($question->options->subquestions as $subqid => $answer) {
!                     if ($answer->questiontext) {
!                         $ans = array_shift($answer->options->answers);
!                         $answer->answertext = $ans->answer ;
!                         $r = new stdClass;
!                         $r->answer = $answer->questiontext . ": " . $answer->answertext;
!                         $r->credit = 1;
!                         $answers[$question->id][$subqid] = array($ans->id => $r);
!                     }
!                 }
!             }
!         }
!         return $answers[$question->id];
!     }
! 
!     /**
!      * @param object $question
!      * @return mixed either a integer score out of 1 that the average random
!      * guess by a student might give or an empty string which means will not
!      * calculate.
!      */
!     function get_random_guess_score($question) {
!         return 1/$question->options->choose;
!     }
  }
  
  //// END OF CLASS ////
--- 11,339 ----
  /**
   * @package questionbank
   * @subpackage questiontypes
!  */
  class question_randomsamatch_qtype extends question_match_qtype {
! 	/// Extends 'match' as there are quite a few simularities...
  
! 	function name() {
! 		return 'randomsamatch';
! 	}
! 
! 	function requires_qtypes() {
! 		return array('shortanswer');
! 	}
! 
! 	function is_usable_by_random() {
! 		return false;
! 	}
! 
! 	function get_question_options(&$question) {
! 		global $DB, $OUTPUT;
! 		if (!$question->options = $DB->get_record('question_randomsamatch', array('question' => $question->id))) {
! 			echo $OUTPUT->notification('Error: Missing question options for random short answer question '.$question->id.'!');
! 			return false;
! 		}
! 
! 		// This could be included as a flag in the database. It's already
! 		// supported by the code.
! 		// Recurse subcategories: 0 = no recursion, 1 = recursion
! 		$question->options->subcats = 1;
! 		return true;
! 
! 	}
! 
! 	function save_question_options($question) {
! 		global $DB;
! 		$options->question = $question->id;
! 		$options->choose = $question->choose;
! 
! 		if (2 > $question->choose) {
! 			$result->error = "At least two shortanswer questions need to be chosen!";
! 			return $result;
! 		}
! 
! 		if ($existing = $DB->get_record("question_randomsamatch", array("question" => $options->question))) {
! 			$options->id = $existing->id;
! 			$DB->update_record("question_randomsamatch", $options);
! 		} else {
! 			$DB->insert_record("question_randomsamatch", $options);
! 		}
! 		return true;
! 	}
! 
! 	function delete_question($questionid, $contextid) {
! 		global $DB;
! 		$DB->delete_records('question_randomsamatch', array('question' => $questionid));
! 
! 		parent::delete_question($questionid, $contextid);
! 	}
! 
! 	function create_session_and_responses(&$question, &$state, $cmoptions, $attempt) {
! 		// Choose a random shortanswer question from the category:
! 		// We need to make sure that no question is used more than once in the
! 		// quiz. Therfore the following need to be excluded:
! 		// 1. All questions that are explicitly assigned to the quiz
! 		// 2. All random questions
! 		// 3. All questions that are already chosen by an other random question
! 		global $QTYPES, $OUTPUT, $USER;
! 		if (!isset($cmoptions->questionsinuse)) {
! 			$cmoptions->questionsinuse = $cmoptions->questions;
! 		}
! 
! 		if ($question->options->subcats) {
! 			// recurse into subcategories
! 			$categorylist = question_categorylist($question->category);
! 		} else {
! 			$categorylist = $question->category;
! 		}
! 
! 		$saquestions = $this->get_sa_candidates($categorylist, $cmoptions->questionsinuse);
! 
! 		$count  = count($saquestions);
! 		$wanted = $question->options->choose;
! 		$errorstr = '';
! 		if ($count < $wanted && has_coursecontact_role($USER->id)) { //TODO: this teacher test is far from optimal
! 			if ($count >= 2) {
! 				$errorstr =  "Error: could not get enough Short-Answer questions!
                   Got $count Short-Answer questions, but wanted $wanted.
                   Reducing number to choose from to $count!";
! 				$wanted = $question->options->choose = $count;
! 			} else {
! 				$errorstr = "Error: could not get enough Short-Answer questions!
                   This can happen if all available Short-Answer questions are already
                   taken up by other Random questions or Random Short-Answer question.
                   Another possible cause for this error is that Short-Answer
                   questions were deleted after this Random Short-Answer question was
                   created.";
! 			}
! 			echo $OUTPUT->notification($errorstr);
! 			$errorstr = '<span class="notifyproblem">' . $errorstr . '</span>';
! 		}
  
! 		if ($count < $wanted) {
! 			$question->questiontext = "$errorstr<br /><br />Insufficient selection options are
               available for this question, therefore it is not available in  this
               quiz. Please inform your teacher.";
! 			// Treat this as a description from this point on
! 			$question->qtype = DESCRIPTION;
! 			return true;
! 		}
! 
! 		$saquestions =
! 		draw_rand_array($saquestions, $question->options->choose); // from bug 1889
! 
! 		foreach ($saquestions as $key => $wrappedquestion) {
! 			if (!$QTYPES[$wrappedquestion->qtype]
! 			->get_question_options($wrappedquestion)) {
! 				return false;
! 			}
! 
! 			// Now we overwrite the $question->options->answers field to only
! 			// *one* (the first) correct answer. This loop can be deleted to
! 			// take all answers into account (i.e. put them all into the
! 			// drop-down menu.
! 			$foundcorrect = false;
! 			foreach ($wrappedquestion->options->answers as $answer) {
! 				if ($foundcorrect || $answer->fraction != 1.0) {
! 					unset($wrappedquestion->options->answers[$answer->id]);
! 				} else if (!$foundcorrect) {
! 					$foundcorrect = true;
! 				}
! 			}
! 
! 			if (!$QTYPES[$wrappedquestion->qtype]
! 			->create_session_and_responses($wrappedquestion, $state, $cmoptions,
! 			$attempt)) {
! 				return false;
! 			}
! 			$wrappedquestion->name_prefix = $question->name_prefix;
! 			$wrappedquestion->maxgrade    = $question->maxgrade;
! 			$cmoptions->questionsinuse .= ",$wrappedquestion->id";
! 			$state->options->subquestions[$key] = clone($wrappedquestion);
! 		}
  
! 		// Shuffle the answers (Do this always because this is a random question type)
! 		$subquestionids = array_values(array_map(create_function('$val',
           'return $val->id;'), $state->options->subquestions));
! 		$subquestionids = swapshuffle($subquestionids);
  
! 		// Create empty responses
! 		foreach ($subquestionids as $val) {
! 			$state->responses[$val] = '';
! 		}
! 		return true;
! 	}
! 
! 	function restore_session_and_responses(&$question, &$state) {
! 		global $DB;
! 		global $QTYPES, $OUTPUT;
! 		static $wrappedquestions = array();
! 		if (empty($state->responses[''])) {
! 			$question->questiontext = "Insufficient selection options are
               available for this question, therefore it is not available in  this
               quiz. Please inform your teacher.";
! 			// Treat this as a description from this point on
! 			$question->qtype = DESCRIPTION;
! 		} else {
! 			$responses = explode(',', $state->responses['']);
! 			$responses = array_map(create_function('$val',
               'return explode("-", $val);'), $responses);
  
! 			// Restore the previous responses
! 			$state->responses = array();
! 			foreach ($responses as $response) {
! 				$wqid = $response[0];
! 				$state->responses[$wqid] = $response[1];
! 				if (!isset($wrappedquestions[$wqid])){
! 					if (!$wrappedquestions[$wqid] = $DB->get_record('question', array('id' => $wqid))) {
! 						echo $OUTPUT->notification("Couldn't get question (id=$wqid)!");
! 						return false;
! 					}
! 					if (!$QTYPES[$wrappedquestions[$wqid]->qtype]
! 					->get_question_options($wrappedquestions[$wqid])) {
! 						echo $OUTPUT->notification("Couldn't get question options (id=$response[0])!");
! 						return false;
! 					}
! 
! 					// Now we overwrite the $question->options->answers field to only
! 					// *one* (the first) correct answer. This loop can be deleted to
! 					// take all answers into account (i.e. put them all into the
! 					// drop-down menu.
! 					$foundcorrect = false;
! 					foreach ($wrappedquestions[$wqid]->options->answers as $answer) {
! 						if ($foundcorrect || $answer->fraction != 1.0) {
! 							unset($wrappedquestions[$wqid]->options->answers[$answer->id]);
! 						} else if (!$foundcorrect) {
! 							$foundcorrect = true;
! 						}
! 					}
! 				}
! 				$wrappedquestion = clone($wrappedquestions[$wqid]);
! 
! 				if (!$QTYPES[$wrappedquestion->qtype]
! 				->restore_session_and_responses($wrappedquestion, $state)) {
! 					echo $OUTPUT->notification("Couldn't restore session of question (id=$response[0])!");
! 					return false;
! 				}
! 				$wrappedquestion->name_prefix = $question->name_prefix;
! 				$wrappedquestion->maxgrade    = $question->maxgrade;
! 
! 				$state->options->subquestions[$wrappedquestion->id] =
! 				clone($wrappedquestion);
! 			}
! 		}
! 		return true;
! 	}
! 
! 	function extract_response($rawresponse, $nameprefix) {
! 		/// Simple implementation that does not check with the database
! 		/// and thus - does not bother to check whether there has been
! 		/// any changes to the question options.
! 		$response = array();
! 		$rawitems = explode(',', $rawresponse->answer);
! 		foreach ($rawitems as $rawitem) {
! 			$splits = explode('-', $rawitem, 2);
! 			$response[$nameprefix.$splits[0]] = $splits[1];
! 		}
! 		return $response;
! 	}
! 
! 	function get_sa_candidates($categorylist, $questionsinuse=0) {
! 		global $DB;
! 		list ($usql, $params) = $DB->get_in_or_equal(explode(',', $categorylist));
! 		list ($ques_usql, $ques_params) = $DB->get_in_or_equal(explode(',', $questionsinuse), SQL_PARAMS_QM, null, false);
! 		$params = array_merge($params, $ques_params);
! 		return $DB->get_records_select('question',
           "qtype = 'shortanswer' " .
           "AND category $usql " .
           "AND parent = '0' " .
           "AND hidden = '0'" .
           "AND id $ques_usql", $params);
! 	}
! 	function get_all_responses($question, $state) {
! 		$answers = array();
! 		if (is_array($question->options->subquestions)) {
! 			foreach ($question->options->subquestions as $aid => $answer) {
! 				if ($answer->questiontext) {
! 					foreach($answer->options->answers as $ans ){
! 						$answer->answertext = $ans->answer ;
! 					}
! 					$r = new stdClass;
! 					$r->answer = $answer->questiontext . ": " . $answer->answertext;
! 					$r->credit = 1;
! 					$answers[$aid] = $r;
! 				}
! 			}
! 		}
! 		$result = new stdClass;
! 		$result->id = $question->id;
! 		$result->responses = $answers;
! 		return $result;
! 	}
! 	/**
! 	 * The difference between this method an get_all_responses is that this
! 	 * method is not passed a state object. It is the possible answers to a
! 	 * question no matter what the state.
! 	 * This method is not called for random questions.
! 	 * @return array of possible answers.
! 	 */
! 	function get_possible_responses(&$question) {
! 		global $QTYPES;
! 		static $answers = array();
! 		if (!isset($answers[$question->id])){
! 			if ($question->options->subcats) {
! 				// recurse into subcategories
! 				$categorylist = question_categorylist($question->category);
! 			} else {
! 				$categorylist = $question->category;
! 			}
! 
! 			$question->options->subquestions = $this->get_sa_candidates($categorylist);
! 			foreach ($question->options->subquestions as $key => $wrappedquestion) {
! 				if (!$QTYPES[$wrappedquestion->qtype]
! 				->get_question_options($wrappedquestion)) {
! 					return false;
! 				}
! 
! 				// Now we overwrite the $question->options->answers field to only
! 				// *one* (the first) correct answer. This loop can be deleted to
! 				// take all answers into account (i.e. put them all into the
! 				// drop-down menu.
! 				$foundcorrect = false;
! 				foreach ($wrappedquestion->options->answers as $answer) {
! 					if ($foundcorrect || $answer->fraction != 1.0) {
! 						unset($wrappedquestion->options->answers[$answer->id]);
! 					} else if (!$foundcorrect) {
! 						$foundcorrect = true;
! 					}
! 				}
! 			}
! 			$answers[$question->id] = array();
! 			if (is_array($question->options->subquestions)) {
! 				foreach ($question->options->subquestions as $subqid => $answer) {
! 					if ($answer->questiontext) {
! 						$ans = array_shift($answer->options->answers);
! 						$answer->answertext = $ans->answer ;
! 						$r = new stdClass;
! 						$r->answer = $answer->questiontext . ": " . $answer->answertext;
! 						$r->credit = 1;
! 						$answers[$question->id][$subqid] = array($ans->id => $r);
! 					}
! 				}
! 			}
! 		}
! 		return $answers[$question->id];
! 	}
! 
! 	/**
! 	 * @param object $question
! 	 * @return mixed either a integer score out of 1 that the average random
! 	 * guess by a student might give or an empty string which means will not
! 	 * calculate.
! 	 */
! 	function get_random_guess_score($question) {
! 		return 1/$question->options->choose;
! 	}
  }
  
  //// END OF CLASS ////
diff -crB questionorg/type/shortanswer/backup/moodle2/backup_qtype_shortanswer_plugin.class.php questionupd/type/shortanswer/backup/moodle2/backup_qtype_shortanswer_plugin.class.php
*** questionorg/type/shortanswer/backup/moodle2/backup_qtype_shortanswer_plugin.class.php	2012-04-13 12:31:12.881178277 +0500
--- questionupd/type/shortanswer/backup/moodle2/backup_qtype_shortanswer_plugin.class.php	2012-04-13 09:42:58.000000000 +0500
***************
*** 28,63 ****
   */
  class backup_qtype_shortanswer_plugin extends backup_qtype_plugin {
  
!     /**
!      * Returns the qtype information to attach to question element
!      */
!     protected function define_question_plugin_structure() {
! 
!         // Define the virtual plugin element with the condition to fulfill
!         $plugin = $this->get_plugin_element(null, '../../qtype', 'shortanswer');
! 
!         // Create one standard named plugin element (the visible container)
!         $pluginwrapper = new backup_nested_element($this->get_recommended_name());
! 
!         // connect the visible container ASAP
!         $plugin->add_child($pluginwrapper);
! 
!         // This qtype uses standard question_answers, add them here
!         // to the tree before any other information that will use them
!         $this->add_question_question_answers($pluginwrapper);
  
!         // Now create the qtype own structures
!         $shortanswer = new backup_nested_element('shortanswer', array('id'), array(
              'answers', 'usecase'));
  
!         // Now the own qtype tree
!         $pluginwrapper->add_child($shortanswer);
  
!         // set source to populate the data
!         $shortanswer->set_source_table('question_shortanswer', array('question' => backup::VAR_PARENTID));
  
!         // don't need to annotate ids nor files
  
!         return $plugin;
!     }
  }
--- 28,63 ----
   */
  class backup_qtype_shortanswer_plugin extends backup_qtype_plugin {
  
! 	/**
! 	 * Returns the qtype information to attach to question element
! 	 */
! 	protected function define_question_plugin_structure() {
! 
! 		// Define the virtual plugin element with the condition to fulfill
! 		$plugin = $this->get_plugin_element(null, '../../qtype', 'shortanswer');
! 
! 		// Create one standard named plugin element (the visible container)
! 		$pluginwrapper = new backup_nested_element($this->get_recommended_name());
! 
! 		// connect the visible container ASAP
! 		$plugin->add_child($pluginwrapper);
! 
! 		// This qtype uses standard question_answers, add them here
! 		// to the tree before any other information that will use them
! 		$this->add_question_question_answers($pluginwrapper);
  
! 		// Now create the qtype own structures
! 		$shortanswer = new backup_nested_element('shortanswer', array('id'), array(
              'answers', 'usecase'));
  
! 		// Now the own qtype tree
! 		$pluginwrapper->add_child($shortanswer);
  
! 		// set source to populate the data
! 		$shortanswer->set_source_table('question_shortanswer', array('question' => backup::VAR_PARENTID));
  
! 		// don't need to annotate ids nor files
  
! 		return $plugin;
! 	}
  }
diff -crB questionorg/type/shortanswer/backup/moodle2/restore_qtype_shortanswer_plugin.class.php questionupd/type/shortanswer/backup/moodle2/restore_qtype_shortanswer_plugin.class.php
*** questionorg/type/shortanswer/backup/moodle2/restore_qtype_shortanswer_plugin.class.php	2012-04-13 12:31:12.839178280 +0500
--- questionupd/type/shortanswer/backup/moodle2/restore_qtype_shortanswer_plugin.class.php	2012-04-13 09:42:58.000000000 +0500
***************
*** 30,84 ****
   */
  class restore_qtype_shortanswer_plugin extends restore_qtype_plugin {
  
!     /**
!      * Returns the paths to be handled by the plugin at question level
!      */
!     protected function define_question_plugin_structure() {
! 
!         $paths = array();
! 
!         // This qtype uses question_answers, add them
!         $this->add_question_question_answers($paths);
! 
!         // Add own qtype stuff
!         $elename = 'shortanswer';
!         $elepath = $this->get_pathfor('/shortanswer'); // we used get_recommended_name() so this works
!         $paths[] = new restore_path_element($elename, $elepath);
! 
! 
!         return $paths; // And we return the interesting paths
!     }
! 
!     /**
!      * Process the qtype/shortanswer element
!      */
!     public function process_shortanswer($data) {
!         global $DB;
! 
!         $data = (object)$data;
!         $oldid = $data->id;
! 
!         // Detect if the question is created or mapped
!         $oldquestionid   = $this->get_old_parentid('question');
!         $newquestionid   = $this->get_new_parentid('question');
!         $questioncreated = $this->get_mappingid('question_created', $oldquestionid) ? true : false;
! 
!         // If the question has been created by restore, we need to create its question_shortanswer too
!         if ($questioncreated) {
!             // Adjust some columns
!             $data->question = $newquestionid;
!             // Map sequence of question_answer ids
!             $answersarr = explode(',', $data->answers);
!             foreach ($answersarr as $key => $answer) {
!                 $answersarr[$key] = $this->get_mappingid('question_answer', $answer);
!             }
!             $data->answers = implode(',', $answersarr);
!             // Insert record
!             $newitemid = $DB->insert_record('question_shortanswer', $data);
!             // Create mapping
!             $this->set_mapping('question_shortanswer', $oldid, $newitemid);
!         } else {
!             // Nothing to remap if the question already existed
!         }
!     }
  }
--- 30,84 ----
   */
  class restore_qtype_shortanswer_plugin extends restore_qtype_plugin {
  
! 	/**
! 	 * Returns the paths to be handled by the plugin at question level
! 	 */
! 	protected function define_question_plugin_structure() {
! 
! 		$paths = array();
! 
! 		// This qtype uses question_answers, add them
! 		$this->add_question_question_answers($paths);
! 
! 		// Add own qtype stuff
! 		$elename = 'shortanswer';
! 		$elepath = $this->get_pathfor('/shortanswer'); // we used get_recommended_name() so this works
! 		$paths[] = new restore_path_element($elename, $elepath);
! 
! 
! 		return $paths; // And we return the interesting paths
! 	}
! 
! 	/**
! 	 * Process the qtype/shortanswer element
! 	 */
! 	public function process_shortanswer($data) {
! 		global $DB;
! 
! 		$data = (object)$data;
! 		$oldid = $data->id;
! 
! 		// Detect if the question is created or mapped
! 		$oldquestionid   = $this->get_old_parentid('question');
! 		$newquestionid   = $this->get_new_parentid('question');
! 		$questioncreated = $this->get_mappingid('question_created', $oldquestionid) ? true : false;
! 
! 		// If the question has been created by restore, we need to create its question_shortanswer too
! 		if ($questioncreated) {
! 			// Adjust some columns
! 			$data->question = $newquestionid;
! 			// Map sequence of question_answer ids
! 			$answersarr = explode(',', $data->answers);
! 			foreach ($answersarr as $key => $answer) {
! 				$answersarr[$key] = $this->get_mappingid('question_answer', $answer);
! 			}
! 			$data->answers = implode(',', $answersarr);
! 			// Insert record
! 			$newitemid = $DB->insert_record('question_shortanswer', $data);
! 			// Create mapping
! 			$this->set_mapping('question_shortanswer', $oldid, $newitemid);
! 		} else {
! 			// Nothing to remap if the question already existed
! 		}
! 	}
  }
diff -crB questionorg/type/shortanswer/db/install.xml questionupd/type/shortanswer/db/install.xml
*** questionorg/type/shortanswer/db/install.xml	2012-04-13 12:31:12.976178280 +0500
--- questionupd/type/shortanswer/db/install.xml	2012-04-13 09:42:58.000000000 +0500
***************
*** 1,20 ****
  <?xml version="1.0" encoding="UTF-8" ?>
! <XMLDB PATH="question/type/shortanswer/db" VERSION="20090305" COMMENT="XMLDB file for Moodle question/type/shortanswer"
!     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
!     xsi:noNamespaceSchemaLocation="../../../../lib/xmldb/xmldb.xsd"
! >
!   <TABLES>
!     <TABLE NAME="question_shortanswer" COMMENT="Options for short answer questions">
!       <FIELDS>
!         <FIELD NAME="id" TYPE="int" LENGTH="10" NOTNULL="true" UNSIGNED="true" SEQUENCE="true" NEXT="question"/>
!         <FIELD NAME="question" TYPE="int" LENGTH="10" NOTNULL="true" UNSIGNED="true" DEFAULT="0" SEQUENCE="false" COMMENT="Foreign key references question.id." PREVIOUS="id" NEXT="answers"/>
!         <FIELD NAME="answers" TYPE="char" LENGTH="255" NOTNULL="true" SEQUENCE="false" COMMENT="Redundant. Comma-separated list of question_answer ids. SELECT id FROM question_answers WHERE question = ? ORDER BY id." PREVIOUS="question" NEXT="usecase"/>
!         <FIELD NAME="usecase" TYPE="int" LENGTH="2" NOTNULL="true" UNSIGNED="false" DEFAULT="0" SEQUENCE="false" COMMENT="Whether answers are matched case-sensitively." PREVIOUS="answers"/>
!       </FIELDS>
!       <KEYS>
!         <KEY NAME="primary" TYPE="primary" FIELDS="id" NEXT="question"/>
!         <KEY NAME="question" TYPE="foreign" FIELDS="question" REFTABLE="question" REFFIELDS="id" PREVIOUS="primary"/>
!       </KEYS>
!     </TABLE>
!   </TABLES>
  </XMLDB>
--- 1,28 ----
  <?xml version="1.0" encoding="UTF-8" ?>
! <XMLDB PATH="question/type/shortanswer/db" VERSION="20090305"
! 	COMMENT="XMLDB file for Moodle question/type/shortanswer" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
! 	xsi:noNamespaceSchemaLocation="../../../../lib/xmldb/xmldb.xsd">
! 	<TABLES>
! 		<TABLE NAME="question_shortanswer" COMMENT="Options for short answer questions">
! 			<FIELDS>
! 				<FIELD NAME="id" TYPE="int" LENGTH="10" NOTNULL="true"
! 					UNSIGNED="true" SEQUENCE="true" NEXT="question" />
! 				<FIELD NAME="question" TYPE="int" LENGTH="10" NOTNULL="true"
! 					UNSIGNED="true" DEFAULT="0" SEQUENCE="false"
! 					COMMENT="Foreign key references question.id." PREVIOUS="id" NEXT="answers" />
! 				<FIELD NAME="answers" TYPE="char" LENGTH="255" NOTNULL="true"
! 					SEQUENCE="false"
! 					COMMENT="Redundant. Comma-separated list of question_answer ids. SELECT id FROM question_answers WHERE question = ? ORDER BY id."
! 					PREVIOUS="question" NEXT="usecase" />
! 				<FIELD NAME="usecase" TYPE="int" LENGTH="2" NOTNULL="true"
! 					UNSIGNED="false" DEFAULT="0" SEQUENCE="false"
! 					COMMENT="Whether answers are matched case-sensitively." PREVIOUS="answers" />
! 			</FIELDS>
! 			<KEYS>
! 				<KEY NAME="primary" TYPE="primary" FIELDS="id" NEXT="question" />
! 				<KEY NAME="question" TYPE="foreign" FIELDS="question" REFTABLE="question"
! 					REFFIELDS="id" PREVIOUS="primary" />
! 			</KEYS>
! 		</TABLE>
! 	</TABLES>
  </XMLDB>
diff -crB questionorg/type/shortanswer/display.html questionupd/type/shortanswer/display.html
*** questionorg/type/shortanswer/display.html	2012-04-13 12:31:12.885178279 +0500
--- questionupd/type/shortanswer/display.html	2012-04-13 09:42:58.000000000 +0500
***************
*** 1,19 ****
  <div class="qtext">
!   <?php echo $questiontext; ?>
  </div>
  
  <div class="ablock clearfix">
!   <div class="prompt">
!     <?php echo get_string("answer", "quiz").': '; ?>
!   </div>
!   <div class="answer">
!     <input type="text" class="<?php echo $class; ?>" <?php echo "$readonly $inputname $value"; ?> size="80"/>
!     <?php echo $feedbackimg; ?>
!   </div>
!   <?php if ($feedback) { ?>
!     <div class="feedback">
!       <?php echo $feedback ?>
!     </div>
!   <?php } ?>
!   <?php $this->print_question_submit_buttons($question, $state, $cmoptions, $options); ?>
  </div>
--- 1,24 ----
  <div class="qtext">
! 	<?php $_SESSION['content'].="&nbsp;&nbsp;&nbsp;&nbsp;".$questiontext."</b></td></tr>";
! echo $questiontext; ?>
  </div>
  
  <div class="ablock clearfix">
! 	<div class="prompt">
! 		<?php $_SESSION['content'].="<tr><td>".get_string("answer", "quiz")." : "; 
! 		   echo get_string("answer", "quiz").': '; ?>
! 	</div>
! 	<div class="answer">
! 		<input type="text" class="<?php echo $class; ?>"<?php echo
! 		"$readonly $inputname $value"; ?> size="80"/>
! 		<?php  $_SESSION['content'].=$value."</td></tr> "; 
! 			echo $feedbackimg; ?>
! 
! 	</div>
! 	<?php if ($feedback) { ?>
! 	<div class="feedback">
! 		<?php echo $feedback ?>
! 	</div>
! 	<?php } ?>
! 	<?php $this->print_question_submit_buttons($question, $state, $cmoptions, $options); ?>
  </div>
diff -crB questionorg/type/shortanswer/edit_shortanswer_form.php questionupd/type/shortanswer/edit_shortanswer_form.php
*** questionorg/type/shortanswer/edit_shortanswer_form.php	2012-04-13 12:31:12.884178279 +0500
--- questionupd/type/shortanswer/edit_shortanswer_form.php	2012-04-13 09:42:58.000000000 +0500
***************
*** 31,114 ****
   * shortanswer editing form definition.
   */
  class question_edit_shortanswer_form extends question_edit_form {
!     /**
!      * Add question-type specific form fields.
!      *
!      * @param MoodleQuickForm $mform the form being built.
!      */
!     function definition_inner(&$mform) {
!         $menu = array(get_string('caseno', 'quiz'), get_string('caseyes', 'quiz'));
!         $mform->addElement('select', 'usecase', get_string('casesensitive', 'quiz'), $menu);
  
!         $mform->addElement('static', 'answersinstruct', get_string('correctanswers', 'quiz'), get_string('filloutoneanswer', 'quiz'));
!         $mform->closeHeaderBefore('answersinstruct');
  
!         $creategrades = get_grade_options();
!         $this->add_per_answer_fields($mform, get_string('answerno', 'qtype_shortanswer', '{no}'),
!                 $creategrades->gradeoptions);
!     }
  
!     function data_preprocessing($question) {
!         if (isset($question->options)){
!             $answers = $question->options->answers;
!             $answers_ids = array();
!             if (count($answers)) {
!                 $key = 0;
!                 foreach ($answers as $answer){
!                     $answers_ids[] = $answer->id;
!                     $default_values['answer['.$key.']'] = $answer->answer;
!                     $default_values['fraction['.$key.']'] = $answer->fraction;
!                     $default_values['feedback['.$key.']'] = array();
  
!                     // prepare feedback editor to display files in draft area
!                     $draftid_editor = file_get_submitted_draft_itemid('feedback['.$key.']');
!                     $default_values['feedback['.$key.']']['text'] = file_prepare_draft_area(
!                         $draftid_editor,       // draftid
!                         $this->context->id,    // context
                          'question',   // component
                          'answerfeedback',             // filarea
!                         !empty($answer->id)?(int)$answer->id:null, // itemid
!                         $this->fileoptions,    // options
!                         $answer->feedback      // text
!                     );
!                     $default_values['feedback['.$key.']']['itemid'] = $draftid_editor;
!                     // prepare files code block ends
  
!                     $default_values['feedback['.$key.']']['format'] = $answer->feedbackformat;
!                     $key++;
!                 }
!             }
!             $default_values['usecase'] = $question->options->usecase;
!             $question = (object)((array)$question + $default_values);
!         }
!         return $question;
!     }
!     function validation($data, $files) {
!         $errors = parent::validation($data, $files);
!         $answers = $data['answer'];
!         $answercount = 0;
!         $maxgrade = false;
!         foreach ($answers as $key => $answer) {
!             $trimmedanswer = trim($answer);
!             if ($trimmedanswer !== ''){
!                 $answercount++;
!                 if ($data['fraction'][$key] == 1) {
!                     $maxgrade = true;
!                 }
!             } else if ($data['fraction'][$key] != 0 || !html_is_blank($data['feedback'][$key]['text'])) {
!                 $errors["answer[$key]"] = get_string('answermustbegiven', 'qtype_shortanswer');
!                 $answercount++;
!             }
!         }
!         if ($answercount==0){
!             $errors['answer[0]'] = get_string('notenoughanswers', 'quiz', 1);
!         }
!         if ($maxgrade == false) {
!             $errors['fraction[0]'] = get_string('fractionsnomax', 'question');
!         }
!         return $errors;
!     }
!     function qtype() {
!         return 'shortanswer';
!     }
  }
--- 31,114 ----
   * shortanswer editing form definition.
   */
  class question_edit_shortanswer_form extends question_edit_form {
! 	/**
! 	 * Add question-type specific form fields.
! 	 *
! 	 * @param MoodleQuickForm $mform the form being built.
! 	 */
! 	function definition_inner(&$mform) {
! 		$menu = array(get_string('caseno', 'quiz'), get_string('caseyes', 'quiz'));
! 		$mform->addElement('select', 'usecase', get_string('casesensitive', 'quiz'), $menu);
  
! 		$mform->addElement('static', 'answersinstruct', get_string('correctanswers', 'quiz'), get_string('filloutoneanswer', 'quiz'));
! 		$mform->closeHeaderBefore('answersinstruct');
  
! 		$creategrades = get_grade_options();
! 		$this->add_per_answer_fields($mform, get_string('answerno', 'qtype_shortanswer', '{no}'),
! 		$creategrades->gradeoptions);
! 	}
  
! 	function data_preprocessing($question) {
! 		if (isset($question->options)){
! 			$answers = $question->options->answers;
! 			$answers_ids = array();
! 			if (count($answers)) {
! 				$key = 0;
! 				foreach ($answers as $answer){
! 					$answers_ids[] = $answer->id;
! 					$default_values['answer['.$key.']'] = $answer->answer;
! 					$default_values['fraction['.$key.']'] = $answer->fraction;
! 					$default_values['feedback['.$key.']'] = array();
  
! 					// prepare feedback editor to display files in draft area
! 					$draftid_editor = file_get_submitted_draft_itemid('feedback['.$key.']');
! 					$default_values['feedback['.$key.']']['text'] = file_prepare_draft_area(
! 					$draftid_editor,       // draftid
! 					$this->context->id,    // context
                          'question',   // component
                          'answerfeedback',             // filarea
! 					!empty($answer->id)?(int)$answer->id:null, // itemid
! 					$this->fileoptions,    // options
! 					$answer->feedback      // text
! 					);
! 					$default_values['feedback['.$key.']']['itemid'] = $draftid_editor;
! 					// prepare files code block ends
  
! 					$default_values['feedback['.$key.']']['format'] = $answer->feedbackformat;
! 					$key++;
! 				}
! 			}
! 			$default_values['usecase'] = $question->options->usecase;
! 			$question = (object)((array)$question + $default_values);
! 		}
! 		return $question;
! 	}
! 	function validation($data, $files) {
! 		$errors = parent::validation($data, $files);
! 		$answers = $data['answer'];
! 		$answercount = 0;
! 		$maxgrade = false;
! 		foreach ($answers as $key => $answer) {
! 			$trimmedanswer = trim($answer);
! 			if ($trimmedanswer !== ''){
! 				$answercount++;
! 				if ($data['fraction'][$key] == 1) {
! 					$maxgrade = true;
! 				}
! 			} else if ($data['fraction'][$key] != 0 || !html_is_blank($data['feedback'][$key]['text'])) {
! 				$errors["answer[$key]"] = get_string('answermustbegiven', 'qtype_shortanswer');
! 				$answercount++;
! 			}
! 		}
! 		if ($answercount==0){
! 			$errors['answer[0]'] = get_string('notenoughanswers', 'quiz', 1);
! 		}
! 		if ($maxgrade == false) {
! 			$errors['fraction[0]'] = get_string('fractionsnomax', 'question');
! 		}
! 		return $errors;
! 	}
! 	function qtype() {
! 		return 'shortanswer';
! 	}
  }
diff -crB questionorg/type/shortanswer/lib.php questionupd/type/shortanswer/lib.php
*** questionorg/type/shortanswer/lib.php	2012-04-13 12:31:12.978178280 +0500
--- questionupd/type/shortanswer/lib.php	2012-04-13 09:42:58.000000000 +0500
***************
*** 25,31 ****
   * @license   http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
   */
  function qtype_shortanswer_pluginfile($course, $cm, $context, $filearea, $args, $forcedownload) {
!     global $DB, $CFG;
!     require_once($CFG->libdir . '/questionlib.php');
!     question_pluginfile($course, $context, 'qtype_shortanswer', $filearea, $args, $forcedownload);
  }
--- 25,31 ----
   * @license   http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
   */
  function qtype_shortanswer_pluginfile($course, $cm, $context, $filearea, $args, $forcedownload) {
! 	global $DB, $CFG;
! 	require_once($CFG->libdir . '/questionlib.php');
! 	question_pluginfile($course, $context, 'qtype_shortanswer', $filearea, $args, $forcedownload);
  }
diff -crB questionorg/type/shortanswer/questiontype.php questionupd/type/shortanswer/questiontype.php
*** questionorg/type/shortanswer/questiontype.php	2012-04-13 12:31:12.974178280 +0500
--- questionupd/type/shortanswer/questiontype.php	2012-04-13 09:42:59.000000000 +0500
***************
*** 33,413 ****
  
  class question_shortanswer_qtype extends default_questiontype {
  
!     function name() {
!         return 'shortanswer';
!     }
! 
!     function has_wildcards_in_responses($question, $subqid) {
!         return true;
!     }
! 
!     function extra_question_fields() {
!         return array('question_shortanswer', 'answers', 'usecase');
!     }
! 
!     function questionid_column_name() {
!         return 'question';
!     }
! 
!     function move_files($questionid, $oldcontextid, $newcontextid) {
!         parent::move_files($questionid, $oldcontextid, $newcontextid);
!         $this->move_files_in_answers($questionid, $oldcontextid, $newcontextid);
!     }
! 
!     protected function delete_files($questionid, $contextid) {
!         parent::delete_files($questionid, $contextid);
!         $this->delete_files_in_answers($questionid, $contextid);
!     }
! 
!     function save_question_options($question) {
!         global $DB;
!         $result = new stdClass;
! 
!         $context = $question->context;
! 
!         $oldanswers = $DB->get_records('question_answers',
!                 array('question' => $question->id), 'id ASC');
! 
!         // Insert all the new answers
!         $answers = array();
!         $maxfraction = -1;
!         foreach ($question->answer as $key => $answerdata) {
!             // Check for, and ignore, completely blank answer from the form.
!             if (trim($answerdata) == '' && $question->fraction[$key] == 0 &&
!                     html_is_blank($question->feedback[$key]['text'])) {
!                 continue;
!             }
! 
!             // Update an existing answer if possible.
!             $answer = array_shift($oldanswers);
!             if (!$answer) {
!                 $answer = new stdClass();
!                 $answer->question = $question->id;
!                 $answer->answer = '';
!                 $answer->feedback = '';
!                 $answer->id = $DB->insert_record('question_answers', $answer);
!             }
! 
!             $answer->answer   = trim($answerdata);
!             $answer->fraction = $question->fraction[$key];
!             $answer->feedback = $this->import_or_save_files($question->feedback[$key],
!                     $context, 'question', 'answerfeedback', $answer->id);
!             $answer->feedbackformat = $question->feedback[$key]['format'];
!             $DB->update_record('question_answers', $answer);
! 
!             $answers[] = $answer->id;
!             if ($question->fraction[$key] > $maxfraction) {
!                 $maxfraction = $question->fraction[$key];
!             }
!         }
! 
!         // Delete any left over old answer records.
!         $fs = get_file_storage();
!         foreach($oldanswers as $oldanswer) {
!             $fs->delete_area_files($context->id, 'question', 'answerfeedback', $oldanswer->id);
!             $DB->delete_records('question_answers', array('id' => $oldanswer->id));
!         }
! 
!         $question->answers = implode(',', $answers);
!         $parentresult = parent::save_question_options($question);
!         if ($parentresult !== null) {
!             // Parent function returns null if all is OK
!             return $parentresult;
!         }
! 
!         // Perform sanity checks on fractional grades
!         if ($maxfraction != 1) {
!             $result->noticeyesno = get_string('fractionsnomax', 'quiz', $maxfraction * 100);
!             return $result;
!         }
! 
!         return true;
!     }
! 
!     function print_question_formulation_and_controls(&$question, &$state, $cmoptions, $options) {
!         global $CFG;
!         $context = $this->get_context_by_category_id($question->category);
!     /// This implementation is also used by question type 'numerical'
!         $readonly = empty($options->readonly) ? '' : 'readonly="readonly"';
!         $formatoptions = new stdClass;
!         $formatoptions->noclean = true;
!         $formatoptions->para = false;
!         $nameprefix = $question->name_prefix;
! 
!         /// Print question text and media
! 
!         $questiontext = format_text($question->questiontext,
!                 $question->questiontextformat,
!                 $formatoptions, $cmoptions->course);
! 
!         /// Print input controls
! 
!         if (isset($state->responses['']) && $state->responses['']!='') {
!             $value = ' value="'.s($state->responses['']).'" ';
!         } else {
!             $value = ' value="" ';
!         }
!         $inputname = ' name="'.$nameprefix.'" ';
! 
!         $feedback = '';
!         $class = '';
!         $feedbackimg = '';
! 
!         if ($options->feedback) {
!             $class = question_get_feedback_class(0);
!             $feedbackimg = question_get_feedback_image(0);
!             //this is OK for the first answer with a good response
!             foreach($question->options->answers as $answer) {
! 
!                 if ($this->test_response($question, $state, $answer)) {
!                     // Answer was correct or partially correct.
!                     $class = question_get_feedback_class($answer->fraction);
!                     $feedbackimg = question_get_feedback_image($answer->fraction);
!                     if ($answer->feedback) {
!                         $answer->feedback = quiz_rewrite_question_urls($answer->feedback, 'pluginfile.php', $context->id, 'question', 'answerfeedback', array($state->attempt, $state->question), $answer->id);
!                         $feedback = format_text($answer->feedback, $answer->feedbackformat, $formatoptions, $cmoptions->course);
!                     }
!                     break;
!                 }
!             }
!         }
! 
!         /// Removed correct answer, to be displayed later MDL-7496
!         include($this->get_display_html_path());
!     }
! 
!     function get_display_html_path() {
!         global $CFG;
!         return $CFG->dirroot.'/question/type/shortanswer/display.html';
!     }
! 
!     function check_response(&$question, &$state) {
!         foreach($question->options->answers as $aid => $answer) {
!             if ($this->test_response($question, $state, $answer)) {
!                 return $aid;
!             }
!         }
!         return false;
!     }
! 
!     function compare_responses($question, $state, $teststate) {
!         if (isset($state->responses['']) && isset($teststate->responses[''])) {
!             return $state->responses[''] === $teststate->responses[''];
!         }
!         return false;
!     }
! 
!     function test_response(&$question, $state, $answer) {
!         // Trim the response before it is saved in the database. See MDL-10709
!         $state->responses[''] = trim($state->responses['']);
!         return $this->compare_string_with_wildcard($state->responses[''],
!                 $answer->answer, !$question->options->usecase);
!     }
! 
!     function compare_string_with_wildcard($string, $pattern, $ignorecase) {
!         // Break the string on non-escaped asterisks.
!         $bits = preg_split('/(?<!\\\\)\*/', $pattern);
!         // Escape regexp special characters in the bits.
!         $excapedbits = array();
!         foreach ($bits as $bit) {
!             $excapedbits[] = preg_quote(str_replace('\*', '*', $bit));
!         }
!         // Put it back together to make the regexp.
!         $regexp = '|^' . implode('.*', $excapedbits) . '$|u';
! 
!         // Make the match insensitive if requested to.
!         if ($ignorecase) {
!             $regexp .= 'i';
!         }
! 
!         return preg_match($regexp, trim($string));
!     }
! 
!     /**
!      * @param string response is a response.
!      * @return formatted response
!      */
!     function format_response($response, $format){
!         return s($response);
!     }
! 
!     /*
!      * Override the parent class method, to remove escaping from asterisks.
!      */
!     function get_correct_responses(&$question, &$state) {
!         $response = parent::get_correct_responses($question, $state);
!         if (is_array($response)) {
!             $response[''] = str_replace('\*', '*', $response['']);
!         }
!         return $response;
!     }
!     /**
!      * @param object $question
!      * @return mixed either a integer score out of 1 that the average random
!      * guess by a student might give or an empty string which means will not
!      * calculate.
!      */
!     function get_random_guess_score($question) {
!         $answers = &$question->options->answers;
!         foreach($answers as $aid => $answer) {
!             if ('*' == trim($answer->answer)){
!                 return $answer->fraction;
!             }
!         }
!         return 0;
!     }
! 
!     /**
!     * Prints the score obtained and maximum score available plus any penalty
!     * information
!     *
!     * This function prints a summary of the scoring in the most recently
!     * graded state (the question may not have been submitted for marking at
!     * the current state). The default implementation should be suitable for most
!     * question types.
!     * @param object $question The question for which the grading details are
!     *                         to be rendered. Question type specific information
!     *                         is included. The maximum possible grade is in
!     *                         ->maxgrade.
!     * @param object $state    The state. In particular the grading information
!     *                          is in ->grade, ->raw_grade and ->penalty.
!     * @param object $cmoptions
!     * @param object $options  An object describing the rendering options.
!     */
!     function print_question_grading_details(&$question, &$state, $cmoptions, $options) {
!         /* The default implementation prints the number of marks if no attempt
!         has been made. Otherwise it displays the grade obtained out of the
!         maximum grade available and a warning if a penalty was applied for the
!         attempt and displays the overall grade obtained counting all previous
!         responses (and penalties) */
! 
!         global $QTYPES ;
!         // MDL-7496 show correct answer after "Incorrect"
!         $correctanswer = '';
!         if ($correctanswers =  $QTYPES[$question->qtype]->get_correct_responses($question, $state)) {
!             if ($options->readonly && $options->correct_responses) {
!                 $delimiter = '';
!                 if ($correctanswers) {
!                     foreach ($correctanswers as $ca) {
!                         $correctanswer .= $delimiter.$ca;
!                         $delimiter = ', ';
!                     }
!                 }
!             }
!         }
! 
!         if (QUESTION_EVENTDUPLICATE == $state->event) {
!             echo ' ';
!             print_string('duplicateresponse', 'quiz');
!         }
!         if ($question->maxgrade > 0 && $options->scores) {
!             if (question_state_is_graded($state->last_graded)) {
!                 // Display the grading details from the last graded state
!                 $grade = new stdClass;
!                 $grade->cur = question_format_grade($cmoptions, $state->last_graded->grade);
!                 $grade->max = question_format_grade($cmoptions, $question->maxgrade);
!                 $grade->raw = question_format_grade($cmoptions, $state->last_graded->raw_grade);
!                 // let student know wether the answer was correct
!                 $class = question_get_feedback_class($state->last_graded->raw_grade /
!                         $question->maxgrade);
!                 echo '<div class="correctness ' . $class . '">' . get_string($class, 'quiz');
!                 if ($correctanswer  != '' && ($class == 'partiallycorrect' || $class == 'incorrect')) {
!                     echo ('<div class="correctness">');
!                     print_string('correctansweris', 'quiz', s($correctanswer));
!                     echo ('</div>');
!                 }
!                 echo '</div>';
! 
!                 echo '<div class="gradingdetails">';
!                 // print grade for this submission
!                 print_string('gradingdetails', 'quiz', $grade) ;
!                 // A unit penalty for numerical was applied so display it
!                 // a temporary solution for unit rendering in numerical
!                 // waiting for the new question engine code for a permanent one
!                 if(isset($state->options->raw_unitpenalty) && $state->options->raw_unitpenalty > 0.0 ){
!                     echo ' ';
!                     print_string('unitappliedpenalty','qtype_numerical',question_format_grade($cmoptions, $state->options->raw_unitpenalty * $question->maxgrade ));
!                 }
!                 if ($cmoptions->penaltyscheme) {
!                     // print details of grade adjustment due to penalties
!                     if ($state->last_graded->raw_grade > $state->last_graded->grade){
!                         echo ' ';
!                         print_string('gradingdetailsadjustment', 'quiz', $grade);
!                     }
!                     // print info about new penalty
!                     // penalty is relevant only if the answer is not correct and further attempts are possible
!                     if (($state->last_graded->raw_grade < $question->maxgrade) and (QUESTION_EVENTCLOSEANDGRADE != $state->event)) {
!                         if ('' !== $state->last_graded->penalty && ((float)$state->last_graded->penalty) > 0.0) {
!                             echo ' ' ;
!                             print_string('gradingdetailspenalty', 'quiz', question_format_grade($cmoptions, $state->last_graded->penalty));
!                         } else {
!                             /* No penalty was applied even though the answer was
!                             not correct (eg. a syntax error) so tell the student
!                             that they were not penalised for the attempt */
!                             echo ' ';
!                             print_string('gradingdetailszeropenalty', 'quiz');
!                         }
!                     }
!                 }
!                 echo '</div>';
!             }
!         }
!     }
! 
!     /**
!      * Runs all the code required to set up and save an essay question for testing purposes.
!      * Alternate DB table prefix may be used to facilitate data deletion.
!      */
!     function generate_test($name, $courseid = null) {
!         global $DB;
!         list($form, $question) = parent::generate_test($name, $courseid);
!         $question->category = $form->category;
! 
!         $form->questiontext = "What is the purpose of life, the universe, and everything";
!         $form->generalfeedback = "Congratulations, you may have solved my biggest problem!";
!         $form->penalty = 0.1;
!         $form->usecase = false;
!         $form->defaultgrade = 1;
!         $form->noanswers = 3;
!         $form->answer = array('42', 'who cares?', 'Be happy');
!         $form->fraction = array(1, 0.6, 0.8);
!         $form->feedback = array('True, but what does that mean?', 'Well you do, dont you?', 'Yes, but thats not funny...');
!         $form->correctfeedback = 'Excellent!';
!         $form->incorrectfeedback = 'Nope!';
!         $form->partiallycorrectfeedback = 'Not bad';
! 
!         if ($courseid) {
!             $course = $DB->get_record('course', array('id' => $courseid));
!         }
! 
!         return $this->save_question($question, $form);
!     }
! 
!     function check_file_access($question, $state, $options, $contextid, $component,
!             $filearea, $args) {
!         if ($component == 'question' && $filearea == 'answerfeedback') {
!             $answers = &$question->options->answers;
!             if (isset($state->responses[''])) {
!                 $response = $state->responses[''];
!             } else {
!                 $response = '';
!             }
!             $answerid = reset($args); // itemid is answer id.
!             if (empty($options->feedback)) {
!                 return false;
!             }
!             foreach($answers as $answer) {
!                 if ($this->test_response($question, $state, $answer)) {
!                     return true;
!                 }
!             }
!             return false;
! 
!         } else {
!             return parent::check_file_access($question, $state, $options, $contextid, $component,
!                     $filearea, $args);
!         }
!     }
  
  }
  //// END OF CLASS ////
--- 33,416 ----
  
  class question_shortanswer_qtype extends default_questiontype {
  
! 	function name() {
! 		return 'shortanswer';
! 	}
! 
! 	function has_wildcards_in_responses($question, $subqid) {
! 		return true;
! 	}
! 
! 	function extra_question_fields() {
! 		return array('question_shortanswer', 'answers', 'usecase');
! 	}
! 
! 	function questionid_column_name() {
! 		return 'question';
! 	}
! 
! 	function move_files($questionid, $oldcontextid, $newcontextid) {
! 		parent::move_files($questionid, $oldcontextid, $newcontextid);
! 		$this->move_files_in_answers($questionid, $oldcontextid, $newcontextid);
! 	}
! 
! 	protected function delete_files($questionid, $contextid) {
! 		parent::delete_files($questionid, $contextid);
! 		$this->delete_files_in_answers($questionid, $contextid);
! 	}
! 
! 	function save_question_options($question) {
! 		global $DB;
! 		$result = new stdClass;
! 
! 		$context = $question->context;
! 
! 		$oldanswers = $DB->get_records('question_answers',
! 		array('question' => $question->id), 'id ASC');
! 
! 		// Insert all the new answers
! 		$answers = array();
! 		$maxfraction = -1;
! 		foreach ($question->answer as $key => $answerdata) {
! 			// Check for, and ignore, completely blank answer from the form.
! 			if (trim($answerdata) == '' && $question->fraction[$key] == 0 &&
! 			html_is_blank($question->feedback[$key]['text'])) {
! 				continue;
! 			}
! 
! 			// Update an existing answer if possible.
! 			$answer = array_shift($oldanswers);
! 			if (!$answer) {
! 				$answer = new stdClass();
! 				$answer->question = $question->id;
! 				$answer->answer = '';
! 				$answer->feedback = '';
! 				$answer->id = $DB->insert_record('question_answers', $answer);
! 			}
! 
! 			$answer->answer   = trim($answerdata);
! 			$answer->fraction = $question->fraction[$key];
! 			$answer->feedback = $this->import_or_save_files($question->feedback[$key],
! 			$context, 'question', 'answerfeedback', $answer->id);
! 			$answer->feedbackformat = $question->feedback[$key]['format'];
! 			$DB->update_record('question_answers', $answer);
! 
! 			$answers[] = $answer->id;
! 			if ($question->fraction[$key] > $maxfraction) {
! 				$maxfraction = $question->fraction[$key];
! 			}
! 		}
! 
! 		// Delete any left over old answer records.
! 		$fs = get_file_storage();
! 		foreach($oldanswers as $oldanswer) {
! 			$fs->delete_area_files($context->id, 'question', 'answerfeedback', $oldanswer->id);
! 			$DB->delete_records('question_answers', array('id' => $oldanswer->id));
! 		}
! 
! 		$question->answers = implode(',', $answers);
! 		$parentresult = parent::save_question_options($question);
! 		if ($parentresult !== null) {
! 			// Parent function returns null if all is OK
! 			return $parentresult;
! 		}
! 
! 		// Perform sanity checks on fractional grades
! 		if ($maxfraction != 1) {
! 			$result->noticeyesno = get_string('fractionsnomax', 'quiz', $maxfraction * 100);
! 			return $result;
! 		}
! 
! 		return true;
! 	}
! 
! 	function print_question_formulation_and_controls(&$question, &$state, $cmoptions, $options) {
! 		global $CFG;
! 		$context = $this->get_context_by_category_id($question->category);
! 		/// This implementation is also used by question type 'numerical'
! 		$readonly = empty($options->readonly) ? '' : 'readonly="readonly"';
! 		$formatoptions = new stdClass;
! 		$formatoptions->noclean = true;
! 		$formatoptions->para = false;
! 		$nameprefix = $question->name_prefix;
! 
! 		/// Print question text and media
! 
! 		$questiontext = format_text($question->questiontext,
! 		$question->questiontextformat,
! 		$formatoptions, $cmoptions->course);
! 
! 		/// Print input controls
! 
! 		if (isset($state->responses['']) && $state->responses['']!='') {
! 			$value = ' value="'.s($state->responses['']).'" ';
! 		} else {
! 			$value = ' value="" ';
! 		}
! 		$inputname = ' name="'.$nameprefix.'" ';
! 
! 		$feedback = '';
! 		$class = '';
! 		$feedbackimg = '';
! 
! 		if ($options->feedback) {
! 			$class = question_get_feedback_class(0);
! 			$feedbackimg = question_get_feedback_image(0);
! 			//this is OK for the first answer with a good response
! 			foreach($question->options->answers as $answer) {
! 
! 				if ($this->test_response($question, $state, $answer)) {
! 					// Answer was correct or partially correct.
! 					$class = question_get_feedback_class($answer->fraction);
! 					$feedbackimg = question_get_feedback_image($answer->fraction);
! 					if ($answer->feedback) {
! 						$answer->feedback = quiz_rewrite_question_urls($answer->feedback, 'pluginfile.php', $context->id, 'question', 'answerfeedback', array($state->attempt, $state->question), $answer->id);
! 						$feedback = format_text($answer->feedback, $answer->feedbackformat, $formatoptions, $cmoptions->course);
! 					}
! 					break;
! 				}
! 			}
! 		}
! 
! 		/// Removed correct answer, to be displayed later MDL-7496
! 		include($this->get_display_html_path());
! 	}
! 
! 	function get_display_html_path() {
! 		global $CFG;
! 		return $CFG->dirroot.'/question/type/shortanswer/display.html';
! 	}
! 
! 	function check_response(&$question, &$state) {
! 		foreach($question->options->answers as $aid => $answer) {
! 			if ($this->test_response($question, $state, $answer)) {
! 				return $aid;
! 			}
! 		}
! 		return false;
! 	}
! 
! 	function compare_responses($question, $state, $teststate) {
! 		if (isset($state->responses['']) && isset($teststate->responses[''])) {
! 			return $state->responses[''] === $teststate->responses[''];
! 		}
! 		return false;
! 	}
! 
! 	function test_response(&$question, $state, $answer) {
! 		// Trim the response before it is saved in the database. See MDL-10709
! 		$state->responses[''] = trim($state->responses['']);
! 		return $this->compare_string_with_wildcard($state->responses[''],
! 		$answer->answer, !$question->options->usecase);
! 	}
! 
! 	function compare_string_with_wildcard($string, $pattern, $ignorecase) {
! 		// Break the string on non-escaped asterisks.
! 		$bits = preg_split('/(?<!\\\\)\*/', $pattern);
! 		// Escape regexp special characters in the bits.
! 		$excapedbits = array();
! 		foreach ($bits as $bit) {
! 			$excapedbits[] = preg_quote(str_replace('\*', '*', $bit));
! 		}
! 		// Put it back together to make the regexp.
! 		$regexp = '|^' . implode('.*', $excapedbits) . '$|u';
! 
! 		// Make the match insensitive if requested to.
! 		if ($ignorecase) {
! 			$regexp .= 'i';
! 		}
! 
! 		return preg_match($regexp, trim($string));
! 	}
! 
! 	/**
! 	 * @param string response is a response.
! 	 * @return formatted response
! 	 */
! 	function format_response($response, $format){
! 		return s($response);
! 	}
! 
! 	/*
! 	 * Override the parent class method, to remove escaping from asterisks.
! 	 */
! 	function get_correct_responses(&$question, &$state) {
! 		$response = parent::get_correct_responses($question, $state);
! 		if (is_array($response)) {
! 			$response[''] = str_replace('\*', '*', $response['']);
! 		}
! 		return $response;
! 	}
! 	/**
! 	 * @param object $question
! 	 * @return mixed either a integer score out of 1 that the average random
! 	 * guess by a student might give or an empty string which means will not
! 	 * calculate.
! 	 */
! 	function get_random_guess_score($question) {
! 		$answers = &$question->options->answers;
! 		foreach($answers as $aid => $answer) {
! 			if ('*' == trim($answer->answer)){
! 				return $answer->fraction;
! 			}
! 		}
! 		return 0;
! 	}
! 
! 	/**
! 	 * Prints the score obtained and maximum score available plus any penalty
! 	 * information
! 	 *
! 	 * This function prints a summary of the scoring in the most recently
! 	 * graded state (the question may not have been submitted for marking at
! 	 * the current state). The default implementation should be suitable for most
! 	 * question types.
! 	 * @param object $question The question for which the grading details are
! 	 *                         to be rendered. Question type specific information
! 	 *                         is included. The maximum possible grade is in
! 	 *                         ->maxgrade.
! 	 * @param object $state    The state. In particular the grading information
! 	 *                          is in ->grade, ->raw_grade and ->penalty.
! 	 * @param object $cmoptions
! 	 * @param object $options  An object describing the rendering options.
! 	 */
! 	function print_question_grading_details(&$question, &$state, $cmoptions, $options) {
! 		/* The default implementation prints the number of marks if no attempt
! 		 has been made. Otherwise it displays the grade obtained out of the
! 		 maximum grade available and a warning if a penalty was applied for the
! 		 attempt and displays the overall grade obtained counting all previous
! 		 responses (and penalties) */
! 
! 		global $QTYPES ;
! 		// MDL-7496 show correct answer after "Incorrect"
! 		$correctanswer = '';
! 		if ($correctanswers =  $QTYPES[$question->qtype]->get_correct_responses($question, $state)) {
! 			if ($options->readonly && $options->correct_responses) {
! 				$delimiter = '';
! 				if ($correctanswers) {
! 					foreach ($correctanswers as $ca) {
! 						$correctanswer .= $delimiter.$ca;
! 						$delimiter = ', ';
! 					}
! 				}
! 			}
! 		}
! 
! 		if (QUESTION_EVENTDUPLICATE == $state->event) {
! 			echo ' ';
! 			print_string('duplicateresponse', 'quiz');
! 		}
! 		if ($question->maxgrade > 0 && $options->scores) {
! 			if (question_state_is_graded($state->last_graded)) {
! 				// Display the grading details from the last graded state
! 				$grade = new stdClass;
! 				$grade->cur = question_format_grade($cmoptions, $state->last_graded->grade);
! 				$grade->max = question_format_grade($cmoptions, $question->maxgrade);
! 				$grade->raw = question_format_grade($cmoptions, $state->last_graded->raw_grade);
! 				// let student know wether the answer was correct
! 				$class = question_get_feedback_class($state->last_graded->raw_grade /
! 				$question->maxgrade);
! 				echo '<div class="correctness ' . $class . '">' . get_string($class, 'quiz');
! 				$_SESSION['content'].= "<tr><td><b>".get_string($class, 'quiz')."</b></td></tr>";
! 				if ($correctanswer  != '' && ($class == 'partiallycorrect' || $class == 'incorrect')) {
! 					echo ('<div class="correctness">');
! 					print_string('correctansweris', 'quiz', s($correctanswer));
! 					echo ('</div>');
! 				}
! 				echo '</div>';
! 
! 				echo '<div class="gradingdetails">';
! 				// print grade for this submission
! 				print_string('gradingdetails', 'quiz', $grade) ;
! 				$_SESSION['content'].= "<tr><td><b>". get_string('gradingdetails', 'quiz', $grade)."</b></td></tr>";
! 				// A unit penalty for numerical was applied so display it
! 				// a temporary solution for unit rendering in numerical
! 				// waiting for the new question engine code for a permanent one
! 				if(isset($state->options->raw_unitpenalty) && $state->options->raw_unitpenalty > 0.0 ){
! 					echo ' ';
! 					print_string('unitappliedpenalty','qtype_numerical',question_format_grade($cmoptions, $state->options->raw_unitpenalty * $question->maxgrade ));
! 				}
! 				if ($cmoptions->penaltyscheme) {
! 					// print details of grade adjustment due to penalties
! 					if ($state->last_graded->raw_grade > $state->last_graded->grade){
! 						echo ' ';
! 						print_string('gradingdetailsadjustment', 'quiz', $grade);
! 					}
! 					// print info about new penalty
! 					// penalty is relevant only if the answer is not correct and further attempts are possible
! 					if (($state->last_graded->raw_grade < $question->maxgrade) and (QUESTION_EVENTCLOSEANDGRADE != $state->event)) {
! 						if ('' !== $state->last_graded->penalty && ((float)$state->last_graded->penalty) > 0.0) {
! 							echo ' ' ;
! 							print_string('gradingdetailspenalty', 'quiz', question_format_grade($cmoptions, $state->last_graded->penalty));
! 						} else {
! 							/* No penalty was applied even though the answer was
! 							 not correct (eg. a syntax error) so tell the student
! 							 that they were not penalised for the attempt */
! 							echo ' ';
! 							print_string('gradingdetailszeropenalty', 'quiz');
! 						}
! 					}
! 				}
! 				echo '</div>';
! 			}
! 		}
! 		$_SESSION['content'].="</table>";
! 	}
! 
! 	/**
! 	 * Runs all the code required to set up and save an essay question for testing purposes.
! 	 * Alternate DB table prefix may be used to facilitate data deletion.
! 	 */
! 	function generate_test($name, $courseid = null) {
! 		global $DB;
! 		list($form, $question) = parent::generate_test($name, $courseid);
! 		$question->category = $form->category;
! 
! 		$form->questiontext = "What is the purpose of life, the universe, and everything";
! 		$form->generalfeedback = "Congratulations, you may have solved my biggest problem!";
! 		$form->penalty = 0.1;
! 		$form->usecase = false;
! 		$form->defaultgrade = 1;
! 		$form->noanswers = 3;
! 		$form->answer = array('42', 'who cares?', 'Be happy');
! 		$form->fraction = array(1, 0.6, 0.8);
! 		$form->feedback = array('True, but what does that mean?', 'Well you do, dont you?', 'Yes, but thats not funny...');
! 		$form->correctfeedback = 'Excellent!';
! 		$form->incorrectfeedback = 'Nope!';
! 		$form->partiallycorrectfeedback = 'Not bad';
! 
! 		if ($courseid) {
! 			$course = $DB->get_record('course', array('id' => $courseid));
! 		}
! 
! 		return $this->save_question($question, $form);
! 	}
! 
! 	function check_file_access($question, $state, $options, $contextid, $component,
! 	$filearea, $args) {
! 		if ($component == 'question' && $filearea == 'answerfeedback') {
! 			$answers = &$question->options->answers;
! 			if (isset($state->responses[''])) {
! 				$response = $state->responses[''];
! 			} else {
! 				$response = '';
! 			}
! 			$answerid = reset($args); // itemid is answer id.
! 			if (empty($options->feedback)) {
! 				return false;
! 			}
! 			foreach($answers as $answer) {
! 				if ($this->test_response($question, $state, $answer)) {
! 					return true;
! 				}
! 			}
! 			return false;
! 
! 		} else {
! 			return parent::check_file_access($question, $state, $options, $contextid, $component,
! 			$filearea, $args);
! 		}
! 	}
  
  }
  //// END OF CLASS ////
diff -crB questionorg/type/shortanswer/simpletest/testquestiontype.php questionupd/type/shortanswer/simpletest/testquestiontype.php
*** questionorg/type/shortanswer/simpletest/testquestiontype.php	2012-04-13 12:31:12.927178283 +0500
--- questionupd/type/shortanswer/simpletest/testquestiontype.php	2012-04-13 09:42:59.000000000 +0500
***************
*** 9,267 ****
   */
  
  if (!defined('MOODLE_INTERNAL')) {
!     die('Direct access to this script is forbidden.');    ///  It must be included from a Moodle page
  }
  
  require_once($CFG->dirroot . '/question/type/questiontype.php');
  
  class question_shortanswer_qtype_test extends UnitTestCase {
!     public static $includecoverage = array('question/type/questiontype.php', 'question/type/shortanswer/questiontype.php');
!     var $qtype;
  
!     function setUp() {
!         $this->qtype = new question_shortanswer_qtype();
!     }
! 
!     function tearDown() {
!         $this->qtype = null;
!     }
! 
!     function test_name() {
!         $this->assertEqual($this->qtype->name(), 'shortanswer');
!     }
! 
!     function test_compare_string_with_wildcard() {
!         // Test case sensitive literal matches.
!         $this->assertTrue($this->qtype->compare_string_with_wildcard('Frog', 'Frog', false));
!         $this->assertFalse($this->qtype->compare_string_with_wildcard('Frog', 'frog', false));
!         $this->assertTrue($this->qtype->compare_string_with_wildcard('   Frog   ', 'Frog', false));
!         $this->assertFalse($this->qtype->compare_string_with_wildcard('Frogs', 'Frog', false));
! 
!         // Test case insensitive literal matches.
!         $this->assertTrue($this->qtype->compare_string_with_wildcard('Frog', 'frog', true));
!         $this->assertTrue($this->qtype->compare_string_with_wildcard('   FROG   ', 'Frog', true));
!         $this->assertFalse($this->qtype->compare_string_with_wildcard('Frogs', 'Frog', true));
! 
!         // Test case sensitive wildcard matches.
!         $this->assertTrue($this->qtype->compare_string_with_wildcard('Frog', 'F*og', false));
!         $this->assertTrue($this->qtype->compare_string_with_wildcard('Fog', 'F*og', false));
!         $this->assertTrue($this->qtype->compare_string_with_wildcard('   Fat dog   ', 'F*og', false));
!         $this->assertFalse($this->qtype->compare_string_with_wildcard('Frogs', 'F*og', false));
!         $this->assertFalse($this->qtype->compare_string_with_wildcard('Fg', 'F*og', false));
!         $this->assertFalse($this->qtype->compare_string_with_wildcard('frog', 'F*og', false));
!         $this->assertFalse($this->qtype->compare_string_with_wildcard('   fat dog   ', 'F*og', false));
! 
!         // Test case insensitive wildcard matches.
!         $this->assertTrue($this->qtype->compare_string_with_wildcard('Frog', 'F*og', true));
!         $this->assertTrue($this->qtype->compare_string_with_wildcard('Fog', 'F*og', true));
!         $this->assertTrue($this->qtype->compare_string_with_wildcard('   Fat dog   ', 'F*og', true));
!         $this->assertFalse($this->qtype->compare_string_with_wildcard('Frogs', 'F*og', true));
!         $this->assertFalse($this->qtype->compare_string_with_wildcard('Fg', 'F*og', true));
!         $this->assertTrue($this->qtype->compare_string_with_wildcard('frog', 'F*og', true));
!         $this->assertTrue($this->qtype->compare_string_with_wildcard('   fat dog   ', 'F*og', true));
! 
!         // Test match using regexp special chars.
!         $this->assertTrue($this->qtype->compare_string_with_wildcard('   *   ', '\*', false));
!         $this->assertTrue($this->qtype->compare_string_with_wildcard('*', '\*', false));
!         $this->assertTrue($this->qtype->compare_string_with_wildcard('Frog*toad', 'Frog\*toad', false));
!         $this->assertFalse($this->qtype->compare_string_with_wildcard('a', '[a-z]', false));
!         $this->assertTrue($this->qtype->compare_string_with_wildcard('[a-z]', '[a-z]', false));
!         $this->assertTrue($this->qtype->compare_string_with_wildcard('\{}/', '\{}/', true));
! 
!         // See http://moodle.org/mod/forum/discuss.php?d=120557
!         $this->assertTrue($this->qtype->compare_string_with_wildcard('ITLIE', 'Itlie', true));
!     }
! 
!     function test_check_response() {
!         $answer1 = new stdClass;
!         $answer1->id = 17;
!         $answer1->answer = "celine";
!         $answer1->fraction = 1;
!         $answer2 = new stdClass;
!         $answer2->id = 23;
!         $answer2->answer = "c*line";
!         $answer2->fraction = 0.8;
!         $answer3 = new stdClass;
!         $answer3->id = 23;
!         $answer3->answer = "*line";
!         $answer3->fraction = 0.7;
!         $answer4 = new stdClass;
!         $answer4->id = 29;
!         $answer4->answer = "12\*13";
!         $answer4->fraction = 0.5;
! 
!         $question = new stdClass;
!         $question->options->answers = array(
!             17 => $answer1,
!             23 => $answer2,
!             29 => $answer3,
!             31 => $answer4
!         );
!         $question->options->usecase = true;
! 
!         $state = new stdClass;
! 
!         $state->responses = array('' => 'celine');
!         $this->assertEqual($this->qtype->check_response($question, $state), 17);
! 
!         $state->responses = array('' => 'caline');
!         $this->assertEqual($this->qtype->check_response($question, $state), 23);
! 
!         $state->responses = array('' => 'aline');
!         $this->assertEqual($this->qtype->check_response($question, $state), 29);
! 
!         $state->responses = array('' => 'frog');
!         $this->assertFalse($this->qtype->check_response($question, $state));
! 
!         $state->responses = array('' => '12*13');
!         $this->assertEqual($this->qtype->check_response($question, $state), 31);
! 
!         $question->options->usecase = false;
! 
!         $answer1->answer = "Fred's";
!         $question->options->answers[17] = $answer1;
! 
!         $state->responses = array('' => 'frog');
!         $this->assertFalse($this->qtype->check_response($question, $state));
! 
!         $state->responses = array('' => "fred's");
!         $this->assertEqual($this->qtype->check_response($question, $state), 17);
! 
!         $state->responses = array('' => '12*13');
!         $this->assertEqual($this->qtype->check_response($question, $state), 31);
! 
!         $state->responses = array('' => 'caLINe');
!         $this->assertEqual($this->qtype->check_response($question, $state), 23);
! 
!         $state->responses = array('' => 'ALIne');
!         $this->assertEqual($this->qtype->check_response($question, $state), 29);
!     }
! 
!     function test_compare_responses() {
!         $question = new stdClass;
!         $question->options->usecase = false;
! 
!         $state = new stdClass;
!         $teststate = new stdClass;
!         $this->assertFalse($this->qtype->compare_responses($question, $state, $teststate));
! 
!         $state->responses = array('' => '');
!         $this->assertFalse($this->qtype->compare_responses($question, $state, $teststate));
! 
!         $state = new stdClass;
!         $teststate->responses = array('' => '');
!         $this->assertFalse($this->qtype->compare_responses($question, $state, $teststate));
! 
!         $state->responses = array('' => '');
!         $this->assertTrue($this->qtype->compare_responses($question, $state, $teststate));
! 
!         $state->responses = array('' => 'frog');
!         $teststate->responses = array('' => 'frog');
!         $this->assertTrue($this->qtype->compare_responses($question, $state, $teststate));
! 
!         $state->responses = array('' => 'frog');
!         $teststate->responses = array('' => 'Frog');
!         $this->assertFalse($this->qtype->compare_responses($question, $state, $teststate));
! 
!         $state->responses = array('' => "\'");
!         $teststate->responses = array('' => "\'");
!         $this->assertTrue($this->qtype->compare_responses($question, $state, $teststate));
! 
!         $state->responses = array('' => "'");
!         $teststate->responses = array('' => "'");
!         $this->assertTrue($this->qtype->compare_responses($question, $state, $teststate));
! 
!         $state->responses = array('' => 'frog*toad');
!         $teststate->responses = array('' => 'frog*TOAD');
!         $this->assertFalse($this->qtype->compare_responses($question, $state, $teststate));
! 
!         $state->responses = array('' => 'frog*');
!         $teststate->responses = array('' => 'frogs');
!         $this->assertFalse($this->qtype->compare_responses($question, $state, $teststate));
! 
!         $state->responses = array('' => 'frogs');
!         $teststate->responses = array('' => 'frog*');
!         $this->assertFalse($this->qtype->compare_responses($question, $state, $teststate));
! 
!         $question->options->usecase = true;
! 
!         $state->responses = array('' => '');
!         $teststate->responses = array('' => '');
!         $this->assertTrue($this->qtype->compare_responses($question, $state, $teststate));
! 
!         $state->responses = array('' => 'frog');
!         $teststate->responses = array('' => 'frog');
!         $this->assertTrue($this->qtype->compare_responses($question, $state, $teststate));
! 
!         $state->responses = array('' => 'frog');
!         $teststate->responses = array('' => 'Frog');
!         $this->assertFalse($this->qtype->compare_responses($question, $state, $teststate));
! 
!         $state->responses = array('' => "\'");
!         $teststate->responses = array('' => "\'");
!         $this->assertTrue($this->qtype->compare_responses($question, $state, $teststate));
! 
!         $state->responses = array('' => 'frog*toad');
!         $teststate->responses = array('' => 'frog*toad');
!         $this->assertTrue($this->qtype->compare_responses($question, $state, $teststate));
! 
!         $state->responses = array('' => 'frog*');
!         $teststate->responses = array('' => 'frogs');
!         $this->assertFalse($this->qtype->compare_responses($question, $state, $teststate));
! 
!         $state->responses = array('' => 'frogs');
!         $teststate->responses = array('' => 'frog*');
!         $this->assertFalse($this->qtype->compare_responses($question, $state, $teststate));
!     }
! 
!     function test_test_response() {
!         $answer = new stdClass;
!         $answer->id = 1;
!         $answer->answer = 'entrance';
!         $answer->fraction = 1;
!         $question = new stdClass;
!         $question->options->answers = array(
!             1 => $answer,
!         );
!         $question->options->usecase = 0;
!         $state = new stdClass;
!         $state->responses[''] = 'Entrance';
!         $this->assertTrue($this->qtype->test_response($question, $state, $answer));
!     }
! 
!     function test_get_correct_responses() {
!         $answer1 = new stdClass;
!         $answer1->id = 17;
!         $answer1->answer = "frog";
!         $answer1->fraction = 1;
!         $answer2 = new stdClass;
!         $answer2->id = 23;
!         $answer2->answer = "f*g";
!         $answer2->fraction = 1;
!         $answer3 = new stdClass;
!         $answer3->id = 29;
!         $answer3->answer = "12\*13";
!         $answer3->fraction = 1;
!         $answer4 = new stdClass;
!         $answer4->id = 31;
!         $answer4->answer = "*";
!         $answer4->fraction = 0;
!         $question = new stdClass;
!         $question->options->answers = array(
!             17 => $answer1,
!             23 => $answer2,
!             29 => $answer3,
!             31 => $answer4
!         );
!         $state = new stdClass;
!         $this->assertEqual($this->qtype->get_correct_responses($question, $state), array('' => 'frog'));
!         $question->options->answers[17]->fraction = 0;
!         $this->assertEqual($this->qtype->get_correct_responses($question, $state), array('' => 'f*g'));
!         $question->options->answers[23]->fraction = 0;
!         $this->assertEqual($this->qtype->get_correct_responses($question, $state), array('' => '12*13'));
!         $question->options->answers[29]->fraction = 0;
!         $this->assertNull($this->qtype->get_correct_responses($question, $state));
!     }
  }
  
  
--- 9,267 ----
   */
  
  if (!defined('MOODLE_INTERNAL')) {
! 	die('Direct access to this script is forbidden.');    ///  It must be included from a Moodle page
  }
  
  require_once($CFG->dirroot . '/question/type/questiontype.php');
  
  class question_shortanswer_qtype_test extends UnitTestCase {
! 	public static $includecoverage = array('question/type/questiontype.php', 'question/type/shortanswer/questiontype.php');
! 	var $qtype;
  
! 	function setUp() {
! 		$this->qtype = new question_shortanswer_qtype();
! 	}
! 
! 	function tearDown() {
! 		$this->qtype = null;
! 	}
! 
! 	function test_name() {
! 		$this->assertEqual($this->qtype->name(), 'shortanswer');
! 	}
! 
! 	function test_compare_string_with_wildcard() {
! 		// Test case sensitive literal matches.
! 		$this->assertTrue($this->qtype->compare_string_with_wildcard('Frog', 'Frog', false));
! 		$this->assertFalse($this->qtype->compare_string_with_wildcard('Frog', 'frog', false));
! 		$this->assertTrue($this->qtype->compare_string_with_wildcard('   Frog   ', 'Frog', false));
! 		$this->assertFalse($this->qtype->compare_string_with_wildcard('Frogs', 'Frog', false));
! 
! 		// Test case insensitive literal matches.
! 		$this->assertTrue($this->qtype->compare_string_with_wildcard('Frog', 'frog', true));
! 		$this->assertTrue($this->qtype->compare_string_with_wildcard('   FROG   ', 'Frog', true));
! 		$this->assertFalse($this->qtype->compare_string_with_wildcard('Frogs', 'Frog', true));
! 
! 		// Test case sensitive wildcard matches.
! 		$this->assertTrue($this->qtype->compare_string_with_wildcard('Frog', 'F*og', false));
! 		$this->assertTrue($this->qtype->compare_string_with_wildcard('Fog', 'F*og', false));
! 		$this->assertTrue($this->qtype->compare_string_with_wildcard('   Fat dog   ', 'F*og', false));
! 		$this->assertFalse($this->qtype->compare_string_with_wildcard('Frogs', 'F*og', false));
! 		$this->assertFalse($this->qtype->compare_string_with_wildcard('Fg', 'F*og', false));
! 		$this->assertFalse($this->qtype->compare_string_with_wildcard('frog', 'F*og', false));
! 		$this->assertFalse($this->qtype->compare_string_with_wildcard('   fat dog   ', 'F*og', false));
! 
! 		// Test case insensitive wildcard matches.
! 		$this->assertTrue($this->qtype->compare_string_with_wildcard('Frog', 'F*og', true));
! 		$this->assertTrue($this->qtype->compare_string_with_wildcard('Fog', 'F*og', true));
! 		$this->assertTrue($this->qtype->compare_string_with_wildcard('   Fat dog   ', 'F*og', true));
! 		$this->assertFalse($this->qtype->compare_string_with_wildcard('Frogs', 'F*og', true));
! 		$this->assertFalse($this->qtype->compare_string_with_wildcard('Fg', 'F*og', true));
! 		$this->assertTrue($this->qtype->compare_string_with_wildcard('frog', 'F*og', true));
! 		$this->assertTrue($this->qtype->compare_string_with_wildcard('   fat dog   ', 'F*og', true));
! 
! 		// Test match using regexp special chars.
! 		$this->assertTrue($this->qtype->compare_string_with_wildcard('   *   ', '\*', false));
! 		$this->assertTrue($this->qtype->compare_string_with_wildcard('*', '\*', false));
! 		$this->assertTrue($this->qtype->compare_string_with_wildcard('Frog*toad', 'Frog\*toad', false));
! 		$this->assertFalse($this->qtype->compare_string_with_wildcard('a', '[a-z]', false));
! 		$this->assertTrue($this->qtype->compare_string_with_wildcard('[a-z]', '[a-z]', false));
! 		$this->assertTrue($this->qtype->compare_string_with_wildcard('\{}/', '\{}/', true));
! 
! 		// See http://moodle.org/mod/forum/discuss.php?d=120557
! 		$this->assertTrue($this->qtype->compare_string_with_wildcard('ITLIE', 'Itlie', true));
! 	}
! 
! 	function test_check_response() {
! 		$answer1 = new stdClass;
! 		$answer1->id = 17;
! 		$answer1->answer = "celine";
! 		$answer1->fraction = 1;
! 		$answer2 = new stdClass;
! 		$answer2->id = 23;
! 		$answer2->answer = "c*line";
! 		$answer2->fraction = 0.8;
! 		$answer3 = new stdClass;
! 		$answer3->id = 23;
! 		$answer3->answer = "*line";
! 		$answer3->fraction = 0.7;
! 		$answer4 = new stdClass;
! 		$answer4->id = 29;
! 		$answer4->answer = "12\*13";
! 		$answer4->fraction = 0.5;
! 
! 		$question = new stdClass;
! 		$question->options->answers = array(
! 		17 => $answer1,
! 		23 => $answer2,
! 		29 => $answer3,
! 		31 => $answer4
! 		);
! 		$question->options->usecase = true;
! 
! 		$state = new stdClass;
! 
! 		$state->responses = array('' => 'celine');
! 		$this->assertEqual($this->qtype->check_response($question, $state), 17);
! 
! 		$state->responses = array('' => 'caline');
! 		$this->assertEqual($this->qtype->check_response($question, $state), 23);
! 
! 		$state->responses = array('' => 'aline');
! 		$this->assertEqual($this->qtype->check_response($question, $state), 29);
! 
! 		$state->responses = array('' => 'frog');
! 		$this->assertFalse($this->qtype->check_response($question, $state));
! 
! 		$state->responses = array('' => '12*13');
! 		$this->assertEqual($this->qtype->check_response($question, $state), 31);
! 
! 		$question->options->usecase = false;
! 
! 		$answer1->answer = "Fred's";
! 		$question->options->answers[17] = $answer1;
! 
! 		$state->responses = array('' => 'frog');
! 		$this->assertFalse($this->qtype->check_response($question, $state));
! 
! 		$state->responses = array('' => "fred's");
! 		$this->assertEqual($this->qtype->check_response($question, $state), 17);
! 
! 		$state->responses = array('' => '12*13');
! 		$this->assertEqual($this->qtype->check_response($question, $state), 31);
! 
! 		$state->responses = array('' => 'caLINe');
! 		$this->assertEqual($this->qtype->check_response($question, $state), 23);
! 
! 		$state->responses = array('' => 'ALIne');
! 		$this->assertEqual($this->qtype->check_response($question, $state), 29);
! 	}
! 
! 	function test_compare_responses() {
! 		$question = new stdClass;
! 		$question->options->usecase = false;
! 
! 		$state = new stdClass;
! 		$teststate = new stdClass;
! 		$this->assertFalse($this->qtype->compare_responses($question, $state, $teststate));
! 
! 		$state->responses = array('' => '');
! 		$this->assertFalse($this->qtype->compare_responses($question, $state, $teststate));
! 
! 		$state = new stdClass;
! 		$teststate->responses = array('' => '');
! 		$this->assertFalse($this->qtype->compare_responses($question, $state, $teststate));
! 
! 		$state->responses = array('' => '');
! 		$this->assertTrue($this->qtype->compare_responses($question, $state, $teststate));
! 
! 		$state->responses = array('' => 'frog');
! 		$teststate->responses = array('' => 'frog');
! 		$this->assertTrue($this->qtype->compare_responses($question, $state, $teststate));
! 
! 		$state->responses = array('' => 'frog');
! 		$teststate->responses = array('' => 'Frog');
! 		$this->assertFalse($this->qtype->compare_responses($question, $state, $teststate));
! 
! 		$state->responses = array('' => "\'");
! 		$teststate->responses = array('' => "\'");
! 		$this->assertTrue($this->qtype->compare_responses($question, $state, $teststate));
! 
! 		$state->responses = array('' => "'");
! 		$teststate->responses = array('' => "'");
! 		$this->assertTrue($this->qtype->compare_responses($question, $state, $teststate));
! 
! 		$state->responses = array('' => 'frog*toad');
! 		$teststate->responses = array('' => 'frog*TOAD');
! 		$this->assertFalse($this->qtype->compare_responses($question, $state, $teststate));
! 
! 		$state->responses = array('' => 'frog*');
! 		$teststate->responses = array('' => 'frogs');
! 		$this->assertFalse($this->qtype->compare_responses($question, $state, $teststate));
! 
! 		$state->responses = array('' => 'frogs');
! 		$teststate->responses = array('' => 'frog*');
! 		$this->assertFalse($this->qtype->compare_responses($question, $state, $teststate));
! 
! 		$question->options->usecase = true;
! 
! 		$state->responses = array('' => '');
! 		$teststate->responses = array('' => '');
! 		$this->assertTrue($this->qtype->compare_responses($question, $state, $teststate));
! 
! 		$state->responses = array('' => 'frog');
! 		$teststate->responses = array('' => 'frog');
! 		$this->assertTrue($this->qtype->compare_responses($question, $state, $teststate));
! 
! 		$state->responses = array('' => 'frog');
! 		$teststate->responses = array('' => 'Frog');
! 		$this->assertFalse($this->qtype->compare_responses($question, $state, $teststate));
! 
! 		$state->responses = array('' => "\'");
! 		$teststate->responses = array('' => "\'");
! 		$this->assertTrue($this->qtype->compare_responses($question, $state, $teststate));
! 
! 		$state->responses = array('' => 'frog*toad');
! 		$teststate->responses = array('' => 'frog*toad');
! 		$this->assertTrue($this->qtype->compare_responses($question, $state, $teststate));
! 
! 		$state->responses = array('' => 'frog*');
! 		$teststate->responses = array('' => 'frogs');
! 		$this->assertFalse($this->qtype->compare_responses($question, $state, $teststate));
! 
! 		$state->responses = array('' => 'frogs');
! 		$teststate->responses = array('' => 'frog*');
! 		$this->assertFalse($this->qtype->compare_responses($question, $state, $teststate));
! 	}
! 
! 	function test_test_response() {
! 		$answer = new stdClass;
! 		$answer->id = 1;
! 		$answer->answer = 'entrance';
! 		$answer->fraction = 1;
! 		$question = new stdClass;
! 		$question->options->answers = array(
! 		1 => $answer,
! 		);
! 		$question->options->usecase = 0;
! 		$state = new stdClass;
! 		$state->responses[''] = 'Entrance';
! 		$this->assertTrue($this->qtype->test_response($question, $state, $answer));
! 	}
! 
! 	function test_get_correct_responses() {
! 		$answer1 = new stdClass;
! 		$answer1->id = 17;
! 		$answer1->answer = "frog";
! 		$answer1->fraction = 1;
! 		$answer2 = new stdClass;
! 		$answer2->id = 23;
! 		$answer2->answer = "f*g";
! 		$answer2->fraction = 1;
! 		$answer3 = new stdClass;
! 		$answer3->id = 29;
! 		$answer3->answer = "12\*13";
! 		$answer3->fraction = 1;
! 		$answer4 = new stdClass;
! 		$answer4->id = 31;
! 		$answer4->answer = "*";
! 		$answer4->fraction = 0;
! 		$question = new stdClass;
! 		$question->options->answers = array(
! 		17 => $answer1,
! 		23 => $answer2,
! 		29 => $answer3,
! 		31 => $answer4
! 		);
! 		$state = new stdClass;
! 		$this->assertEqual($this->qtype->get_correct_responses($question, $state), array('' => 'frog'));
! 		$question->options->answers[17]->fraction = 0;
! 		$this->assertEqual($this->qtype->get_correct_responses($question, $state), array('' => 'f*g'));
! 		$question->options->answers[23]->fraction = 0;
! 		$this->assertEqual($this->qtype->get_correct_responses($question, $state), array('' => '12*13'));
! 		$question->options->answers[29]->fraction = 0;
! 		$this->assertNull($this->qtype->get_correct_responses($question, $state));
! 	}
  }
  
  
diff -crB questionorg/type/simpletest/testquestiontype.php questionupd/type/simpletest/testquestiontype.php
*** questionorg/type/simpletest/testquestiontype.php	2012-04-13 12:31:12.793178278 +0500
--- questionupd/type/simpletest/testquestiontype.php	2012-04-13 09:42:59.000000000 +0500
***************
*** 31,74 ****
   */
  
  if (!defined('MOODLE_INTERNAL')) {
!     die('Direct access to this script is forbidden.');    ///  It must be included from a Moodle page
  }
  
  require_once($CFG->dirroot . '/question/type/questiontype.php');
  
  class default_questiontype_test extends UnitTestCase {
!     public static $includecoverage = array('question/type/questiontype.php');
!     protected $qtype;
  
!     public function setUp() {
!         $this->qtype = new default_questiontype();
!     }
! 
!     public function tearDown() {
!         $this->qtype = null;
!     }
! 
!     function test_compare_responses() {
!         $question = new stdClass;
!         $state = new stdClass;
!         $teststate = new stdClass;
! 
!         $state->responses = array();
!         $teststate->responses = array();
!         $this->assertTrue($this->qtype->compare_responses($question, $state, $teststate));
! 
!         $state->responses = array('' => 'frog');
!         $teststate->responses = array('' => 'toad');
!         $this->assertFalse($this->qtype->compare_responses($question, $state, $teststate));
! 
!         $state->responses = array('x' => 'frog');
!         $teststate->responses = array('y' => 'frog');
!         $this->assertFalse($this->qtype->compare_responses($question, $state, $teststate));
! 
!         $state->responses = array(1 => 1, 2 => 2);
!         $teststate->responses = array(2 => 2, 1 => 1);
!         $this->assertTrue($this->qtype->compare_responses($question, $state, $teststate));
!     }
  }
  
  
--- 31,74 ----
   */
  
  if (!defined('MOODLE_INTERNAL')) {
! 	die('Direct access to this script is forbidden.');    ///  It must be included from a Moodle page
  }
  
  require_once($CFG->dirroot . '/question/type/questiontype.php');
  
  class default_questiontype_test extends UnitTestCase {
! 	public static $includecoverage = array('question/type/questiontype.php');
! 	protected $qtype;
  
! 	public function setUp() {
! 		$this->qtype = new default_questiontype();
! 	}
! 
! 	public function tearDown() {
! 		$this->qtype = null;
! 	}
! 
! 	function test_compare_responses() {
! 		$question = new stdClass;
! 		$state = new stdClass;
! 		$teststate = new stdClass;
! 
! 		$state->responses = array();
! 		$teststate->responses = array();
! 		$this->assertTrue($this->qtype->compare_responses($question, $state, $teststate));
! 
! 		$state->responses = array('' => 'frog');
! 		$teststate->responses = array('' => 'toad');
! 		$this->assertFalse($this->qtype->compare_responses($question, $state, $teststate));
! 
! 		$state->responses = array('x' => 'frog');
! 		$teststate->responses = array('y' => 'frog');
! 		$this->assertFalse($this->qtype->compare_responses($question, $state, $teststate));
! 
! 		$state->responses = array(1 => 1, 2 => 2);
! 		$teststate->responses = array(2 => 2, 1 => 1);
! 		$this->assertTrue($this->qtype->compare_responses($question, $state, $teststate));
! 	}
  }
  
  
diff -crB questionorg/type/truefalse/backup/moodle2/backup_qtype_truefalse_plugin.class.php questionupd/type/truefalse/backup/moodle2/backup_qtype_truefalse_plugin.class.php
*** questionorg/type/truefalse/backup/moodle2/backup_qtype_truefalse_plugin.class.php	2012-04-13 12:31:13.606178287 +0500
--- questionupd/type/truefalse/backup/moodle2/backup_qtype_truefalse_plugin.class.php	2012-04-13 09:42:59.000000000 +0500
***************
*** 28,63 ****
   */
  class backup_qtype_truefalse_plugin extends backup_qtype_plugin {
  
!     /**
!      * Returns the qtype information to attach to question element
!      */
!     protected function define_question_plugin_structure() {
! 
!         // Define the virtual plugin element with the condition to fulfill
!         $plugin = $this->get_plugin_element(null, '../../qtype', 'truefalse');
! 
!         // Create one standard named plugin element (the visible container)
!         $pluginwrapper = new backup_nested_element($this->get_recommended_name());
! 
!         // connect the visible container ASAP
!         $plugin->add_child($pluginwrapper);
! 
!         // This qtype uses standard question_answers, add them here
!         // to the tree before any other information that will use them
!         $this->add_question_question_answers($pluginwrapper);
  
!         // Now create the qtype own structures
!         $truefalse = new backup_nested_element('truefalse', array('id'), array(
              'trueanswer', 'falseanswer'));
  
!         // Now the own qtype tree
!         $pluginwrapper->add_child($truefalse);
  
!         // set source to populate the data
!         $truefalse->set_source_table('question_truefalse', array('question' => backup::VAR_PARENTID));
  
!         // don't need to annotate ids nor files
  
!         return $plugin;
!     }
  }
--- 28,63 ----
   */
  class backup_qtype_truefalse_plugin extends backup_qtype_plugin {
  
! 	/**
! 	 * Returns the qtype information to attach to question element
! 	 */
! 	protected function define_question_plugin_structure() {
! 
! 		// Define the virtual plugin element with the condition to fulfill
! 		$plugin = $this->get_plugin_element(null, '../../qtype', 'truefalse');
! 
! 		// Create one standard named plugin element (the visible container)
! 		$pluginwrapper = new backup_nested_element($this->get_recommended_name());
! 
! 		// connect the visible container ASAP
! 		$plugin->add_child($pluginwrapper);
! 
! 		// This qtype uses standard question_answers, add them here
! 		// to the tree before any other information that will use them
! 		$this->add_question_question_answers($pluginwrapper);
  
! 		// Now create the qtype own structures
! 		$truefalse = new backup_nested_element('truefalse', array('id'), array(
              'trueanswer', 'falseanswer'));
  
! 		// Now the own qtype tree
! 		$pluginwrapper->add_child($truefalse);
  
! 		// set source to populate the data
! 		$truefalse->set_source_table('question_truefalse', array('question' => backup::VAR_PARENTID));
  
! 		// don't need to annotate ids nor files
  
! 		return $plugin;
! 	}
  }
diff -crB questionorg/type/truefalse/backup/moodle2/restore_qtype_truefalse_plugin.class.php questionupd/type/truefalse/backup/moodle2/restore_qtype_truefalse_plugin.class.php
*** questionorg/type/truefalse/backup/moodle2/restore_qtype_truefalse_plugin.class.php	2012-04-13 12:31:13.608178296 +0500
--- questionupd/type/truefalse/backup/moodle2/restore_qtype_truefalse_plugin.class.php	2012-04-13 09:42:59.000000000 +0500
***************
*** 30,95 ****
   */
  class restore_qtype_truefalse_plugin extends restore_qtype_plugin {
  
!     /**
!      * Returns the paths to be handled by the plugin at question level
!      */
!     protected function define_question_plugin_structure() {
! 
!         $paths = array();
! 
!         // This qtype uses question_answers, add them
!         $this->add_question_question_answers($paths);
! 
!         // Add own qtype stuff
!         $elename = 'truefalse';
!         $elepath = $this->get_pathfor('/truefalse'); // we used get_recommended_name() so this works
!         $paths[] = new restore_path_element($elename, $elepath);
! 
! 
!         return $paths; // And we return the interesting paths
!     }
! 
!     /**
!      * Process the qtype/truefalse element
!      */
!     public function process_truefalse($data) {
!         global $DB;
! 
!         $data = (object)$data;
!         $oldid = $data->id;
! 
!         // Detect if the question is created or mapped
!         $oldquestionid   = $this->get_old_parentid('question');
!         $newquestionid   = $this->get_new_parentid('question');
!         $questioncreated = $this->get_mappingid('question_created', $oldquestionid) ? true : false;
! 
!         // If the question has been created by restore, we need to create its question_truefalse too
!         if ($questioncreated) {
!             // Adjust some columns
!             $data->question = $newquestionid;
!             $data->trueanswer = $this->get_mappingid('question_answer', $data->trueanswer);
!             $data->falseanswer = $this->get_mappingid('question_answer', $data->falseanswer);
!             // Insert record
!             $newitemid = $DB->insert_record('question_truefalse', $data);
!             // Create mapping
!             $this->set_mapping('question_truefalse', $oldid, $newitemid);
!         } else {
!             // Nothing to remap if the question already existed
!         }
!     }
! 
!     /**
!      * Given one question_states record, return the answer
!      * recoded pointing to all the restored stuff for truefalse questions
!      *
!      * if not empty, answer is one question_answers->id
!      */
!     public function recode_state_answer($state) {
!         $answer = $state->answer;
!         $result = '';
!         if ($answer) {
!             $result = $this->get_mappingid('question_answer', $answer);
!         }
!         return $result;
!     }
  }
--- 30,95 ----
   */
  class restore_qtype_truefalse_plugin extends restore_qtype_plugin {
  
! 	/**
! 	 * Returns the paths to be handled by the plugin at question level
! 	 */
! 	protected function define_question_plugin_structure() {
! 
! 		$paths = array();
! 
! 		// This qtype uses question_answers, add them
! 		$this->add_question_question_answers($paths);
! 
! 		// Add own qtype stuff
! 		$elename = 'truefalse';
! 		$elepath = $this->get_pathfor('/truefalse'); // we used get_recommended_name() so this works
! 		$paths[] = new restore_path_element($elename, $elepath);
! 
! 
! 		return $paths; // And we return the interesting paths
! 	}
! 
! 	/**
! 	 * Process the qtype/truefalse element
! 	 */
! 	public function process_truefalse($data) {
! 		global $DB;
! 
! 		$data = (object)$data;
! 		$oldid = $data->id;
! 
! 		// Detect if the question is created or mapped
! 		$oldquestionid   = $this->get_old_parentid('question');
! 		$newquestionid   = $this->get_new_parentid('question');
! 		$questioncreated = $this->get_mappingid('question_created', $oldquestionid) ? true : false;
! 
! 		// If the question has been created by restore, we need to create its question_truefalse too
! 		if ($questioncreated) {
! 			// Adjust some columns
! 			$data->question = $newquestionid;
! 			$data->trueanswer = $this->get_mappingid('question_answer', $data->trueanswer);
! 			$data->falseanswer = $this->get_mappingid('question_answer', $data->falseanswer);
! 			// Insert record
! 			$newitemid = $DB->insert_record('question_truefalse', $data);
! 			// Create mapping
! 			$this->set_mapping('question_truefalse', $oldid, $newitemid);
! 		} else {
! 			// Nothing to remap if the question already existed
! 		}
! 	}
! 
! 	/**
! 	 * Given one question_states record, return the answer
! 	 * recoded pointing to all the restored stuff for truefalse questions
! 	 *
! 	 * if not empty, answer is one question_answers->id
! 	 */
! 	public function recode_state_answer($state) {
! 		$answer = $state->answer;
! 		$result = '';
! 		if ($answer) {
! 			$result = $this->get_mappingid('question_answer', $answer);
! 		}
! 		return $result;
! 	}
  }
diff -crB questionorg/type/truefalse/db/install.xml questionupd/type/truefalse/db/install.xml
*** questionorg/type/truefalse/db/install.xml	2012-04-13 12:31:13.697178299 +0500
--- questionupd/type/truefalse/db/install.xml	2012-04-13 09:42:59.000000000 +0500
***************
*** 1,20 ****
  <?xml version="1.0" encoding="UTF-8" ?>
! <XMLDB PATH="question/type/truefalse/db" VERSION="20060812" COMMENT="XMLDB file for Moodle question/type/truefalse"
!     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
!     xsi:noNamespaceSchemaLocation="../../../../lib/xmldb/xmldb.xsd"
! >
!   <TABLES>
!     <TABLE NAME="question_truefalse" COMMENT="Options for True-False questions">
!       <FIELDS>
!         <FIELD NAME="id" TYPE="int" LENGTH="10" NOTNULL="true" UNSIGNED="true" SEQUENCE="true" NEXT="question"/>
!         <FIELD NAME="question" TYPE="int" LENGTH="10" NOTNULL="true" UNSIGNED="true" DEFAULT="0" SEQUENCE="false" COMMENT="Foreign key references question.id." PREVIOUS="id" NEXT="trueanswer"/>
!         <FIELD NAME="trueanswer" TYPE="int" LENGTH="10" NOTNULL="true" UNSIGNED="true" DEFAULT="0" SEQUENCE="false" COMMENT="Foreign key references question_answers.id. The 'True' choice." PREVIOUS="question" NEXT="falseanswer"/>
!         <FIELD NAME="falseanswer" TYPE="int" LENGTH="10" NOTNULL="true" UNSIGNED="true" DEFAULT="0" SEQUENCE="false" COMMENT="Foreign key references question_answers.id. The 'False' choice." PREVIOUS="trueanswer"/>
!       </FIELDS>
!       <KEYS>
!         <KEY NAME="primary" TYPE="primary" FIELDS="id" NEXT="question"/>
!         <KEY NAME="question" TYPE="foreign" FIELDS="question" REFTABLE="question" REFFIELDS="id" PREVIOUS="primary"/>
!       </KEYS>
!     </TABLE>
!   </TABLES>
  </XMLDB>
--- 1,29 ----
  <?xml version="1.0" encoding="UTF-8" ?>
! <XMLDB PATH="question/type/truefalse/db" VERSION="20060812"
! 	COMMENT="XMLDB file for Moodle question/type/truefalse" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
! 	xsi:noNamespaceSchemaLocation="../../../../lib/xmldb/xmldb.xsd">
! 	<TABLES>
! 		<TABLE NAME="question_truefalse" COMMENT="Options for True-False questions">
! 			<FIELDS>
! 				<FIELD NAME="id" TYPE="int" LENGTH="10" NOTNULL="true"
! 					UNSIGNED="true" SEQUENCE="true" NEXT="question" />
! 				<FIELD NAME="question" TYPE="int" LENGTH="10" NOTNULL="true"
! 					UNSIGNED="true" DEFAULT="0" SEQUENCE="false"
! 					COMMENT="Foreign key references question.id." PREVIOUS="id" NEXT="trueanswer" />
! 				<FIELD NAME="trueanswer" TYPE="int" LENGTH="10" NOTNULL="true"
! 					UNSIGNED="true" DEFAULT="0" SEQUENCE="false"
! 					COMMENT="Foreign key references question_answers.id. The 'True' choice."
! 					PREVIOUS="question" NEXT="falseanswer" />
! 				<FIELD NAME="falseanswer" TYPE="int" LENGTH="10" NOTNULL="true"
! 					UNSIGNED="true" DEFAULT="0" SEQUENCE="false"
! 					COMMENT="Foreign key references question_answers.id. The 'False' choice."
! 					PREVIOUS="trueanswer" />
! 			</FIELDS>
! 			<KEYS>
! 				<KEY NAME="primary" TYPE="primary" FIELDS="id" NEXT="question" />
! 				<KEY NAME="question" TYPE="foreign" FIELDS="question" REFTABLE="question"
! 					REFFIELDS="id" PREVIOUS="primary" />
! 			</KEYS>
! 		</TABLE>
! 	</TABLES>
  </XMLDB>
diff -crB questionorg/type/truefalse/display.html questionupd/type/truefalse/display.html
*** questionorg/type/truefalse/display.html	2012-04-13 12:31:13.609178296 +0500
--- questionupd/type/truefalse/display.html	2012-04-13 09:42:59.000000000 +0500
***************
*** 1,26 ****
  <div class="qtext">
!   <?php echo $questiontext; ?>
  </div>
  
  <div class="ablock clearfix">
!   <div class="prompt">
!     <?php print_string('answer', 'quiz') ?>:
!   </div>
  
!   <div class="answer">
!     <span <?php echo 'class="r0 '.$trueclass.'"'; ?>>
!         <?php echo $radiotrue ?>
!         <?php echo $truefeedbackimg; ?>
!     </span>
!     <span <?php echo 'class="r1 '.$falseclass.'"'; ?>>
!         <?php echo $radiofalse ?>
!         <?php echo $falsefeedbackimg; ?>
!     </span>
!   </div>
!     <?php if ($feedback) { ?>
!         <div class="feedback">
!             <?php echo $feedback ?>
!         </div>
!     <?php } ?>
!     <?php $this->print_question_submit_buttons($question, $state, $cmoptions, $options); ?>
  </div>
--- 1,26 ----
  <div class="qtext">
! 	<?php 
!  
!   echo $questiontext; ?>
  </div>
  
  <div class="ablock clearfix">
! 	<div class="prompt">
! 		<?php 
! 		 print_string('answer', 'quiz') ?>
! 		:
! 	</div>
  
! 	<div class="answer">
! 		<span<?php echo 'class="r0 '.$trueclass.'"'; ?>> <?php echo $radiotrue ?>
! 			<?php echo $truefeedbackimg; ?> </span> <span<?php echo 'class="r1
! 			'.$falseclass.'"'; ?>> <?php echo $radiofalse ?> <?php echo $falsefeedbackimg; ?>
! 		</span>
! 	</div>
! 	<?php if ($feedback) { ?>
! 	<div class="feedback">
! 		<?php echo $feedback ?>
! 	</div>
! 	<?php } ?>
! 	<?php $this->print_question_submit_buttons($question, $state, $cmoptions, $options); ?>
  </div>
diff -crB questionorg/type/truefalse/edit_truefalse_form.php questionupd/type/truefalse/edit_truefalse_form.php
*** questionorg/type/truefalse/edit_truefalse_form.php	2012-04-13 12:31:13.699178285 +0500
--- questionupd/type/truefalse/edit_truefalse_form.php	2012-04-13 09:42:59.000000000 +0500
***************
*** 16,22 ****
  // along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
  
  if (!defined('MOODLE_INTERNAL')) {
!     die('Direct access to this script is forbidden.');    ///  It must be included from a Moodle page
  }
  
  require_once($CFG->dirroot.'/question/type/edit_question_form.php');
--- 16,22 ----
  // along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
  
  if (!defined('MOODLE_INTERNAL')) {
! 	die('Direct access to this script is forbidden.');    ///  It must be included from a Moodle page
  }
  
  require_once($CFG->dirroot.'/question/type/edit_question_form.php');
***************
*** 35,106 ****
   * truefalse editing form definition.
   */
  class question_edit_truefalse_form extends question_edit_form {
!     /**
!      * Add question-type specific form fields.
!      *
!      * @param object $mform the form being built.
!      */
!     function definition_inner(&$mform) {
!         $mform->addElement('select', 'correctanswer', get_string('correctanswer', 'qtype_truefalse'),
!                 array(0 => get_string('false', 'qtype_truefalse'), 1 => get_string('true', 'qtype_truefalse')));
! 
!         $mform->addElement('editor', 'feedbacktrue', get_string('feedbacktrue', 'qtype_truefalse'), null, $this->editoroptions);;
!         $mform->setType('feedbacktrue', PARAM_RAW);
! 
!         $mform->addElement('editor', 'feedbackfalse', get_string('feedbackfalse', 'qtype_truefalse'), null, $this->editoroptions);
!         $mform->setType('feedbackfalse', PARAM_RAW);
! 
!         // Fix penalty factor at 1.
!         $mform->setDefault('penalty', 1);
!         $mform->freeze('penalty');
!     }
! 
!     function set_data($question) {
!         if (!empty($question->options->trueanswer)) {
!             $trueanswer = $question->options->answers[$question->options->trueanswer];
!             $draftid = file_get_submitted_draft_itemid('trueanswer');
!             $answerid = $question->options->trueanswer;
!             $text = $trueanswer->feedback;
! 
!             $question->correctanswer = ($trueanswer->fraction != 0);
!             $question->feedbacktrue = array();
!             $question->feedbacktrue['text'] = $trueanswer->feedback;
!             $question->feedbacktrue['format'] = $trueanswer->feedbackformat;
!             $question->feedbacktrue['text'] = file_prepare_draft_area(
!                 $draftid,       // draftid
!                 $this->context->id,    // context
                  'question',     // component
                  'answerfeedback',        // filarea
!                 !empty($answerid)?(int)$answerid:null, // itemid
!                 $this->fileoptions,    // options
!                 $text      // text
!             );
!             $question->feedbacktrue['itemid'] = $draftid;
!         }
!         if (!empty($question->options->falseanswer)) {
!             $falseanswer = $question->options->answers[$question->options->falseanswer];
!             $draftid = file_get_submitted_draft_itemid('falseanswer');
!             $answerid = $question->options->falseanswer;
!             $text = $falseanswer->feedback;
! 
!             $question->feedbackfalse = array();
!             $question->feedbackfalse['text'] = $falseanswer->feedback;
!             $question->feedbackfalse['format'] = $falseanswer->feedbackformat;
!             $question->feedbackfalse['text'] = file_prepare_draft_area(
!                 $draftid,       // draftid
!                 $this->context->id,    // context
                  'question',     // component
                  'answerfeedback',        // filarea
!                 !empty($answerid)?(int)$answerid:null, // itemid
!                 $this->fileoptions,    // options
!                 $text      // text
!             );
!             $question->feedbackfalse['itemid'] = $draftid;
!         }
!         parent::set_data($question);
!     }
! 
!     function qtype() {
!         return 'truefalse';
!     }
  }
--- 35,106 ----
   * truefalse editing form definition.
   */
  class question_edit_truefalse_form extends question_edit_form {
! 	/**
! 	 * Add question-type specific form fields.
! 	 *
! 	 * @param object $mform the form being built.
! 	 */
! 	function definition_inner(&$mform) {
! 		$mform->addElement('select', 'correctanswer', get_string('correctanswer', 'qtype_truefalse'),
! 		array(0 => get_string('false', 'qtype_truefalse'), 1 => get_string('true', 'qtype_truefalse')));
! 
! 		$mform->addElement('editor', 'feedbacktrue', get_string('feedbacktrue', 'qtype_truefalse'), null, $this->editoroptions);;
! 		$mform->setType('feedbacktrue', PARAM_RAW);
! 
! 		$mform->addElement('editor', 'feedbackfalse', get_string('feedbackfalse', 'qtype_truefalse'), null, $this->editoroptions);
! 		$mform->setType('feedbackfalse', PARAM_RAW);
! 
! 		// Fix penalty factor at 1.
! 		$mform->setDefault('penalty', 1);
! 		$mform->freeze('penalty');
! 	}
! 
! 	function set_data($question) {
! 		if (!empty($question->options->trueanswer)) {
! 			$trueanswer = $question->options->answers[$question->options->trueanswer];
! 			$draftid = file_get_submitted_draft_itemid('trueanswer');
! 			$answerid = $question->options->trueanswer;
! 			$text = $trueanswer->feedback;
! 
! 			$question->correctanswer = ($trueanswer->fraction != 0);
! 			$question->feedbacktrue = array();
! 			$question->feedbacktrue['text'] = $trueanswer->feedback;
! 			$question->feedbacktrue['format'] = $trueanswer->feedbackformat;
! 			$question->feedbacktrue['text'] = file_prepare_draft_area(
! 			$draftid,       // draftid
! 			$this->context->id,    // context
                  'question',     // component
                  'answerfeedback',        // filarea
! 			!empty($answerid)?(int)$answerid:null, // itemid
! 			$this->fileoptions,    // options
! 			$text      // text
! 			);
! 			$question->feedbacktrue['itemid'] = $draftid;
! 		}
! 		if (!empty($question->options->falseanswer)) {
! 			$falseanswer = $question->options->answers[$question->options->falseanswer];
! 			$draftid = file_get_submitted_draft_itemid('falseanswer');
! 			$answerid = $question->options->falseanswer;
! 			$text = $falseanswer->feedback;
! 
! 			$question->feedbackfalse = array();
! 			$question->feedbackfalse['text'] = $falseanswer->feedback;
! 			$question->feedbackfalse['format'] = $falseanswer->feedbackformat;
! 			$question->feedbackfalse['text'] = file_prepare_draft_area(
! 			$draftid,       // draftid
! 			$this->context->id,    // context
                  'question',     // component
                  'answerfeedback',        // filarea
! 			!empty($answerid)?(int)$answerid:null, // itemid
! 			$this->fileoptions,    // options
! 			$text      // text
! 			);
! 			$question->feedbackfalse['itemid'] = $draftid;
! 		}
! 		parent::set_data($question);
! 	}
! 
! 	function qtype() {
! 		return 'truefalse';
! 	}
  }
diff -crB questionorg/type/truefalse/lib.php questionupd/type/truefalse/lib.php
*** questionorg/type/truefalse/lib.php	2012-04-13 12:31:13.700178284 +0500
--- questionupd/type/truefalse/lib.php	2012-04-13 09:42:59.000000000 +0500
***************
*** 25,31 ****
   * @license http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
   */
  function qtype_truefalse_pluginfile($course, $cm, $context, $filearea, $args, $forcedownload) {
!     global $CFG;
!     require_once($CFG->libdir . '/questionlib.php');
!     question_pluginfile($course, $context, 'qtype_truefalse', $filearea, $args, $forcedownload);
  }
--- 25,31 ----
   * @license http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
   */
  function qtype_truefalse_pluginfile($course, $cm, $context, $filearea, $args, $forcedownload) {
! 	global $CFG;
! 	require_once($CFG->libdir . '/questionlib.php');
! 	question_pluginfile($course, $context, 'qtype_truefalse', $filearea, $args, $forcedownload);
  }
diff -crB questionorg/type/truefalse/questiontype.php questionupd/type/truefalse/questiontype.php
*** questionorg/type/truefalse/questiontype.php	2012-04-13 12:31:13.695178308 +0500
--- questionupd/type/truefalse/questiontype.php	2012-04-13 09:42:59.000000000 +0500
***************
*** 28,313 ****
   */
  class question_truefalse_qtype extends default_questiontype {
  
!     function name() {
!         return 'truefalse';
!     }
! 
!     function save_question_options($question) {
!         global $DB;
!         $result = new stdClass;
!         $context = $question->context;
! 
!         // Fetch old answer ids so that we can reuse them
!         $oldanswers = $DB->get_records('question_answers',
!                 array('question' => $question->id), 'id ASC');
! 
!         // Save the true answer - update an existing answer if possible.
!         $answer = array_shift($oldanswers);
!         if (!$answer) {
!             $answer = new stdClass();
!             $answer->question = $question->id;
!             $answer->answer = '';
!             $answer->feedback = '';
!             $answer->id = $DB->insert_record('question_answers', $answer);
!         }
! 
!         $answer->answer   = get_string('true', 'quiz');
!         $answer->fraction = $question->correctanswer;
!         $answer->feedback = $this->import_or_save_files($question->feedbacktrue,
!                 $context, 'question', 'answerfeedback', $answer->id);
!         $answer->feedbackformat = $question->feedbacktrue['format'];
!         $DB->update_record('question_answers', $answer);
!         $trueid = $answer->id;
! 
!         // Save the false answer - update an existing answer if possible.
!         $answer = array_shift($oldanswers);
!         if (!$answer) {
!             $answer = new stdClass();
!             $answer->question = $question->id;
!             $answer->answer = '';
!             $answer->feedback = '';
!             $answer->id = $DB->insert_record('question_answers', $answer);
!         }
! 
!         $answer->answer   = get_string('false', 'quiz');
!         $answer->fraction = 1 - (int)$question->correctanswer;
!         $answer->feedback = $this->import_or_save_files($question->feedbackfalse,
!                 $context, 'question', 'answerfeedback', $answer->id);
!         $answer->feedbackformat = $question->feedbackfalse['format'];
!         $DB->update_record('question_answers', $answer);
!         $falseid = $answer->id;
! 
!         // Delete any left over old answer records.
!         $fs = get_file_storage();
!         foreach($oldanswers as $oldanswer) {
!             $fs->delete_area_files($context->id, 'question', 'answerfeedback', $oldanswer->id);
!             $DB->delete_records('question_answers', array('id' => $oldanswer->id));
!         }
! 
!         // Save question options in question_truefalse table
!         if ($options = $DB->get_record('question_truefalse', array('question' => $question->id))) {
!             // No need to do anything, since the answer IDs won't have changed
!             // But we'll do it anyway, just for robustness
!             $options->trueanswer  = $trueid;
!             $options->falseanswer = $falseid;
!             $DB->update_record('question_truefalse', $options);
!         } else {
!             $options = new stdClass();
!             $options->question    = $question->id;
!             $options->trueanswer  = $trueid;
!             $options->falseanswer = $falseid;
!             $DB->insert_record('question_truefalse', $options);
!         }
! 
!         return true;
!     }
! 
!     /**
!     * Loads the question type specific options for the question.
!     */
!     function get_question_options(&$question) {
!         global $DB, $OUTPUT;
!         // Get additional information from database
!         // and attach it to the question object
!         if (!$question->options = $DB->get_record('question_truefalse', array('question' => $question->id))) {
!             echo $OUTPUT->notification('Error: Missing question options!');
!             return false;
!         }
!         // Load the answers
!         if (!$question->options->answers = $DB->get_records('question_answers', array('question' =>  $question->id), 'id ASC')) {
!            echo $OUTPUT->notification('Error: Missing question answers for truefalse question ' . $question->id . '!');
!            return false;
!         }
! 
!         return true;
!     }
! 
!     function delete_question($questionid, $contextid) {
!         global $DB;
!         $DB->delete_records('question_truefalse', array('question' => $questionid));
! 
!         parent::delete_question($questionid, $contextid);
!     }
! 
!     function compare_responses($question, $state, $teststate) {
!         if (isset($state->responses['']) && isset($teststate->responses[''])) {
!             return $state->responses[''] === $teststate->responses[''];
!         } else if (isset($teststate->responses['']) && $teststate->responses[''] === '' &&
!                 !isset($state->responses[''])) {
!             // Nothing selected in the past, and nothing selected now.
!             return true;
!         }
!         return false;
!     }
! 
!     function get_correct_responses(&$question, &$state) {
!         // The correct answer is the one which gives full marks
!         foreach ($question->options->answers as $answer) {
!             if (((int) $answer->fraction) === 1) {
!                 return array('' => $answer->id);
!             }
!         }
!         return null;
!     }
! 
!     /**
!     * Prints the main content of the question including any interactions
!     */
!     function print_question_formulation_and_controls(&$question, &$state, $cmoptions, $options) {
!         global $CFG;
!         $context = $this->get_context_by_category_id($question->category);
! 
!         $readonly = $options->readonly ? ' disabled="disabled"' : '';
! 
!         $formatoptions = new stdClass;
!         $formatoptions->noclean = true;
!         $formatoptions->para = false;
! 
!         // Print question formulation
!         $questiontext = format_text($question->questiontext,
!                          $question->questiontextformat,
!                          $formatoptions, $cmoptions->course);
! 
!         $answers = &$question->options->answers;
!         $trueanswer = &$answers[$question->options->trueanswer];
!         $falseanswer = &$answers[$question->options->falseanswer];
!         $correctanswer = ($trueanswer->fraction == 1) ? $trueanswer : $falseanswer;
! 
!         $trueclass = '';
!         $falseclass = '';
!         $truefeedbackimg = '';
!         $falsefeedbackimg = '';
! 
!         // Work out which radio button to select (if any)
!         if (isset($state->responses[''])) {
!             $response = $state->responses[''];
!         } else {
!             $response = '';
!         }
!         $truechecked = ($response == $trueanswer->id) ? ' checked="checked"' : '';
!         $falsechecked = ($response == $falseanswer->id) ? ' checked="checked"' : '';
! 
!         // Work out visual feedback for answer correctness.
!         if ($options->feedback) {
!             if ($truechecked) {
!                 $trueclass = question_get_feedback_class($trueanswer->fraction);
!             } else if ($falsechecked) {
!                 $falseclass = question_get_feedback_class($falseanswer->fraction);
!             }
!         }
!         if ($options->feedback || $options->correct_responses) {
!             if (isset($answers[$response])) {
!                 $truefeedbackimg = question_get_feedback_image($trueanswer->fraction, !empty($truechecked) && $options->feedback);
!                 $falsefeedbackimg = question_get_feedback_image($falseanswer->fraction, !empty($falsechecked) && $options->feedback);
!             }
!         }
! 
!         $inputname = ' name="'.$question->name_prefix.'" ';
!         $trueid    = $question->name_prefix.'true';
!         $falseid   = $question->name_prefix.'false';
! 
!         $radiotrue = '<input type="radio"' . $truechecked . $readonly . $inputname
!             . 'id="'.$trueid . '" value="' . $trueanswer->id . '" /><label for="'.$trueid . '">'
!             . s($trueanswer->answer) . '</label>';
!         $radiofalse = '<input type="radio"' . $falsechecked . $readonly . $inputname
!             . 'id="'.$falseid . '" value="' . $falseanswer->id . '" /><label for="'.$falseid . '">'
!             . s($falseanswer->answer) . '</label>';
! 
!         $feedback = '';
!         if ($options->feedback and isset($answers[$response])) {
!             $chosenanswer = $answers[$response];
!             $chosenanswer->feedback = quiz_rewrite_question_urls($chosenanswer->feedback, 'pluginfile.php', $context->id, 'question', 'answerfeedback', array($state->attempt, $state->question), $chosenanswer->id);
!             $feedback = format_text($chosenanswer->feedback, $chosenanswer->feedbackformat, $formatoptions, $cmoptions->course);
!         }
! 
!         include("$CFG->dirroot/question/type/truefalse/display.html");
!     }
! 
!     function move_files($questionid, $oldcontextid, $newcontextid) {
!         parent::move_files($questionid, $oldcontextid, $newcontextid);
!         $this->move_files_in_answers($questionid, $oldcontextid, $newcontextid);
!     }
! 
!     protected function delete_files($questionid, $contextid) {
!         parent::delete_files($questionid, $contextid);
!         $this->delete_files_in_answers($questionid, $contextid);
!     }
! 
!     function check_file_access($question, $state, $options, $contextid, $component,
!             $filearea, $args) {
!         if ($component == 'question' && $filearea == 'answerfeedback') {
! 
!             $answerid = reset($args); // itemid is answer id.
!             $answers = &$question->options->answers;
!             if (isset($state->responses[''])) {
!                 $response = $state->responses[''];
!             } else {
!                 $response = '';
!             }
! 
!             return $options->feedback && isset($answers[$response]) && $answerid == $response;
! 
!         } else {
!             return parent::check_file_access($question, $state, $options, $contextid, $component,
!                     $filearea, $args);
!         }
!     }
! 
!     function grade_responses(&$question, &$state, $cmoptions) {
!         if (isset($state->responses['']) && isset($question->options->answers[$state->responses['']])) {
!             $state->raw_grade = $question->options->answers[$state->responses['']]->fraction * $question->maxgrade;
!         } else {
!             $state->raw_grade = 0;
!         }
!         // Only allow one attempt at the question
!         $state->penalty = 1 * $question->maxgrade;
! 
!         // mark the state as graded
!         $state->event = ($state->event ==  QUESTION_EVENTCLOSE) ? QUESTION_EVENTCLOSEANDGRADE : QUESTION_EVENTGRADE;
! 
!         return true;
!     }
! 
!     function get_actual_response($question, $state) {
!         if (isset($question->options->answers[$state->responses['']])) {
!             $responses[] = $question->options->answers[$state->responses['']]->answer;
!         } else {
!             $responses[] = '';
!         }
!         return $responses;
!     }
!     /**
!      * @param object $question
!      * @return mixed either a integer score out of 1 that the average random
!      * guess by a student might give or an empty string which means will not
!      * calculate.
!      */
!     function get_random_guess_score($question) {
!         return 0.5;
!     }
! 
!     /**
!      * Runs all the code required to set up and save an essay question for testing purposes.
!      * Alternate DB table prefix may be used to facilitate data deletion.
!      */
!     function generate_test($name, $courseid = null) {
!         global $DB;
!         list($form, $question) = parent::generate_test($name, $courseid);
!         $question->category = $form->category;
! 
!         $form->questiontext = "This question is really stupid";
!         $form->penalty = 1;
!         $form->defaultgrade = 1;
!         $form->correctanswer = 0;
!         $form->feedbacktrue = 'Can you justify such a hasty judgment?';
!         $form->feedbackfalse = 'Wisdom has spoken!';
! 
!         if ($courseid) {
!             $course = $DB->get_record('course', array('id' => $courseid));
!         }
  
!         return $this->save_question($question, $form);
!     }
  }
  //// END OF CLASS ////
  
--- 28,325 ----
   */
  class question_truefalse_qtype extends default_questiontype {
  
! 	function name() {
! 		return 'truefalse';
! 	}
! 
! 	function save_question_options($question) {
! 		global $DB;
! 		$result = new stdClass;
! 		$context = $question->context;
! 
! 		// Fetch old answer ids so that we can reuse them
! 		$oldanswers = $DB->get_records('question_answers',
! 		array('question' => $question->id), 'id ASC');
! 
! 		// Save the true answer - update an existing answer if possible.
! 		$answer = array_shift($oldanswers);
! 		if (!$answer) {
! 			$answer = new stdClass();
! 			$answer->question = $question->id;
! 			$answer->answer = '';
! 			$answer->feedback = '';
! 			$answer->id = $DB->insert_record('question_answers', $answer);
! 		}
! 
! 		$answer->answer   = get_string('true', 'quiz');
! 		$answer->fraction = $question->correctanswer;
! 		$answer->feedback = $this->import_or_save_files($question->feedbacktrue,
! 		$context, 'question', 'answerfeedback', $answer->id);
! 		$answer->feedbackformat = $question->feedbacktrue['format'];
! 		$DB->update_record('question_answers', $answer);
! 		$trueid = $answer->id;
! 
! 		// Save the false answer - update an existing answer if possible.
! 		$answer = array_shift($oldanswers);
! 		if (!$answer) {
! 			$answer = new stdClass();
! 			$answer->question = $question->id;
! 			$answer->answer = '';
! 			$answer->feedback = '';
! 			$answer->id = $DB->insert_record('question_answers', $answer);
! 		}
! 
! 		$answer->answer   = get_string('false', 'quiz');
! 		$answer->fraction = 1 - (int)$question->correctanswer;
! 		$answer->feedback = $this->import_or_save_files($question->feedbackfalse,
! 		$context, 'question', 'answerfeedback', $answer->id);
! 		$answer->feedbackformat = $question->feedbackfalse['format'];
! 		$DB->update_record('question_answers', $answer);
! 		$falseid = $answer->id;
! 
! 		// Delete any left over old answer records.
! 		$fs = get_file_storage();
! 		foreach($oldanswers as $oldanswer) {
! 			$fs->delete_area_files($context->id, 'question', 'answerfeedback', $oldanswer->id);
! 			$DB->delete_records('question_answers', array('id' => $oldanswer->id));
! 		}
! 
! 		// Save question options in question_truefalse table
! 		if ($options = $DB->get_record('question_truefalse', array('question' => $question->id))) {
! 			// No need to do anything, since the answer IDs won't have changed
! 			// But we'll do it anyway, just for robustness
! 			$options->trueanswer  = $trueid;
! 			$options->falseanswer = $falseid;
! 			$DB->update_record('question_truefalse', $options);
! 		} else {
! 			$options = new stdClass();
! 			$options->question    = $question->id;
! 			$options->trueanswer  = $trueid;
! 			$options->falseanswer = $falseid;
! 			$DB->insert_record('question_truefalse', $options);
! 		}
! 
! 		return true;
! 	}
! 
! 	/**
! 	 * Loads the question type specific options for the question.
! 	 */
! 	function get_question_options(&$question) {
! 		global $DB, $OUTPUT;
! 		// Get additional information from database
! 		// and attach it to the question object
! 		if (!$question->options = $DB->get_record('question_truefalse', array('question' => $question->id))) {
! 			echo $OUTPUT->notification('Error: Missing question options!');
! 			return false;
! 		}
! 		// Load the answers
! 		if (!$question->options->answers = $DB->get_records('question_answers', array('question' =>  $question->id), 'id ASC')) {
! 			echo $OUTPUT->notification('Error: Missing question answers for truefalse question ' . $question->id . '!');
! 			return false;
! 		}
! 
! 		return true;
! 	}
! 
! 	function delete_question($questionid, $contextid) {
! 		global $DB;
! 		$DB->delete_records('question_truefalse', array('question' => $questionid));
! 
! 		parent::delete_question($questionid, $contextid);
! 	}
! 
! 	function compare_responses($question, $state, $teststate) {
! 		if (isset($state->responses['']) && isset($teststate->responses[''])) {
! 			return $state->responses[''] === $teststate->responses[''];
! 		} else if (isset($teststate->responses['']) && $teststate->responses[''] === '' &&
! 		!isset($state->responses[''])) {
! 			// Nothing selected in the past, and nothing selected now.
! 			return true;
! 		}
! 		return false;
! 	}
! 
! 	function get_correct_responses(&$question, &$state) {
! 		// The correct answer is the one which gives full marks
! 		foreach ($question->options->answers as $answer) {
! 			if (((int) $answer->fraction) === 1) {
! 				return array('' => $answer->id);
! 			}
! 		}
! 		return null;
! 	}
! 
! 	/**
! 	 * Prints the main content of the question including any interactions
! 	 */
! 	function print_question_formulation_and_controls(&$question, &$state, $cmoptions, $options) {
! 		global $CFG;
! 		$context = $this->get_context_by_category_id($question->category);
! 
! 		$readonly = $options->readonly ? ' disabled="disabled"' : '';
! 
! 		$formatoptions = new stdClass;
! 		$formatoptions->noclean = true;
! 		$formatoptions->para = false;
! 
! 		// Print question formulation
! 		$questiontext = format_text($question->questiontext,
! 		$question->questiontextformat,
! 		$formatoptions, $cmoptions->course);
! 		$_SESSION['content'].="&nbsp;&nbsp;&nbsp;&nbsp;".$questiontext."</b></td></tr>";
! 
! 		$answers = &$question->options->answers;
! 		$trueanswer = &$answers[$question->options->trueanswer];
! 		$falseanswer = &$answers[$question->options->falseanswer];
! 		$correctanswer = ($trueanswer->fraction == 1) ? $trueanswer : $falseanswer;
! 
! 		$trueclass = '';
! 		$falseclass = '';
! 		$truefeedbackimg = '';
! 		$falsefeedbackimg = '';
! 
! 		// Work out which radio button to select (if any)
! 		if (isset($state->responses[''])) {
! 			$response = $state->responses[''];
! 		} else {
! 			$response = '';
! 		}
! 		$truechecked = ($response == $trueanswer->id) ? ' checked="checked"' : '';
! 		$falsechecked = ($response == $falseanswer->id) ? ' checked="checked"' : '';
! 		if($truechecked==''){
! 			$_SESSION['content'].='<tr><td><img src="hollow rb.jpg" height="12" width="12" />'.$trueanswer->answer."</td></tr>";
! 		}else{
! 			$_SESSION['content'].='<tr><td><img src="filled rb.jpg" height="12" width="12" />'.$trueanswer->answer."</td></tr>";
! 		}
! 
! 		if($falsechecked==''){
! 			$_SESSION['content'].='<tr><td><img src="hollow rb.jpg" height="12" width="12" />'.$falseanswer->answer."</td></tr>";
! 		}else{
! 			$_SESSION['content'].='<tr><td><img src="filled rb.jpg" height="12" width="12" />'.$falseanswer->answer."</td></tr>";
! 		}
! 
! 		// Work out visual feedback for answer correctness.
! 		if ($options->feedback) {
! 			if ($truechecked) {
! 				$trueclass = question_get_feedback_class($trueanswer->fraction);
! 			} else if ($falsechecked) {
! 				$falseclass = question_get_feedback_class($falseanswer->fraction);
! 			}
! 		}
! 		if ($options->feedback || $options->correct_responses) {
! 			if (isset($answers[$response])) {
! 				$truefeedbackimg = question_get_feedback_image($trueanswer->fraction, !empty($truechecked) && $options->feedback);
! 				$falsefeedbackimg = question_get_feedback_image($falseanswer->fraction, !empty($falsechecked) && $options->feedback);
! 			}
! 		}
! 
! 		$inputname = ' name="'.$question->name_prefix.'" ';
! 		$trueid    = $question->name_prefix.'true';
! 		$falseid   = $question->name_prefix.'false';
! 
! 		$radiotrue = '<input type="radio"' . $truechecked . $readonly . $inputname
! 		. 'id="'.$trueid . '" value="' . $trueanswer->id . '" /><label for="'.$trueid . '">'
! 		. s($trueanswer->answer) . '</label>';
! 		$radiofalse = '<input type="radio"' . $falsechecked . $readonly . $inputname
! 		. 'id="'.$falseid . '" value="' . $falseanswer->id . '" /><label for="'.$falseid . '">'
! 		. s($falseanswer->answer) . '</label>';
! 
! 		$feedback = '';
! 		if ($options->feedback and isset($answers[$response])) {
! 			$chosenanswer = $answers[$response];
! 			$chosenanswer->feedback = quiz_rewrite_question_urls($chosenanswer->feedback, 'pluginfile.php', $context->id, 'question', 'answerfeedback', array($state->attempt, $state->question), $chosenanswer->id);
! 			$feedback = format_text($chosenanswer->feedback, $chosenanswer->feedbackformat, $formatoptions, $cmoptions->course);
! 		}
! 
! 		include("$CFG->dirroot/question/type/truefalse/display.html");
! 	}
! 
! 	function move_files($questionid, $oldcontextid, $newcontextid) {
! 		parent::move_files($questionid, $oldcontextid, $newcontextid);
! 		$this->move_files_in_answers($questionid, $oldcontextid, $newcontextid);
! 	}
! 
! 	protected function delete_files($questionid, $contextid) {
! 		parent::delete_files($questionid, $contextid);
! 		$this->delete_files_in_answers($questionid, $contextid);
! 	}
! 
! 	function check_file_access($question, $state, $options, $contextid, $component,
! 	$filearea, $args) {
! 		if ($component == 'question' && $filearea == 'answerfeedback') {
! 
! 			$answerid = reset($args); // itemid is answer id.
! 			$answers = &$question->options->answers;
! 			if (isset($state->responses[''])) {
! 				$response = $state->responses[''];
! 			} else {
! 				$response = '';
! 			}
! 
! 			return $options->feedback && isset($answers[$response]) && $answerid == $response;
! 
! 		} else {
! 			return parent::check_file_access($question, $state, $options, $contextid, $component,
! 			$filearea, $args);
! 		}
! 	}
! 
! 	function grade_responses(&$question, &$state, $cmoptions) {
! 		if (isset($state->responses['']) && isset($question->options->answers[$state->responses['']])) {
! 			$state->raw_grade = $question->options->answers[$state->responses['']]->fraction * $question->maxgrade;
! 		} else {
! 			$state->raw_grade = 0;
! 		}
! 		// Only allow one attempt at the question
! 		$state->penalty = 1 * $question->maxgrade;
! 
! 		// mark the state as graded
! 		$state->event = ($state->event ==  QUESTION_EVENTCLOSE) ? QUESTION_EVENTCLOSEANDGRADE : QUESTION_EVENTGRADE;
! 
! 		return true;
! 	}
! 
! 	function get_actual_response($question, $state) {
! 		if (isset($question->options->answers[$state->responses['']])) {
! 			$responses[] = $question->options->answers[$state->responses['']]->answer;
! 		} else {
! 			$responses[] = '';
! 		}
! 		return $responses;
! 	}
! 	/**
! 	 * @param object $question
! 	 * @return mixed either a integer score out of 1 that the average random
! 	 * guess by a student might give or an empty string which means will not
! 	 * calculate.
! 	 */
! 	function get_random_guess_score($question) {
! 		return 0.5;
! 	}
! 
! 	/**
! 	 * Runs all the code required to set up and save an essay question for testing purposes.
! 	 * Alternate DB table prefix may be used to facilitate data deletion.
! 	 */
! 	function generate_test($name, $courseid = null) {
! 		global $DB;
! 		list($form, $question) = parent::generate_test($name, $courseid);
! 		$question->category = $form->category;
! 
! 		$form->questiontext = "This question is really stupid";
! 		$form->penalty = 1;
! 		$form->defaultgrade = 1;
! 		$form->correctanswer = 0;
! 		$form->feedbacktrue = 'Can you justify such a hasty judgment?';
! 		$form->feedbackfalse = 'Wisdom has spoken!';
! 
! 		if ($courseid) {
! 			$course = $DB->get_record('course', array('id' => $courseid));
! 		}
  
! 		return $this->save_question($question, $form);
! 	}
  }
  //// END OF CLASS ////
  
diff -crB questionorg/upgrade.php questionupd/upgrade.php
*** questionorg/upgrade.php	2012-04-13 12:31:14.551178306 +0500
--- questionupd/upgrade.php	2012-04-13 09:42:59.000000000 +0500
***************
*** 19,27 ****
   * that is what this update does.
   */
  function question_fix_random_question_parents() {
!     global $CFG, $DB;
!     $DB->execute("UPDATE {question} SET parent = id WHERE qtype = 'random' AND parent <> id");
!     return true;
  }
  
  
--- 19,27 ----
   * that is what this update does.
   */
  function question_fix_random_question_parents() {
! 	global $CFG, $DB;
! 	$DB->execute("UPDATE {question} SET parent = id WHERE qtype = 'random' AND parent <> id");
! 	return true;
  }
  
  
